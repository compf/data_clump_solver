messages:
[
	content:"
	
	I will provide you one or more Java code files .
	Find all data clumps in the respective files.
	
	A data clump exists if
	1) two methods (in the same or in different classes) have at least 3 common parameters
	    and one of those methods does not override the other,
	
	or  
	2) At least three fields in a class are common with the parameters of a method (in the same or in a different class),
	
	or
	3) Two different classes have at least three common fields
	
	## OUTPUT FORMAT
	Use the following JSON format for the output:
	
	{
	   "data_clumps":{
	        "unique_key":{
	            "key": "a unique key that should be created. It must be same as the key 'unique_key' in the 'data_clumps' object",
	            "from_file_path":"The path of the file where one part of the data clump is found",
	            "from_class_or_interface_key":"The fully qualified name of the class or interface where one part of the data clump is found",
	            "from_class_or_interface_name":"The name of the class or interface where one part of the data clump is found",
	            
	            "from_method_key":"The fully qualified name of the method where one part of the data clump is found. It may be 'null' if the data clump on this part is not found in a method",
	            "from_method_name":"The name of the method where one part of the data clump is found. It may be 'null' if the data clump on this part is not found in a method",
	
	            "to_file_path":"The path of the file where the  other part of the data clump is found",
	            "to_class_or_interface_key":"The fully qualified name of the class or interface where the  other part part of the data clump is found",
	            "to_class_or_interface_name":"The name of the class or interface where the  other  part of the data clump is found",
	            
	            "to_method_key":"The fully qualified name of the method where the  other part part of the data clump is found. It may be 'null' if the data clump on this part is not found in a method",
	            "to_method_name":"The name of the method where the  other  part of the data clump is found. It may be 'null' if the data clump on this part is not found in a method",
	            "data_clump_data":{
	                // for each data clump variable
	                "other_unique_key":{
	                    "key":"a unique key that should be created. It must be same as the key 'other_unique_key' in the 'data_clump_data' object",
	                    "name": "The name of the data clump variable that exists on the one part of the data clump",
	                    "type": "The type of the data clump variable that exists on the one part of the data clump",
	                    "displayedType": "The  type of the data clump variable, as it appears in the source code, that exists on the one part of the data clump",
	                    
	                    "position": {
	                        "startLine": "The line number of the  data clump variable on the one part of the data clump.This must be relative to the file",
	                        "startColumn": "The column number of the data clump variable on the one part of the data clump"
	                    },
	                    "to_variable":{
	                        "key":"a unique key that should be created.",
	                        "name": "The name of the data clump variable that exists on the other part of the data clump",
	                        "type": "The type of the data clump variable, as it appears in the source code, that exists on the other part of the data clump",
	                        "position": {
	                            "startLine": "The line number of the  data clump variable on the other part of the data clump. This must be relative to the file",
	                            "startColumn": "The column number of the data clump variable on the other part of the data clump",
	                        }
	                    }
	                }
	            }
	        }
	   }
	}
	
	## END OUTPUT FORMAT
		
",
	role:"
	system	
",
,
	content:
{
			common/src/main/java/org/apache/rocketmq/common/stats/Stats.java:
		[
			fromLine:"			16",
			toLine:"			51",
			content:"
			 */
			package org.apache.rocketmq.common.stats;
			
			public class Stats {
			
			    public static final String QUEUE_PUT_NUMS = "QUEUE_PUT_NUMS";
			    public static final String QUEUE_PUT_SIZE = "QUEUE_PUT_SIZE";
			    public static final String QUEUE_GET_NUMS = "QUEUE_GET_NUMS";
			    public static final String QUEUE_GET_SIZE = "QUEUE_GET_SIZE";
			    public static final String TOPIC_PUT_NUMS = "TOPIC_PUT_NUMS";
			    public static final String TOPIC_PUT_SIZE = "TOPIC_PUT_SIZE";
			    public static final String GROUP_GET_NUMS = "GROUP_GET_NUMS";
			    public static final String GROUP_GET_SIZE = "GROUP_GET_SIZE";
			    public static final String SNDBCK_PUT_NUMS = "SNDBCK_PUT_NUMS";
			    public static final String BROKER_PUT_NUMS = "BROKER_PUT_NUMS";
			    public static final String BROKER_GET_NUMS = "BROKER_GET_NUMS";
			    public static final String GROUP_GET_FROM_DISK_NUMS = "GROUP_GET_FROM_DISK_NUMS";
			    public static final String GROUP_GET_FROM_DISK_SIZE = "GROUP_GET_FROM_DISK_SIZE";
			    public static final String BROKER_GET_FROM_DISK_NUMS = "BROKER_GET_FROM_DISK_NUMS";
			    public static final String BROKER_GET_FROM_DISK_SIZE = "BROKER_GET_FROM_DISK_SIZE";
			    public static final String COMMERCIAL_SEND_TIMES = "COMMERCIAL_SEND_TIMES";
			    public static final String COMMERCIAL_SNDBCK_TIMES = "COMMERCIAL_SNDBCK_TIMES";
			    public static final String COMMERCIAL_RCV_TIMES = "COMMERCIAL_RCV_TIMES";
			    public static final String COMMERCIAL_RCV_EPOLLS = "COMMERCIAL_RCV_EPOLLS";
			    public static final String COMMERCIAL_SEND_SIZE = "COMMERCIAL_SEND_SIZE";
			    public static final String COMMERCIAL_RCV_SIZE = "COMMERCIAL_RCV_SIZE";
			    public static final String COMMERCIAL_PERM_FAILURES = "COMMERCIAL_PERM_FAILURES";
			
			    public static final String GROUP_GET_FALL_SIZE = "GROUP_GET_FALL_SIZE";
			    public static final String GROUP_GET_FALL_TIME = "GROUP_GET_FALL_TIME";
			    public static final String GROUP_GET_LATENCY = "GROUP_GET_LATENCY";
			}
						
",
,

		],
		store/src/main/java/org/apache/rocketmq/store/stats/BrokerStatsManager.java:
		[
			fromLine:"			16",
			toLine:"			153",
			content:"
			 */
			package org.apache.rocketmq.store.stats;
			
			import java.util.HashMap;
			import java.util.concurrent.ScheduledExecutorService;
			import org.apache.commons.lang3.tuple.Pair;
			import org.apache.rocketmq.common.BrokerConfig;
			import org.apache.rocketmq.common.ThreadFactoryImpl;
			import org.apache.rocketmq.common.UtilAll;
			import org.apache.rocketmq.common.constant.LoggerName;
			import org.apache.rocketmq.common.statistics.StatisticsItem;
			import org.apache.rocketmq.common.statistics.StatisticsItemFormatter;
			import org.apache.rocketmq.common.statistics.StatisticsItemPrinter;
			import org.apache.rocketmq.common.statistics.StatisticsItemScheduledIncrementPrinter;
			import org.apache.rocketmq.common.statistics.StatisticsItemScheduledPrinter;
			import org.apache.rocketmq.common.statistics.StatisticsItemStateGetter;
			import org.apache.rocketmq.common.statistics.StatisticsKindMeta;
			import org.apache.rocketmq.common.statistics.StatisticsManager;
			import org.apache.rocketmq.common.stats.MomentStatsItemSet;
			import org.apache.rocketmq.common.stats.Stats;
			import org.apache.rocketmq.common.stats.StatsItem;
			import org.apache.rocketmq.common.stats.StatsItemSet;
			import org.apache.rocketmq.common.topic.TopicValidator;
			import org.apache.rocketmq.common.utils.ThreadUtils;
			import org.apache.rocketmq.logging.org.slf4j.Logger;
			import org.apache.rocketmq.logging.org.slf4j.LoggerFactory;
			
			public class BrokerStatsManager {
			
			    @Deprecated public static final String QUEUE_PUT_NUMS = Stats.QUEUE_PUT_NUMS;
			    @Deprecated public static final String QUEUE_PUT_SIZE = Stats.QUEUE_PUT_SIZE;
			    @Deprecated public static final String QUEUE_GET_NUMS = Stats.QUEUE_GET_NUMS;
			    @Deprecated public static final String QUEUE_GET_SIZE = Stats.QUEUE_GET_SIZE;
			    @Deprecated public static final String TOPIC_PUT_NUMS = Stats.TOPIC_PUT_NUMS;
			    @Deprecated public static final String TOPIC_PUT_SIZE = Stats.TOPIC_PUT_SIZE;
			
			    @Deprecated public static final String GROUP_GET_NUMS = Stats.GROUP_GET_NUMS;
			    @Deprecated public static final String GROUP_GET_SIZE = Stats.GROUP_GET_SIZE;
			
			    @Deprecated public static final String SNDBCK_PUT_NUMS = Stats.SNDBCK_PUT_NUMS;
			    @Deprecated public static final String BROKER_PUT_NUMS = Stats.BROKER_PUT_NUMS;
			    @Deprecated public static final String BROKER_GET_NUMS = Stats.BROKER_GET_NUMS;
			    @Deprecated public static final String GROUP_GET_FROM_DISK_NUMS = Stats.GROUP_GET_FROM_DISK_NUMS;
			    @Deprecated public static final String GROUP_GET_FROM_DISK_SIZE = Stats.GROUP_GET_FROM_DISK_SIZE;
			    @Deprecated public static final String BROKER_GET_FROM_DISK_NUMS = Stats.BROKER_GET_FROM_DISK_NUMS;
			    @Deprecated public static final String BROKER_GET_FROM_DISK_SIZE = Stats.BROKER_GET_FROM_DISK_SIZE;
			    // For commercial
			    @Deprecated public static final String COMMERCIAL_SEND_TIMES = Stats.COMMERCIAL_SEND_TIMES;
			    @Deprecated public static final String COMMERCIAL_SNDBCK_TIMES = Stats.COMMERCIAL_SNDBCK_TIMES;
			    @Deprecated public static final String COMMERCIAL_RCV_TIMES = Stats.COMMERCIAL_RCV_TIMES;
			    @Deprecated public static final String COMMERCIAL_RCV_EPOLLS = Stats.COMMERCIAL_RCV_EPOLLS;
			    @Deprecated public static final String COMMERCIAL_SEND_SIZE = Stats.COMMERCIAL_SEND_SIZE;
			    @Deprecated public static final String COMMERCIAL_RCV_SIZE = Stats.COMMERCIAL_RCV_SIZE;
			    @Deprecated public static final String COMMERCIAL_PERM_FAILURES = Stats.COMMERCIAL_PERM_FAILURES;
			
			    // Send message latency
			    public static final String TOPIC_PUT_LATENCY = "TOPIC_PUT_LATENCY";
			    public static final String GROUP_ACK_NUMS = "GROUP_ACK_NUMS";
			    public static final String GROUP_CK_NUMS = "GROUP_CK_NUMS";
			    public static final String DLQ_PUT_NUMS = "DLQ_PUT_NUMS";
			    public static final String BROKER_ACK_NUMS = "BROKER_ACK_NUMS";
			    public static final String BROKER_CK_NUMS = "BROKER_CK_NUMS";
			    public static final String BROKER_GET_NUMS_WITHOUT_SYSTEM_TOPIC = "BROKER_GET_NUMS_WITHOUT_SYSTEM_TOPIC";
			    public static final String BROKER_PUT_NUMS_WITHOUT_SYSTEM_TOPIC = "BROKER_PUT_NUMS_WITHOUT_SYSTEM_TOPIC";
			    public static final String SNDBCK2DLQ_TIMES = "SNDBCK2DLQ_TIMES";
			
			    public static final String COMMERCIAL_OWNER = "Owner";
			
			    public static final String ACCOUNT_OWNER_PARENT = "OWNER_PARENT";
			    public static final String ACCOUNT_OWNER_SELF = "OWNER_SELF";
			
			    public static final long ACCOUNT_STAT_INVERTAL = 60 * 1000;
			    public static final String ACCOUNT_AUTH_TYPE = "AUTH_TYPE";
			
			    public static final String ACCOUNT_SEND = "SEND";
			    public static final String ACCOUNT_RCV = "RCV";
			    public static final String ACCOUNT_SEND_BACK = "SEND_BACK";
			    public static final String ACCOUNT_SEND_BACK_TO_DLQ = "SEND_BACK_TO_DLQ";
			    public static final String ACCOUNT_AUTH_FAILED = "AUTH_FAILED";
			    public static final String ACCOUNT_SEND_REJ = "SEND_REJ";
			    public static final String ACCOUNT_REV_REJ = "RCV_REJ";
			
			    public static final String MSG_NUM = "MSG_NUM";
			    public static final String MSG_SIZE = "MSG_SIZE";
			    public static final String SUCCESS_MSG_NUM = "SUCCESS_MSG_NUM";
			    public static final String FAILURE_MSG_NUM = "FAILURE_MSG_NUM";
			    public static final String COMMERCIAL_MSG_NUM = "COMMERCIAL_MSG_NUM";
			    public static final String SUCCESS_REQ_NUM = "SUCCESS_REQ_NUM";
			    public static final String FAILURE_REQ_NUM = "FAILURE_REQ_NUM";
			    public static final String SUCCESS_MSG_SIZE = "SUCCESS_MSG_SIZE";
			    public static final String FAILURE_MSG_SIZE = "FAILURE_MSG_SIZE";
			    public static final String RT = "RT";
			    public static final String INNER_RT = "INNER_RT";
			
			    @Deprecated public static final String GROUP_GET_FALL_SIZE = Stats.GROUP_GET_FALL_SIZE;
			    @Deprecated public static final String GROUP_GET_FALL_TIME = Stats.GROUP_GET_FALL_TIME;
			    // Pull Message Latency
			    @Deprecated public static final String GROUP_GET_LATENCY = Stats.GROUP_GET_LATENCY;
			
			    // Consumer Register Time
			    public static final String CONSUMER_REGISTER_TIME = "CONSUMER_REGISTER_TIME";
			    // Producer Register Time
			    public static final String PRODUCER_REGISTER_TIME = "PRODUCER_REGISTER_TIME";
			    public static final String CHANNEL_ACTIVITY = "CHANNEL_ACTIVITY";
			    public static final String CHANNEL_ACTIVITY_CONNECT = "CONNECT";
			    public static final String CHANNEL_ACTIVITY_IDLE = "IDLE";
			    public static final String CHANNEL_ACTIVITY_EXCEPTION = "EXCEPTION";
			    public static final String CHANNEL_ACTIVITY_CLOSE = "CLOSE";
			
			    /**
			     * read disk follow stats
			     */
			    private static final Logger log = LoggerFactory.getLogger(LoggerName.ROCKETMQ_STATS_LOGGER_NAME);
			    private static final Logger COMMERCIAL_LOG = LoggerFactory.getLogger(
			        LoggerName.COMMERCIAL_LOGGER_NAME);
			    private static final Logger ACCOUNT_LOG = LoggerFactory.getLogger(LoggerName.ACCOUNT_LOGGER_NAME);
			    private static final Logger DLQ_STAT_LOG = LoggerFactory.getLogger(
			        LoggerName.DLQ_STATS_LOGGER_NAME);
			    private ScheduledExecutorService scheduledExecutorService;
			    private ScheduledExecutorService commercialExecutor;
			    private ScheduledExecutorService accountExecutor;
			
			    private final HashMap<String, StatsItemSet> statsTable = new HashMap<>();
			    private final String clusterName;
			    private final boolean enableQueueStat;
			    private MomentStatsItemSet momentStatsItemSetFallSize;
			    private MomentStatsItemSet momentStatsItemSetFallTime;
			
			    private final StatisticsManager accountStatManager = new StatisticsManager();
			    private StateGetter producerStateGetter;
			    private StateGetter consumerStateGetter;
			
			    private BrokerConfig brokerConfig;
			
			    public BrokerStatsManager(BrokerConfig brokerConfig) {
			        this.brokerConfig = brokerConfig;
			        this.enableQueueStat = brokerConfig.isEnableDetailStat();
			        initScheduleService();			
",
,
			fromLine:"			363",
			toLine:"			392",
			content:"
			        if (enableQueueStat) {
			            this.statsTable.get(Stats.QUEUE_PUT_NUMS).addValue(buildStatsKey(topic, queueId), 1, 1);
			        }
			    }
			
			    public void incQueuePutNums(final String topic, final Integer queueId, int num, int times) {
			        if (enableQueueStat) {
			            this.statsTable.get(Stats.QUEUE_PUT_NUMS).addValue(buildStatsKey(topic, queueId), num, times);
			        }
			    }
			
			    public void incQueuePutSize(final String topic, final Integer queueId, final int size) {
			        if (enableQueueStat) {
			            this.statsTable.get(Stats.QUEUE_PUT_SIZE).addValue(buildStatsKey(topic, queueId), size, 1);
			        }
			    }
			
			    public void incQueueGetNums(final String group, final String topic, final Integer queueId, final int incValue) {
			        if (enableQueueStat) {
			            final String statsKey = buildStatsKey(topic, queueId, group);
			            this.statsTable.get(Stats.QUEUE_GET_NUMS).addValue(statsKey, incValue, 1);
			        }
			    }
			
			    public void incQueueGetSize(final String group, final String topic, final Integer queueId, final int incValue) {
			        if (enableQueueStat) {
			            final String statsKey = buildStatsKey(topic, queueId, group);
			            this.statsTable.get(Stats.QUEUE_GET_SIZE).addValue(statsKey, incValue, 1);
			        }
			    }			
",
,
			fromLine:"			417",
			toLine:"			445",
			content:"
			
			    public void incTopicPutNums(final String topic) {
			        this.statsTable.get(Stats.TOPIC_PUT_NUMS).addValue(topic, 1, 1);
			    }
			
			    public void incTopicPutNums(final String topic, int num, int times) {
			        this.statsTable.get(Stats.TOPIC_PUT_NUMS).addValue(topic, num, times);
			    }
			
			    public void incTopicPutSize(final String topic, final int size) {
			        this.statsTable.get(Stats.TOPIC_PUT_SIZE).addValue(topic, size, 1);
			    }
			
			    public void incGroupGetNums(final String group, final String topic, final int incValue) {
			        final String statsKey = buildStatsKey(topic, group);
			        this.statsTable.get(Stats.GROUP_GET_NUMS).addValue(statsKey, incValue, 1);
			    }
			
			    public void incGroupCkNums(final String group, final String topic, final int incValue) {
			        final String statsKey = buildStatsKey(topic, group);
			        this.statsTable.get(GROUP_CK_NUMS).addValue(statsKey, incValue, 1);
			    }
			
			    public void incGroupAckNums(final String group, final String topic, final int incValue) {
			        final String statsKey = buildStatsKey(topic, group);
			        this.statsTable.get(GROUP_ACK_NUMS).addValue(statsKey, incValue, 1);
			    }
			
			    public String buildStatsKey(String topic, String group) {			
",
,
			fromLine:"			462",
			toLine:"			509",
			content:"
			        }
			        strBuilder.append(topic).append("@").append(queueId);
			        return strBuilder.toString();
			    }
			
			    public String buildStatsKey(String topic, int queueId, String group) {
			        StringBuilder strBuilder;
			        if (topic != null && group != null) {
			            strBuilder = new StringBuilder(topic.length() + group.length() + 6);
			        } else {
			            strBuilder = new StringBuilder();
			        }
			        strBuilder.append(topic).append("@").append(queueId).append("@").append(group);
			        return strBuilder.toString();
			    }
			
			    public String buildStatsKey(int queueId, String topic, String group) {
			        StringBuilder strBuilder;
			        if (topic != null && group != null) {
			            strBuilder = new StringBuilder(topic.length() + group.length() + 6);
			        } else {
			            strBuilder = new StringBuilder();
			        }
			        strBuilder.append(queueId).append("@").append(topic).append("@").append(group);
			        return strBuilder.toString();
			    }
			
			    public void incGroupGetSize(final String group, final String topic, final int incValue) {
			        final String statsKey = buildStatsKey(topic, group);
			        this.statsTable.get(Stats.GROUP_GET_SIZE).addValue(statsKey, incValue, 1);
			    }
			
			    public void incGroupGetLatency(final String group, final String topic, final int queueId, final int incValue) {
			        String statsKey;
			        if (enableQueueStat) {
			            statsKey = buildStatsKey(queueId, topic, group);
			        } else {
			            statsKey = buildStatsKey(topic, group);
			        }
			        this.statsTable.get(Stats.GROUP_GET_LATENCY).addRTValue(statsKey, incValue, 1);
			    }
			
			    public void incTopicPutLatency(final String topic, final int queueId, final int incValue) {
			        StringBuilder statsKey;
			        if (topic != null) {
			            statsKey = new StringBuilder(topic.length() + 6);
			        } else {
			            statsKey = new StringBuilder(6);			
",
,
			fromLine:"			580",
			toLine:"			644",
			content:"
			    public double tpsGroupGetNums(final String group, final String topic) {
			        final String statsKey = buildStatsKey(topic, group);
			        return this.statsTable.get(Stats.GROUP_GET_NUMS).getStatsDataInMinute(statsKey).getTps();
			    }
			
			    public void recordDiskFallBehindTime(final String group, final String topic, final int queueId,
			        final long fallBehind) {
			        final String statsKey = buildStatsKey(queueId, topic, group);
			        this.momentStatsItemSetFallTime.getAndCreateStatsItem(statsKey).getValue().set(fallBehind);
			    }
			
			    public void recordDiskFallBehindSize(final String group, final String topic, final int queueId,
			        final long fallBehind) {
			        final String statsKey = buildStatsKey(queueId, topic, group);
			        this.momentStatsItemSetFallSize.getAndCreateStatsItem(statsKey).getValue().set(fallBehind);
			    }
			
			    public void incDLQStatValue(final String key, final String owner, final String group,
			        final String topic, final String type, final int incValue) {
			        final String statsKey = buildCommercialStatsKey(owner, topic, group, type);
			        this.statsTable.get(key).addValue(statsKey, incValue, 1);
			    }
			
			    public void incCommercialValue(final String key, final String owner, final String group,
			        final String topic, final String type, final int incValue) {
			        final String statsKey = buildCommercialStatsKey(owner, topic, group, type);
			        this.statsTable.get(key).addValue(statsKey, incValue, 1);
			    }
			
			    public void incAccountValue(final String key, final String accountOwnerParent, final String accountOwnerSelf,
			        final String instanceId, final String group, final String topic,
			        final String msgType, final int incValue) {
			        final String statsKey = buildAccountStatsKey(accountOwnerParent, accountOwnerSelf, instanceId, topic, group,
			            msgType);
			        this.statsTable.get(key).addValue(statsKey, incValue, 1);
			    }
			
			    public void incAccountValue(final String key, final String accountOwnerParent, final String accountOwnerSelf,
			        final String instanceId, final String group, final String topic,
			        final String msgType, final String flowlimitThreshold, final int incValue) {
			        final String statsKey = buildAccountStatsKey(accountOwnerParent, accountOwnerSelf, instanceId, topic, group,
			            msgType, flowlimitThreshold);
			        this.statsTable.get(key).addValue(statsKey, incValue, 1);
			    }
			
			    public void incAccountValue(final String statType, final String owner, final String instanceId, final String topic,
			        final String group, final String msgType,
			        final long... incValues) {
			        final String key = buildAccountStatKey(owner, instanceId, topic, group, msgType);
			        this.accountStatManager.inc(statType, key, incValues);
			    }
			
			    public void incAccountValue(final String statType, final String owner, final String instanceId, final String topic,
			        final String group, final String msgType, final String flowlimitThreshold,
			        final long... incValues) {
			        final String key = buildAccountStatKey(owner, instanceId, topic, group, msgType, flowlimitThreshold);
			        this.accountStatManager.inc(statType, key, incValues);
			    }
			
			    public String buildCommercialStatsKey(String owner, String topic, String group, String type) {
			        StringBuilder strBuilder = new StringBuilder();
			        strBuilder.append(owner);
			        strBuilder.append("@");
			        strBuilder.append(topic);
			        strBuilder.append("@");			
",
,
			fromLine:"			646",
			toLine:"			657",
			content:"
			        strBuilder.append("@");
			        strBuilder.append(type);
			        return strBuilder.toString();
			    }
			
			    public String buildAccountStatsKey(String accountOwnerParent, String accountOwnerSelf, String instanceId,
			        String topic, String group, String msgType) {
			        StringBuffer strBuilder = new StringBuffer();
			        strBuilder.append(accountOwnerParent);
			        strBuilder.append("@");
			        strBuilder.append(accountOwnerSelf);
			        strBuilder.append("@");			
",
,
			fromLine:"			663",
			toLine:"			674",
			content:"
			        strBuilder.append("@");
			        strBuilder.append(msgType);
			        return strBuilder.toString();
			    }
			
			    public String buildAccountStatsKey(String accountOwnerParent, String accountOwnerSelf, String instanceId,
			        String topic, String group, String msgType, String flowlimitThreshold) {
			        StringBuffer strBuilder = new StringBuffer();
			        strBuilder.append(accountOwnerParent);
			        strBuilder.append("@");
			        strBuilder.append(accountOwnerSelf);
			        strBuilder.append("@");			
",
,
			fromLine:"			682",
			toLine:"			707",
			content:"
			        strBuilder.append("@");
			        strBuilder.append(flowlimitThreshold);
			        return strBuilder.toString();
			    }
			
			    public String buildAccountStatKey(final String owner, final String instanceId,
			        final String topic, final String group,
			        final String msgType) {
			        final String sep = "|";
			        StringBuffer strBuilder = new StringBuffer();
			        strBuilder.append(owner).append(sep);
			        strBuilder.append(instanceId).append(sep);
			        strBuilder.append(topic).append(sep);
			        strBuilder.append(group).append(sep);
			        strBuilder.append(msgType);
			        return strBuilder.toString();
			    }
			
			    public String buildAccountStatKey(final String owner, final String instanceId,
			        final String topic, final String group,
			        final String msgType, String flowlimitThreshold) {
			        final String sep = "|";
			        StringBuffer strBuilder = new StringBuffer();
			        strBuilder.append(owner).append(sep);
			        strBuilder.append(instanceId).append(sep);
			        strBuilder.append(topic).append(sep);			
",
,
			fromLine:"			714",
			toLine:"			729",
			content:"
			    public String[] splitAccountStatKey(final String accountStatKey) {
			        final String sep = "\\|";
			        return accountStatKey.split(sep);
			    }
			
			    private StatisticsKindMeta createStatisticsKindMeta(String name,
			        String[] itemNames,
			        ScheduledExecutorService executorService,
			        StatisticsItemFormatter formatter,
			        Logger log,
			        long interval) {
			        final BrokerConfig brokerConfig = this.brokerConfig;
			        StatisticsItemPrinter printer = new StatisticsItemPrinter(formatter, log);
			        StatisticsKindMeta kindMeta = new StatisticsKindMeta();
			        kindMeta.setName(name);
			        kindMeta.setItemNames(itemNames);			
",
,

		],
		client/src/main/java/org/apache/rocketmq/client/impl/consumer/DefaultLitePullConsumerImpl.java:
		[
			fromLine:"			16",
			toLine:"			167",
			content:"
			 */
			package org.apache.rocketmq.client.impl.consumer;
			
			import java.util.ArrayList;
			import java.util.Collection;
			import java.util.Collections;
			import java.util.HashMap;
			import java.util.HashSet;
			import java.util.Iterator;
			import java.util.List;
			import java.util.Map;
			import java.util.Properties;
			import java.util.Set;
			import java.util.concurrent.BlockingQueue;
			import java.util.concurrent.ConcurrentHashMap;
			import java.util.concurrent.ConcurrentMap;
			import java.util.concurrent.Executors;
			import java.util.concurrent.LinkedBlockingQueue;
			import java.util.concurrent.ScheduledExecutorService;
			import java.util.concurrent.ScheduledThreadPoolExecutor;
			import java.util.concurrent.TimeUnit;
			import org.apache.commons.lang3.StringUtils;
			import org.apache.rocketmq.client.Validators;
			import org.apache.rocketmq.client.consumer.DefaultLitePullConsumer;
			import org.apache.rocketmq.client.consumer.MessageQueueListener;
			import org.apache.rocketmq.client.consumer.MessageSelector;
			import org.apache.rocketmq.client.consumer.PullResult;
			import org.apache.rocketmq.client.consumer.TopicMessageQueueChangeListener;
			import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;
			import org.apache.rocketmq.client.consumer.store.LocalFileOffsetStore;
			import org.apache.rocketmq.client.consumer.store.OffsetStore;
			import org.apache.rocketmq.client.consumer.store.ReadOffsetType;
			import org.apache.rocketmq.client.consumer.store.RemoteBrokerOffsetStore;
			import org.apache.rocketmq.client.exception.MQBrokerException;
			import org.apache.rocketmq.client.exception.MQClientException;
			import org.apache.rocketmq.client.hook.ConsumeMessageContext;
			import org.apache.rocketmq.client.hook.ConsumeMessageHook;
			import org.apache.rocketmq.client.hook.FilterMessageHook;
			import org.apache.rocketmq.client.impl.CommunicationMode;
			import org.apache.rocketmq.client.impl.MQClientManager;
			import org.apache.rocketmq.client.impl.factory.MQClientInstance;
			import org.apache.rocketmq.common.MixAll;
			import org.apache.rocketmq.common.ServiceState;
			import org.apache.rocketmq.common.ThreadFactoryImpl;
			import org.apache.rocketmq.common.consumer.ConsumeFromWhere;
			import org.apache.rocketmq.common.filter.ExpressionType;
			import org.apache.rocketmq.common.help.FAQUrl;
			import org.apache.rocketmq.common.message.MessageExt;
			import org.apache.rocketmq.common.message.MessageQueue;
			import org.apache.rocketmq.common.sysflag.PullSysFlag;
			import org.apache.rocketmq.remoting.RPCHook;
			import org.apache.rocketmq.remoting.exception.RemotingException;
			import org.apache.rocketmq.remoting.protocol.NamespaceUtil;
			import org.apache.rocketmq.remoting.protocol.ResponseCode;
			import org.apache.rocketmq.remoting.protocol.body.ConsumerRunningInfo;
			import org.apache.rocketmq.remoting.protocol.body.ProcessQueueInfo;
			import org.apache.rocketmq.remoting.protocol.filter.FilterAPI;
			import org.apache.rocketmq.remoting.protocol.heartbeat.ConsumeType;
			import org.apache.rocketmq.remoting.protocol.heartbeat.MessageModel;
			import org.apache.rocketmq.remoting.protocol.heartbeat.SubscriptionData;
			import org.apache.rocketmq.logging.org.slf4j.Logger;
			import org.apache.rocketmq.logging.org.slf4j.LoggerFactory;
			
			public class DefaultLitePullConsumerImpl implements MQConsumerInner {
			
			    private static final Logger log = LoggerFactory.getLogger(DefaultLitePullConsumerImpl.class);
			
			    private final long consumerStartTimestamp = System.currentTimeMillis();
			
			    private final RPCHook rpcHook;
			
			    private final ArrayList<FilterMessageHook> filterMessageHookList = new ArrayList<>();
			
			    private volatile ServiceState serviceState = ServiceState.CREATE_JUST;
			
			    protected MQClientInstance mQClientFactory;
			
			    private PullAPIWrapper pullAPIWrapper;
			
			    private OffsetStore offsetStore;
			
			    private RebalanceImpl rebalanceImpl = new RebalanceLitePullImpl(this);
			
			    private enum SubscriptionType {
			        NONE, SUBSCRIBE, ASSIGN
			    }
			
			    private static final String NOT_RUNNING_EXCEPTION_MESSAGE = "The consumer not running, please start it first.";
			
			    private static final String SUBSCRIPTION_CONFLICT_EXCEPTION_MESSAGE = "Subscribe and assign are mutually exclusive.";
			    /**
			     * the type of subscription
			     */
			    private SubscriptionType subscriptionType = SubscriptionType.NONE;
			    /**
			     * Delay some time when exception occur
			     */
			    private long pullTimeDelayMillsWhenException = 1000;
			    /**
			     * Flow control interval when message cache is full
			     */
			    private static final long PULL_TIME_DELAY_MILLS_WHEN_CACHE_FLOW_CONTROL = 50;
			    /**
			     * Flow control interval when broker return flow control
			     */
			    private static final long PULL_TIME_DELAY_MILLS_WHEN_BROKER_FLOW_CONTROL = 20;
			    /**
			     * Delay some time when suspend pull service
			     */
			    private static final long PULL_TIME_DELAY_MILLS_WHEN_PAUSE = 1000;
			
			    private static final long PULL_TIME_DELAY_MILLS_ON_EXCEPTION = 3 * 1000;
			
			    private ConcurrentHashMap<String/* topic */, String/* subExpression */> topicToSubExpression = new ConcurrentHashMap<>();
			
			    private DefaultLitePullConsumer defaultLitePullConsumer;
			
			    private final ConcurrentMap<MessageQueue, PullTaskImpl> taskTable =
			        new ConcurrentHashMap<>();
			
			    private AssignedMessageQueue assignedMessageQueue = new AssignedMessageQueue();
			
			    private final BlockingQueue<ConsumeRequest> consumeRequestCache = new LinkedBlockingQueue<>();
			
			    private ScheduledThreadPoolExecutor scheduledThreadPoolExecutor;
			
			    private final ScheduledExecutorService scheduledExecutorService;
			
			    private Map<String, TopicMessageQueueChangeListener> topicMessageQueueChangeListenerMap = new HashMap<>();
			
			    private Map<String, Set<MessageQueue>> messageQueuesForTopic = new HashMap<>();
			
			    private long consumeRequestFlowControlTimes = 0L;
			
			    private long queueFlowControlTimes = 0L;
			
			    private long queueMaxSpanFlowControlTimes = 0L;
			
			    private long nextAutoCommitDeadline = -1L;
			
			    private final MessageQueueLock messageQueueLock = new MessageQueueLock();
			
			    private final ArrayList<ConsumeMessageHook> consumeMessageHookList = new ArrayList<>();
			
			    // only for test purpose, will be modified by reflection in unit test.
			    @SuppressWarnings("FieldMayBeFinal")
			    private static boolean doNotUpdateTopicSubscribeInfoWhenSubscriptionChanged = false;
			
			    public DefaultLitePullConsumerImpl(final DefaultLitePullConsumer defaultLitePullConsumer, final RPCHook rpcHook) {
			        this.defaultLitePullConsumer = defaultLitePullConsumer;
			        this.rpcHook = rpcHook;
			        this.scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(			
",
,
			fromLine:"			242",
			toLine:"			252",
			content:"
			        public void messageQueueChanged(String topic, Set<MessageQueue> mqAll, Set<MessageQueue> mqDivided) {
			            updateAssignQueueAndStartPullTask(topic, mqAll, mqDivided);
			        }
			    }
			
			    public void updateAssignQueueAndStartPullTask(String topic, Set<MessageQueue> mqAll, Set<MessageQueue> mqDivided) {
			        MessageModel messageModel = defaultLitePullConsumer.getMessageModel();
			        switch (messageModel) {
			            case BROADCASTING:
			                updateAssignedMessageQueue(topic, mqAll);
			                updatePullTask(topic, mqAll);			
",
,
			fromLine:"			484",
			toLine:"			495",
			content:"
			     * @param topic
			     * @param subExpression
			     * @param messageQueueListener
			     * @throws MQClientException
			     */
			    public synchronized void subscribe(String topic, String subExpression,
			        MessageQueueListener messageQueueListener) throws MQClientException {
			        try {
			            if (StringUtils.isEmpty(topic)) {
			                throw new IllegalArgumentException("Topic can not be null or empty.");
			            }
			            setSubscriptionType(SubscriptionType.SUBSCRIBE);			
",
,
			fromLine:"			792",
			toLine:"			802",
			content:"
			        } else {
			            log.error("consumerOffset is -1 in messageQueue [" + messageQueue + "].");
			        }
			    }
			
			    private void updatePullOffset(MessageQueue messageQueue, long nextPullOffset, ProcessQueue processQueue) {
			        if (assignedMessageQueue.getSeekOffset(messageQueue) == -1) {
			            assignedMessageQueue.updatePullOffset(messageQueue, nextPullOffset, processQueue);
			        }
			    }
						
",
,
			fromLine:"			1016",
			toLine:"			1038",
			content:"
			        public MessageQueue getMessageQueue() {
			            return messageQueue;
			        }
			    }
			
			    private PullResult pull(MessageQueue mq, SubscriptionData subscriptionData, long offset, int maxNums)
			        throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
			        return pull(mq, subscriptionData, offset, maxNums, this.defaultLitePullConsumer.getConsumerPullTimeoutMillis());
			    }
			
			    private PullResult pull(MessageQueue mq, SubscriptionData subscriptionData, long offset, int maxNums, long timeout)
			        throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
			        return this.pullSyncImpl(mq, subscriptionData, offset, maxNums, true, timeout);
			    }
			
			    private PullResult pullSyncImpl(MessageQueue mq, SubscriptionData subscriptionData, long offset, int maxNums,
			        boolean block,
			        long timeout)
			        throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
			
			        if (null == mq) {
			            throw new MQClientException("mq is null", null);
			        }			
",
,
			fromLine:"			1195",
			toLine:"			1205",
			content:"
			        }
			
			        return info;
			    }
			
			    private void updateConsumeOffsetToBroker(MessageQueue mq, long offset, boolean isOneway) throws RemotingException,
			        MQBrokerException, InterruptedException, MQClientException {
			        this.offsetStore.updateConsumeOffsetToBroker(mq, offset, isOneway);
			    }
			
			    public OffsetStore getOffsetStore() {			
",
,

		],
		client/src/main/java/org/apache/rocketmq/client/impl/consumer/DefaultMQPushConsumerImpl.java:
		[
			fromLine:"			16",
			toLine:"			149",
			content:"
			 */
			package org.apache.rocketmq.client.impl.consumer;
			
			import java.util.ArrayList;
			import java.util.Date;
			import java.util.HashMap;
			import java.util.HashSet;
			import java.util.Iterator;
			import java.util.List;
			import java.util.Map;
			import java.util.Map.Entry;
			import java.util.Properties;
			import java.util.Set;
			import java.util.concurrent.ConcurrentMap;
			import org.apache.commons.collections.CollectionUtils;
			import org.apache.commons.lang3.StringUtils;
			import org.apache.rocketmq.client.QueryResult;
			import org.apache.rocketmq.client.Validators;
			import org.apache.rocketmq.client.consumer.AckCallback;
			import org.apache.rocketmq.client.consumer.AckResult;
			import org.apache.rocketmq.client.consumer.AckStatus;
			import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
			import org.apache.rocketmq.client.consumer.MessageQueueListener;
			import org.apache.rocketmq.client.consumer.MessageSelector;
			import org.apache.rocketmq.client.consumer.PopCallback;
			import org.apache.rocketmq.client.consumer.PopResult;
			import org.apache.rocketmq.client.consumer.PopStatus;
			import org.apache.rocketmq.client.consumer.PullCallback;
			import org.apache.rocketmq.client.consumer.PullResult;
			import org.apache.rocketmq.client.consumer.listener.MessageListener;
			import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;
			import org.apache.rocketmq.client.consumer.listener.MessageListenerOrderly;
			import org.apache.rocketmq.client.consumer.store.LocalFileOffsetStore;
			import org.apache.rocketmq.client.consumer.store.OffsetStore;
			import org.apache.rocketmq.client.consumer.store.ReadOffsetType;
			import org.apache.rocketmq.client.consumer.store.RemoteBrokerOffsetStore;
			import org.apache.rocketmq.client.exception.MQBrokerException;
			import org.apache.rocketmq.client.exception.MQClientException;
			import org.apache.rocketmq.client.hook.ConsumeMessageContext;
			import org.apache.rocketmq.client.hook.ConsumeMessageHook;
			import org.apache.rocketmq.client.hook.FilterMessageContext;
			import org.apache.rocketmq.client.hook.FilterMessageHook;
			import org.apache.rocketmq.client.impl.CommunicationMode;
			import org.apache.rocketmq.client.impl.FindBrokerResult;
			import org.apache.rocketmq.client.impl.MQClientManager;
			import org.apache.rocketmq.client.impl.factory.MQClientInstance;
			import org.apache.rocketmq.client.stat.ConsumerStatsManager;
			import org.apache.rocketmq.common.KeyBuilder;
			import org.apache.rocketmq.common.MixAll;
			import org.apache.rocketmq.common.ServiceState;
			import org.apache.rocketmq.common.UtilAll;
			import org.apache.rocketmq.common.consumer.ConsumeFromWhere;
			import org.apache.rocketmq.common.help.FAQUrl;
			import org.apache.rocketmq.common.message.Message;
			import org.apache.rocketmq.common.message.MessageAccessor;
			import org.apache.rocketmq.common.message.MessageConst;
			import org.apache.rocketmq.common.message.MessageExt;
			import org.apache.rocketmq.common.message.MessageQueue;
			import org.apache.rocketmq.common.sysflag.PullSysFlag;
			import org.apache.rocketmq.remoting.RPCHook;
			import org.apache.rocketmq.remoting.common.RemotingHelper;
			import org.apache.rocketmq.remoting.exception.RemotingException;
			import org.apache.rocketmq.remoting.protocol.NamespaceUtil;
			import org.apache.rocketmq.remoting.protocol.ResponseCode;
			import org.apache.rocketmq.remoting.protocol.body.ConsumeStatus;
			import org.apache.rocketmq.remoting.protocol.body.ConsumerRunningInfo;
			import org.apache.rocketmq.remoting.protocol.body.PopProcessQueueInfo;
			import org.apache.rocketmq.remoting.protocol.body.ProcessQueueInfo;
			import org.apache.rocketmq.remoting.protocol.body.QueueTimeSpan;
			import org.apache.rocketmq.remoting.protocol.filter.FilterAPI;
			import org.apache.rocketmq.remoting.protocol.header.AckMessageRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.ChangeInvisibleTimeRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.ExtraInfoUtil;
			import org.apache.rocketmq.remoting.protocol.heartbeat.ConsumeType;
			import org.apache.rocketmq.remoting.protocol.heartbeat.MessageModel;
			import org.apache.rocketmq.remoting.protocol.heartbeat.SubscriptionData;
			import org.apache.rocketmq.remoting.protocol.route.BrokerData;
			import org.apache.rocketmq.remoting.protocol.route.TopicRouteData;
			import org.apache.rocketmq.logging.org.slf4j.Logger;
			import org.apache.rocketmq.logging.org.slf4j.LoggerFactory;
			
			public class DefaultMQPushConsumerImpl implements MQConsumerInner {
			    /**
			     * Delay some time when exception occur
			     */
			    private long pullTimeDelayMillsWhenException = 3000;
			    /**
			     * Flow control interval when message cache is full
			     */
			    private static final long PULL_TIME_DELAY_MILLS_WHEN_CACHE_FLOW_CONTROL = 50;
			    /**
			     * Flow control interval when broker return flow control
			     */
			    private static final long PULL_TIME_DELAY_MILLS_WHEN_BROKER_FLOW_CONTROL = 20;
			    /**
			     * Delay some time when suspend pull service
			     */
			    private static final long PULL_TIME_DELAY_MILLS_WHEN_SUSPEND = 1000;
			    private static final long BROKER_SUSPEND_MAX_TIME_MILLIS = 1000 * 15;
			    private static final long CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND = 1000 * 30;
			    private static final Logger log = LoggerFactory.getLogger(DefaultMQPushConsumerImpl.class);
			    private final DefaultMQPushConsumer defaultMQPushConsumer;
			    private final RebalanceImpl rebalanceImpl = new RebalancePushImpl(this);
			    private final ArrayList<FilterMessageHook> filterMessageHookList = new ArrayList<>();
			    private final long consumerStartTimestamp = System.currentTimeMillis();
			    private final ArrayList<ConsumeMessageHook> consumeMessageHookList = new ArrayList<>();
			    private final RPCHook rpcHook;
			    private volatile ServiceState serviceState = ServiceState.CREATE_JUST;
			    private MQClientInstance mQClientFactory;
			    private PullAPIWrapper pullAPIWrapper;
			    private volatile boolean pause = false;
			    private boolean consumeOrderly = false;
			    private MessageListener messageListenerInner;
			    private OffsetStore offsetStore;
			    private ConsumeMessageService consumeMessageService;
			    private ConsumeMessageService consumeMessagePopService;
			    private long queueFlowControlTimes = 0;
			    private long queueMaxSpanFlowControlTimes = 0;
			
			    //10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h
			    private final int[] popDelayLevel = new int[] {10, 30, 60, 120, 180, 240, 300, 360, 420, 480, 540, 600, 1200, 1800, 3600, 7200};
			
			    private static final int MAX_POP_INVISIBLE_TIME = 300000;
			    private static final int MIN_POP_INVISIBLE_TIME = 5000;
			    private static final int ASYNC_TIMEOUT = 3000;
			
			    // only for test purpose, will be modified by reflection in unit test.
			    @SuppressWarnings("FieldMayBeFinal")
			    private static boolean doNotUpdateTopicSubscribeInfoWhenSubscriptionChanged = false;
			
			    public DefaultMQPushConsumerImpl(DefaultMQPushConsumer defaultMQPushConsumer, RPCHook rpcHook) {
			        this.defaultMQPushConsumer = defaultMQPushConsumer;
			        this.rpcHook = rpcHook;
			        this.pullTimeDelayMillsWhenException = defaultMQPushConsumer.getPullTimeDelayMillsWhenException();			
",
,
			fromLine:"			185",
			toLine:"			199",
			content:"
			                }
			            }
			        }
			    }
			
			    public void createTopic(String key, String newTopic, int queueNum) throws MQClientException {
			        createTopic(key, newTopic, queueNum, 0);
			    }
			
			    public void createTopic(String key, String newTopic, int queueNum, int topicSysFlag) throws MQClientException {
			        this.mQClientFactory.getMQAdminImpl().createTopic(key, newTopic, queueNum, topicSysFlag, null);
			    }
			
			    public Set<MessageQueue> fetchSubscribeMessageQueues(String topic) throws MQClientException {
			        Set<MessageQueue> result = this.rebalanceImpl.getTopicSubscribeInfoTable().get(topic);			
",
,
			fromLine:"			714",
			toLine:"			724",
			content:"
			
			    public void executeTask(final Runnable r) {
			        this.mQClientFactory.getPullMessageService().executeTask(r);
			    }
			
			    public QueryResult queryMessage(String topic, String key, int maxNum, long begin, long end)
			        throws MQClientException, InterruptedException {
			        return this.mQClientFactory.getMQAdminImpl().queryMessage(topic, key, maxNum, begin, end);
			    }
			
			    public MessageExt queryMessageByUniqKey(String topic, String uniqKey) throws MQClientException,			
",
,
			fromLine:"			735",
			toLine:"			756",
			content:"
			        doRebalance();
			        log.info("resume this consumer, {}", this.defaultMQPushConsumer.getConsumerGroup());
			    }
			
			    @Deprecated
			    public void sendMessageBack(MessageExt msg, int delayLevel, final String brokerName)
			            throws RemotingException, MQBrokerException, InterruptedException, MQClientException {
			        sendMessageBack(msg, delayLevel, brokerName, null);
			    }
			
			    public void sendMessageBack(MessageExt msg, int delayLevel, final MessageQueue mq)
			            throws RemotingException, MQBrokerException, InterruptedException, MQClientException {
			        sendMessageBack(msg, delayLevel, null, mq);
			    }
			
			
			    private void sendMessageBack(MessageExt msg, int delayLevel, final String brokerName, final MessageQueue mq)
			        throws RemotingException, MQBrokerException, InterruptedException, MQClientException {
			        boolean needRetry = true;
			        try {
			            if (brokerName != null && brokerName.startsWith(MixAll.LOGICAL_QUEUE_MOCK_BROKER_PREFIX)
			                || mq != null && mq.getBrokerName().startsWith(MixAll.LOGICAL_QUEUE_MOCK_BROKER_PREFIX)) {			
",
,
			fromLine:"			841",
			toLine:"			851",
			content:"
			        } catch (Throwable t) {
			            log.error("ack async error.", t);
			        }
			    }
			
			    void changePopInvisibleTimeAsync(String topic, String consumerGroup, String extraInfo, long invisibleTime, AckCallback callback)
			        throws MQClientException, RemotingException, InterruptedException, MQBrokerException {
			        String[] extraInfoStrs = ExtraInfoUtil.split(extraInfo);
			        String brokerName = ExtraInfoUtil.getBrokerName(extraInfoStrs);
			        int queueId = ExtraInfoUtil.getQueueId(extraInfoStrs);
						
",
,
			fromLine:"			1255",
			toLine:"			1265",
			content:"
			        } catch (Exception e) {
			            throw new MQClientException("subscription exception", e);
			        }
			    }
			
			    public void subscribe(String topic, String fullClassName, String filterClassSource) throws MQClientException {
			        try {
			            SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(topic, SubscriptionData.SUB_ALL);
			            subscriptionData.setSubString(fullClassName);
			            subscriptionData.setClassFilterMode(true);
			            subscriptionData.setFilterClassSource(filterClassSource);			
",
,

		],
		common/src/main/java/org/apache/rocketmq/common/BrokerConfig.java:
		[
			fromLine:"			16",
			toLine:"			425",
			content:"
			 */
			package org.apache.rocketmq.common;
			
			import org.apache.rocketmq.common.annotation.ImportantField;
			import org.apache.rocketmq.common.constant.PermName;
			import org.apache.rocketmq.common.message.MessageRequestMode;
			import org.apache.rocketmq.common.metrics.MetricsExporterType;
			import org.apache.rocketmq.common.topic.TopicValidator;
			import org.apache.rocketmq.common.utils.NetworkUtil;
			
			import java.util.concurrent.TimeUnit;
			
			public class BrokerConfig extends BrokerIdentity {
			
			    private String brokerConfigPath = null;
			
			    private String rocketmqHome = System.getProperty(MixAll.ROCKETMQ_HOME_PROPERTY, System.getenv(MixAll.ROCKETMQ_HOME_ENV));
			    @ImportantField
			    private String namesrvAddr = System.getProperty(MixAll.NAMESRV_ADDR_PROPERTY, System.getenv(MixAll.NAMESRV_ADDR_ENV));
			
			    /**
			     * Listen port for single broker
			     */
			    @ImportantField
			    private int listenPort = 6888;
			
			    @ImportantField
			    private String brokerIP1 = NetworkUtil.getLocalAddress();
			    private String brokerIP2 = NetworkUtil.getLocalAddress();
			
			    @ImportantField
			    private boolean recoverConcurrently = false;
			
			    private int brokerPermission = PermName.PERM_READ | PermName.PERM_WRITE;
			    private int defaultTopicQueueNums = 8;
			    @ImportantField
			    private boolean autoCreateTopicEnable = true;
			
			    private boolean clusterTopicEnable = true;
			
			    private boolean brokerTopicEnable = true;
			    @ImportantField
			    private boolean autoCreateSubscriptionGroup = true;
			    private String messageStorePlugIn = "";
			
			    private static final int PROCESSOR_NUMBER = Runtime.getRuntime().availableProcessors();
			    @ImportantField
			    private String msgTraceTopicName = TopicValidator.RMQ_SYS_TRACE_TOPIC;
			    @ImportantField
			    private boolean traceTopicEnable = false;
			    /**
			     * thread numbers for send message thread pool.
			     */
			    private int sendMessageThreadPoolNums = Math.min(PROCESSOR_NUMBER, 4);
			    private int putMessageFutureThreadPoolNums = Math.min(PROCESSOR_NUMBER, 4);
			    private int pullMessageThreadPoolNums = 16 + PROCESSOR_NUMBER * 2;
			    private int litePullMessageThreadPoolNums = 16 + PROCESSOR_NUMBER * 2;
			    private int ackMessageThreadPoolNums = 3;
			    private int processReplyMessageThreadPoolNums = 16 + PROCESSOR_NUMBER * 2;
			    private int queryMessageThreadPoolNums = 8 + PROCESSOR_NUMBER;
			
			    private int adminBrokerThreadPoolNums = 16;
			    private int clientManageThreadPoolNums = 32;
			    private int consumerManageThreadPoolNums = 32;
			    private int loadBalanceProcessorThreadPoolNums = 32;
			    private int heartbeatThreadPoolNums = Math.min(32, PROCESSOR_NUMBER);
			    private int recoverThreadPoolNums = 32;
			
			    /**
			     * Thread numbers for EndTransactionProcessor
			     */
			    private int endTransactionThreadPoolNums = Math.max(8 + PROCESSOR_NUMBER * 2,
			            sendMessageThreadPoolNums * 4);
			
			    private int flushConsumerOffsetInterval = 1000 * 5;
			
			    private int flushConsumerOffsetHistoryInterval = 1000 * 60;
			
			    @ImportantField
			    private boolean rejectTransactionMessage = false;
			
			    @ImportantField
			    private boolean fetchNameSrvAddrByDnsLookup = false;
			
			    @ImportantField
			    private boolean fetchNamesrvAddrByAddressServer = false;
			
			    private int sendThreadPoolQueueCapacity = 10000;
			    private int putThreadPoolQueueCapacity = 10000;
			    private int pullThreadPoolQueueCapacity = 100000;
			    private int litePullThreadPoolQueueCapacity = 100000;
			    private int ackThreadPoolQueueCapacity = 100000;
			    private int replyThreadPoolQueueCapacity = 10000;
			    private int queryThreadPoolQueueCapacity = 20000;
			    private int clientManagerThreadPoolQueueCapacity = 1000000;
			    private int consumerManagerThreadPoolQueueCapacity = 1000000;
			    private int heartbeatThreadPoolQueueCapacity = 50000;
			    private int endTransactionPoolQueueCapacity = 100000;
			    private int adminBrokerThreadPoolQueueCapacity = 10000;
			    private int loadBalanceThreadPoolQueueCapacity = 100000;
			
			    private boolean longPollingEnable = true;
			
			    private long shortPollingTimeMills = 1000;
			
			    private boolean notifyConsumerIdsChangedEnable = true;
			
			    private boolean highSpeedMode = false;
			
			    private int commercialBaseCount = 1;
			
			    private int commercialSizePerMsg = 4 * 1024;
			
			    private boolean accountStatsEnable = true;
			    private boolean accountStatsPrintZeroValues = true;
			
			    private boolean transferMsgByHeap = true;
			
			    private String regionId = MixAll.DEFAULT_TRACE_REGION_ID;
			    private int registerBrokerTimeoutMills = 24000;
			
			    private int sendHeartbeatTimeoutMillis = 1000;
			
			    private boolean slaveReadEnable = false;
			
			    private boolean disableConsumeIfConsumerReadSlowly = false;
			    private long consumerFallbehindThreshold = 1024L * 1024 * 1024 * 16;
			
			    private boolean brokerFastFailureEnable = true;
			    private long waitTimeMillsInSendQueue = 200;
			    private long waitTimeMillsInPullQueue = 5 * 1000;
			    private long waitTimeMillsInLitePullQueue = 5 * 1000;
			    private long waitTimeMillsInHeartbeatQueue = 31 * 1000;
			    private long waitTimeMillsInTransactionQueue = 3 * 1000;
			    private long waitTimeMillsInAckQueue = 3000;
			
			    private long startAcceptSendRequestTimeStamp = 0L;
			
			    private boolean traceOn = true;
			
			    // Switch of filter bit map calculation.
			    // If switch on:
			    // 1. Calculate filter bit map when construct queue.
			    // 2. Filter bit map will be saved to consume queue extend file if allowed.
			    private boolean enableCalcFilterBitMap = false;
			
			    //Reject the pull consumer instance to pull messages from broker.
			    private boolean rejectPullConsumerEnable = false;
			
			    // Expect num of consumers will use filter.
			    private int expectConsumerNumUseFilter = 32;
			
			    // Error rate of bloom filter, 1~100.
			    private int maxErrorRateOfBloomFilter = 20;
			
			    //how long to clean filter data after dead.Default: 24h
			    private long filterDataCleanTimeSpan = 24 * 3600 * 1000;
			
			    // whether do filter when retry.
			    private boolean filterSupportRetry = false;
			    private boolean enablePropertyFilter = false;
			
			    private boolean compressedRegister = false;
			
			    private boolean forceRegister = true;
			
			    /**
			     * This configurable item defines interval of topics registration of broker to name server. Allowing values are
			     * between 10,000 and 60,000 milliseconds.
			     */
			    private int registerNameServerPeriod = 1000 * 30;
			
			    /**
			     * the interval to send heartbeat to name server for liveness detection.
			     */
			    private int brokerHeartbeatInterval = 1000;
			
			    /**
			     * How long the broker will be considered as inactive by nameserver since last heartbeat. Effective only if
			     * enableSlaveActingMaster is true
			     */
			    private long brokerNotActiveTimeoutMillis = 10 * 1000;
			
			    private boolean enableNetWorkFlowControl = false;
			
			    private boolean enableBroadcastOffsetStore = true;
			
			    private long broadcastOffsetExpireSecond = 2 * 60;
			
			    private long broadcastOffsetExpireMaxSecond = 5 * 60;
			
			    private int popPollingSize = 1024;
			    private int popPollingMapSize = 100000;
			    // 20w cost 200M heap memory.
			    private long maxPopPollingSize = 100000;
			    private int reviveQueueNum = 8;
			    private long reviveInterval = 1000;
			    private long reviveMaxSlow = 3;
			    private long reviveScanTime = 10000;
			    private boolean enableSkipLongAwaitingAck = false;
			    private long reviveAckWaitMs = TimeUnit.MINUTES.toMillis(3);
			    private boolean enablePopLog = false;
			    private boolean enablePopBufferMerge = false;
			    private int popCkStayBufferTime = 10 * 1000;
			    private int popCkStayBufferTimeOut = 3 * 1000;
			    private int popCkMaxBufferSize = 200000;
			    private int popCkOffsetMaxQueueSize = 20000;
			    private boolean enablePopBatchAck = false;
			    private boolean enableNotifyAfterPopOrderLockRelease = true;
			    private boolean initPopOffsetByCheckMsgInMem = true;
			    // read message from pop retry topic v1, for the compatibility, will be removed in the future version
			    private boolean retrieveMessageFromPopRetryTopicV1 = true;
			    private boolean enableRetryTopicV2 = false;
			
			    private boolean realTimeNotifyConsumerChange = true;
			
			    private boolean litePullMessageEnable = true;
			
			    // The period to sync broker member group from namesrv, default value is 1 second
			    private int syncBrokerMemberGroupPeriod = 1000;
			
			    /**
			     * the interval of pulling topic information from the named server
			     */
			    private long loadBalancePollNameServerInterval = 1000 * 30;
			
			    /**
			     * the interval of cleaning
			     */
			    private int cleanOfflineBrokerInterval = 1000 * 30;
			
			    private boolean serverLoadBalancerEnable = true;
			
			    private MessageRequestMode defaultMessageRequestMode = MessageRequestMode.PULL;
			
			    private int defaultPopShareQueueNum = -1;
			
			    /**
			     * The minimum time of the transactional message  to be checked firstly, one message only exceed this time interval
			     * that can be checked.
			     */
			    @ImportantField
			    private long transactionTimeOut = 6 * 1000;
			
			    /**
			     * The maximum number of times the message was checked, if exceed this value, this message will be discarded.
			     */
			    @ImportantField
			    private int transactionCheckMax = 15;
			
			    /**
			     * Transaction message check interval.
			     */
			    @ImportantField
			    private long transactionCheckInterval = 30 * 1000;
			
			    private long transactionMetricFlushInterval = 3 * 1000;
			
			    /**
			     * transaction batch op message
			     */
			    private int transactionOpMsgMaxSize = 4096;
			
			    private int transactionOpBatchInterval = 3000;
			
			    /**
			     * Acl feature switch
			     */
			    @ImportantField
			    private boolean aclEnable = false;
			
			    private boolean storeReplyMessageEnable = true;
			
			    private boolean enableDetailStat = true;
			
			    private boolean autoDeleteUnusedStats = false;
			
			    /**
			     * Whether to distinguish log paths when multiple brokers are deployed on the same machine
			     */
			    private boolean isolateLogEnable = false;
			
			    private long forwardTimeout = 3 * 1000;
			
			    /**
			     * Slave will act master when failover. For example, if master down, timer or transaction message which is expire in slave will
			     * put to master (master of the same process in broker container mode or other masters in cluster when enableFailoverRemotingActing is true)
			     * when enableSlaveActingMaster is true
			     */
			    private boolean enableSlaveActingMaster = false;
			
			    private boolean enableRemoteEscape = false;
			
			    private boolean skipPreOnline = false;
			
			    private boolean asyncSendEnable = true;
			
			    private boolean useServerSideResetOffset = true;
			
			    private long consumerOffsetUpdateVersionStep = 500;
			
			    private long delayOffsetUpdateVersionStep = 200;
			
			    /**
			     * Whether to lock quorum replicas.
			     *
			     * True: need to lock quorum replicas succeed. False: only need to lock one replica succeed.
			     */
			    private boolean lockInStrictMode = false;
			
			    private boolean compatibleWithOldNameSrv = true;
			
			    /**
			     * Is startup controller mode, which support auto switch broker's role.
			     */
			    private boolean enableControllerMode = false;
			
			    private String controllerAddr = "";
			
			    private boolean fetchControllerAddrByDnsLookup = false;
			
			    private long syncBrokerMetadataPeriod = 5 * 1000;
			
			    private long checkSyncStateSetPeriod = 5 * 1000;
			
			    private long syncControllerMetadataPeriod = 10 * 1000;
			
			    private long controllerHeartBeatTimeoutMills = 10 * 1000;
			
			    private boolean validateSystemTopicWhenUpdateTopic = true;
			
			    /**
			     * It is an important basis for the controller to choose the broker master.
			     * The lower the value of brokerElectionPriority, the higher the priority of the broker being selected as the master.
			     * You can set a lower priority for the broker with better machine conditions.
			     */
			    private int brokerElectionPriority = Integer.MAX_VALUE;
			
			    private boolean useStaticSubscription = false;
			
			    private MetricsExporterType metricsExporterType = MetricsExporterType.DISABLE;
			
			    private int metricsOtelCardinalityLimit = 50 * 1000;
			    private String metricsGrpcExporterTarget = "";
			    private String metricsGrpcExporterHeader = "";
			    private long metricGrpcExporterTimeOutInMills = 3 * 1000;
			    private long metricGrpcExporterIntervalInMills = 60 * 1000;
			    private long metricLoggingExporterIntervalInMills = 10 * 1000;
			
			    private int metricsPromExporterPort = 5557;
			    private String metricsPromExporterHost = "";
			
			    // Label pairs in CSV. Each label follows pattern of Key:Value. eg: instance_id:xxx,uid:xxx
			    private String metricsLabel = "";
			
			    private boolean metricsInDelta = false;
			
			    private long channelExpiredTimeout = 1000 * 120;
			    private long subscriptionExpiredTimeout = 1000 * 60 * 10;
			
			    /**
			     * Estimate accumulation or not when subscription filter type is tag and is not SUB_ALL.
			     */
			    private boolean estimateAccumulation = true;
			
			    private boolean coldCtrStrategyEnable = false;
			    private boolean usePIDColdCtrStrategy = true;
			    private long cgColdReadThreshold = 3 * 1024 * 1024;
			    private long globalColdReadThreshold = 100 * 1024 * 1024;
			    
			    /**
			     * The interval to fetch namesrv addr, default value is 10 second
			     */
			    private long fetchNamesrvAddrInterval = 10 * 1000;
			
			    /**
			     * Pop response returns the actual retry topic rather than tampering with the original topic
			     */
			    private boolean popResponseReturnActualRetryTopic = false;
			
			    /**
			     * If both the deleteTopicWithBrokerRegistration flag in the NameServer configuration and this flag are set to true,
			     * it guarantees the ultimate consistency of data between the broker and the nameserver during topic deletion.
			     */
			    private boolean enableSingleTopicRegister = false;
			
			    private boolean enableMixedMessageType = false;
			
			    /**
			     * This flag and deleteTopicWithBrokerRegistration flag in the NameServer cannot be set to true at the same time,
			     * otherwise there will be a loss of routing
			     */
			    private boolean enableSplitRegistration = false;
			
			    private long popInflightMessageThreshold = 10000;
			    private boolean enablePopMessageThreshold = false;
			
			    private int splitRegistrationSize = 800;
			
			    /**
			     * Config in this black list will be not allowed to update by command.
			     * Try to update this config black list by restart process.
			     * Try to update configures in black list by restart process.
			     */
			    private String configBlackList = "configBlackList;brokerConfigPath";
			
			    public String getConfigBlackList() {
			        return configBlackList;
			    }
						
",
,

		],
		proxy/src/main/java/org/apache/rocketmq/proxy/config/ProxyConfig.java:
		[
			fromLine:"			17",
			toLine:"			274",
			content:"
			
			package org.apache.rocketmq.proxy.config;
			
			import java.net.InetAddress;
			import java.net.UnknownHostException;
			import java.time.Duration;
			import java.util.Comparator;
			import java.util.HashMap;
			import java.util.List;
			import java.util.Map;
			import java.util.concurrent.ConcurrentSkipListMap;
			import java.util.concurrent.TimeUnit;
			import java.util.stream.Collectors;
			import org.apache.commons.lang3.StringUtils;
			import org.apache.rocketmq.common.MixAll;
			import org.apache.rocketmq.common.constant.LoggerName;
			import org.apache.rocketmq.common.metrics.MetricsExporterType;
			import org.apache.rocketmq.common.utils.NetworkUtil;
			import org.apache.rocketmq.logging.org.slf4j.Logger;
			import org.apache.rocketmq.logging.org.slf4j.LoggerFactory;
			import org.apache.rocketmq.proxy.ProxyMode;
			import org.apache.rocketmq.proxy.common.ProxyException;
			import org.apache.rocketmq.proxy.common.ProxyExceptionCode;
			
			public class ProxyConfig implements ConfigFile {
			    private final static Logger log = LoggerFactory.getLogger(LoggerName.PROXY_LOGGER_NAME);
			    public final static String DEFAULT_CONFIG_FILE_NAME = "rmq-proxy.json";
			    private static final int PROCESSOR_NUMBER = Runtime.getRuntime().availableProcessors();
			    private static final String DEFAULT_CLUSTER_NAME = "DefaultCluster";
			
			    private static String localHostName;
			
			    static {
			        try {
			            localHostName = InetAddress.getLocalHost().getHostName();
			        } catch (UnknownHostException e) {
			            log.error("Failed to obtain the host name", e);
			        }
			    }
			
			    private String rocketMQClusterName = DEFAULT_CLUSTER_NAME;
			    private String proxyClusterName = DEFAULT_CLUSTER_NAME;
			    private String proxyName = StringUtils.isEmpty(localHostName) ? "DEFAULT_PROXY" : localHostName;
			
			    private String localServeAddr = "";
			
			    private String heartbeatSyncerTopicClusterName = "";
			    private int heartbeatSyncerThreadPoolNums = 4;
			    private int heartbeatSyncerThreadPoolQueueCapacity = 100;
			
			    private String heartbeatSyncerTopicName = "DefaultHeartBeatSyncerTopic";
			
			    /**
			     * configuration for ThreadPoolMonitor
			     */
			    private boolean enablePrintJstack = true;
			    private long printJstackInMillis = Duration.ofSeconds(60).toMillis();
			    private long printThreadPoolStatusInMillis = Duration.ofSeconds(3).toMillis();
			
			    private String namesrvAddr = System.getProperty(MixAll.NAMESRV_ADDR_PROPERTY, System.getenv(MixAll.NAMESRV_ADDR_ENV));
			    private String namesrvDomain = "";
			    private String namesrvDomainSubgroup = "";
			    /**
			     * TLS
			     */
			    private boolean tlsTestModeEnable = true;
			    private String tlsKeyPath = ConfigurationManager.getProxyHome() + "/conf/tls/rocketmq.key";
			    private String tlsCertPath = ConfigurationManager.getProxyHome() + "/conf/tls/rocketmq.crt";
			    /**
			     * gRPC
			     */
			    private String proxyMode = ProxyMode.CLUSTER.name();
			    private Integer grpcServerPort = 8081;
			    private long grpcShutdownTimeSeconds = 30;
			    private int grpcBossLoopNum = 1;
			    private int grpcWorkerLoopNum = PROCESSOR_NUMBER * 2;
			    private boolean enableGrpcEpoll = false;
			    private int grpcThreadPoolNums = 16 + PROCESSOR_NUMBER * 2;
			    private int grpcThreadPoolQueueCapacity = 100000;
			    private String brokerConfigPath = ConfigurationManager.getProxyHome() + "/conf/broker.conf";
			    /**
			     * gRPC max message size
			     * 130M = 4M * 32 messages + 2M attributes
			     */
			    private int grpcMaxInboundMessageSize = 130 * 1024 * 1024;
			    /**
			     * max message body size, 0 or negative number means no limit for proxy
			     */
			    private int maxMessageSize = 4 * 1024 * 1024;
			    /**
			     * max user property size, 0 or negative number means no limit for proxy
			     */
			    private int maxUserPropertySize = 16 * 1024;
			    private int userPropertyMaxNum = 128;
			
			    /**
			     * max message group size, 0 or negative number means no limit for proxy
			     */
			    private int maxMessageGroupSize = 64;
			
			    /**
			     * When a message pops, the message is invisible by default
			     */
			    private long defaultInvisibleTimeMills = Duration.ofSeconds(60).toMillis();
			    private long minInvisibleTimeMillsForRecv = Duration.ofSeconds(10).toMillis();
			    private long maxInvisibleTimeMills = Duration.ofHours(12).toMillis();
			    private long maxDelayTimeMills = Duration.ofDays(1).toMillis();
			    private long maxTransactionRecoverySecond = Duration.ofHours(1).getSeconds();
			    private boolean enableTopicMessageTypeCheck = true;
			
			    private int grpcClientProducerMaxAttempts = 3;
			    private long grpcClientProducerBackoffInitialMillis = 10;
			    private long grpcClientProducerBackoffMaxMillis = 1000;
			    private int grpcClientProducerBackoffMultiplier = 2;
			    private long grpcClientConsumerMinLongPollingTimeoutMillis = Duration.ofSeconds(5).toMillis();
			    private long grpcClientConsumerMaxLongPollingTimeoutMillis = Duration.ofSeconds(20).toMillis();
			    private int grpcClientConsumerLongPollingBatchSize = 32;
			    private long grpcClientIdleTimeMills = Duration.ofSeconds(120).toMillis();
			
			    private int channelExpiredInSeconds = 60;
			    private int contextExpiredInSeconds = 30;
			
			    private int rocketmqMQClientNum = 6;
			
			    private long grpcProxyRelayRequestTimeoutInSeconds = 5;
			    private int grpcProducerThreadPoolNums = PROCESSOR_NUMBER;
			    private int grpcProducerThreadQueueCapacity = 10000;
			    private int grpcConsumerThreadPoolNums = PROCESSOR_NUMBER;
			    private int grpcConsumerThreadQueueCapacity = 10000;
			    private int grpcRouteThreadPoolNums = PROCESSOR_NUMBER;
			    private int grpcRouteThreadQueueCapacity = 10000;
			    private int grpcClientManagerThreadPoolNums = PROCESSOR_NUMBER;
			    private int grpcClientManagerThreadQueueCapacity = 10000;
			    private int grpcTransactionThreadPoolNums = PROCESSOR_NUMBER;
			    private int grpcTransactionThreadQueueCapacity = 10000;
			
			    private int producerProcessorThreadPoolNums = PROCESSOR_NUMBER;
			    private int producerProcessorThreadPoolQueueCapacity = 10000;
			    private int consumerProcessorThreadPoolNums = PROCESSOR_NUMBER;
			    private int consumerProcessorThreadPoolQueueCapacity = 10000;
			
			    private boolean useEndpointPortFromRequest = false;
			
			    private int topicRouteServiceCacheExpiredSeconds = 300;
			    private int topicRouteServiceCacheRefreshSeconds = 20;
			    private int topicRouteServiceCacheMaxNum = 20000;
			    private int topicRouteServiceThreadPoolNums = PROCESSOR_NUMBER;
			    private int topicRouteServiceThreadPoolQueueCapacity = 5000;
			    private int topicConfigCacheExpiredSeconds = 300;
			    private int topicConfigCacheRefreshSeconds = 20;
			    private int topicConfigCacheMaxNum = 20000;
			    private int subscriptionGroupConfigCacheExpiredSeconds = 300;
			    private int subscriptionGroupConfigCacheRefreshSeconds = 20;
			    private int subscriptionGroupConfigCacheMaxNum = 20000;
			    private int userCacheExpiredSeconds = 300;
			    private int userCacheRefreshSeconds = 20;
			    private int userCacheMaxNum = 20000;
			    private int aclCacheExpiredSeconds = 300;
			    private int aclCacheRefreshSeconds = 20;
			    private int aclCacheMaxNum = 20000;
			    private int metadataThreadPoolNums = 3;
			    private int metadataThreadPoolQueueCapacity = 100000;
			
			    private int transactionHeartbeatThreadPoolNums = 20;
			    private int transactionHeartbeatThreadPoolQueueCapacity = 200;
			    private int transactionHeartbeatPeriodSecond = 20;
			    private int transactionHeartbeatBatchNum = 100;
			    private long transactionDataExpireScanPeriodMillis = Duration.ofSeconds(10).toMillis();
			    private long transactionDataMaxWaitClearMillis = Duration.ofSeconds(30).toMillis();
			    private long transactionDataExpireMillis = Duration.ofSeconds(30).toMillis();
			    private int transactionDataMaxNum = 15;
			
			    private long longPollingReserveTimeInMillis = 100;
			
			    private long invisibleTimeMillisWhenClear = 1000L;
			    private boolean enableProxyAutoRenew = true;
			    private int maxRenewRetryTimes = 3;
			    private int renewThreadPoolNums = 2;
			    private int renewMaxThreadPoolNums = 4;
			    private int renewThreadPoolQueueCapacity = 300;
			    private long lockTimeoutMsInHandleGroup = TimeUnit.SECONDS.toMillis(3);
			    private long renewAheadTimeMillis = TimeUnit.SECONDS.toMillis(10);
			    private long renewMaxTimeMillis = TimeUnit.HOURS.toMillis(3);
			    private long renewSchedulePeriodMillis = TimeUnit.SECONDS.toMillis(5);
			
			    private boolean enableACL = false;
			
			    private boolean enableAclRpcHookForClusterMode = false;
			
			    private boolean useDelayLevel = false;
			    private String messageDelayLevel = "1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h";
			    private transient ConcurrentSkipListMap<Integer /* level */, Long/* delay timeMillis */> delayLevelTable = new ConcurrentSkipListMap<>();
			
			    private String metricCollectorMode = MetricCollectorMode.OFF.getModeString();
			    // Example address: 127.0.0.1:1234
			    private String metricCollectorAddress = "";
			
			    private String regionId = "";
			
			    private boolean traceOn = false;
			
			    private MetricsExporterType metricsExporterType = MetricsExporterType.DISABLE;
			
			    private String metricsGrpcExporterTarget = "";
			    private String metricsGrpcExporterHeader = "";
			    private long metricGrpcExporterTimeOutInMills = 3 * 1000;
			    private long metricGrpcExporterIntervalInMills = 60 * 1000;
			    private long metricLoggingExporterIntervalInMills = 10 * 1000;
			
			    private int metricsPromExporterPort = 5557;
			    private String metricsPromExporterHost = "";
			
			    // Label pairs in CSV. Each label follows pattern of Key:Value. eg: instance_id:xxx,uid:xxx
			    private String metricsLabel = "";
			
			    private boolean metricsInDelta = false;
			
			    private long channelExpiredTimeout = 1000 * 120;
			
			    // remoting
			    private boolean enableRemotingLocalProxyGrpc = true;
			    private int localProxyConnectTimeoutMs = 3000;
			    private String remotingAccessAddr = "";
			    private int remotingListenPort = 8080;
			
			    // related to proxy's send strategy in cluster mode.
			    private boolean sendLatencyEnable = false;
			    private boolean startDetectorEnable = false;
			    private int detectTimeout = 200;
			    private int detectInterval = 2 * 1000;
			
			    private int remotingHeartbeatThreadPoolNums = 2 * PROCESSOR_NUMBER;
			    private int remotingTopicRouteThreadPoolNums = 2 * PROCESSOR_NUMBER;
			    private int remotingSendMessageThreadPoolNums = 4 * PROCESSOR_NUMBER;
			    private int remotingPullMessageThreadPoolNums = 4 * PROCESSOR_NUMBER;
			    private int remotingUpdateOffsetThreadPoolNums = 4 * PROCESSOR_NUMBER;
			    private int remotingDefaultThreadPoolNums = 4 * PROCESSOR_NUMBER;
			
			    private int remotingHeartbeatThreadPoolQueueCapacity = 50000;
			    private int remotingTopicRouteThreadPoolQueueCapacity = 50000;
			    private int remotingSendThreadPoolQueueCapacity = 10000;
			    private int remotingPullThreadPoolQueueCapacity = 50000;
			    private int remotingUpdateOffsetThreadPoolQueueCapacity = 10000;
			    private int remotingDefaultThreadPoolQueueCapacity = 50000;
			
			    private long remotingWaitTimeMillsInSendQueue = 3 * 1000;
			    private long remotingWaitTimeMillsInPullQueue = 5 * 1000;
			    private long remotingWaitTimeMillsInHeartbeatQueue = 31 * 1000;
			    private long remotingWaitTimeMillsInUpdateOffsetQueue = 3 * 1000;
			    private long remotingWaitTimeMillsInTopicRouteQueue = 3 * 1000;
			    private long remotingWaitTimeMillsInDefaultQueue = 3 * 1000;
			
			    private boolean enableBatchAck = false;
			
			    @Override
			    public void initData() {
			        parseDelayLevel();
			        if (StringUtils.isEmpty(localServeAddr)) {			
",
,

		],
		broker/src/main/java/org/apache/rocketmq/broker/metrics/ConsumerLagCalculator.java:
		[
			fromLine:"			16",
			toLine:"			68",
			content:"
			 */
			package org.apache.rocketmq.broker.metrics;
			
			import java.util.Map;
			import java.util.Set;
			import java.util.function.Consumer;
			import java.util.stream.Collectors;
			import org.apache.rocketmq.broker.BrokerController;
			import org.apache.rocketmq.broker.client.ConsumerGroupInfo;
			import org.apache.rocketmq.broker.client.ConsumerManager;
			import org.apache.rocketmq.broker.filter.ConsumerFilterData;
			import org.apache.rocketmq.broker.filter.ConsumerFilterManager;
			import org.apache.rocketmq.broker.filter.ExpressionMessageFilter;
			import org.apache.rocketmq.broker.offset.ConsumerOffsetManager;
			import org.apache.rocketmq.broker.processor.PopBufferMergeService;
			import org.apache.rocketmq.broker.processor.PopInflightMessageCounter;
			import org.apache.rocketmq.broker.subscription.SubscriptionGroupManager;
			import org.apache.rocketmq.broker.topic.TopicConfigManager;
			import org.apache.rocketmq.common.BrokerConfig;
			import org.apache.rocketmq.common.KeyBuilder;
			import org.apache.rocketmq.common.MixAll;
			import org.apache.rocketmq.common.Pair;
			import org.apache.rocketmq.common.TopicConfig;
			import org.apache.rocketmq.common.constant.LoggerName;
			import org.apache.rocketmq.common.constant.PermName;
			import org.apache.rocketmq.common.filter.ExpressionType;
			import org.apache.rocketmq.logging.org.slf4j.Logger;
			import org.apache.rocketmq.logging.org.slf4j.LoggerFactory;
			import org.apache.rocketmq.remoting.protocol.filter.FilterAPI;
			import org.apache.rocketmq.remoting.protocol.heartbeat.ConsumeType;
			import org.apache.rocketmq.remoting.protocol.heartbeat.SubscriptionData;
			import org.apache.rocketmq.remoting.protocol.subscription.SimpleSubscriptionData;
			import org.apache.rocketmq.remoting.protocol.subscription.SubscriptionGroupConfig;
			import org.apache.rocketmq.store.DefaultMessageFilter;
			import org.apache.rocketmq.store.MessageStore;
			
			public class ConsumerLagCalculator {
			    private final BrokerConfig brokerConfig;
			    private final TopicConfigManager topicConfigManager;
			    private final ConsumerManager consumerManager;
			    private final ConsumerOffsetManager offsetManager;
			    private final ConsumerFilterManager consumerFilterManager;
			    private final SubscriptionGroupManager subscriptionGroupManager;
			    private final MessageStore messageStore;
			    private final PopBufferMergeService popBufferMergeService;
			    private final PopInflightMessageCounter popInflightMessageCounter;
			
			    private static final Logger LOGGER = LoggerFactory.getLogger(LoggerName.BROKER_LOGGER_NAME);
			
			    public ConsumerLagCalculator(BrokerController brokerController) {
			        this.brokerConfig = brokerController.getBrokerConfig();
			        this.topicConfigManager = brokerController.getTopicConfigManager();
			        this.consumerManager = brokerController.getConsumerManager();			
",
,
			fromLine:"			270",
			toLine:"			280",
			content:"
			                availableRecorder.accept(result);
			            }
			        });
			    }
			
			    public Pair<Long, Long> getConsumerLagStats(String group, String topic, boolean isPop) {
			        long total = 0L;
			        long earliestUnconsumedTimestamp = Long.MAX_VALUE;
			
			        if (group == null || topic == null) {
			            return new Pair<>(total, earliestUnconsumedTimestamp);			
",
,
			fromLine:"			296",
			toLine:"			306",
			content:"
			        }
			
			        return new Pair<>(total, earliestUnconsumedTimestamp);
			    }
			
			    public Pair<Long, Long> getConsumerLagStats(String group, String topic, int queueId, boolean isPop) {
			        long brokerOffset = messageStore.getMaxOffsetInQueue(topic, queueId);
			        if (brokerOffset < 0) {
			            brokerOffset = 0;
			        }
						
",
,
			fromLine:"			327",
			toLine:"			337",
			content:"
			        long lag = calculateMessageCount(group, topic, queueId, consumerOffset, brokerOffset);
			        long consumerStoreTimeStamp = getStoreTimeStamp(topic, queueId, consumerOffset);
			        return new Pair<>(lag, consumerStoreTimeStamp);
			    }
			
			    public Pair<Long, Long> getInFlightMsgStats(String group, String topic, boolean isPop) {
			        long total = 0L;
			        long earliestUnPulledTimestamp = Long.MAX_VALUE;
			
			        if (group == null || topic == null) {
			            return new Pair<>(total, earliestUnPulledTimestamp);			
",
,
			fromLine:"			353",
			toLine:"			363",
			content:"
			        }
			
			        return new Pair<>(total, earliestUnPulledTimestamp);
			    }
			
			    public Pair<Long, Long> getInFlightMsgStats(String group, String topic, int queueId, boolean isPop) {
			        if (isPop) {
			            long inflight = popInflightMessageCounter.getGroupPopInFlightMessageNum(topic, group, queueId);
			            long pullOffset = popBufferMergeService.getLatestOffset(topic, group, queueId);
			            if (pullOffset < 0) {
			                pullOffset = offsetManager.queryOffset(group, topic, queueId);			
",
,
			fromLine:"			382",
			toLine:"			392",
			content:"
			        long inflight = calculateMessageCount(group, topic, queueId, commitOffset, pullOffset);
			        long pullStoreTimeStamp = getStoreTimeStamp(topic, queueId, pullOffset);
			        return new Pair<>(inflight, pullStoreTimeStamp);
			    }
			
			    public long getAvailableMsgCount(String group, String topic, boolean isPop) {
			        long total = 0L;
			
			        if (group == null || topic == null) {
			            return total;
			        }			
",
,
			fromLine:"			401",
			toLine:"			411",
			content:"
			        }
			
			        return total;
			    }
			
			    public long getAvailableMsgCount(String group, String topic, int queueId, boolean isPop) {
			        long brokerOffset = messageStore.getMaxOffsetInQueue(topic, queueId);
			        if (brokerOffset < 0) {
			            brokerOffset = 0;
			        }
						
",
,
			fromLine:"			426",
			toLine:"			445",
			content:"
			        }
			
			        return calculateMessageCount(group, topic, queueId, pullOffset, brokerOffset);
			    }
			
			    public long getStoreTimeStamp(String topic, int queueId, long offset) {
			        long storeTimeStamp = Long.MAX_VALUE;
			        if (offset >= 0) {
			            storeTimeStamp = messageStore.getMessageStoreTimeStamp(topic, queueId, offset);
			            storeTimeStamp = storeTimeStamp > 0 ? storeTimeStamp : Long.MAX_VALUE;
			        }
			        return storeTimeStamp;
			    }
			
			    public long calculateMessageCount(String group, String topic, int queueId, long from, long to) {
			        long count = to - from;
			
			        if (brokerConfig.isEstimateAccumulation() && to > from) {
			            SubscriptionData subscriptionData = null;
			            if (brokerConfig.isUseStaticSubscription()) {			
",
,

		],
		broker/src/main/java/org/apache/rocketmq/broker/out/BrokerOuterAPI.java:
		[
			fromLine:"			16",
			toLine:"			164",
			content:"
			 */
			package org.apache.rocketmq.broker.out;
			
			import com.alibaba.fastjson2.JSON;
			import java.io.UnsupportedEncodingException;
			import java.net.InetAddress;
			import java.nio.ByteBuffer;
			import java.util.ArrayList;
			import java.util.Arrays;
			import java.util.List;
			import java.util.Set;
			import java.util.concurrent.ArrayBlockingQueue;
			import java.util.concurrent.CompletableFuture;
			import java.util.concurrent.CopyOnWriteArrayList;
			import java.util.concurrent.CountDownLatch;
			import java.util.concurrent.ExecutorService;
			import java.util.concurrent.TimeUnit;
			import org.apache.commons.lang3.StringUtils;
			import org.apache.rocketmq.acl.common.AclClientRPCHook;
			import org.apache.rocketmq.acl.common.SessionCredentials;
			import org.apache.rocketmq.auth.config.AuthConfig;
			import org.apache.rocketmq.client.consumer.PullResult;
			import org.apache.rocketmq.client.consumer.PullStatus;
			import org.apache.rocketmq.client.exception.MQBrokerException;
			import org.apache.rocketmq.client.impl.consumer.PullResultExt;
			import org.apache.rocketmq.client.producer.SendResult;
			import org.apache.rocketmq.client.producer.SendStatus;
			import org.apache.rocketmq.common.AbstractBrokerRunnable;
			import org.apache.rocketmq.common.BrokerIdentity;
			import org.apache.rocketmq.common.LockCallback;
			import org.apache.rocketmq.common.MixAll;
			import org.apache.rocketmq.common.Pair;
			import org.apache.rocketmq.common.ThreadFactoryImpl;
			import org.apache.rocketmq.common.TopicConfig;
			import org.apache.rocketmq.common.UnlockCallback;
			import org.apache.rocketmq.common.UtilAll;
			import org.apache.rocketmq.common.constant.LoggerName;
			import org.apache.rocketmq.common.filter.ExpressionType;
			import org.apache.rocketmq.common.message.Message;
			import org.apache.rocketmq.common.message.MessageAccessor;
			import org.apache.rocketmq.common.message.MessageBatch;
			import org.apache.rocketmq.common.message.MessageClientIDSetter;
			import org.apache.rocketmq.common.message.MessageConst;
			import org.apache.rocketmq.common.message.MessageDecoder;
			import org.apache.rocketmq.common.message.MessageExt;
			import org.apache.rocketmq.common.message.MessageQueue;
			import org.apache.rocketmq.common.namesrv.DefaultTopAddressing;
			import org.apache.rocketmq.common.namesrv.TopAddressing;
			import org.apache.rocketmq.common.sysflag.PullSysFlag;
			import org.apache.rocketmq.common.topic.TopicValidator;
			import org.apache.rocketmq.common.utils.ThreadUtils;
			import org.apache.rocketmq.logging.org.slf4j.Logger;
			import org.apache.rocketmq.logging.org.slf4j.LoggerFactory;
			import org.apache.rocketmq.remoting.InvokeCallback;
			import org.apache.rocketmq.remoting.RPCHook;
			import org.apache.rocketmq.remoting.RemotingClient;
			import org.apache.rocketmq.remoting.exception.RemotingCommandException;
			import org.apache.rocketmq.remoting.exception.RemotingConnectException;
			import org.apache.rocketmq.remoting.exception.RemotingException;
			import org.apache.rocketmq.remoting.exception.RemotingSendRequestException;
			import org.apache.rocketmq.remoting.exception.RemotingTimeoutException;
			import org.apache.rocketmq.remoting.exception.RemotingTooMuchRequestException;
			import org.apache.rocketmq.remoting.netty.NettyClientConfig;
			import org.apache.rocketmq.remoting.netty.NettyRemotingClient;
			import org.apache.rocketmq.remoting.netty.ResponseFuture;
			import org.apache.rocketmq.remoting.protocol.BrokerSyncInfo;
			import org.apache.rocketmq.remoting.protocol.DataVersion;
			import org.apache.rocketmq.remoting.protocol.RemotingCommand;
			import org.apache.rocketmq.remoting.protocol.RemotingSerializable;
			import org.apache.rocketmq.remoting.protocol.RequestCode;
			import org.apache.rocketmq.remoting.protocol.ResponseCode;
			import org.apache.rocketmq.remoting.protocol.body.BrokerMemberGroup;
			import org.apache.rocketmq.remoting.protocol.body.ClusterInfo;
			import org.apache.rocketmq.remoting.protocol.body.ConsumerOffsetSerializeWrapper;
			import org.apache.rocketmq.remoting.protocol.body.ElectMasterResponseBody;
			import org.apache.rocketmq.remoting.protocol.body.GetBrokerMemberGroupResponseBody;
			import org.apache.rocketmq.remoting.protocol.body.KVTable;
			import org.apache.rocketmq.remoting.protocol.body.LockBatchRequestBody;
			import org.apache.rocketmq.remoting.protocol.body.LockBatchResponseBody;
			import org.apache.rocketmq.remoting.protocol.body.MessageRequestModeSerializeWrapper;
			import org.apache.rocketmq.remoting.protocol.body.RegisterBrokerBody;
			import org.apache.rocketmq.remoting.protocol.body.SubscriptionGroupWrapper;
			import org.apache.rocketmq.remoting.protocol.body.SyncStateSet;
			import org.apache.rocketmq.remoting.protocol.body.TopicConfigAndMappingSerializeWrapper;
			import org.apache.rocketmq.remoting.protocol.body.TopicConfigSerializeWrapper;
			import org.apache.rocketmq.remoting.protocol.body.UnlockBatchRequestBody;
			import org.apache.rocketmq.remoting.protocol.header.ExchangeHAInfoRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.ExchangeHAInfoResponseHeader;
			import org.apache.rocketmq.remoting.protocol.header.GetBrokerMemberGroupRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.GetMaxOffsetRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.GetMaxOffsetResponseHeader;
			import org.apache.rocketmq.remoting.protocol.header.GetMinOffsetRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.GetMinOffsetResponseHeader;
			import org.apache.rocketmq.remoting.protocol.header.LockBatchMqRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.PullMessageRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.PullMessageResponseHeader;
			import org.apache.rocketmq.remoting.protocol.header.SendMessageRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.SendMessageRequestHeaderV2;
			import org.apache.rocketmq.remoting.protocol.header.SendMessageResponseHeader;
			import org.apache.rocketmq.remoting.protocol.header.UnlockBatchMqRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.controller.AlterSyncStateSetRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.controller.ElectMasterRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.controller.ElectMasterResponseHeader;
			import org.apache.rocketmq.remoting.protocol.header.controller.GetMetaDataResponseHeader;
			import org.apache.rocketmq.remoting.protocol.header.controller.GetReplicaInfoRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.controller.GetReplicaInfoResponseHeader;
			import org.apache.rocketmq.remoting.protocol.header.controller.register.ApplyBrokerIdRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.controller.register.ApplyBrokerIdResponseHeader;
			import org.apache.rocketmq.remoting.protocol.header.controller.register.GetNextBrokerIdRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.controller.register.GetNextBrokerIdResponseHeader;
			import org.apache.rocketmq.remoting.protocol.header.controller.register.RegisterBrokerToControllerRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.controller.register.RegisterBrokerToControllerResponseHeader;
			import org.apache.rocketmq.remoting.protocol.header.namesrv.BrokerHeartbeatRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.namesrv.GetRouteInfoRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.namesrv.QueryDataVersionRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.namesrv.QueryDataVersionResponseHeader;
			import org.apache.rocketmq.remoting.protocol.header.namesrv.RegisterBrokerRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.namesrv.RegisterBrokerResponseHeader;
			import org.apache.rocketmq.remoting.protocol.header.namesrv.RegisterTopicRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.namesrv.UnRegisterBrokerRequestHeader;
			import org.apache.rocketmq.remoting.protocol.heartbeat.SubscriptionData;
			import org.apache.rocketmq.remoting.protocol.namesrv.RegisterBrokerResult;
			import org.apache.rocketmq.remoting.protocol.route.BrokerData;
			import org.apache.rocketmq.remoting.protocol.route.QueueData;
			import org.apache.rocketmq.remoting.protocol.route.TopicRouteData;
			import org.apache.rocketmq.remoting.rpc.ClientMetadata;
			import org.apache.rocketmq.remoting.rpc.RpcClient;
			import org.apache.rocketmq.remoting.rpc.RpcClientImpl;
			import org.apache.rocketmq.remoting.rpchook.DynamicalExtFieldRPCHook;
			import org.apache.rocketmq.store.timer.TimerCheckpoint;
			import org.apache.rocketmq.store.timer.TimerMetrics;
			
			import static org.apache.rocketmq.remoting.protocol.RemotingSysResponseCode.SUCCESS;
			import static org.apache.rocketmq.remoting.protocol.ResponseCode.CONTROLLER_MASTER_STILL_EXIST;
			
			public class BrokerOuterAPI {
			    private static final Logger LOGGER = LoggerFactory.getLogger(LoggerName.BROKER_LOGGER_NAME);
			    private final RemotingClient remotingClient;
			    private final TopAddressing topAddressing = new DefaultTopAddressing(MixAll.getWSAddr());
			    private final ExecutorService brokerOuterExecutor = ThreadUtils.newThreadPoolExecutor(4, 10, 1, TimeUnit.MINUTES,
			            new ArrayBlockingQueue<>(32), new ThreadFactoryImpl("brokerOutApi_thread_", true));
			    private final ClientMetadata clientMetadata;
			    private final RpcClient rpcClient;
			    private String nameSrvAddr = null;
			
			    public BrokerOuterAPI(final NettyClientConfig nettyClientConfig, AuthConfig authConfig) {
			        this(nettyClientConfig, authConfig, new DynamicalExtFieldRPCHook(), new ClientMetadata());
			    }
						
",
,
			fromLine:"			248",
			toLine:"			259",
			content:"
			    public BrokerMemberGroup syncBrokerMemberGroup(String clusterName, String brokerName)
			        throws InterruptedException, RemotingTimeoutException, RemotingSendRequestException, RemotingConnectException {
			        return syncBrokerMemberGroup(clusterName, brokerName, false);
			    }
			
			    public BrokerMemberGroup syncBrokerMemberGroup(String clusterName, String brokerName,
			        boolean isCompatibleWithOldNameSrv)
			        throws InterruptedException, RemotingTimeoutException, RemotingSendRequestException, RemotingConnectException {
			        if (isCompatibleWithOldNameSrv) {
			            return getBrokerMemberGroupCompatible(clusterName, brokerName);
			        } else {
			            return getBrokerMemberGroup(clusterName, brokerName);			
",
,
			fromLine:"			326",
			toLine:"			342",
			content:"
			
			        return brokerMemberGroup;
			    }
			
			    public void sendHeartbeatViaDataVersion(
			        final String clusterName,
			        final String brokerAddr,
			        final String brokerName,
			        final Long brokerId,
			        final int timeoutMillis,
			        final DataVersion dataVersion,
			        final boolean isInBrokerContainer) {
			        List<String> nameServerAddressList = this.remotingClient.getAvailableNameSrvList();
			        if (nameServerAddressList != null && nameServerAddressList.size() > 0) {
			            final QueryDataVersionRequestHeader requestHeader = new QueryDataVersionRequestHeader();
			            requestHeader.setBrokerAddr(brokerAddr);
			            requestHeader.setBrokerName(brokerName);			
",
,
			fromLine:"			360",
			toLine:"			375",
			content:"
			                });
			            }
			        }
			    }
			
			    public void sendHeartbeat(final String clusterName,
			        final String brokerAddr,
			        final String brokerName,
			        final Long brokerId,
			        final int timeoutMills,
			        final boolean isInBrokerContainer) {
			        List<String> nameServerAddressList = this.remotingClient.getAvailableNameSrvList();
			
			        final BrokerHeartbeatRequestHeader requestHeader = new BrokerHeartbeatRequestHeader();
			        requestHeader.setClusterName(clusterName);
			        requestHeader.setBrokerAddr(brokerAddr);			
",
,
			fromLine:"			413",
			toLine:"			423",
			content:"
			        }
			
			        throw new MQBrokerException(response.getCode(), response.getRemark());
			    }
			
			    public void sendBrokerHaInfo(String brokerAddr, String masterHaAddr, long brokerInitMaxOffset, String masterAddr)
			        throws InterruptedException, RemotingTimeoutException, RemotingSendRequestException, RemotingConnectException, MQBrokerException {
			        ExchangeHAInfoRequestHeader requestHeader = new ExchangeHAInfoRequestHeader();
			        requestHeader.setMasterHaAddress(masterHaAddr);
			        requestHeader.setMasterFlushOffset(brokerInitMaxOffset);
			        requestHeader.setMasterAddress(masterAddr);			
",
,
			fromLine:"			437",
			toLine:"			458",
			content:"
			
			        throw new MQBrokerException(response.getCode(), response.getRemark());
			    }
			
			    public List<RegisterBrokerResult> registerBrokerAll(
			        final String clusterName,
			        final String brokerAddr,
			        final String brokerName,
			        final long brokerId,
			        final String haServerAddr,
			        final TopicConfigSerializeWrapper topicConfigWrapper,
			        final List<String> filterServerList,
			        final boolean oneway,
			        final int timeoutMills,
			        final boolean enableActingMaster,
			        final boolean compressed,
			        final BrokerIdentity brokerIdentity) {
			        return registerBrokerAll(clusterName,
			            brokerAddr,
			            brokerName,
			            brokerId,
			            haServerAddr,			
",
,
			fromLine:"			480",
			toLine:"			502",
			content:"
			     * @param timeoutMills
			     * @param compressed         default false
			     * @return
			     */
			    public List<RegisterBrokerResult> registerBrokerAll(
			        final String clusterName,
			        final String brokerAddr,
			        final String brokerName,
			        final long brokerId,
			        final String haServerAddr,
			        final TopicConfigSerializeWrapper topicConfigWrapper,
			        final List<String> filterServerList,
			        final boolean oneway,
			        final int timeoutMills,
			        final boolean enableActingMaster,
			        final boolean compressed,
			        final Long heartbeatTimeoutMillis,
			        final BrokerIdentity brokerIdentity) {
			
			        final List<RegisterBrokerResult> registerBrokerResultList = new CopyOnWriteArrayList<>();
			        List<String> nameServerAddressList = this.remotingClient.getAvailableNameSrvList();
			        if (nameServerAddressList != null && nameServerAddressList.size() > 0) {
						
",
,
			fromLine:"			549",
			toLine:"			563",
			content:"
			
			        return registerBrokerResultList;
			    }
			
			    private RegisterBrokerResult registerBroker(
			        final String namesrvAddr,
			        final boolean oneway,
			        final int timeoutMills,
			        final RegisterBrokerRequestHeader requestHeader,
			        final byte[] body
			    ) throws RemotingCommandException, MQBrokerException, RemotingConnectException, RemotingSendRequestException, RemotingTimeoutException,
			        InterruptedException {
			        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.REGISTER_BROKER, requestHeader);
			        request.setBody(body);
						
",
,
			fromLine:"			590",
			toLine:"			603",
			content:"
			
			        throw new MQBrokerException(response.getCode(), response.getRemark(), requestHeader == null ? null : requestHeader.getBrokerAddr());
			    }
			
			    public void unregisterBrokerAll(
			        final String clusterName,
			        final String brokerAddr,
			        final String brokerName,
			        final long brokerId
			    ) {
			        List<String> nameServerAddressList = this.remotingClient.getNameServerAddressList();
			        if (nameServerAddressList != null) {
			            for (String namesrvAddr : nameServerAddressList) {
			                try {			
",
,
			fromLine:"			609",
			toLine:"			623",
			content:"
			            }
			        }
			    }
			
			    public void unregisterBroker(
			        final String namesrvAddr,
			        final String clusterName,
			        final String brokerAddr,
			        final String brokerName,
			        final long brokerId
			    ) throws RemotingConnectException, RemotingSendRequestException, RemotingTimeoutException, InterruptedException, MQBrokerException {
			        UnRegisterBrokerRequestHeader requestHeader = new UnRegisterBrokerRequestHeader();
			        requestHeader.setBrokerAddr(brokerAddr);
			        requestHeader.setBrokerId(brokerId);
			        requestHeader.setBrokerName(brokerName);			
",
,
			fromLine:"			640",
			toLine:"			652",
			content:"
			    /**
			     * Register the topic route info of single topic to all name server nodes.
			     * This method is used to replace incremental broker registration feature.
			     */
			    public void registerSingleTopicAll(
			        final String brokerName,
			        final TopicConfig topicConfig,
			        final int timeoutMills) {
			        String topic = topicConfig.getTopicName();
			        RegisterTopicRequestHeader requestHeader = new RegisterTopicRequestHeader();
			        requestHeader.setTopic(topic);
			
			        TopicRouteData topicRouteData = new TopicRouteData();			
",
,
			fromLine:"			694",
			toLine:"			710",
			content:"
			        } catch (InterruptedException ignore) {
			        }
			    }
			
			    public List<Boolean> needRegister(
			        final String clusterName,
			        final String brokerAddr,
			        final String brokerName,
			        final long brokerId,
			        final TopicConfigSerializeWrapper topicConfigWrapper,
			        final int timeoutMills,
			        final boolean isInBrokerContainer) {
			        final List<Boolean> changedList = new CopyOnWriteArrayList<>();
			        List<String> nameServerAddressList = this.remotingClient.getNameServerAddressList();
			        if (nameServerAddressList != null && nameServerAddressList.size() > 0) {
			            final CountDownLatch countDownLatch = new CountDownLatch(nameServerAddressList.size());
			            for (final String namesrvAddr : nameServerAddressList) {			
",
,
			fromLine:"			872",
			toLine:"			883",
			content:"
			
			    public void clearRPCHook() {
			        remotingClient.clearRPCHook();
			    }
			
			    public long getMaxOffset(final String addr, final String topic, final int queueId, final boolean committed,
			        final boolean isOnlyThisBroker)
			        throws RemotingException, MQBrokerException, InterruptedException {
			        GetMaxOffsetRequestHeader requestHeader = new GetMaxOffsetRequestHeader();
			        requestHeader.setTopic(topic);
			        requestHeader.setQueueId(queueId);
			        requestHeader.setCommitted(committed);			
",
,
			fromLine:"			896",
			toLine:"			906",
			content:"
			        }
			
			        throw new MQBrokerException(response.getCode(), response.getRemark());
			    }
			
			    public long getMinOffset(final String addr, final String topic, final int queueId, final boolean isOnlyThisBroker)
			        throws RemotingException, MQBrokerException, InterruptedException {
			        GetMinOffsetRequestHeader requestHeader = new GetMinOffsetRequestHeader();
			        requestHeader.setTopic(topic);
			        requestHeader.setQueueId(queueId);
			        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.GET_MIN_OFFSET, requestHeader);			
",
,
			fromLine:"			919",
			toLine:"			932",
			content:"
			
			        throw new MQBrokerException(response.getCode(), response.getRemark());
			    }
			
			    public void lockBatchMQAsync(
			        final String addr,
			        final LockBatchRequestBody requestBody,
			        final long timeoutMillis,
			        final LockCallback callback) throws RemotingException, InterruptedException {
			        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.LOCK_BATCH_MQ, new LockBatchMqRequestHeader());
			
			        request.setBody(requestBody.encode());
			        this.remotingClient.invokeAsync(addr, request, timeoutMillis, new InvokeCallback() {
			            @Override			
",
,
			fromLine:"			958",
			toLine:"			971",
			content:"
			            }
			        });
			    }
			
			    public void unlockBatchMQAsync(
			        final String addr,
			        final UnlockBatchRequestBody requestBody,
			        final long timeoutMillis,
			        final UnlockCallback callback) throws RemotingException, InterruptedException {
			        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.UNLOCK_BATCH_MQ, new UnlockBatchMqRequestHeader());
			
			        request.setBody(requestBody.encode());
			
			        this.remotingClient.invokeAsync(addr, request, timeoutMillis, new InvokeCallback() {			
",
,
			fromLine:"			998",
			toLine:"			1019",
			content:"
			
			    public RemotingClient getRemotingClient() {
			        return this.remotingClient;
			    }
			
			    public SendResult sendMessageToSpecificBroker(String brokerAddr, final String brokerName,
			        final MessageExt msg, String group,
			        long timeoutMillis) throws RemotingException, MQBrokerException, InterruptedException {
			
			        RemotingCommand request = buildSendMessageRequest(msg, group);
			        RemotingCommand response = this.remotingClient.invokeSync(brokerAddr, request, timeoutMillis);
			        return this.processSendResponse(brokerName, msg, response);
			    }
			
			    public CompletableFuture<SendResult> sendMessageToSpecificBrokerAsync(String brokerAddr, final String brokerName,
			        final MessageExt msg, String group,
			        long timeoutMillis) {
			        RemotingCommand request = buildSendMessageRequest(msg, group);
			
			        CompletableFuture<SendResult> cf = new CompletableFuture<>();
			        final String msgId = msg.getMsgId();
			        try {			
",
,
			fromLine:"			1071",
			toLine:"			1083",
			content:"
			        SendMessageRequestHeaderV2 requestHeaderV2 = SendMessageRequestHeaderV2.createSendMessageRequestHeaderV2(requestHeader);
			        return requestHeaderV2;
			    }
			
			    private SendResult processSendResponse(
			        final String brokerName,
			        final Message msg,
			        final RemotingCommand response
			    ) throws MQBrokerException, RemotingCommandException {
			        SendStatus sendStatus = null;
			        switch (response.getCode()) {
			            case ResponseCode.FLUSH_DISK_TIMEOUT:
			                sendStatus = SendStatus.FLUSH_DISK_TIMEOUT;			
",
,
			fromLine:"			1140",
			toLine:"			1151",
			content:"
			    public TopicRouteData getTopicRouteInfoFromNameServer(final String topic, final long timeoutMillis)
			        throws RemotingException, MQBrokerException, InterruptedException {
			        return getTopicRouteInfoFromNameServer(topic, timeoutMillis, true);
			    }
			
			    public TopicRouteData getTopicRouteInfoFromNameServer(final String topic, final long timeoutMillis,
			        boolean allowTopicNotExist) throws MQBrokerException, InterruptedException, RemotingTimeoutException, RemotingSendRequestException, RemotingConnectException {
			        GetRouteInfoRequestHeader requestHeader = new GetRouteInfoRequestHeader();
			        requestHeader.setTopic(topic);
			
			        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.GET_ROUTEINFO_BY_TOPIC, requestHeader);
						
",
,
			fromLine:"			1185",
			toLine:"			1196",
			content:"
			        }
			
			        throw new MQBrokerException(response.getCode(), response.getRemark());
			    }
			
			    public void forwardRequest(String brokerAddr, RemotingCommand request, long timeoutMillis,
			        InvokeCallback invokeCallback) throws InterruptedException, RemotingSendRequestException, RemotingTimeoutException, RemotingTooMuchRequestException, RemotingConnectException {
			        this.remotingClient.invokeAsync(brokerAddr, request, timeoutMillis, invokeCallback);
			    }
			
			    public void refreshMetadata() throws Exception {
			        ClusterInfo brokerClusterInfo = getBrokerClusterInfo();			
",
,
			fromLine:"			1234",
			toLine:"			1247",
			content:"
			
			    /**
			     * Alter syncStateSet
			     */
			    public SyncStateSet alterSyncStateSet(
			        final String controllerAddress,
			        final String brokerName,
			        final Long masterBrokerId, final int masterEpoch,
			        final Set<Long> newSyncStateSet, final int syncStateSetEpoch) throws Exception {
			
			        final AlterSyncStateSetRequestHeader requestHeader = new AlterSyncStateSetRequestHeader(brokerName, masterBrokerId, masterEpoch);
			        final RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.CONTROLLER_ALTER_SYNC_STATE_SET, requestHeader);
			        request.setBody(new SyncStateSet(newSyncStateSet, syncStateSetEpoch).encode());
			        final RemotingCommand response = this.remotingClient.invokeSync(controllerAddress, request, 3000);			
",
,
			fromLine:"			1256",
			toLine:"			1268",
			content:"
			    }
			
			    /**
			     * Broker try to elect itself as a master in broker set
			     */
			    public Pair<ElectMasterResponseHeader, Set<Long>> brokerElect(String controllerAddress, String clusterName,
			        String brokerName,
			        Long brokerId) throws Exception {
			
			        final ElectMasterRequestHeader requestHeader = ElectMasterRequestHeader.ofBrokerTrigger(clusterName, brokerName, brokerId);
			        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.CONTROLLER_ELECT_MASTER, requestHeader);
			        RemotingCommand response = this.remotingClient.invokeSync(controllerAddress, request, 3000);
			        assert response != null;			
",
,
			fromLine:"			1276",
			toLine:"			1299",
			content:"
			        }
			
			        throw new MQBrokerException(response.getCode(), response.getRemark());
			    }
			
			    public GetNextBrokerIdResponseHeader getNextBrokerId(final String clusterName, final String brokerName,
			        final String controllerAddress) throws Exception {
			        final GetNextBrokerIdRequestHeader requestHeader = new GetNextBrokerIdRequestHeader(clusterName, brokerName);
			        final RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.CONTROLLER_GET_NEXT_BROKER_ID, requestHeader);
			        final RemotingCommand response = this.remotingClient.invokeSync(controllerAddress, request, 3000);
			        assert response != null;
			        if (response.getCode() == SUCCESS) {
			            return (GetNextBrokerIdResponseHeader) response.decodeCommandCustomHeader(GetNextBrokerIdResponseHeader.class);
			        }
			        throw new MQBrokerException(response.getCode(), response.getRemark());
			    }
			
			    public ApplyBrokerIdResponseHeader applyBrokerId(final String clusterName, final String brokerName,
			        final Long brokerId, final String registerCheckCode, final String controllerAddress) throws Exception {
			        final ApplyBrokerIdRequestHeader requestHeader = new ApplyBrokerIdRequestHeader(clusterName, brokerName, brokerId, registerCheckCode);
			        final RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.CONTROLLER_APPLY_BROKER_ID, requestHeader);
			        final RemotingCommand response = this.remotingClient.invokeSync(controllerAddress, request, 3000);
			        assert response != null;
			        if (response.getCode() == SUCCESS) {			
",
,
			fromLine:"			1301",
			toLine:"			1312",
			content:"
			        }
			        throw new MQBrokerException(response.getCode(), response.getRemark());
			    }
			
			    public Pair<RegisterBrokerToControllerResponseHeader, Set<Long>> registerBrokerToController(
			        final String clusterName, final String brokerName, final Long brokerId, final String brokerAddress,
			        final String controllerAddress) throws Exception {
			        final RegisterBrokerToControllerRequestHeader requestHeader = new RegisterBrokerToControllerRequestHeader(clusterName, brokerName, brokerId, brokerAddress);
			        final RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.CONTROLLER_REGISTER_BROKER, requestHeader);
			        final RemotingCommand response = this.remotingClient.invokeSync(controllerAddress, request, 3000);
			        assert response != null;
			        if (response.getCode() == SUCCESS) {			
",
,
			fromLine:"			1338",
			toLine:"			1359",
			content:"
			    }
			
			    /**
			     * Send heartbeat to controller
			     */
			    public void sendHeartbeatToController(final String controllerAddress,
			        final String clusterName,
			        final String brokerAddr,
			        final String brokerName,
			        final Long brokerId,
			        final int sendHeartBeatTimeoutMills,
			        final boolean isInBrokerContainer,
			        final int epoch,
			        final long maxOffset,
			        final long confirmOffset,
			        final long controllerHeartBeatTimeoutMills,
			        final int electionPriority) {
			        if (StringUtils.isEmpty(controllerAddress)) {
			            return;
			        }
			
			        final BrokerHeartbeatRequestHeader requestHeader = new BrokerHeartbeatRequestHeader();			
",
,
			fromLine:"			1378",
			toLine:"			1390",
			content:"
			                }
			            }
			        });
			    }
			
			    public CompletableFuture<PullResult> pullMessageFromSpecificBrokerAsync(String brokerName, String brokerAddr,
			        String consumerGroup, String topic, int queueId, long offset,
			        int maxNums, long timeoutMillis) throws RemotingException, InterruptedException {
			        PullMessageRequestHeader requestHeader = new PullMessageRequestHeader();
			        requestHeader.setConsumerGroup(consumerGroup);
			        requestHeader.setTopic(topic);
			        requestHeader.setQueueId(queueId);
			        requestHeader.setQueueOffset(offset);			
",
,
			fromLine:"			1453",
			toLine:"			1463",
			content:"
			        return new PullResultExt(pullStatus, responseHeader.getNextBeginOffset(), responseHeader.getMinOffset(),
			            responseHeader.getMaxOffset(), null, responseHeader.getSuggestWhichBrokerId(), response.getBody(), responseHeader.getOffsetDelta());
			
			    }
			
			    private PullResult processPullResult(final PullResultExt pullResult, String brokerName, int queueId) {
			
			        if (PullStatus.FOUND == pullResult.getPullStatus()) {
			            ByteBuffer byteBuffer = ByteBuffer.wrap(pullResult.getMessageBinary());
			            List<MessageExt> msgList = MessageDecoder.decodesBatch(
			                byteBuffer,			
",
,

		],
		broker/src/main/java/org/apache/rocketmq/broker/failover/EscapeBridge.java:
		[
			fromLine:"			17",
			toLine:"			69",
			content:"
			
			package org.apache.rocketmq.broker.failover;
			
			import java.nio.ByteBuffer;
			import java.util.ArrayList;
			import java.util.List;
			import java.util.concurrent.BlockingQueue;
			import java.util.concurrent.CompletableFuture;
			import java.util.concurrent.ExecutorService;
			import java.util.concurrent.LinkedBlockingQueue;
			import java.util.concurrent.TimeUnit;
			import org.apache.commons.lang3.StringUtils;
			import org.apache.rocketmq.broker.BrokerController;
			import org.apache.rocketmq.broker.transaction.queue.TransactionalMessageUtil;
			import org.apache.rocketmq.client.consumer.PullStatus;
			import org.apache.rocketmq.client.exception.MQBrokerException;
			import org.apache.rocketmq.client.impl.producer.TopicPublishInfo;
			import org.apache.rocketmq.client.producer.SendResult;
			import org.apache.rocketmq.client.producer.SendStatus;
			import org.apache.rocketmq.common.MixAll;
			import org.apache.rocketmq.common.Pair;
			import org.apache.rocketmq.common.ThreadFactoryImpl;
			import org.apache.rocketmq.common.constant.LoggerName;
			import org.apache.rocketmq.common.message.MessageConst;
			import org.apache.rocketmq.common.message.MessageDecoder;
			import org.apache.rocketmq.common.message.MessageExt;
			import org.apache.rocketmq.common.message.MessageExtBrokerInner;
			import org.apache.rocketmq.common.message.MessageQueue;
			import org.apache.rocketmq.common.utils.ThreadUtils;
			import org.apache.rocketmq.logging.org.slf4j.Logger;
			import org.apache.rocketmq.logging.org.slf4j.LoggerFactory;
			import org.apache.rocketmq.remoting.exception.RemotingException;
			import org.apache.rocketmq.store.GetMessageResult;
			import org.apache.rocketmq.store.GetMessageStatus;
			import org.apache.rocketmq.store.MessageStore;
			import org.apache.rocketmq.store.PutMessageResult;
			import org.apache.rocketmq.store.PutMessageStatus;
			
			public class EscapeBridge {
			    protected static final Logger LOG = LoggerFactory.getLogger(LoggerName.BROKER_LOGGER_NAME);
			    private static final long SEND_TIMEOUT = 3000L;
			    private static final long DEFAULT_PULL_TIMEOUT_MILLIS = 1000 * 10L;
			    private final String innerProducerGroupName;
			    private final String innerConsumerGroupName;
			
			    private final BrokerController brokerController;
			
			    private ExecutorService defaultAsyncSenderExecutor;
			
			    public EscapeBridge(BrokerController brokerController) {
			        this.brokerController = brokerController;
			        this.innerProducerGroupName = "InnerProducerGroup_" + brokerController.getBrokerConfig().getBrokerName() + "_" + brokerController.getBrokerConfig().getBrokerId();
			        this.innerConsumerGroupName = "InnerConsumerGroup_" + brokerController.getBrokerConfig().getBrokerName() + "_" + brokerController.getBrokerConfig().getBrokerId();			
",
,
			fromLine:"			261",
			toLine:"			275",
			content:"
			            default:
			                return new PutMessageResult(PutMessageStatus.PUT_TO_REMOTE_BROKER_FAIL, null, true);
			        }
			    }
			
			    public Pair<GetMessageStatus, MessageExt> getMessage(String topic, long offset, int queueId, String brokerName, boolean deCompressBody) {
			        return getMessageAsync(topic, offset, queueId, brokerName, deCompressBody).join();
			    }
			
			    public CompletableFuture<Pair<GetMessageStatus, MessageExt>> getMessageAsync(String topic, long offset, int queueId, String brokerName, boolean deCompressBody) {
			        MessageStore messageStore = brokerController.getMessageStoreByBrokerName(brokerName);
			        if (messageStore != null) {
			            return messageStore.getMessageAsync(innerConsumerGroupName, topic, queueId, offset, 1, null)
			                .thenApply(result -> {
			                    if (result == null) {			
",
,
			fromLine:"			320",
			toLine:"			334",
			content:"
			        }
			
			        return foundList;
			    }
			
			    protected MessageExt getMessageFromRemote(String topic, long offset, int queueId, String brokerName) {
			        return getMessageFromRemoteAsync(topic, offset, queueId, brokerName).join();
			    }
			
			    protected CompletableFuture<MessageExt> getMessageFromRemoteAsync(String topic, long offset, int queueId, String brokerName) {
			        try {
			            String brokerAddr = this.brokerController.getTopicRouteInfoManager().findBrokerAddressInSubscribe(brokerName, MixAll.MASTER_ID, false);
			            if (null == brokerAddr) {
			                this.brokerController.getTopicRouteInfoManager().updateTopicRouteInfoFromNameServer(topic, true, false);
			                brokerAddr = this.brokerController.getTopicRouteInfoManager().findBrokerAddressInSubscribe(brokerName, MixAll.MASTER_ID, false);			
",
,

		],
		remoting/src/main/java/org/apache/rocketmq/remoting/protocol/filter/FilterAPI.java:
		[
			fromLine:"			16",
			toLine:"			24",
			content:"
			 */
			package org.apache.rocketmq.remoting.protocol.filter;
			
			import org.apache.commons.lang3.StringUtils;
			import org.apache.rocketmq.common.filter.ExpressionType;
			import org.apache.rocketmq.remoting.protocol.heartbeat.SubscriptionData;
			
			import java.util.Arrays;
						
",
,
			fromLine:"			44",
			toLine:"			63",
			content:"
			        }
			
			        return subscriptionData;
			    }
			
			    public static SubscriptionData buildSubscriptionData(String topic, String subString, String expressionType) throws Exception {
			        final SubscriptionData subscriptionData = buildSubscriptionData(topic, subString);
			        if (StringUtils.isNotBlank(expressionType)) {
			            subscriptionData.setExpressionType(expressionType);
			        }
			        return subscriptionData;
			    }
			
			    public static SubscriptionData build(final String topic, final String subString,
			        final String type) throws Exception {
			        if (ExpressionType.TAG.equals(type) || type == null) {
			            return buildSubscriptionData(topic, subString);
			        }
			
			        if (StringUtils.isEmpty(subString)) {			
",
,

		],
		remoting/src/main/java/org/apache/rocketmq/remoting/protocol/heartbeat/SubscriptionData.java:
		[
			fromLine:"			20",
			toLine:"			44",
			content:"
			 */
			package org.apache.rocketmq.remoting.protocol.heartbeat;
			
			import com.alibaba.fastjson.annotation.JSONField;
			import java.util.HashSet;
			import java.util.Set;
			import org.apache.rocketmq.common.filter.ExpressionType;
			
			public class SubscriptionData implements Comparable<SubscriptionData> {
			    public final static String SUB_ALL = "*";
			    private boolean classFilterMode = false;
			    private String topic;
			    private String subString;
			    private Set<String> tagsSet = new HashSet<>();
			    private Set<Integer> codeSet = new HashSet<>();
			    private long subVersion = System.currentTimeMillis();
			    private String expressionType = ExpressionType.TAG;
			
			    @JSONField(serialize = false)
			    private String filterClassSource;
			
			    public SubscriptionData() {
			
			    }
						
",
,

		],
	
}
	role:"
	user	
",
,

],
model:"
gpt-4-1106-preview
",
response_format:
{
	type:"
	json_object	
",

}
temperature:"0.5",
