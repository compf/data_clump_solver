messages:
[
	content:"
	
	I will provide you one or more Java code files .
	Find all data clumps in the respective files.
	
	A data clump exists if
	1) two methods (in the same or in different classes) have at least 3 common parameters
	    and one of those methods does not override the other,
	
	or  
	2) At least three fields in a class are common with the parameters of a method (in the same or in a different class),
	
	or
	3) Two different classes have at least three common fields
	
	## OUTPUT FORMAT
	Use the following JSON format for the output:
	
	{
	   "data_clumps":{
	        "unique_key":{
	            "key": "a unique key that should be created. It must be same as the key 'unique_key' in the 'data_clumps' object",
	            "from_file_path":"The path of the file where one part of the data clump is found",
	            "from_class_or_interface_key":"The fully qualified name of the class or interface where one part of the data clump is found",
	            "from_class_or_interface_name":"The name of the class or interface where one part of the data clump is found",
	            
	            "from_method_key":"The fully qualified name of the method where one part of the data clump is found. It may be 'null' if the data clump on this part is not found in a method",
	            "from_method_name":"The name of the method where one part of the data clump is found. It may be 'null' if the data clump on this part is not found in a method",
	
	            "to_file_path":"The path of the file where the  other part of the data clump is found",
	            "to_class_or_interface_key":"The fully qualified name of the class or interface where the  other part part of the data clump is found",
	            "to_class_or_interface_name":"The name of the class or interface where the  other  part of the data clump is found",
	            
	            "to_method_key":"The fully qualified name of the method where the  other part part of the data clump is found. It may be 'null' if the data clump on this part is not found in a method",
	            "to_method_name":"The name of the method where the  other  part of the data clump is found. It may be 'null' if the data clump on this part is not found in a method",
	            "data_clump_data":{
	                // for each data clump variable
	                "other_unique_key":{
	                    "key":"a unique key that should be created. It must be same as the key 'other_unique_key' in the 'data_clump_data' object",
	                    "name": "The name of the data clump variable that exists on the one part of the data clump",
	                    "type": "The type of the data clump variable that exists on the one part of the data clump",
	                    "displayedType": "The  type of the data clump variable, as it appears in the source code, that exists on the one part of the data clump",
	                    
	                    "position": {
	                        "startLine": "The line number of the  data clump variable on the one part of the data clump.This must be relative to the file",
	                        "startColumn": "The column number of the data clump variable on the one part of the data clump"
	                    },
	                    "to_variable":{
	                        "key":"a unique key that should be created.",
	                        "name": "The name of the data clump variable that exists on the other part of the data clump",
	                        "type": "The type of the data clump variable, as it appears in the source code, that exists on the other part of the data clump",
	                        "position": {
	                            "startLine": "The line number of the  data clump variable on the other part of the data clump. This must be relative to the file",
	                            "startColumn": "The column number of the data clump variable on the other part of the data clump",
	                        }
	                    }
	                }
	            }
	        }
	   }
	}
	
	## END OUTPUT FORMAT
		
",
	role:"
	system	
",
,
	content:
{
			common/src/main/java/org/apache/rocketmq/common/stats/Stats.java:
		[
			fromLine:"			16",
			toLine:"			48",
			content:"
			 */
			package org.apache.rocketmq.common.stats;
			
			public class Stats {
			
			    public static final String QUEUE_PUT_NUMS = "QUEUE_PUT_NUMS";
			    public static final String QUEUE_PUT_SIZE = "QUEUE_PUT_SIZE";
			    public static final String QUEUE_GET_NUMS = "QUEUE_GET_NUMS";
			    public static final String QUEUE_GET_SIZE = "QUEUE_GET_SIZE";
			    public static final String TOPIC_PUT_NUMS = "TOPIC_PUT_NUMS";
			    public static final String TOPIC_PUT_SIZE = "TOPIC_PUT_SIZE";
			    public static final String GROUP_GET_NUMS = "GROUP_GET_NUMS";
			    public static final String GROUP_GET_SIZE = "GROUP_GET_SIZE";
			    public static final String SNDBCK_PUT_NUMS = "SNDBCK_PUT_NUMS";
			    public static final String BROKER_PUT_NUMS = "BROKER_PUT_NUMS";
			    public static final String BROKER_GET_NUMS = "BROKER_GET_NUMS";
			    public static final String GROUP_GET_FROM_DISK_NUMS = "GROUP_GET_FROM_DISK_NUMS";
			    public static final String GROUP_GET_FROM_DISK_SIZE = "GROUP_GET_FROM_DISK_SIZE";
			    public static final String BROKER_GET_FROM_DISK_NUMS = "BROKER_GET_FROM_DISK_NUMS";
			    public static final String BROKER_GET_FROM_DISK_SIZE = "BROKER_GET_FROM_DISK_SIZE";
			    public static final String COMMERCIAL_SEND_TIMES = "COMMERCIAL_SEND_TIMES";
			    public static final String COMMERCIAL_SNDBCK_TIMES = "COMMERCIAL_SNDBCK_TIMES";
			    public static final String COMMERCIAL_RCV_TIMES = "COMMERCIAL_RCV_TIMES";
			    public static final String COMMERCIAL_RCV_EPOLLS = "COMMERCIAL_RCV_EPOLLS";
			    public static final String COMMERCIAL_SEND_SIZE = "COMMERCIAL_SEND_SIZE";
			    public static final String COMMERCIAL_RCV_SIZE = "COMMERCIAL_RCV_SIZE";
			    public static final String COMMERCIAL_PERM_FAILURES = "COMMERCIAL_PERM_FAILURES";
			
			    public static final String GROUP_GET_FALL_SIZE = "GROUP_GET_FALL_SIZE";
			    public static final String GROUP_GET_FALL_TIME = "GROUP_GET_FALL_TIME";
			    public static final String GROUP_GET_LATENCY = "GROUP_GET_LATENCY";
			}
						
",
,

		],
		store/src/main/java/org/apache/rocketmq/store/stats/BrokerStatsManager.java:
		[
			fromLine:"			16",
			toLine:"			150",
			content:"
			 */
			package org.apache.rocketmq.store.stats;
			
			import java.util.HashMap;
			import java.util.concurrent.ScheduledExecutorService;
			import org.apache.commons.lang3.tuple.Pair;
			import org.apache.rocketmq.common.BrokerConfig;
			import org.apache.rocketmq.common.ThreadFactoryImpl;
			import org.apache.rocketmq.common.UtilAll;
			import org.apache.rocketmq.common.constant.LoggerName;
			import org.apache.rocketmq.common.statistics.StatisticsItem;
			import org.apache.rocketmq.common.statistics.StatisticsItemFormatter;
			import org.apache.rocketmq.common.statistics.StatisticsItemPrinter;
			import org.apache.rocketmq.common.statistics.StatisticsItemScheduledIncrementPrinter;
			import org.apache.rocketmq.common.statistics.StatisticsItemScheduledPrinter;
			import org.apache.rocketmq.common.statistics.StatisticsItemStateGetter;
			import org.apache.rocketmq.common.statistics.StatisticsKindMeta;
			import org.apache.rocketmq.common.statistics.StatisticsManager;
			import org.apache.rocketmq.common.stats.MomentStatsItemSet;
			import org.apache.rocketmq.common.stats.Stats;
			import org.apache.rocketmq.common.stats.StatsItem;
			import org.apache.rocketmq.common.stats.StatsItemSet;
			import org.apache.rocketmq.common.topic.TopicValidator;
			import org.apache.rocketmq.common.utils.ThreadUtils;
			import org.apache.rocketmq.logging.org.slf4j.Logger;
			import org.apache.rocketmq.logging.org.slf4j.LoggerFactory;
			
			public class BrokerStatsManager {
			
			    @Deprecated public static final String QUEUE_PUT_NUMS = Stats.QUEUE_PUT_NUMS;
			    @Deprecated public static final String QUEUE_PUT_SIZE = Stats.QUEUE_PUT_SIZE;
			    @Deprecated public static final String QUEUE_GET_NUMS = Stats.QUEUE_GET_NUMS;
			    @Deprecated public static final String QUEUE_GET_SIZE = Stats.QUEUE_GET_SIZE;
			    @Deprecated public static final String TOPIC_PUT_NUMS = Stats.TOPIC_PUT_NUMS;
			    @Deprecated public static final String TOPIC_PUT_SIZE = Stats.TOPIC_PUT_SIZE;
			
			    @Deprecated public static final String GROUP_GET_NUMS = Stats.GROUP_GET_NUMS;
			    @Deprecated public static final String GROUP_GET_SIZE = Stats.GROUP_GET_SIZE;
			
			    @Deprecated public static final String SNDBCK_PUT_NUMS = Stats.SNDBCK_PUT_NUMS;
			    @Deprecated public static final String BROKER_PUT_NUMS = Stats.BROKER_PUT_NUMS;
			    @Deprecated public static final String BROKER_GET_NUMS = Stats.BROKER_GET_NUMS;
			    @Deprecated public static final String GROUP_GET_FROM_DISK_NUMS = Stats.GROUP_GET_FROM_DISK_NUMS;
			    @Deprecated public static final String GROUP_GET_FROM_DISK_SIZE = Stats.GROUP_GET_FROM_DISK_SIZE;
			    @Deprecated public static final String BROKER_GET_FROM_DISK_NUMS = Stats.BROKER_GET_FROM_DISK_NUMS;
			    @Deprecated public static final String BROKER_GET_FROM_DISK_SIZE = Stats.BROKER_GET_FROM_DISK_SIZE;
			    // For commercial
			    @Deprecated public static final String COMMERCIAL_SEND_TIMES = Stats.COMMERCIAL_SEND_TIMES;
			    @Deprecated public static final String COMMERCIAL_SNDBCK_TIMES = Stats.COMMERCIAL_SNDBCK_TIMES;
			    @Deprecated public static final String COMMERCIAL_RCV_TIMES = Stats.COMMERCIAL_RCV_TIMES;
			    @Deprecated public static final String COMMERCIAL_RCV_EPOLLS = Stats.COMMERCIAL_RCV_EPOLLS;
			    @Deprecated public static final String COMMERCIAL_SEND_SIZE = Stats.COMMERCIAL_SEND_SIZE;
			    @Deprecated public static final String COMMERCIAL_RCV_SIZE = Stats.COMMERCIAL_RCV_SIZE;
			    @Deprecated public static final String COMMERCIAL_PERM_FAILURES = Stats.COMMERCIAL_PERM_FAILURES;
			
			    // Send message latency
			    public static final String TOPIC_PUT_LATENCY = "TOPIC_PUT_LATENCY";
			    public static final String GROUP_ACK_NUMS = "GROUP_ACK_NUMS";
			    public static final String GROUP_CK_NUMS = "GROUP_CK_NUMS";
			    public static final String DLQ_PUT_NUMS = "DLQ_PUT_NUMS";
			    public static final String BROKER_ACK_NUMS = "BROKER_ACK_NUMS";
			    public static final String BROKER_CK_NUMS = "BROKER_CK_NUMS";
			    public static final String BROKER_GET_NUMS_WITHOUT_SYSTEM_TOPIC = "BROKER_GET_NUMS_WITHOUT_SYSTEM_TOPIC";
			    public static final String BROKER_PUT_NUMS_WITHOUT_SYSTEM_TOPIC = "BROKER_PUT_NUMS_WITHOUT_SYSTEM_TOPIC";
			    public static final String SNDBCK2DLQ_TIMES = "SNDBCK2DLQ_TIMES";
			
			    public static final String COMMERCIAL_OWNER = "Owner";
			
			    public static final String ACCOUNT_OWNER_PARENT = "OWNER_PARENT";
			    public static final String ACCOUNT_OWNER_SELF = "OWNER_SELF";
			
			    public static final long ACCOUNT_STAT_INVERTAL = 60 * 1000;
			    public static final String ACCOUNT_AUTH_TYPE = "AUTH_TYPE";
			
			    public static final String ACCOUNT_SEND = "SEND";
			    public static final String ACCOUNT_RCV = "RCV";
			    public static final String ACCOUNT_SEND_BACK = "SEND_BACK";
			    public static final String ACCOUNT_SEND_BACK_TO_DLQ = "SEND_BACK_TO_DLQ";
			    public static final String ACCOUNT_AUTH_FAILED = "AUTH_FAILED";
			    public static final String ACCOUNT_SEND_REJ = "SEND_REJ";
			    public static final String ACCOUNT_REV_REJ = "RCV_REJ";
			
			    public static final String MSG_NUM = "MSG_NUM";
			    public static final String MSG_SIZE = "MSG_SIZE";
			    public static final String SUCCESS_MSG_NUM = "SUCCESS_MSG_NUM";
			    public static final String FAILURE_MSG_NUM = "FAILURE_MSG_NUM";
			    public static final String COMMERCIAL_MSG_NUM = "COMMERCIAL_MSG_NUM";
			    public static final String SUCCESS_REQ_NUM = "SUCCESS_REQ_NUM";
			    public static final String FAILURE_REQ_NUM = "FAILURE_REQ_NUM";
			    public static final String SUCCESS_MSG_SIZE = "SUCCESS_MSG_SIZE";
			    public static final String FAILURE_MSG_SIZE = "FAILURE_MSG_SIZE";
			    public static final String RT = "RT";
			    public static final String INNER_RT = "INNER_RT";
			
			    @Deprecated public static final String GROUP_GET_FALL_SIZE = Stats.GROUP_GET_FALL_SIZE;
			    @Deprecated public static final String GROUP_GET_FALL_TIME = Stats.GROUP_GET_FALL_TIME;
			    // Pull Message Latency
			    @Deprecated public static final String GROUP_GET_LATENCY = Stats.GROUP_GET_LATENCY;
			
			    // Consumer Register Time
			    public static final String CONSUMER_REGISTER_TIME = "CONSUMER_REGISTER_TIME";
			    // Producer Register Time
			    public static final String PRODUCER_REGISTER_TIME = "PRODUCER_REGISTER_TIME";
			    public static final String CHANNEL_ACTIVITY = "CHANNEL_ACTIVITY";
			    public static final String CHANNEL_ACTIVITY_CONNECT = "CONNECT";
			    public static final String CHANNEL_ACTIVITY_IDLE = "IDLE";
			    public static final String CHANNEL_ACTIVITY_EXCEPTION = "EXCEPTION";
			    public static final String CHANNEL_ACTIVITY_CLOSE = "CLOSE";
			
			    /**
			     * read disk follow stats
			     */
			    private static final Logger log = LoggerFactory.getLogger(LoggerName.ROCKETMQ_STATS_LOGGER_NAME);
			    private static final Logger COMMERCIAL_LOG = LoggerFactory.getLogger(
			        LoggerName.COMMERCIAL_LOGGER_NAME);
			    private static final Logger ACCOUNT_LOG = LoggerFactory.getLogger(LoggerName.ACCOUNT_LOGGER_NAME);
			    private static final Logger DLQ_STAT_LOG = LoggerFactory.getLogger(
			        LoggerName.DLQ_STATS_LOGGER_NAME);
			    private ScheduledExecutorService scheduledExecutorService;
			    private ScheduledExecutorService commercialExecutor;
			    private ScheduledExecutorService accountExecutor;
			
			    private final HashMap<String, StatsItemSet> statsTable = new HashMap<>();
			    private final String clusterName;
			    private final boolean enableQueueStat;
			    private MomentStatsItemSet momentStatsItemSetFallSize;
			    private MomentStatsItemSet momentStatsItemSetFallTime;
			
			    private final StatisticsManager accountStatManager = new StatisticsManager();
			    private StateGetter producerStateGetter;
			    private StateGetter consumerStateGetter;
			
			    private BrokerConfig brokerConfig;
			
			    public BrokerStatsManager(BrokerConfig brokerConfig) {			
",
,
			fromLine:"			366",
			toLine:"			370",
			content:"
			    }
			
			    public void incQueuePutNums(final String topic, final Integer queueId, int num, int times) {
			        if (enableQueueStat) {
			            this.statsTable.get(Stats.QUEUE_PUT_NUMS).addValue(buildStatsKey(topic, queueId), num, times);			
",
,
			fromLine:"			372",
			toLine:"			376",
			content:"
			    }
			
			    public void incQueuePutSize(final String topic, final Integer queueId, final int size) {
			        if (enableQueueStat) {
			            this.statsTable.get(Stats.QUEUE_PUT_SIZE).addValue(buildStatsKey(topic, queueId), size, 1);			
",
,
			fromLine:"			378",
			toLine:"			382",
			content:"
			    }
			
			    public void incQueueGetNums(final String group, final String topic, final Integer queueId, final int incValue) {
			        if (enableQueueStat) {
			            final String statsKey = buildStatsKey(topic, queueId, group);			
",
,
			fromLine:"			385",
			toLine:"			389",
			content:"
			    }
			
			    public void incQueueGetSize(final String group, final String topic, final Integer queueId, final int incValue) {
			        if (enableQueueStat) {
			            final String statsKey = buildStatsKey(topic, queueId, group);			
",
,
			fromLine:"			420",
			toLine:"			424",
			content:"
			    }
			
			    public void incTopicPutNums(final String topic, int num, int times) {
			        this.statsTable.get(Stats.TOPIC_PUT_NUMS).addValue(topic, num, times);
			    }			
",
,
			fromLine:"			428",
			toLine:"			442",
			content:"
			    }
			
			    public void incGroupGetNums(final String group, final String topic, final int incValue) {
			        final String statsKey = buildStatsKey(topic, group);
			        this.statsTable.get(Stats.GROUP_GET_NUMS).addValue(statsKey, incValue, 1);
			    }
			
			    public void incGroupCkNums(final String group, final String topic, final int incValue) {
			        final String statsKey = buildStatsKey(topic, group);
			        this.statsTable.get(GROUP_CK_NUMS).addValue(statsKey, incValue, 1);
			    }
			
			    public void incGroupAckNums(final String group, final String topic, final int incValue) {
			        final String statsKey = buildStatsKey(topic, group);
			        this.statsTable.get(GROUP_ACK_NUMS).addValue(statsKey, incValue, 1);			
",
,
			fromLine:"			465",
			toLine:"			469",
			content:"
			    }
			
			    public String buildStatsKey(String topic, int queueId, String group) {
			        StringBuilder strBuilder;
			        if (topic != null && group != null) {			
",
,
			fromLine:"			476",
			toLine:"			480",
			content:"
			    }
			
			    public String buildStatsKey(int queueId, String topic, String group) {
			        StringBuilder strBuilder;
			        if (topic != null && group != null) {			
",
,
			fromLine:"			487",
			toLine:"			496",
			content:"
			    }
			
			    public void incGroupGetSize(final String group, final String topic, final int incValue) {
			        final String statsKey = buildStatsKey(topic, group);
			        this.statsTable.get(Stats.GROUP_GET_SIZE).addValue(statsKey, incValue, 1);
			    }
			
			    public void incGroupGetLatency(final String group, final String topic, final int queueId, final int incValue) {
			        String statsKey;
			        if (enableQueueStat) {			
",
,
			fromLine:"			502",
			toLine:"			506",
			content:"
			    }
			
			    public void incTopicPutLatency(final String topic, final int queueId, final int incValue) {
			        StringBuilder statsKey;
			        if (topic != null) {			
",
,
			fromLine:"			583",
			toLine:"			613",
			content:"
			    }
			
			    public void recordDiskFallBehindTime(final String group, final String topic, final int queueId,
			        final long fallBehind) {
			        final String statsKey = buildStatsKey(queueId, topic, group);
			        this.momentStatsItemSetFallTime.getAndCreateStatsItem(statsKey).getValue().set(fallBehind);
			    }
			
			    public void recordDiskFallBehindSize(final String group, final String topic, final int queueId,
			        final long fallBehind) {
			        final String statsKey = buildStatsKey(queueId, topic, group);
			        this.momentStatsItemSetFallSize.getAndCreateStatsItem(statsKey).getValue().set(fallBehind);
			    }
			
			    public void incDLQStatValue(final String key, final String owner, final String group,
			        final String topic, final String type, final int incValue) {
			        final String statsKey = buildCommercialStatsKey(owner, topic, group, type);
			        this.statsTable.get(key).addValue(statsKey, incValue, 1);
			    }
			
			    public void incCommercialValue(final String key, final String owner, final String group,
			        final String topic, final String type, final int incValue) {
			        final String statsKey = buildCommercialStatsKey(owner, topic, group, type);
			        this.statsTable.get(key).addValue(statsKey, incValue, 1);
			    }
			
			    public void incAccountValue(final String key, final String accountOwnerParent, final String accountOwnerSelf,
			        final String instanceId, final String group, final String topic,
			        final String msgType, final int incValue) {
			        final String statsKey = buildAccountStatsKey(accountOwnerParent, accountOwnerSelf, instanceId, topic, group,
			            msgType);			
",
,
			fromLine:"			615",
			toLine:"			621",
			content:"
			    }
			
			    public void incAccountValue(final String key, final String accountOwnerParent, final String accountOwnerSelf,
			        final String instanceId, final String group, final String topic,
			        final String msgType, final String flowlimitThreshold, final int incValue) {
			        final String statsKey = buildAccountStatsKey(accountOwnerParent, accountOwnerSelf, instanceId, topic, group,
			            msgType, flowlimitThreshold);			
",
,
			fromLine:"			623",
			toLine:"			641",
			content:"
			    }
			
			    public void incAccountValue(final String statType, final String owner, final String instanceId, final String topic,
			        final String group, final String msgType,
			        final long... incValues) {
			        final String key = buildAccountStatKey(owner, instanceId, topic, group, msgType);
			        this.accountStatManager.inc(statType, key, incValues);
			    }
			
			    public void incAccountValue(final String statType, final String owner, final String instanceId, final String topic,
			        final String group, final String msgType, final String flowlimitThreshold,
			        final long... incValues) {
			        final String key = buildAccountStatKey(owner, instanceId, topic, group, msgType, flowlimitThreshold);
			        this.accountStatManager.inc(statType, key, incValues);
			    }
			
			    public String buildCommercialStatsKey(String owner, String topic, String group, String type) {
			        StringBuilder strBuilder = new StringBuilder();
			        strBuilder.append(owner);			
",
,
			fromLine:"			649",
			toLine:"			654",
			content:"
			    }
			
			    public String buildAccountStatsKey(String accountOwnerParent, String accountOwnerSelf, String instanceId,
			        String topic, String group, String msgType) {
			        StringBuffer strBuilder = new StringBuffer();
			        strBuilder.append(accountOwnerParent);			
",
,
			fromLine:"			666",
			toLine:"			671",
			content:"
			    }
			
			    public String buildAccountStatsKey(String accountOwnerParent, String accountOwnerSelf, String instanceId,
			        String topic, String group, String msgType, String flowlimitThreshold) {
			        StringBuffer strBuilder = new StringBuffer();
			        strBuilder.append(accountOwnerParent);			
",
,
			fromLine:"			685",
			toLine:"			691",
			content:"
			    }
			
			    public String buildAccountStatKey(final String owner, final String instanceId,
			        final String topic, final String group,
			        final String msgType) {
			        final String sep = "|";
			        StringBuffer strBuilder = new StringBuffer();			
",
,
			fromLine:"			698",
			toLine:"			704",
			content:"
			    }
			
			    public String buildAccountStatKey(final String owner, final String instanceId,
			        final String topic, final String group,
			        final String msgType, String flowlimitThreshold) {
			        final String sep = "|";
			        StringBuffer strBuilder = new StringBuffer();			
",
,
			fromLine:"			717",
			toLine:"			726",
			content:"
			    }
			
			    private StatisticsKindMeta createStatisticsKindMeta(String name,
			        String[] itemNames,
			        ScheduledExecutorService executorService,
			        StatisticsItemFormatter formatter,
			        Logger log,
			        long interval) {
			        final BrokerConfig brokerConfig = this.brokerConfig;
			        StatisticsItemPrinter printer = new StatisticsItemPrinter(formatter, log);			
",
,

		],
		client/src/main/java/org/apache/rocketmq/client/impl/consumer/DefaultLitePullConsumerImpl.java:
		[
			fromLine:"			16",
			toLine:"			99",
			content:"
			 */
			package org.apache.rocketmq.client.impl.consumer;
			
			import java.util.ArrayList;
			import java.util.Collection;
			import java.util.Collections;
			import java.util.HashMap;
			import java.util.HashSet;
			import java.util.Iterator;
			import java.util.List;
			import java.util.Map;
			import java.util.Properties;
			import java.util.Set;
			import java.util.concurrent.BlockingQueue;
			import java.util.concurrent.ConcurrentHashMap;
			import java.util.concurrent.ConcurrentMap;
			import java.util.concurrent.Executors;
			import java.util.concurrent.LinkedBlockingQueue;
			import java.util.concurrent.ScheduledExecutorService;
			import java.util.concurrent.ScheduledThreadPoolExecutor;
			import java.util.concurrent.TimeUnit;
			import org.apache.commons.lang3.StringUtils;
			import org.apache.rocketmq.client.Validators;
			import org.apache.rocketmq.client.consumer.DefaultLitePullConsumer;
			import org.apache.rocketmq.client.consumer.MessageQueueListener;
			import org.apache.rocketmq.client.consumer.MessageSelector;
			import org.apache.rocketmq.client.consumer.PullResult;
			import org.apache.rocketmq.client.consumer.TopicMessageQueueChangeListener;
			import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;
			import org.apache.rocketmq.client.consumer.store.LocalFileOffsetStore;
			import org.apache.rocketmq.client.consumer.store.OffsetStore;
			import org.apache.rocketmq.client.consumer.store.ReadOffsetType;
			import org.apache.rocketmq.client.consumer.store.RemoteBrokerOffsetStore;
			import org.apache.rocketmq.client.exception.MQBrokerException;
			import org.apache.rocketmq.client.exception.MQClientException;
			import org.apache.rocketmq.client.hook.ConsumeMessageContext;
			import org.apache.rocketmq.client.hook.ConsumeMessageHook;
			import org.apache.rocketmq.client.hook.FilterMessageHook;
			import org.apache.rocketmq.client.impl.CommunicationMode;
			import org.apache.rocketmq.client.impl.MQClientManager;
			import org.apache.rocketmq.client.impl.factory.MQClientInstance;
			import org.apache.rocketmq.common.MixAll;
			import org.apache.rocketmq.common.ServiceState;
			import org.apache.rocketmq.common.ThreadFactoryImpl;
			import org.apache.rocketmq.common.consumer.ConsumeFromWhere;
			import org.apache.rocketmq.common.filter.ExpressionType;
			import org.apache.rocketmq.common.help.FAQUrl;
			import org.apache.rocketmq.common.message.MessageExt;
			import org.apache.rocketmq.common.message.MessageQueue;
			import org.apache.rocketmq.common.sysflag.PullSysFlag;
			import org.apache.rocketmq.remoting.RPCHook;
			import org.apache.rocketmq.remoting.exception.RemotingException;
			import org.apache.rocketmq.remoting.protocol.NamespaceUtil;
			import org.apache.rocketmq.remoting.protocol.ResponseCode;
			import org.apache.rocketmq.remoting.protocol.body.ConsumerRunningInfo;
			import org.apache.rocketmq.remoting.protocol.body.ProcessQueueInfo;
			import org.apache.rocketmq.remoting.protocol.filter.FilterAPI;
			import org.apache.rocketmq.remoting.protocol.heartbeat.ConsumeType;
			import org.apache.rocketmq.remoting.protocol.heartbeat.MessageModel;
			import org.apache.rocketmq.remoting.protocol.heartbeat.SubscriptionData;
			import org.apache.rocketmq.logging.org.slf4j.Logger;
			import org.apache.rocketmq.logging.org.slf4j.LoggerFactory;
			
			public class DefaultLitePullConsumerImpl implements MQConsumerInner {
			
			    private static final Logger log = LoggerFactory.getLogger(DefaultLitePullConsumerImpl.class);
			
			    private final long consumerStartTimestamp = System.currentTimeMillis();
			
			    private final RPCHook rpcHook;
			
			    private final ArrayList<FilterMessageHook> filterMessageHookList = new ArrayList<>();
			
			    private volatile ServiceState serviceState = ServiceState.CREATE_JUST;
			
			    protected MQClientInstance mQClientFactory;
			
			    private PullAPIWrapper pullAPIWrapper;
			
			    private OffsetStore offsetStore;
			
			    private RebalanceImpl rebalanceImpl = new RebalanceLitePullImpl(this);
			
			    private enum SubscriptionType {			
",
,
			fromLine:"			101",
			toLine:"			164",
			content:"
			    }
			
			    private static final String NOT_RUNNING_EXCEPTION_MESSAGE = "The consumer not running, please start it first.";
			
			    private static final String SUBSCRIPTION_CONFLICT_EXCEPTION_MESSAGE = "Subscribe and assign are mutually exclusive.";
			    /**
			     * the type of subscription
			     */
			    private SubscriptionType subscriptionType = SubscriptionType.NONE;
			    /**
			     * Delay some time when exception occur
			     */
			    private long pullTimeDelayMillsWhenException = 1000;
			    /**
			     * Flow control interval when message cache is full
			     */
			    private static final long PULL_TIME_DELAY_MILLS_WHEN_CACHE_FLOW_CONTROL = 50;
			    /**
			     * Flow control interval when broker return flow control
			     */
			    private static final long PULL_TIME_DELAY_MILLS_WHEN_BROKER_FLOW_CONTROL = 20;
			    /**
			     * Delay some time when suspend pull service
			     */
			    private static final long PULL_TIME_DELAY_MILLS_WHEN_PAUSE = 1000;
			
			    private static final long PULL_TIME_DELAY_MILLS_ON_EXCEPTION = 3 * 1000;
			
			    private ConcurrentHashMap<String/* topic */, String/* subExpression */> topicToSubExpression = new ConcurrentHashMap<>();
			
			    private DefaultLitePullConsumer defaultLitePullConsumer;
			
			    private final ConcurrentMap<MessageQueue, PullTaskImpl> taskTable =
			        new ConcurrentHashMap<>();
			
			    private AssignedMessageQueue assignedMessageQueue = new AssignedMessageQueue();
			
			    private final BlockingQueue<ConsumeRequest> consumeRequestCache = new LinkedBlockingQueue<>();
			
			    private ScheduledThreadPoolExecutor scheduledThreadPoolExecutor;
			
			    private final ScheduledExecutorService scheduledExecutorService;
			
			    private Map<String, TopicMessageQueueChangeListener> topicMessageQueueChangeListenerMap = new HashMap<>();
			
			    private Map<String, Set<MessageQueue>> messageQueuesForTopic = new HashMap<>();
			
			    private long consumeRequestFlowControlTimes = 0L;
			
			    private long queueFlowControlTimes = 0L;
			
			    private long queueMaxSpanFlowControlTimes = 0L;
			
			    private long nextAutoCommitDeadline = -1L;
			
			    private final MessageQueueLock messageQueueLock = new MessageQueueLock();
			
			    private final ArrayList<ConsumeMessageHook> consumeMessageHookList = new ArrayList<>();
			
			    // only for test purpose, will be modified by reflection in unit test.
			    @SuppressWarnings("FieldMayBeFinal")
			    private static boolean doNotUpdateTopicSubscribeInfoWhenSubscriptionChanged = false;
			
			    public DefaultLitePullConsumerImpl(final DefaultLitePullConsumer defaultLitePullConsumer, final RPCHook rpcHook) {			
",
,
			fromLine:"			245",
			toLine:"			249",
			content:"
			    }
			
			    public void updateAssignQueueAndStartPullTask(String topic, Set<MessageQueue> mqAll, Set<MessageQueue> mqDivided) {
			        MessageModel messageModel = defaultLitePullConsumer.getMessageModel();
			        switch (messageModel) {			
",
,
			fromLine:"			487",
			toLine:"			492",
			content:"
			     * @throws MQClientException
			     */
			    public synchronized void subscribe(String topic, String subExpression,
			        MessageQueueListener messageQueueListener) throws MQClientException {
			        try {
			            if (StringUtils.isEmpty(topic)) {			
",
,
			fromLine:"			795",
			toLine:"			799",
			content:"
			    }
			
			    private void updatePullOffset(MessageQueue messageQueue, long nextPullOffset, ProcessQueue processQueue) {
			        if (assignedMessageQueue.getSeekOffset(messageQueue) == -1) {
			            assignedMessageQueue.updatePullOffset(messageQueue, nextPullOffset, processQueue);			
",
,
			fromLine:"			1019",
			toLine:"			1035",
			content:"
			    }
			
			    private PullResult pull(MessageQueue mq, SubscriptionData subscriptionData, long offset, int maxNums)
			        throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
			        return pull(mq, subscriptionData, offset, maxNums, this.defaultLitePullConsumer.getConsumerPullTimeoutMillis());
			    }
			
			    private PullResult pull(MessageQueue mq, SubscriptionData subscriptionData, long offset, int maxNums, long timeout)
			        throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
			        return this.pullSyncImpl(mq, subscriptionData, offset, maxNums, true, timeout);
			    }
			
			    private PullResult pullSyncImpl(MessageQueue mq, SubscriptionData subscriptionData, long offset, int maxNums,
			        boolean block,
			        long timeout)
			        throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
						
",
,
			fromLine:"			1198",
			toLine:"			1202",
			content:"
			    }
			
			    private void updateConsumeOffsetToBroker(MessageQueue mq, long offset, boolean isOneway) throws RemotingException,
			        MQBrokerException, InterruptedException, MQClientException {
			        this.offsetStore.updateConsumeOffsetToBroker(mq, offset, isOneway);			
",
,

		],
		client/src/main/java/org/apache/rocketmq/client/impl/consumer/DefaultMQPushConsumerImpl.java:
		[
			fromLine:"			16",
			toLine:"			96",
			content:"
			 */
			package org.apache.rocketmq.client.impl.consumer;
			
			import java.util.ArrayList;
			import java.util.Date;
			import java.util.HashMap;
			import java.util.HashSet;
			import java.util.Iterator;
			import java.util.List;
			import java.util.Map;
			import java.util.Map.Entry;
			import java.util.Properties;
			import java.util.Set;
			import java.util.concurrent.ConcurrentMap;
			import org.apache.commons.collections.CollectionUtils;
			import org.apache.commons.lang3.StringUtils;
			import org.apache.rocketmq.client.QueryResult;
			import org.apache.rocketmq.client.Validators;
			import org.apache.rocketmq.client.consumer.AckCallback;
			import org.apache.rocketmq.client.consumer.AckResult;
			import org.apache.rocketmq.client.consumer.AckStatus;
			import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
			import org.apache.rocketmq.client.consumer.MessageQueueListener;
			import org.apache.rocketmq.client.consumer.MessageSelector;
			import org.apache.rocketmq.client.consumer.PopCallback;
			import org.apache.rocketmq.client.consumer.PopResult;
			import org.apache.rocketmq.client.consumer.PopStatus;
			import org.apache.rocketmq.client.consumer.PullCallback;
			import org.apache.rocketmq.client.consumer.PullResult;
			import org.apache.rocketmq.client.consumer.listener.MessageListener;
			import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;
			import org.apache.rocketmq.client.consumer.listener.MessageListenerOrderly;
			import org.apache.rocketmq.client.consumer.store.LocalFileOffsetStore;
			import org.apache.rocketmq.client.consumer.store.OffsetStore;
			import org.apache.rocketmq.client.consumer.store.ReadOffsetType;
			import org.apache.rocketmq.client.consumer.store.RemoteBrokerOffsetStore;
			import org.apache.rocketmq.client.exception.MQBrokerException;
			import org.apache.rocketmq.client.exception.MQClientException;
			import org.apache.rocketmq.client.hook.ConsumeMessageContext;
			import org.apache.rocketmq.client.hook.ConsumeMessageHook;
			import org.apache.rocketmq.client.hook.FilterMessageContext;
			import org.apache.rocketmq.client.hook.FilterMessageHook;
			import org.apache.rocketmq.client.impl.CommunicationMode;
			import org.apache.rocketmq.client.impl.FindBrokerResult;
			import org.apache.rocketmq.client.impl.MQClientManager;
			import org.apache.rocketmq.client.impl.factory.MQClientInstance;
			import org.apache.rocketmq.client.stat.ConsumerStatsManager;
			import org.apache.rocketmq.common.KeyBuilder;
			import org.apache.rocketmq.common.MixAll;
			import org.apache.rocketmq.common.ServiceState;
			import org.apache.rocketmq.common.UtilAll;
			import org.apache.rocketmq.common.consumer.ConsumeFromWhere;
			import org.apache.rocketmq.common.help.FAQUrl;
			import org.apache.rocketmq.common.message.Message;
			import org.apache.rocketmq.common.message.MessageAccessor;
			import org.apache.rocketmq.common.message.MessageConst;
			import org.apache.rocketmq.common.message.MessageExt;
			import org.apache.rocketmq.common.message.MessageQueue;
			import org.apache.rocketmq.common.sysflag.PullSysFlag;
			import org.apache.rocketmq.remoting.RPCHook;
			import org.apache.rocketmq.remoting.common.RemotingHelper;
			import org.apache.rocketmq.remoting.exception.RemotingException;
			import org.apache.rocketmq.remoting.protocol.NamespaceUtil;
			import org.apache.rocketmq.remoting.protocol.ResponseCode;
			import org.apache.rocketmq.remoting.protocol.body.ConsumeStatus;
			import org.apache.rocketmq.remoting.protocol.body.ConsumerRunningInfo;
			import org.apache.rocketmq.remoting.protocol.body.PopProcessQueueInfo;
			import org.apache.rocketmq.remoting.protocol.body.ProcessQueueInfo;
			import org.apache.rocketmq.remoting.protocol.body.QueueTimeSpan;
			import org.apache.rocketmq.remoting.protocol.filter.FilterAPI;
			import org.apache.rocketmq.remoting.protocol.header.AckMessageRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.ChangeInvisibleTimeRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.ExtraInfoUtil;
			import org.apache.rocketmq.remoting.protocol.heartbeat.ConsumeType;
			import org.apache.rocketmq.remoting.protocol.heartbeat.MessageModel;
			import org.apache.rocketmq.remoting.protocol.heartbeat.SubscriptionData;
			import org.apache.rocketmq.remoting.protocol.route.BrokerData;
			import org.apache.rocketmq.remoting.protocol.route.TopicRouteData;
			import org.apache.rocketmq.logging.org.slf4j.Logger;
			import org.apache.rocketmq.logging.org.slf4j.LoggerFactory;
						
",
,
			fromLine:"			99",
			toLine:"			146",
			content:"
			     * Delay some time when exception occur
			     */
			    private long pullTimeDelayMillsWhenException = 3000;
			    /**
			     * Flow control interval when message cache is full
			     */
			    private static final long PULL_TIME_DELAY_MILLS_WHEN_CACHE_FLOW_CONTROL = 50;
			    /**
			     * Flow control interval when broker return flow control
			     */
			    private static final long PULL_TIME_DELAY_MILLS_WHEN_BROKER_FLOW_CONTROL = 20;
			    /**
			     * Delay some time when suspend pull service
			     */
			    private static final long PULL_TIME_DELAY_MILLS_WHEN_SUSPEND = 1000;
			    private static final long BROKER_SUSPEND_MAX_TIME_MILLIS = 1000 * 15;
			    private static final long CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND = 1000 * 30;
			    private static final Logger log = LoggerFactory.getLogger(DefaultMQPushConsumerImpl.class);
			    private final DefaultMQPushConsumer defaultMQPushConsumer;
			    private final RebalanceImpl rebalanceImpl = new RebalancePushImpl(this);
			    private final ArrayList<FilterMessageHook> filterMessageHookList = new ArrayList<>();
			    private final long consumerStartTimestamp = System.currentTimeMillis();
			    private final ArrayList<ConsumeMessageHook> consumeMessageHookList = new ArrayList<>();
			    private final RPCHook rpcHook;
			    private volatile ServiceState serviceState = ServiceState.CREATE_JUST;
			    private MQClientInstance mQClientFactory;
			    private PullAPIWrapper pullAPIWrapper;
			    private volatile boolean pause = false;
			    private boolean consumeOrderly = false;
			    private MessageListener messageListenerInner;
			    private OffsetStore offsetStore;
			    private ConsumeMessageService consumeMessageService;
			    private ConsumeMessageService consumeMessagePopService;
			    private long queueFlowControlTimes = 0;
			    private long queueMaxSpanFlowControlTimes = 0;
			
			    //10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h
			    private final int[] popDelayLevel = new int[] {10, 30, 60, 120, 180, 240, 300, 360, 420, 480, 540, 600, 1200, 1800, 3600, 7200};
			
			    private static final int MAX_POP_INVISIBLE_TIME = 300000;
			    private static final int MIN_POP_INVISIBLE_TIME = 5000;
			    private static final int ASYNC_TIMEOUT = 3000;
			
			    // only for test purpose, will be modified by reflection in unit test.
			    @SuppressWarnings("FieldMayBeFinal")
			    private static boolean doNotUpdateTopicSubscribeInfoWhenSubscriptionChanged = false;
			
			    public DefaultMQPushConsumerImpl(DefaultMQPushConsumer defaultMQPushConsumer, RPCHook rpcHook) {			
",
,
			fromLine:"			188",
			toLine:"			196",
			content:"
			    }
			
			    public void createTopic(String key, String newTopic, int queueNum) throws MQClientException {
			        createTopic(key, newTopic, queueNum, 0);
			    }
			
			    public void createTopic(String key, String newTopic, int queueNum, int topicSysFlag) throws MQClientException {
			        this.mQClientFactory.getMQAdminImpl().createTopic(key, newTopic, queueNum, topicSysFlag, null);
			    }			
",
,
			fromLine:"			717",
			toLine:"			721",
			content:"
			    }
			
			    public QueryResult queryMessage(String topic, String key, int maxNum, long begin, long end)
			        throws MQClientException, InterruptedException {
			        return this.mQClientFactory.getMQAdminImpl().queryMessage(topic, key, maxNum, begin, end);			
",
,
			fromLine:"			738",
			toLine:"			747",
			content:"
			
			    @Deprecated
			    public void sendMessageBack(MessageExt msg, int delayLevel, final String brokerName)
			            throws RemotingException, MQBrokerException, InterruptedException, MQClientException {
			        sendMessageBack(msg, delayLevel, brokerName, null);
			    }
			
			    public void sendMessageBack(MessageExt msg, int delayLevel, final MessageQueue mq)
			            throws RemotingException, MQBrokerException, InterruptedException, MQClientException {
			        sendMessageBack(msg, delayLevel, null, mq);			
",
,
			fromLine:"			749",
			toLine:"			753",
			content:"
			
			
			    private void sendMessageBack(MessageExt msg, int delayLevel, final String brokerName, final MessageQueue mq)
			        throws RemotingException, MQBrokerException, InterruptedException, MQClientException {
			        boolean needRetry = true;			
",
,
			fromLine:"			844",
			toLine:"			848",
			content:"
			    }
			
			    void changePopInvisibleTimeAsync(String topic, String consumerGroup, String extraInfo, long invisibleTime, AckCallback callback)
			        throws MQClientException, RemotingException, InterruptedException, MQBrokerException {
			        String[] extraInfoStrs = ExtraInfoUtil.split(extraInfo);			
",
,
			fromLine:"			1258",
			toLine:"			1262",
			content:"
			    }
			
			    public void subscribe(String topic, String fullClassName, String filterClassSource) throws MQClientException {
			        try {
			            SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(topic, SubscriptionData.SUB_ALL);			
",
,

		],
		common/src/main/java/org/apache/rocketmq/common/BrokerConfig.java:
		[
			fromLine:"			16",
			toLine:"			36",
			content:"
			 */
			package org.apache.rocketmq.common;
			
			import org.apache.rocketmq.common.annotation.ImportantField;
			import org.apache.rocketmq.common.constant.PermName;
			import org.apache.rocketmq.common.message.MessageRequestMode;
			import org.apache.rocketmq.common.metrics.MetricsExporterType;
			import org.apache.rocketmq.common.topic.TopicValidator;
			import org.apache.rocketmq.common.utils.NetworkUtil;
			
			import java.util.concurrent.TimeUnit;
			
			public class BrokerConfig extends BrokerIdentity {
			
			    private String brokerConfigPath = null;
			
			    private String rocketmqHome = System.getProperty(MixAll.ROCKETMQ_HOME_PROPERTY, System.getenv(MixAll.ROCKETMQ_HOME_ENV));
			    @ImportantField
			    private String namesrvAddr = System.getProperty(MixAll.NAMESRV_ADDR_PROPERTY, System.getenv(MixAll.NAMESRV_ADDR_ENV));
			
			    /**			
",
,
			fromLine:"			38",
			toLine:"			156",
			content:"
			     */
			    @ImportantField
			    private int listenPort = 6888;
			
			    @ImportantField
			    private String brokerIP1 = NetworkUtil.getLocalAddress();
			    private String brokerIP2 = NetworkUtil.getLocalAddress();
			
			    @ImportantField
			    private boolean recoverConcurrently = false;
			
			    private int brokerPermission = PermName.PERM_READ | PermName.PERM_WRITE;
			    private int defaultTopicQueueNums = 8;
			    @ImportantField
			    private boolean autoCreateTopicEnable = true;
			
			    private boolean clusterTopicEnable = true;
			
			    private boolean brokerTopicEnable = true;
			    @ImportantField
			    private boolean autoCreateSubscriptionGroup = true;
			    private String messageStorePlugIn = "";
			
			    private static final int PROCESSOR_NUMBER = Runtime.getRuntime().availableProcessors();
			    @ImportantField
			    private String msgTraceTopicName = TopicValidator.RMQ_SYS_TRACE_TOPIC;
			    @ImportantField
			    private boolean traceTopicEnable = false;
			    /**
			     * thread numbers for send message thread pool.
			     */
			    private int sendMessageThreadPoolNums = Math.min(PROCESSOR_NUMBER, 4);
			    private int putMessageFutureThreadPoolNums = Math.min(PROCESSOR_NUMBER, 4);
			    private int pullMessageThreadPoolNums = 16 + PROCESSOR_NUMBER * 2;
			    private int litePullMessageThreadPoolNums = 16 + PROCESSOR_NUMBER * 2;
			    private int ackMessageThreadPoolNums = 3;
			    private int processReplyMessageThreadPoolNums = 16 + PROCESSOR_NUMBER * 2;
			    private int queryMessageThreadPoolNums = 8 + PROCESSOR_NUMBER;
			
			    private int adminBrokerThreadPoolNums = 16;
			    private int clientManageThreadPoolNums = 32;
			    private int consumerManageThreadPoolNums = 32;
			    private int loadBalanceProcessorThreadPoolNums = 32;
			    private int heartbeatThreadPoolNums = Math.min(32, PROCESSOR_NUMBER);
			    private int recoverThreadPoolNums = 32;
			
			    /**
			     * Thread numbers for EndTransactionProcessor
			     */
			    private int endTransactionThreadPoolNums = Math.max(8 + PROCESSOR_NUMBER * 2,
			            sendMessageThreadPoolNums * 4);
			
			    private int flushConsumerOffsetInterval = 1000 * 5;
			
			    private int flushConsumerOffsetHistoryInterval = 1000 * 60;
			
			    @ImportantField
			    private boolean rejectTransactionMessage = false;
			
			    @ImportantField
			    private boolean fetchNameSrvAddrByDnsLookup = false;
			
			    @ImportantField
			    private boolean fetchNamesrvAddrByAddressServer = false;
			
			    private int sendThreadPoolQueueCapacity = 10000;
			    private int putThreadPoolQueueCapacity = 10000;
			    private int pullThreadPoolQueueCapacity = 100000;
			    private int litePullThreadPoolQueueCapacity = 100000;
			    private int ackThreadPoolQueueCapacity = 100000;
			    private int replyThreadPoolQueueCapacity = 10000;
			    private int queryThreadPoolQueueCapacity = 20000;
			    private int clientManagerThreadPoolQueueCapacity = 1000000;
			    private int consumerManagerThreadPoolQueueCapacity = 1000000;
			    private int heartbeatThreadPoolQueueCapacity = 50000;
			    private int endTransactionPoolQueueCapacity = 100000;
			    private int adminBrokerThreadPoolQueueCapacity = 10000;
			    private int loadBalanceThreadPoolQueueCapacity = 100000;
			
			    private boolean longPollingEnable = true;
			
			    private long shortPollingTimeMills = 1000;
			
			    private boolean notifyConsumerIdsChangedEnable = true;
			
			    private boolean highSpeedMode = false;
			
			    private int commercialBaseCount = 1;
			
			    private int commercialSizePerMsg = 4 * 1024;
			
			    private boolean accountStatsEnable = true;
			    private boolean accountStatsPrintZeroValues = true;
			
			    private boolean transferMsgByHeap = true;
			
			    private String regionId = MixAll.DEFAULT_TRACE_REGION_ID;
			    private int registerBrokerTimeoutMills = 24000;
			
			    private int sendHeartbeatTimeoutMillis = 1000;
			
			    private boolean slaveReadEnable = false;
			
			    private boolean disableConsumeIfConsumerReadSlowly = false;
			    private long consumerFallbehindThreshold = 1024L * 1024 * 1024 * 16;
			
			    private boolean brokerFastFailureEnable = true;
			    private long waitTimeMillsInSendQueue = 200;
			    private long waitTimeMillsInPullQueue = 5 * 1000;
			    private long waitTimeMillsInLitePullQueue = 5 * 1000;
			    private long waitTimeMillsInHeartbeatQueue = 31 * 1000;
			    private long waitTimeMillsInTransactionQueue = 3 * 1000;
			    private long waitTimeMillsInAckQueue = 3000;
			
			    private long startAcceptSendRequestTimeStamp = 0L;
			
			    private boolean traceOn = true;
			
			    // Switch of filter bit map calculation.			
",
,
			fromLine:"			158",
			toLine:"			182",
			content:"
			    // 1. Calculate filter bit map when construct queue.
			    // 2. Filter bit map will be saved to consume queue extend file if allowed.
			    private boolean enableCalcFilterBitMap = false;
			
			    //Reject the pull consumer instance to pull messages from broker.
			    private boolean rejectPullConsumerEnable = false;
			
			    // Expect num of consumers will use filter.
			    private int expectConsumerNumUseFilter = 32;
			
			    // Error rate of bloom filter, 1~100.
			    private int maxErrorRateOfBloomFilter = 20;
			
			    //how long to clean filter data after dead.Default: 24h
			    private long filterDataCleanTimeSpan = 24 * 3600 * 1000;
			
			    // whether do filter when retry.
			    private boolean filterSupportRetry = false;
			    private boolean enablePropertyFilter = false;
			
			    private boolean compressedRegister = false;
			
			    private boolean forceRegister = true;
			
			    /**			
",
,
			fromLine:"			184",
			toLine:"			193",
			content:"
			     * between 10,000 and 60,000 milliseconds.
			     */
			    private int registerNameServerPeriod = 1000 * 30;
			
			    /**
			     * the interval to send heartbeat to name server for liveness detection.
			     */
			    private int brokerHeartbeatInterval = 1000;
			
			    /**			
",
,
			fromLine:"			195",
			toLine:"			253",
			content:"
			     * enableSlaveActingMaster is true
			     */
			    private long brokerNotActiveTimeoutMillis = 10 * 1000;
			
			    private boolean enableNetWorkFlowControl = false;
			
			    private boolean enableBroadcastOffsetStore = true;
			
			    private long broadcastOffsetExpireSecond = 2 * 60;
			
			    private long broadcastOffsetExpireMaxSecond = 5 * 60;
			
			    private int popPollingSize = 1024;
			    private int popPollingMapSize = 100000;
			    // 20w cost 200M heap memory.
			    private long maxPopPollingSize = 100000;
			    private int reviveQueueNum = 8;
			    private long reviveInterval = 1000;
			    private long reviveMaxSlow = 3;
			    private long reviveScanTime = 10000;
			    private boolean enableSkipLongAwaitingAck = false;
			    private long reviveAckWaitMs = TimeUnit.MINUTES.toMillis(3);
			    private boolean enablePopLog = false;
			    private boolean enablePopBufferMerge = false;
			    private int popCkStayBufferTime = 10 * 1000;
			    private int popCkStayBufferTimeOut = 3 * 1000;
			    private int popCkMaxBufferSize = 200000;
			    private int popCkOffsetMaxQueueSize = 20000;
			    private boolean enablePopBatchAck = false;
			    private boolean enableNotifyAfterPopOrderLockRelease = true;
			    private boolean initPopOffsetByCheckMsgInMem = true;
			    // read message from pop retry topic v1, for the compatibility, will be removed in the future version
			    private boolean retrieveMessageFromPopRetryTopicV1 = true;
			    private boolean enableRetryTopicV2 = false;
			
			    private boolean realTimeNotifyConsumerChange = true;
			
			    private boolean litePullMessageEnable = true;
			
			    // The period to sync broker member group from namesrv, default value is 1 second
			    private int syncBrokerMemberGroupPeriod = 1000;
			
			    /**
			     * the interval of pulling topic information from the named server
			     */
			    private long loadBalancePollNameServerInterval = 1000 * 30;
			
			    /**
			     * the interval of cleaning
			     */
			    private int cleanOfflineBrokerInterval = 1000 * 30;
			
			    private boolean serverLoadBalancerEnable = true;
			
			    private MessageRequestMode defaultMessageRequestMode = MessageRequestMode.PULL;
			
			    private int defaultPopShareQueueNum = -1;
			
			    /**			
",
,
			fromLine:"			256",
			toLine:"			260",
			content:"
			     */
			    @ImportantField
			    private long transactionTimeOut = 6 * 1000;
			
			    /**			
",
,
			fromLine:"			262",
			toLine:"			266",
			content:"
			     */
			    @ImportantField
			    private int transactionCheckMax = 15;
			
			    /**			
",
,
			fromLine:"			268",
			toLine:"			281",
			content:"
			     */
			    @ImportantField
			    private long transactionCheckInterval = 30 * 1000;
			
			    private long transactionMetricFlushInterval = 3 * 1000;
			
			    /**
			     * transaction batch op message
			     */
			    private int transactionOpMsgMaxSize = 4096;
			
			    private int transactionOpBatchInterval = 3000;
			
			    /**			
",
,
			fromLine:"			283",
			toLine:"			300",
			content:"
			     */
			    @ImportantField
			    private boolean aclEnable = false;
			
			    private boolean storeReplyMessageEnable = true;
			
			    private boolean enableDetailStat = true;
			
			    private boolean autoDeleteUnusedStats = false;
			
			    /**
			     * Whether to distinguish log paths when multiple brokers are deployed on the same machine
			     */
			    private boolean isolateLogEnable = false;
			
			    private long forwardTimeout = 3 * 1000;
			
			    /**			
",
,
			fromLine:"			303",
			toLine:"			319",
			content:"
			     * when enableSlaveActingMaster is true
			     */
			    private boolean enableSlaveActingMaster = false;
			
			    private boolean enableRemoteEscape = false;
			
			    private boolean skipPreOnline = false;
			
			    private boolean asyncSendEnable = true;
			
			    private boolean useServerSideResetOffset = true;
			
			    private long consumerOffsetUpdateVersionStep = 500;
			
			    private long delayOffsetUpdateVersionStep = 200;
			
			    /**			
",
,
			fromLine:"			322",
			toLine:"			347",
			content:"
			     * True: need to lock quorum replicas succeed. False: only need to lock one replica succeed.
			     */
			    private boolean lockInStrictMode = false;
			
			    private boolean compatibleWithOldNameSrv = true;
			
			    /**
			     * Is startup controller mode, which support auto switch broker's role.
			     */
			    private boolean enableControllerMode = false;
			
			    private String controllerAddr = "";
			
			    private boolean fetchControllerAddrByDnsLookup = false;
			
			    private long syncBrokerMetadataPeriod = 5 * 1000;
			
			    private long checkSyncStateSetPeriod = 5 * 1000;
			
			    private long syncControllerMetadataPeriod = 10 * 1000;
			
			    private long controllerHeartBeatTimeoutMills = 10 * 1000;
			
			    private boolean validateSystemTopicWhenUpdateTopic = true;
			
			    /**			
",
,
			fromLine:"			350",
			toLine:"			396",
			content:"
			     * You can set a lower priority for the broker with better machine conditions.
			     */
			    private int brokerElectionPriority = Integer.MAX_VALUE;
			
			    private boolean useStaticSubscription = false;
			
			    private MetricsExporterType metricsExporterType = MetricsExporterType.DISABLE;
			
			    private int metricsOtelCardinalityLimit = 50 * 1000;
			    private String metricsGrpcExporterTarget = "";
			    private String metricsGrpcExporterHeader = "";
			    private long metricGrpcExporterTimeOutInMills = 3 * 1000;
			    private long metricGrpcExporterIntervalInMills = 60 * 1000;
			    private long metricLoggingExporterIntervalInMills = 10 * 1000;
			
			    private int metricsPromExporterPort = 5557;
			    private String metricsPromExporterHost = "";
			
			    // Label pairs in CSV. Each label follows pattern of Key:Value. eg: instance_id:xxx,uid:xxx
			    private String metricsLabel = "";
			
			    private boolean metricsInDelta = false;
			
			    private long channelExpiredTimeout = 1000 * 120;
			    private long subscriptionExpiredTimeout = 1000 * 60 * 10;
			
			    /**
			     * Estimate accumulation or not when subscription filter type is tag and is not SUB_ALL.
			     */
			    private boolean estimateAccumulation = true;
			
			    private boolean coldCtrStrategyEnable = false;
			    private boolean usePIDColdCtrStrategy = true;
			    private long cgColdReadThreshold = 3 * 1024 * 1024;
			    private long globalColdReadThreshold = 100 * 1024 * 1024;
			    
			    /**
			     * The interval to fetch namesrv addr, default value is 10 second
			     */
			    private long fetchNamesrvAddrInterval = 10 * 1000;
			
			    /**
			     * Pop response returns the actual retry topic rather than tampering with the original topic
			     */
			    private boolean popResponseReturnActualRetryTopic = false;
			
			    /**			
",
,
			fromLine:"			398",
			toLine:"			404",
			content:"
			     * it guarantees the ultimate consistency of data between the broker and the nameserver during topic deletion.
			     */
			    private boolean enableSingleTopicRegister = false;
			
			    private boolean enableMixedMessageType = false;
			
			    /**			
",
,
			fromLine:"			406",
			toLine:"			415",
			content:"
			     * otherwise there will be a loss of routing
			     */
			    private boolean enableSplitRegistration = false;
			
			    private long popInflightMessageThreshold = 10000;
			    private boolean enablePopMessageThreshold = false;
			
			    private int splitRegistrationSize = 800;
			
			    /**			
",
,
			fromLine:"			418",
			toLine:"			422",
			content:"
			     * Try to update configures in black list by restart process.
			     */
			    private String configBlackList = "configBlackList;brokerConfigPath";
			
			    public String getConfigBlackList() {			
",
,

		],
		proxy/src/main/java/org/apache/rocketmq/proxy/config/ProxyConfig.java:
		[
			fromLine:"			17",
			toLine:"			49",
			content:"
			
			package org.apache.rocketmq.proxy.config;
			
			import java.net.InetAddress;
			import java.net.UnknownHostException;
			import java.time.Duration;
			import java.util.Comparator;
			import java.util.HashMap;
			import java.util.List;
			import java.util.Map;
			import java.util.concurrent.ConcurrentSkipListMap;
			import java.util.concurrent.TimeUnit;
			import java.util.stream.Collectors;
			import org.apache.commons.lang3.StringUtils;
			import org.apache.rocketmq.common.MixAll;
			import org.apache.rocketmq.common.constant.LoggerName;
			import org.apache.rocketmq.common.metrics.MetricsExporterType;
			import org.apache.rocketmq.common.utils.NetworkUtil;
			import org.apache.rocketmq.logging.org.slf4j.Logger;
			import org.apache.rocketmq.logging.org.slf4j.LoggerFactory;
			import org.apache.rocketmq.proxy.ProxyMode;
			import org.apache.rocketmq.proxy.common.ProxyException;
			import org.apache.rocketmq.proxy.common.ProxyExceptionCode;
			
			public class ProxyConfig implements ConfigFile {
			    private final static Logger log = LoggerFactory.getLogger(LoggerName.PROXY_LOGGER_NAME);
			    public final static String DEFAULT_CONFIG_FILE_NAME = "rmq-proxy.json";
			    private static final int PROCESSOR_NUMBER = Runtime.getRuntime().availableProcessors();
			    private static final String DEFAULT_CLUSTER_NAME = "DefaultCluster";
			
			    private static String localHostName;
			
			    static {			
",
,
			fromLine:"			55",
			toLine:"			271",
			content:"
			    }
			
			    private String rocketMQClusterName = DEFAULT_CLUSTER_NAME;
			    private String proxyClusterName = DEFAULT_CLUSTER_NAME;
			    private String proxyName = StringUtils.isEmpty(localHostName) ? "DEFAULT_PROXY" : localHostName;
			
			    private String localServeAddr = "";
			
			    private String heartbeatSyncerTopicClusterName = "";
			    private int heartbeatSyncerThreadPoolNums = 4;
			    private int heartbeatSyncerThreadPoolQueueCapacity = 100;
			
			    private String heartbeatSyncerTopicName = "DefaultHeartBeatSyncerTopic";
			
			    /**
			     * configuration for ThreadPoolMonitor
			     */
			    private boolean enablePrintJstack = true;
			    private long printJstackInMillis = Duration.ofSeconds(60).toMillis();
			    private long printThreadPoolStatusInMillis = Duration.ofSeconds(3).toMillis();
			
			    private String namesrvAddr = System.getProperty(MixAll.NAMESRV_ADDR_PROPERTY, System.getenv(MixAll.NAMESRV_ADDR_ENV));
			    private String namesrvDomain = "";
			    private String namesrvDomainSubgroup = "";
			    /**
			     * TLS
			     */
			    private boolean tlsTestModeEnable = true;
			    private String tlsKeyPath = ConfigurationManager.getProxyHome() + "/conf/tls/rocketmq.key";
			    private String tlsCertPath = ConfigurationManager.getProxyHome() + "/conf/tls/rocketmq.crt";
			    /**
			     * gRPC
			     */
			    private String proxyMode = ProxyMode.CLUSTER.name();
			    private Integer grpcServerPort = 8081;
			    private long grpcShutdownTimeSeconds = 30;
			    private int grpcBossLoopNum = 1;
			    private int grpcWorkerLoopNum = PROCESSOR_NUMBER * 2;
			    private boolean enableGrpcEpoll = false;
			    private int grpcThreadPoolNums = 16 + PROCESSOR_NUMBER * 2;
			    private int grpcThreadPoolQueueCapacity = 100000;
			    private String brokerConfigPath = ConfigurationManager.getProxyHome() + "/conf/broker.conf";
			    /**
			     * gRPC max message size
			     * 130M = 4M * 32 messages + 2M attributes
			     */
			    private int grpcMaxInboundMessageSize = 130 * 1024 * 1024;
			    /**
			     * max message body size, 0 or negative number means no limit for proxy
			     */
			    private int maxMessageSize = 4 * 1024 * 1024;
			    /**
			     * max user property size, 0 or negative number means no limit for proxy
			     */
			    private int maxUserPropertySize = 16 * 1024;
			    private int userPropertyMaxNum = 128;
			
			    /**
			     * max message group size, 0 or negative number means no limit for proxy
			     */
			    private int maxMessageGroupSize = 64;
			
			    /**
			     * When a message pops, the message is invisible by default
			     */
			    private long defaultInvisibleTimeMills = Duration.ofSeconds(60).toMillis();
			    private long minInvisibleTimeMillsForRecv = Duration.ofSeconds(10).toMillis();
			    private long maxInvisibleTimeMills = Duration.ofHours(12).toMillis();
			    private long maxDelayTimeMills = Duration.ofDays(1).toMillis();
			    private long maxTransactionRecoverySecond = Duration.ofHours(1).getSeconds();
			    private boolean enableTopicMessageTypeCheck = true;
			
			    private int grpcClientProducerMaxAttempts = 3;
			    private long grpcClientProducerBackoffInitialMillis = 10;
			    private long grpcClientProducerBackoffMaxMillis = 1000;
			    private int grpcClientProducerBackoffMultiplier = 2;
			    private long grpcClientConsumerMinLongPollingTimeoutMillis = Duration.ofSeconds(5).toMillis();
			    private long grpcClientConsumerMaxLongPollingTimeoutMillis = Duration.ofSeconds(20).toMillis();
			    private int grpcClientConsumerLongPollingBatchSize = 32;
			    private long grpcClientIdleTimeMills = Duration.ofSeconds(120).toMillis();
			
			    private int channelExpiredInSeconds = 60;
			    private int contextExpiredInSeconds = 30;
			
			    private int rocketmqMQClientNum = 6;
			
			    private long grpcProxyRelayRequestTimeoutInSeconds = 5;
			    private int grpcProducerThreadPoolNums = PROCESSOR_NUMBER;
			    private int grpcProducerThreadQueueCapacity = 10000;
			    private int grpcConsumerThreadPoolNums = PROCESSOR_NUMBER;
			    private int grpcConsumerThreadQueueCapacity = 10000;
			    private int grpcRouteThreadPoolNums = PROCESSOR_NUMBER;
			    private int grpcRouteThreadQueueCapacity = 10000;
			    private int grpcClientManagerThreadPoolNums = PROCESSOR_NUMBER;
			    private int grpcClientManagerThreadQueueCapacity = 10000;
			    private int grpcTransactionThreadPoolNums = PROCESSOR_NUMBER;
			    private int grpcTransactionThreadQueueCapacity = 10000;
			
			    private int producerProcessorThreadPoolNums = PROCESSOR_NUMBER;
			    private int producerProcessorThreadPoolQueueCapacity = 10000;
			    private int consumerProcessorThreadPoolNums = PROCESSOR_NUMBER;
			    private int consumerProcessorThreadPoolQueueCapacity = 10000;
			
			    private boolean useEndpointPortFromRequest = false;
			
			    private int topicRouteServiceCacheExpiredSeconds = 300;
			    private int topicRouteServiceCacheRefreshSeconds = 20;
			    private int topicRouteServiceCacheMaxNum = 20000;
			    private int topicRouteServiceThreadPoolNums = PROCESSOR_NUMBER;
			    private int topicRouteServiceThreadPoolQueueCapacity = 5000;
			    private int topicConfigCacheExpiredSeconds = 300;
			    private int topicConfigCacheRefreshSeconds = 20;
			    private int topicConfigCacheMaxNum = 20000;
			    private int subscriptionGroupConfigCacheExpiredSeconds = 300;
			    private int subscriptionGroupConfigCacheRefreshSeconds = 20;
			    private int subscriptionGroupConfigCacheMaxNum = 20000;
			    private int userCacheExpiredSeconds = 300;
			    private int userCacheRefreshSeconds = 20;
			    private int userCacheMaxNum = 20000;
			    private int aclCacheExpiredSeconds = 300;
			    private int aclCacheRefreshSeconds = 20;
			    private int aclCacheMaxNum = 20000;
			    private int metadataThreadPoolNums = 3;
			    private int metadataThreadPoolQueueCapacity = 100000;
			
			    private int transactionHeartbeatThreadPoolNums = 20;
			    private int transactionHeartbeatThreadPoolQueueCapacity = 200;
			    private int transactionHeartbeatPeriodSecond = 20;
			    private int transactionHeartbeatBatchNum = 100;
			    private long transactionDataExpireScanPeriodMillis = Duration.ofSeconds(10).toMillis();
			    private long transactionDataMaxWaitClearMillis = Duration.ofSeconds(30).toMillis();
			    private long transactionDataExpireMillis = Duration.ofSeconds(30).toMillis();
			    private int transactionDataMaxNum = 15;
			
			    private long longPollingReserveTimeInMillis = 100;
			
			    private long invisibleTimeMillisWhenClear = 1000L;
			    private boolean enableProxyAutoRenew = true;
			    private int maxRenewRetryTimes = 3;
			    private int renewThreadPoolNums = 2;
			    private int renewMaxThreadPoolNums = 4;
			    private int renewThreadPoolQueueCapacity = 300;
			    private long lockTimeoutMsInHandleGroup = TimeUnit.SECONDS.toMillis(3);
			    private long renewAheadTimeMillis = TimeUnit.SECONDS.toMillis(10);
			    private long renewMaxTimeMillis = TimeUnit.HOURS.toMillis(3);
			    private long renewSchedulePeriodMillis = TimeUnit.SECONDS.toMillis(5);
			
			    private boolean enableACL = false;
			
			    private boolean enableAclRpcHookForClusterMode = false;
			
			    private boolean useDelayLevel = false;
			    private String messageDelayLevel = "1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h";
			    private transient ConcurrentSkipListMap<Integer /* level */, Long/* delay timeMillis */> delayLevelTable = new ConcurrentSkipListMap<>();
			
			    private String metricCollectorMode = MetricCollectorMode.OFF.getModeString();
			    // Example address: 127.0.0.1:1234
			    private String metricCollectorAddress = "";
			
			    private String regionId = "";
			
			    private boolean traceOn = false;
			
			    private MetricsExporterType metricsExporterType = MetricsExporterType.DISABLE;
			
			    private String metricsGrpcExporterTarget = "";
			    private String metricsGrpcExporterHeader = "";
			    private long metricGrpcExporterTimeOutInMills = 3 * 1000;
			    private long metricGrpcExporterIntervalInMills = 60 * 1000;
			    private long metricLoggingExporterIntervalInMills = 10 * 1000;
			
			    private int metricsPromExporterPort = 5557;
			    private String metricsPromExporterHost = "";
			
			    // Label pairs in CSV. Each label follows pattern of Key:Value. eg: instance_id:xxx,uid:xxx
			    private String metricsLabel = "";
			
			    private boolean metricsInDelta = false;
			
			    private long channelExpiredTimeout = 1000 * 120;
			
			    // remoting
			    private boolean enableRemotingLocalProxyGrpc = true;
			    private int localProxyConnectTimeoutMs = 3000;
			    private String remotingAccessAddr = "";
			    private int remotingListenPort = 8080;
			
			    // related to proxy's send strategy in cluster mode.
			    private boolean sendLatencyEnable = false;
			    private boolean startDetectorEnable = false;
			    private int detectTimeout = 200;
			    private int detectInterval = 2 * 1000;
			
			    private int remotingHeartbeatThreadPoolNums = 2 * PROCESSOR_NUMBER;
			    private int remotingTopicRouteThreadPoolNums = 2 * PROCESSOR_NUMBER;
			    private int remotingSendMessageThreadPoolNums = 4 * PROCESSOR_NUMBER;
			    private int remotingPullMessageThreadPoolNums = 4 * PROCESSOR_NUMBER;
			    private int remotingUpdateOffsetThreadPoolNums = 4 * PROCESSOR_NUMBER;
			    private int remotingDefaultThreadPoolNums = 4 * PROCESSOR_NUMBER;
			
			    private int remotingHeartbeatThreadPoolQueueCapacity = 50000;
			    private int remotingTopicRouteThreadPoolQueueCapacity = 50000;
			    private int remotingSendThreadPoolQueueCapacity = 10000;
			    private int remotingPullThreadPoolQueueCapacity = 50000;
			    private int remotingUpdateOffsetThreadPoolQueueCapacity = 10000;
			    private int remotingDefaultThreadPoolQueueCapacity = 50000;
			
			    private long remotingWaitTimeMillsInSendQueue = 3 * 1000;
			    private long remotingWaitTimeMillsInPullQueue = 5 * 1000;
			    private long remotingWaitTimeMillsInHeartbeatQueue = 31 * 1000;
			    private long remotingWaitTimeMillsInUpdateOffsetQueue = 3 * 1000;
			    private long remotingWaitTimeMillsInTopicRouteQueue = 3 * 1000;
			    private long remotingWaitTimeMillsInDefaultQueue = 3 * 1000;
			
			    private boolean enableBatchAck = false;
			
			    @Override			
",
,

		],
		broker/src/main/java/org/apache/rocketmq/broker/metrics/ConsumerLagCalculator.java:
		[
			fromLine:"			16",
			toLine:"			65",
			content:"
			 */
			package org.apache.rocketmq.broker.metrics;
			
			import java.util.Map;
			import java.util.Set;
			import java.util.function.Consumer;
			import java.util.stream.Collectors;
			import org.apache.rocketmq.broker.BrokerController;
			import org.apache.rocketmq.broker.client.ConsumerGroupInfo;
			import org.apache.rocketmq.broker.client.ConsumerManager;
			import org.apache.rocketmq.broker.filter.ConsumerFilterData;
			import org.apache.rocketmq.broker.filter.ConsumerFilterManager;
			import org.apache.rocketmq.broker.filter.ExpressionMessageFilter;
			import org.apache.rocketmq.broker.offset.ConsumerOffsetManager;
			import org.apache.rocketmq.broker.processor.PopBufferMergeService;
			import org.apache.rocketmq.broker.processor.PopInflightMessageCounter;
			import org.apache.rocketmq.broker.subscription.SubscriptionGroupManager;
			import org.apache.rocketmq.broker.topic.TopicConfigManager;
			import org.apache.rocketmq.common.BrokerConfig;
			import org.apache.rocketmq.common.KeyBuilder;
			import org.apache.rocketmq.common.MixAll;
			import org.apache.rocketmq.common.Pair;
			import org.apache.rocketmq.common.TopicConfig;
			import org.apache.rocketmq.common.constant.LoggerName;
			import org.apache.rocketmq.common.constant.PermName;
			import org.apache.rocketmq.common.filter.ExpressionType;
			import org.apache.rocketmq.logging.org.slf4j.Logger;
			import org.apache.rocketmq.logging.org.slf4j.LoggerFactory;
			import org.apache.rocketmq.remoting.protocol.filter.FilterAPI;
			import org.apache.rocketmq.remoting.protocol.heartbeat.ConsumeType;
			import org.apache.rocketmq.remoting.protocol.heartbeat.SubscriptionData;
			import org.apache.rocketmq.remoting.protocol.subscription.SimpleSubscriptionData;
			import org.apache.rocketmq.remoting.protocol.subscription.SubscriptionGroupConfig;
			import org.apache.rocketmq.store.DefaultMessageFilter;
			import org.apache.rocketmq.store.MessageStore;
			
			public class ConsumerLagCalculator {
			    private final BrokerConfig brokerConfig;
			    private final TopicConfigManager topicConfigManager;
			    private final ConsumerManager consumerManager;
			    private final ConsumerOffsetManager offsetManager;
			    private final ConsumerFilterManager consumerFilterManager;
			    private final SubscriptionGroupManager subscriptionGroupManager;
			    private final MessageStore messageStore;
			    private final PopBufferMergeService popBufferMergeService;
			    private final PopInflightMessageCounter popInflightMessageCounter;
			
			    private static final Logger LOGGER = LoggerFactory.getLogger(LoggerName.BROKER_LOGGER_NAME);
			
			    public ConsumerLagCalculator(BrokerController brokerController) {			
",
,
			fromLine:"			273",
			toLine:"			277",
			content:"
			    }
			
			    public Pair<Long, Long> getConsumerLagStats(String group, String topic, boolean isPop) {
			        long total = 0L;
			        long earliestUnconsumedTimestamp = Long.MAX_VALUE;			
",
,
			fromLine:"			299",
			toLine:"			303",
			content:"
			    }
			
			    public Pair<Long, Long> getConsumerLagStats(String group, String topic, int queueId, boolean isPop) {
			        long brokerOffset = messageStore.getMaxOffsetInQueue(topic, queueId);
			        if (brokerOffset < 0) {			
",
,
			fromLine:"			330",
			toLine:"			334",
			content:"
			    }
			
			    public Pair<Long, Long> getInFlightMsgStats(String group, String topic, boolean isPop) {
			        long total = 0L;
			        long earliestUnPulledTimestamp = Long.MAX_VALUE;			
",
,
			fromLine:"			356",
			toLine:"			360",
			content:"
			    }
			
			    public Pair<Long, Long> getInFlightMsgStats(String group, String topic, int queueId, boolean isPop) {
			        if (isPop) {
			            long inflight = popInflightMessageCounter.getGroupPopInFlightMessageNum(topic, group, queueId);			
",
,
			fromLine:"			385",
			toLine:"			389",
			content:"
			    }
			
			    public long getAvailableMsgCount(String group, String topic, boolean isPop) {
			        long total = 0L;
						
",
,
			fromLine:"			404",
			toLine:"			408",
			content:"
			    }
			
			    public long getAvailableMsgCount(String group, String topic, int queueId, boolean isPop) {
			        long brokerOffset = messageStore.getMaxOffsetInQueue(topic, queueId);
			        if (brokerOffset < 0) {			
",
,
			fromLine:"			429",
			toLine:"			433",
			content:"
			    }
			
			    public long getStoreTimeStamp(String topic, int queueId, long offset) {
			        long storeTimeStamp = Long.MAX_VALUE;
			        if (offset >= 0) {			
",
,
			fromLine:"			438",
			toLine:"			442",
			content:"
			    }
			
			    public long calculateMessageCount(String group, String topic, int queueId, long from, long to) {
			        long count = to - from;
						
",
,

		],
		broker/src/main/java/org/apache/rocketmq/broker/out/BrokerOuterAPI.java:
		[
			fromLine:"			16",
			toLine:"			161",
			content:"
			 */
			package org.apache.rocketmq.broker.out;
			
			import com.alibaba.fastjson2.JSON;
			import java.io.UnsupportedEncodingException;
			import java.net.InetAddress;
			import java.nio.ByteBuffer;
			import java.util.ArrayList;
			import java.util.Arrays;
			import java.util.List;
			import java.util.Set;
			import java.util.concurrent.ArrayBlockingQueue;
			import java.util.concurrent.CompletableFuture;
			import java.util.concurrent.CopyOnWriteArrayList;
			import java.util.concurrent.CountDownLatch;
			import java.util.concurrent.ExecutorService;
			import java.util.concurrent.TimeUnit;
			import org.apache.commons.lang3.StringUtils;
			import org.apache.rocketmq.acl.common.AclClientRPCHook;
			import org.apache.rocketmq.acl.common.SessionCredentials;
			import org.apache.rocketmq.auth.config.AuthConfig;
			import org.apache.rocketmq.client.consumer.PullResult;
			import org.apache.rocketmq.client.consumer.PullStatus;
			import org.apache.rocketmq.client.exception.MQBrokerException;
			import org.apache.rocketmq.client.impl.consumer.PullResultExt;
			import org.apache.rocketmq.client.producer.SendResult;
			import org.apache.rocketmq.client.producer.SendStatus;
			import org.apache.rocketmq.common.AbstractBrokerRunnable;
			import org.apache.rocketmq.common.BrokerIdentity;
			import org.apache.rocketmq.common.LockCallback;
			import org.apache.rocketmq.common.MixAll;
			import org.apache.rocketmq.common.Pair;
			import org.apache.rocketmq.common.ThreadFactoryImpl;
			import org.apache.rocketmq.common.TopicConfig;
			import org.apache.rocketmq.common.UnlockCallback;
			import org.apache.rocketmq.common.UtilAll;
			import org.apache.rocketmq.common.constant.LoggerName;
			import org.apache.rocketmq.common.filter.ExpressionType;
			import org.apache.rocketmq.common.message.Message;
			import org.apache.rocketmq.common.message.MessageAccessor;
			import org.apache.rocketmq.common.message.MessageBatch;
			import org.apache.rocketmq.common.message.MessageClientIDSetter;
			import org.apache.rocketmq.common.message.MessageConst;
			import org.apache.rocketmq.common.message.MessageDecoder;
			import org.apache.rocketmq.common.message.MessageExt;
			import org.apache.rocketmq.common.message.MessageQueue;
			import org.apache.rocketmq.common.namesrv.DefaultTopAddressing;
			import org.apache.rocketmq.common.namesrv.TopAddressing;
			import org.apache.rocketmq.common.sysflag.PullSysFlag;
			import org.apache.rocketmq.common.topic.TopicValidator;
			import org.apache.rocketmq.common.utils.ThreadUtils;
			import org.apache.rocketmq.logging.org.slf4j.Logger;
			import org.apache.rocketmq.logging.org.slf4j.LoggerFactory;
			import org.apache.rocketmq.remoting.InvokeCallback;
			import org.apache.rocketmq.remoting.RPCHook;
			import org.apache.rocketmq.remoting.RemotingClient;
			import org.apache.rocketmq.remoting.exception.RemotingCommandException;
			import org.apache.rocketmq.remoting.exception.RemotingConnectException;
			import org.apache.rocketmq.remoting.exception.RemotingException;
			import org.apache.rocketmq.remoting.exception.RemotingSendRequestException;
			import org.apache.rocketmq.remoting.exception.RemotingTimeoutException;
			import org.apache.rocketmq.remoting.exception.RemotingTooMuchRequestException;
			import org.apache.rocketmq.remoting.netty.NettyClientConfig;
			import org.apache.rocketmq.remoting.netty.NettyRemotingClient;
			import org.apache.rocketmq.remoting.netty.ResponseFuture;
			import org.apache.rocketmq.remoting.protocol.BrokerSyncInfo;
			import org.apache.rocketmq.remoting.protocol.DataVersion;
			import org.apache.rocketmq.remoting.protocol.RemotingCommand;
			import org.apache.rocketmq.remoting.protocol.RemotingSerializable;
			import org.apache.rocketmq.remoting.protocol.RequestCode;
			import org.apache.rocketmq.remoting.protocol.ResponseCode;
			import org.apache.rocketmq.remoting.protocol.body.BrokerMemberGroup;
			import org.apache.rocketmq.remoting.protocol.body.ClusterInfo;
			import org.apache.rocketmq.remoting.protocol.body.ConsumerOffsetSerializeWrapper;
			import org.apache.rocketmq.remoting.protocol.body.ElectMasterResponseBody;
			import org.apache.rocketmq.remoting.protocol.body.GetBrokerMemberGroupResponseBody;
			import org.apache.rocketmq.remoting.protocol.body.KVTable;
			import org.apache.rocketmq.remoting.protocol.body.LockBatchRequestBody;
			import org.apache.rocketmq.remoting.protocol.body.LockBatchResponseBody;
			import org.apache.rocketmq.remoting.protocol.body.MessageRequestModeSerializeWrapper;
			import org.apache.rocketmq.remoting.protocol.body.RegisterBrokerBody;
			import org.apache.rocketmq.remoting.protocol.body.SubscriptionGroupWrapper;
			import org.apache.rocketmq.remoting.protocol.body.SyncStateSet;
			import org.apache.rocketmq.remoting.protocol.body.TopicConfigAndMappingSerializeWrapper;
			import org.apache.rocketmq.remoting.protocol.body.TopicConfigSerializeWrapper;
			import org.apache.rocketmq.remoting.protocol.body.UnlockBatchRequestBody;
			import org.apache.rocketmq.remoting.protocol.header.ExchangeHAInfoRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.ExchangeHAInfoResponseHeader;
			import org.apache.rocketmq.remoting.protocol.header.GetBrokerMemberGroupRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.GetMaxOffsetRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.GetMaxOffsetResponseHeader;
			import org.apache.rocketmq.remoting.protocol.header.GetMinOffsetRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.GetMinOffsetResponseHeader;
			import org.apache.rocketmq.remoting.protocol.header.LockBatchMqRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.PullMessageRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.PullMessageResponseHeader;
			import org.apache.rocketmq.remoting.protocol.header.SendMessageRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.SendMessageRequestHeaderV2;
			import org.apache.rocketmq.remoting.protocol.header.SendMessageResponseHeader;
			import org.apache.rocketmq.remoting.protocol.header.UnlockBatchMqRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.controller.AlterSyncStateSetRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.controller.ElectMasterRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.controller.ElectMasterResponseHeader;
			import org.apache.rocketmq.remoting.protocol.header.controller.GetMetaDataResponseHeader;
			import org.apache.rocketmq.remoting.protocol.header.controller.GetReplicaInfoRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.controller.GetReplicaInfoResponseHeader;
			import org.apache.rocketmq.remoting.protocol.header.controller.register.ApplyBrokerIdRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.controller.register.ApplyBrokerIdResponseHeader;
			import org.apache.rocketmq.remoting.protocol.header.controller.register.GetNextBrokerIdRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.controller.register.GetNextBrokerIdResponseHeader;
			import org.apache.rocketmq.remoting.protocol.header.controller.register.RegisterBrokerToControllerRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.controller.register.RegisterBrokerToControllerResponseHeader;
			import org.apache.rocketmq.remoting.protocol.header.namesrv.BrokerHeartbeatRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.namesrv.GetRouteInfoRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.namesrv.QueryDataVersionRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.namesrv.QueryDataVersionResponseHeader;
			import org.apache.rocketmq.remoting.protocol.header.namesrv.RegisterBrokerRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.namesrv.RegisterBrokerResponseHeader;
			import org.apache.rocketmq.remoting.protocol.header.namesrv.RegisterTopicRequestHeader;
			import org.apache.rocketmq.remoting.protocol.header.namesrv.UnRegisterBrokerRequestHeader;
			import org.apache.rocketmq.remoting.protocol.heartbeat.SubscriptionData;
			import org.apache.rocketmq.remoting.protocol.namesrv.RegisterBrokerResult;
			import org.apache.rocketmq.remoting.protocol.route.BrokerData;
			import org.apache.rocketmq.remoting.protocol.route.QueueData;
			import org.apache.rocketmq.remoting.protocol.route.TopicRouteData;
			import org.apache.rocketmq.remoting.rpc.ClientMetadata;
			import org.apache.rocketmq.remoting.rpc.RpcClient;
			import org.apache.rocketmq.remoting.rpc.RpcClientImpl;
			import org.apache.rocketmq.remoting.rpchook.DynamicalExtFieldRPCHook;
			import org.apache.rocketmq.store.timer.TimerCheckpoint;
			import org.apache.rocketmq.store.timer.TimerMetrics;
			
			import static org.apache.rocketmq.remoting.protocol.RemotingSysResponseCode.SUCCESS;
			import static org.apache.rocketmq.remoting.protocol.ResponseCode.CONTROLLER_MASTER_STILL_EXIST;
			
			public class BrokerOuterAPI {
			    private static final Logger LOGGER = LoggerFactory.getLogger(LoggerName.BROKER_LOGGER_NAME);
			    private final RemotingClient remotingClient;
			    private final TopAddressing topAddressing = new DefaultTopAddressing(MixAll.getWSAddr());
			    private final ExecutorService brokerOuterExecutor = ThreadUtils.newThreadPoolExecutor(4, 10, 1, TimeUnit.MINUTES,
			            new ArrayBlockingQueue<>(32), new ThreadFactoryImpl("brokerOutApi_thread_", true));
			    private final ClientMetadata clientMetadata;
			    private final RpcClient rpcClient;
			    private String nameSrvAddr = null;
			
			    public BrokerOuterAPI(final NettyClientConfig nettyClientConfig, AuthConfig authConfig) {			
",
,
			fromLine:"			251",
			toLine:"			256",
			content:"
			    }
			
			    public BrokerMemberGroup syncBrokerMemberGroup(String clusterName, String brokerName,
			        boolean isCompatibleWithOldNameSrv)
			        throws InterruptedException, RemotingTimeoutException, RemotingSendRequestException, RemotingConnectException {
			        if (isCompatibleWithOldNameSrv) {			
",
,
			fromLine:"			329",
			toLine:"			339",
			content:"
			
			    public void sendHeartbeatViaDataVersion(
			        final String clusterName,
			        final String brokerAddr,
			        final String brokerName,
			        final Long brokerId,
			        final int timeoutMillis,
			        final DataVersion dataVersion,
			        final boolean isInBrokerContainer) {
			        List<String> nameServerAddressList = this.remotingClient.getAvailableNameSrvList();
			        if (nameServerAddressList != null && nameServerAddressList.size() > 0) {			
",
,
			fromLine:"			363",
			toLine:"			372",
			content:"
			    }
			
			    public void sendHeartbeat(final String clusterName,
			        final String brokerAddr,
			        final String brokerName,
			        final Long brokerId,
			        final int timeoutMills,
			        final boolean isInBrokerContainer) {
			        List<String> nameServerAddressList = this.remotingClient.getAvailableNameSrvList();
						
",
,
			fromLine:"			416",
			toLine:"			420",
			content:"
			    }
			
			    public void sendBrokerHaInfo(String brokerAddr, String masterHaAddr, long brokerInitMaxOffset, String masterAddr)
			        throws InterruptedException, RemotingTimeoutException, RemotingSendRequestException, RemotingConnectException, MQBrokerException {
			        ExchangeHAInfoRequestHeader requestHeader = new ExchangeHAInfoRequestHeader();			
",
,
			fromLine:"			440",
			toLine:"			455",
			content:"
			
			    public List<RegisterBrokerResult> registerBrokerAll(
			        final String clusterName,
			        final String brokerAddr,
			        final String brokerName,
			        final long brokerId,
			        final String haServerAddr,
			        final TopicConfigSerializeWrapper topicConfigWrapper,
			        final List<String> filterServerList,
			        final boolean oneway,
			        final int timeoutMills,
			        final boolean enableActingMaster,
			        final boolean compressed,
			        final BrokerIdentity brokerIdentity) {
			        return registerBrokerAll(clusterName,
			            brokerAddr,			
",
,
			fromLine:"			483",
			toLine:"			499",
			content:"
			     */
			    public List<RegisterBrokerResult> registerBrokerAll(
			        final String clusterName,
			        final String brokerAddr,
			        final String brokerName,
			        final long brokerId,
			        final String haServerAddr,
			        final TopicConfigSerializeWrapper topicConfigWrapper,
			        final List<String> filterServerList,
			        final boolean oneway,
			        final int timeoutMills,
			        final boolean enableActingMaster,
			        final boolean compressed,
			        final Long heartbeatTimeoutMillis,
			        final BrokerIdentity brokerIdentity) {
			
			        final List<RegisterBrokerResult> registerBrokerResultList = new CopyOnWriteArrayList<>();			
",
,
			fromLine:"			552",
			toLine:"			560",
			content:"
			
			    private RegisterBrokerResult registerBroker(
			        final String namesrvAddr,
			        final boolean oneway,
			        final int timeoutMills,
			        final RegisterBrokerRequestHeader requestHeader,
			        final byte[] body
			    ) throws RemotingCommandException, MQBrokerException, RemotingConnectException, RemotingSendRequestException, RemotingTimeoutException,
			        InterruptedException {			
",
,
			fromLine:"			593",
			toLine:"			600",
			content:"
			
			    public void unregisterBrokerAll(
			        final String clusterName,
			        final String brokerAddr,
			        final String brokerName,
			        final long brokerId
			    ) {
			        List<String> nameServerAddressList = this.remotingClient.getNameServerAddressList();			
",
,
			fromLine:"			612",
			toLine:"			620",
			content:"
			
			    public void unregisterBroker(
			        final String namesrvAddr,
			        final String clusterName,
			        final String brokerAddr,
			        final String brokerName,
			        final long brokerId
			    ) throws RemotingConnectException, RemotingSendRequestException, RemotingTimeoutException, InterruptedException, MQBrokerException {
			        UnRegisterBrokerRequestHeader requestHeader = new UnRegisterBrokerRequestHeader();			
",
,
			fromLine:"			643",
			toLine:"			649",
			content:"
			     */
			    public void registerSingleTopicAll(
			        final String brokerName,
			        final TopicConfig topicConfig,
			        final int timeoutMills) {
			        String topic = topicConfig.getTopicName();
			        RegisterTopicRequestHeader requestHeader = new RegisterTopicRequestHeader();			
",
,
			fromLine:"			697",
			toLine:"			707",
			content:"
			
			    public List<Boolean> needRegister(
			        final String clusterName,
			        final String brokerAddr,
			        final String brokerName,
			        final long brokerId,
			        final TopicConfigSerializeWrapper topicConfigWrapper,
			        final int timeoutMills,
			        final boolean isInBrokerContainer) {
			        final List<Boolean> changedList = new CopyOnWriteArrayList<>();
			        List<String> nameServerAddressList = this.remotingClient.getNameServerAddressList();			
",
,
			fromLine:"			875",
			toLine:"			880",
			content:"
			    }
			
			    public long getMaxOffset(final String addr, final String topic, final int queueId, final boolean committed,
			        final boolean isOnlyThisBroker)
			        throws RemotingException, MQBrokerException, InterruptedException {
			        GetMaxOffsetRequestHeader requestHeader = new GetMaxOffsetRequestHeader();			
",
,
			fromLine:"			899",
			toLine:"			903",
			content:"
			    }
			
			    public long getMinOffset(final String addr, final String topic, final int queueId, final boolean isOnlyThisBroker)
			        throws RemotingException, MQBrokerException, InterruptedException {
			        GetMinOffsetRequestHeader requestHeader = new GetMinOffsetRequestHeader();			
",
,
			fromLine:"			922",
			toLine:"			929",
			content:"
			
			    public void lockBatchMQAsync(
			        final String addr,
			        final LockBatchRequestBody requestBody,
			        final long timeoutMillis,
			        final LockCallback callback) throws RemotingException, InterruptedException {
			        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.LOCK_BATCH_MQ, new LockBatchMqRequestHeader());
						
",
,
			fromLine:"			961",
			toLine:"			968",
			content:"
			
			    public void unlockBatchMQAsync(
			        final String addr,
			        final UnlockBatchRequestBody requestBody,
			        final long timeoutMillis,
			        final UnlockCallback callback) throws RemotingException, InterruptedException {
			        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.UNLOCK_BATCH_MQ, new UnlockBatchMqRequestHeader());
						
",
,
			fromLine:"			1001",
			toLine:"			1007",
			content:"
			    }
			
			    public SendResult sendMessageToSpecificBroker(String brokerAddr, final String brokerName,
			        final MessageExt msg, String group,
			        long timeoutMillis) throws RemotingException, MQBrokerException, InterruptedException {
			
			        RemotingCommand request = buildSendMessageRequest(msg, group);			
",
,
			fromLine:"			1010",
			toLine:"			1016",
			content:"
			    }
			
			    public CompletableFuture<SendResult> sendMessageToSpecificBrokerAsync(String brokerAddr, final String brokerName,
			        final MessageExt msg, String group,
			        long timeoutMillis) {
			        RemotingCommand request = buildSendMessageRequest(msg, group);
						
",
,
			fromLine:"			1074",
			toLine:"			1080",
			content:"
			
			    private SendResult processSendResponse(
			        final String brokerName,
			        final Message msg,
			        final RemotingCommand response
			    ) throws MQBrokerException, RemotingCommandException {
			        SendStatus sendStatus = null;			
",
,
			fromLine:"			1143",
			toLine:"			1148",
			content:"
			    }
			
			    public TopicRouteData getTopicRouteInfoFromNameServer(final String topic, final long timeoutMillis,
			        boolean allowTopicNotExist) throws MQBrokerException, InterruptedException, RemotingTimeoutException, RemotingSendRequestException, RemotingConnectException {
			        GetRouteInfoRequestHeader requestHeader = new GetRouteInfoRequestHeader();
			        requestHeader.setTopic(topic);			
",
,
			fromLine:"			1188",
			toLine:"			1193",
			content:"
			    }
			
			    public void forwardRequest(String brokerAddr, RemotingCommand request, long timeoutMillis,
			        InvokeCallback invokeCallback) throws InterruptedException, RemotingSendRequestException, RemotingTimeoutException, RemotingTooMuchRequestException, RemotingConnectException {
			        this.remotingClient.invokeAsync(brokerAddr, request, timeoutMillis, invokeCallback);
			    }			
",
,
			fromLine:"			1237",
			toLine:"			1244",
			content:"
			     */
			    public SyncStateSet alterSyncStateSet(
			        final String controllerAddress,
			        final String brokerName,
			        final Long masterBrokerId, final int masterEpoch,
			        final Set<Long> newSyncStateSet, final int syncStateSetEpoch) throws Exception {
			
			        final AlterSyncStateSetRequestHeader requestHeader = new AlterSyncStateSetRequestHeader(brokerName, masterBrokerId, masterEpoch);			
",
,
			fromLine:"			1259",
			toLine:"			1265",
			content:"
			     * Broker try to elect itself as a master in broker set
			     */
			    public Pair<ElectMasterResponseHeader, Set<Long>> brokerElect(String controllerAddress, String clusterName,
			        String brokerName,
			        Long brokerId) throws Exception {
			
			        final ElectMasterRequestHeader requestHeader = ElectMasterRequestHeader.ofBrokerTrigger(clusterName, brokerName, brokerId);			
",
,
			fromLine:"			1279",
			toLine:"			1284",
			content:"
			    }
			
			    public GetNextBrokerIdResponseHeader getNextBrokerId(final String clusterName, final String brokerName,
			        final String controllerAddress) throws Exception {
			        final GetNextBrokerIdRequestHeader requestHeader = new GetNextBrokerIdRequestHeader(clusterName, brokerName);
			        final RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.CONTROLLER_GET_NEXT_BROKER_ID, requestHeader);			
",
,
			fromLine:"			1291",
			toLine:"			1296",
			content:"
			    }
			
			    public ApplyBrokerIdResponseHeader applyBrokerId(final String clusterName, final String brokerName,
			        final Long brokerId, final String registerCheckCode, final String controllerAddress) throws Exception {
			        final ApplyBrokerIdRequestHeader requestHeader = new ApplyBrokerIdRequestHeader(clusterName, brokerName, brokerId, registerCheckCode);
			        final RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.CONTROLLER_APPLY_BROKER_ID, requestHeader);			
",
,
			fromLine:"			1304",
			toLine:"			1309",
			content:"
			
			    public Pair<RegisterBrokerToControllerResponseHeader, Set<Long>> registerBrokerToController(
			        final String clusterName, final String brokerName, final Long brokerId, final String brokerAddress,
			        final String controllerAddress) throws Exception {
			        final RegisterBrokerToControllerRequestHeader requestHeader = new RegisterBrokerToControllerRequestHeader(clusterName, brokerName, brokerId, brokerAddress);
			        final RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.CONTROLLER_REGISTER_BROKER, requestHeader);			
",
,
			fromLine:"			1341",
			toLine:"			1356",
			content:"
			     * Send heartbeat to controller
			     */
			    public void sendHeartbeatToController(final String controllerAddress,
			        final String clusterName,
			        final String brokerAddr,
			        final String brokerName,
			        final Long brokerId,
			        final int sendHeartBeatTimeoutMills,
			        final boolean isInBrokerContainer,
			        final int epoch,
			        final long maxOffset,
			        final long confirmOffset,
			        final long controllerHeartBeatTimeoutMills,
			        final int electionPriority) {
			        if (StringUtils.isEmpty(controllerAddress)) {
			            return;			
",
,
			fromLine:"			1381",
			toLine:"			1387",
			content:"
			    }
			
			    public CompletableFuture<PullResult> pullMessageFromSpecificBrokerAsync(String brokerName, String brokerAddr,
			        String consumerGroup, String topic, int queueId, long offset,
			        int maxNums, long timeoutMillis) throws RemotingException, InterruptedException {
			        PullMessageRequestHeader requestHeader = new PullMessageRequestHeader();
			        requestHeader.setConsumerGroup(consumerGroup);			
",
,
			fromLine:"			1456",
			toLine:"			1460",
			content:"
			    }
			
			    private PullResult processPullResult(final PullResultExt pullResult, String brokerName, int queueId) {
			
			        if (PullStatus.FOUND == pullResult.getPullStatus()) {			
",
,

		],
		broker/src/main/java/org/apache/rocketmq/broker/failover/EscapeBridge.java:
		[
			fromLine:"			17",
			toLine:"			66",
			content:"
			
			package org.apache.rocketmq.broker.failover;
			
			import java.nio.ByteBuffer;
			import java.util.ArrayList;
			import java.util.List;
			import java.util.concurrent.BlockingQueue;
			import java.util.concurrent.CompletableFuture;
			import java.util.concurrent.ExecutorService;
			import java.util.concurrent.LinkedBlockingQueue;
			import java.util.concurrent.TimeUnit;
			import org.apache.commons.lang3.StringUtils;
			import org.apache.rocketmq.broker.BrokerController;
			import org.apache.rocketmq.broker.transaction.queue.TransactionalMessageUtil;
			import org.apache.rocketmq.client.consumer.PullStatus;
			import org.apache.rocketmq.client.exception.MQBrokerException;
			import org.apache.rocketmq.client.impl.producer.TopicPublishInfo;
			import org.apache.rocketmq.client.producer.SendResult;
			import org.apache.rocketmq.client.producer.SendStatus;
			import org.apache.rocketmq.common.MixAll;
			import org.apache.rocketmq.common.Pair;
			import org.apache.rocketmq.common.ThreadFactoryImpl;
			import org.apache.rocketmq.common.constant.LoggerName;
			import org.apache.rocketmq.common.message.MessageConst;
			import org.apache.rocketmq.common.message.MessageDecoder;
			import org.apache.rocketmq.common.message.MessageExt;
			import org.apache.rocketmq.common.message.MessageExtBrokerInner;
			import org.apache.rocketmq.common.message.MessageQueue;
			import org.apache.rocketmq.common.utils.ThreadUtils;
			import org.apache.rocketmq.logging.org.slf4j.Logger;
			import org.apache.rocketmq.logging.org.slf4j.LoggerFactory;
			import org.apache.rocketmq.remoting.exception.RemotingException;
			import org.apache.rocketmq.store.GetMessageResult;
			import org.apache.rocketmq.store.GetMessageStatus;
			import org.apache.rocketmq.store.MessageStore;
			import org.apache.rocketmq.store.PutMessageResult;
			import org.apache.rocketmq.store.PutMessageStatus;
			
			public class EscapeBridge {
			    protected static final Logger LOG = LoggerFactory.getLogger(LoggerName.BROKER_LOGGER_NAME);
			    private static final long SEND_TIMEOUT = 3000L;
			    private static final long DEFAULT_PULL_TIMEOUT_MILLIS = 1000 * 10L;
			    private final String innerProducerGroupName;
			    private final String innerConsumerGroupName;
			
			    private final BrokerController brokerController;
			
			    private ExecutorService defaultAsyncSenderExecutor;
			
			    public EscapeBridge(BrokerController brokerController) {			
",
,
			fromLine:"			264",
			toLine:"			272",
			content:"
			    }
			
			    public Pair<GetMessageStatus, MessageExt> getMessage(String topic, long offset, int queueId, String brokerName, boolean deCompressBody) {
			        return getMessageAsync(topic, offset, queueId, brokerName, deCompressBody).join();
			    }
			
			    public CompletableFuture<Pair<GetMessageStatus, MessageExt>> getMessageAsync(String topic, long offset, int queueId, String brokerName, boolean deCompressBody) {
			        MessageStore messageStore = brokerController.getMessageStoreByBrokerName(brokerName);
			        if (messageStore != null) {			
",
,
			fromLine:"			323",
			toLine:"			331",
			content:"
			    }
			
			    protected MessageExt getMessageFromRemote(String topic, long offset, int queueId, String brokerName) {
			        return getMessageFromRemoteAsync(topic, offset, queueId, brokerName).join();
			    }
			
			    protected CompletableFuture<MessageExt> getMessageFromRemoteAsync(String topic, long offset, int queueId, String brokerName) {
			        try {
			            String brokerAddr = this.brokerController.getTopicRouteInfoManager().findBrokerAddressInSubscribe(brokerName, MixAll.MASTER_ID, false);			
",
,

		],
		remoting/src/main/java/org/apache/rocketmq/remoting/protocol/filter/FilterAPI.java:
		[
			fromLine:"			16",
			toLine:"			24",
			content:"
			 */
			package org.apache.rocketmq.remoting.protocol.filter;
			
			import org.apache.commons.lang3.StringUtils;
			import org.apache.rocketmq.common.filter.ExpressionType;
			import org.apache.rocketmq.remoting.protocol.heartbeat.SubscriptionData;
			
			import java.util.Arrays;
						
",
,
			fromLine:"			47",
			toLine:"			51",
			content:"
			    }
			
			    public static SubscriptionData buildSubscriptionData(String topic, String subString, String expressionType) throws Exception {
			        final SubscriptionData subscriptionData = buildSubscriptionData(topic, subString);
			        if (StringUtils.isNotBlank(expressionType)) {			
",
,
			fromLine:"			55",
			toLine:"			60",
			content:"
			    }
			
			    public static SubscriptionData build(final String topic, final String subString,
			        final String type) throws Exception {
			        if (ExpressionType.TAG.equals(type) || type == null) {
			            return buildSubscriptionData(topic, subString);			
",
,

		],
		remoting/src/main/java/org/apache/rocketmq/remoting/protocol/heartbeat/SubscriptionData.java:
		[
			fromLine:"			20",
			toLine:"			41",
			content:"
			 */
			package org.apache.rocketmq.remoting.protocol.heartbeat;
			
			import com.alibaba.fastjson.annotation.JSONField;
			import java.util.HashSet;
			import java.util.Set;
			import org.apache.rocketmq.common.filter.ExpressionType;
			
			public class SubscriptionData implements Comparable<SubscriptionData> {
			    public final static String SUB_ALL = "*";
			    private boolean classFilterMode = false;
			    private String topic;
			    private String subString;
			    private Set<String> tagsSet = new HashSet<>();
			    private Set<Integer> codeSet = new HashSet<>();
			    private long subVersion = System.currentTimeMillis();
			    private String expressionType = ExpressionType.TAG;
			
			    @JSONField(serialize = false)
			    private String filterClassSource;
			
			    public SubscriptionData() {			
",
,

		],
	
}
	role:"
	user	
",
,

],
model:"
gpt-4-1106-preview
",
response_format:
{
	type:"
	json_object	
",

}
temperature:"0.1",
