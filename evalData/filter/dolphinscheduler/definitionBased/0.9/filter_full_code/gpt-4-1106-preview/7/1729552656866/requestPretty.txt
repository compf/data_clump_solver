messages:
[
	content:"
	
	I will provide you Java files that contain data clumps.
	Choose one data clump that you think is most important and should be refactored.
	
	A data clump exists if
	1) two methods (in the same or in different classes) have at least 3 common parameters
	    and one of those methods does not override the other,
	
	or  
	2) At least three fields in a class are common with the parameters of a method (in the same or in a different class),
	
	or
	3) Two different classes have at least three common fields
	
	
	Return the key of that data clump.
	Justify your response. 
	Use the following  output format in JSON:
	
	The "reason" attribute should be equal to as follows:
	        "size" -> if you choose the data clump because of its large number of parameters/fields
	        "occurrence" -> if you choose the data clump because it occurs very often and leads to much duplication
	        "affected_files" -> if you choose this data clump because many files are affected by this data clump
	        "domain" -> if you choose this data clump because the variables share a common domain so that extracting a class is a good idea
	        "other" -> if none of the options above fits
	
	### JSON
	{
	    "key":"<a portion of the source code, as submitted, that shows where the data clump is located",,
	    "reason":"<as explained above>,
	    "justification":"<Your justification which explains the 'reason' in more details>",
	    "suggestedName":"<A suitable name for an extracted class if the data clumps variables were to be extracted>"
	
	}
	
	### END JSON
		
",
	role:"
	user	
",
,
	content:"
	//dolphinscheduler-datasource-plugin/dolphinscheduler-datasource-api/src/main/java/org/apache/dolphinscheduler/plugin/datasource/api/constants/DataSourceConstants.java
	/*
	 * Licensed to the Apache Software Foundation (ASF) under one or more
	 * contributor license agreements.  See the NOTICE file distributed with
	 * this work for additional information regarding copyright ownership.
	 * The ASF licenses this file to You under the Apache License, Version 2.0
	 * (the "License"); you may not use this file except in compliance with
	 * the License.  You may obtain a copy of the License at
	 *
	 *    http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	package org.apache.dolphinscheduler.plugin.datasource.api.constants;
	
	import org.apache.dolphinscheduler.common.constants.DateConstants;
	
	import java.time.Duration;
	import java.util.Set;
	import java.util.regex.Pattern;
	
	import lombok.experimental.UtilityClass;
	
	import com.google.common.collect.Sets;
	
	@UtilityClass
	public class DataSourceConstants {
	
	    public static final String ORG_POSTGRESQL_DRIVER = "org.postgresql.Driver";
	    public static final String COM_MYSQL_CJ_JDBC_DRIVER = "com.mysql.cj.jdbc.Driver";
	    public static final String COM_MYSQL_JDBC_DRIVER = "com.mysql.jdbc.Driver";
	    public static final String ORG_APACHE_HIVE_JDBC_HIVE_DRIVER = "org.apache.hive.jdbc.HiveDriver";
	    public static final String COM_CLICKHOUSE_JDBC_DRIVER = "com.clickhouse.jdbc.ClickHouseDriver";
	    public static final String COM_DATABEND_JDBC_DRIVER = "com.databend.jdbc.DatabendDriver";
	    public static final String COM_ORACLE_JDBC_DRIVER = "oracle.jdbc.OracleDriver";
	    public static final String COM_SQLSERVER_JDBC_DRIVER = "com.microsoft.sqlserver.jdbc.SQLServerDriver";
	    public static final String COM_DB2_JDBC_DRIVER = "com.ibm.db2.jcc.DB2Driver";
	    public static final String COM_PRESTO_JDBC_DRIVER = "com.facebook.presto.jdbc.PrestoDriver";
	    public static final String COM_REDSHIFT_JDBC_DRIVER = "com.amazon.redshift.jdbc42.Driver";
	    public static final String COM_ATHENA_JDBC_DRIVER = "com.simba.athena.jdbc.Driver";
	    public static final String COM_TRINO_JDBC_DRIVER = "io.trino.jdbc.TrinoDriver";
	    public static final String COM_DAMENG_JDBC_DRIVER = "dm.jdbc.driver.DmDriver";
	    public static final String ORG_APACHE_KYUUBI_JDBC_DRIVER = "org.apache.kyuubi.jdbc.KyuubiHiveDriver";
	    public static final String COM_OCEANBASE_JDBC_DRIVER = "com.oceanbase.jdbc.Driver";
	    public static final String NET_SNOWFLAKE_JDBC_DRIVER = "net.snowflake.client.jdbc.SnowflakeDriver";
	    public static final String COM_VERTICA_JDBC_DRIVER = "com.vertica.jdbc.Driver";
	    public static final String COM_HANA_DB_JDBC_DRIVER = "com.sap.db.jdbc.Driver";
	
	    public static final String JDBC_MYSQL = "jdbc:mysql://";
	    public static final String JDBC_MYSQL_LOADBALANCE = "jdbc:mysql:loadbalance://";
	    public static final String JDBC_POSTGRESQL = "jdbc:postgresql://";
	    public static final String JDBC_HIVE_2 = "jdbc:hive2://";
	    public static final String JDBC_KYUUBI = "jdbc:kyuubi://";
	    public static final String JDBC_CLICKHOUSE = "jdbc:clickhouse://";
	    public static final String JDBC_DATABEND = "jdbc:databend://";
	    public static final String JDBC_ORACLE_SID = "jdbc:oracle:thin:@";
	    public static final String JDBC_ORACLE_SERVICE_NAME = "jdbc:oracle:thin:@//";
	    public static final String JDBC_SQLSERVER = "jdbc:sqlserver://";
	    public static final String JDBC_DB2 = "jdbc:db2://";
	    public static final String JDBC_PRESTO = "jdbc:presto://";
	    public static final String JDBC_REDSHIFT = "jdbc:redshift://";
	    public static final String JDBC_REDSHIFT_IAM = "jdbc:redshift:iam://";
	    public static final String JDBC_ATHENA = "jdbc:awsathena://";
	    public static final String JDBC_TRINO = "jdbc:trino://";
	    public static final String JDBC_DAMENG = "jdbc:dm://";
	    public static final String JDBC_OCEANBASE = "jdbc:oceanbase://";
	    public static final String JDBC_SNOWFLAKE = "jdbc:snowflake://";
	    public static final String JDBC_VERTICA = "jdbc:vertica://";
	    public static final String JDBC_HANA = "jdbc:sap://";
	
	    public static final String POSTGRESQL_VALIDATION_QUERY = "select version()";
	    public static final String MYSQL_VALIDATION_QUERY = "select 1";
	    public static final String HIVE_VALIDATION_QUERY = "select 1";
	    public static final String CLICKHOUSE_VALIDATION_QUERY = "select 1";
	    public static final String DATABEND_VALIDATION_QUERY = "select 1";
	    public static final String ORACLE_VALIDATION_QUERY = "select 1 from dual";
	    public static final String SQLSERVER_VALIDATION_QUERY = "select 1";
	    public static final String DB2_VALIDATION_QUERY = "select 1 from sysibm.sysdummy1";
	    public static final String PRESTO_VALIDATION_QUERY = "select 1";
	    public static final String REDHIFT_VALIDATION_QUERY = "select 1";
	    public static final String ATHENA_VALIDATION_QUERY = "select 1";
	    public static final String TRINO_VALIDATION_QUERY = "select 1";
	    public static final String DAMENG_VALIDATION_QUERY = "select 1";
	    public static final String SNOWFLAKE_VALIDATION_QUERY = "select 1";
	
	    public static final String KYUUBI_VALIDATION_QUERY = "select 1";
	    public static final String VERTICA_VALIDATION_QUERY = "select 1";
	
	    public static final String HANA_VALIDATION_QUERY = "select 1 from DUMMY";
	
	    public static final String SPRING_DATASOURCE_MIN_IDLE = "spring.datasource.minIdle";
	
	    public static final String SPRING_DATASOURCE_MAX_ACTIVE = "spring.datasource.maxActive";
	
	    public static final String SUPPORT_HIVE_ONE_SESSION = "support.hive.oneSession";
	    /**
	     * QUESTION ?
	     */
	    public static final String QUESTION = "?";
	
	    /**
	     * comma ,
	     */
	    public static final String COMMA = ",";
	
	    /**
	     * hyphen
	     */
	    public static final String HYPHEN = "-";
	
	    /**
	     * slash /
	     */
	    public static final String SLASH = "/";
	
	    /**
	     * COLON :
	     */
	    public static final String COLON = ":";
	
	    /**
	     * SPACE " "
	     */
	    public static final String SPACE = " ";
	
	    /**
	     * SINGLE_SLASH /
	     */
	    public static final String SINGLE_SLASH = "/";
	
	    /**
	     * DOUBLE_SLASH //
	     */
	    public static final String DOUBLE_SLASH = "//";
	
	    /**
	     * SINGLE_QUOTES "'"
	     */
	    public static final String SINGLE_QUOTES = "'";
	    /**
	     * DOUBLE_QUOTES "\""
	     */
	    public static final String DOUBLE_QUOTES = "\"";
	
	    /**
	     * SEMICOLON ;
	     */
	    public static final String SEMICOLON = ";";
	
	    /**
	     * EQUAL SIGN
	     */
	    public static final String EQUAL_SIGN = "=";
	    /**
	     * AT SIGN
	     */
	    public static final String AT_SIGN = "@";
	    /**
	     * UNDERLINE
	     */
	    public static final String UNDERLINE = "_";
	
	    /**
	     * sleep time
	     */
	    public static final int SLEEP_TIME_MILLIS = 1000;
	
	    /**
	     * exit code failure
	     */
	    public static final int EXIT_CODE_FAILURE = -1;
	
	    /**
	     * exit code success
	     */
	    public static final int EXIT_CODE_SUCCESS = 0;
	    /**
	     * running code
	     */
	    public static final int RUNNING_CODE = 1;
	
	    public static final String SH = "sh";
	
	    /**
	     * log flush interval?output when reach the interval
	     */
	    public static final int DEFAULT_LOG_FLUSH_INTERVAL = 1000;
	
	    /**
	     * pstree, get pud and sub pid
	     */
	    public static final String PSTREE = "pstree";
	
	    public static final String RWXR_XR_X = "rwxr-xr-x";
	
	    /**
	     * date format of yyyyMMddHHmmss
	     */
	    public static final String PARAMETER_FORMAT_TIME = "yyyyMMddHHmmss";
	
	    /**
	     * new
	     * schedule time
	     */
	    public static final String PARAMETER_SHECDULE_TIME = "schedule.time";
	
	    /**
	     * system date(yyyyMMddHHmmss)
	     */
	    public static final String PARAMETER_DATETIME = DateConstants.PARAMETER_DATETIME;
	
	    /**
	     * system date(yyyymmdd) today
	     */
	    public static final String PARAMETER_CURRENT_DATE = DateConstants.PARAMETER_CURRENT_DATE;
	
	    /**
	     * system date(yyyymmdd) yesterday
	     */
	    public static final String PARAMETER_BUSINESS_DATE = DateConstants.PARAMETER_BUSINESS_DATE;
	
	    /**
	     * the absolute path of current executing task
	     */
	    public static final String PARAMETER_TASK_EXECUTE_PATH = "system.task.execute.path";
	
	    /**
	     * the instance id of current task
	     */
	    public static final String PARAMETER_TASK_INSTANCE_ID = "system.task.instance.id";
	
	    /**
	     * the definition code of current task
	     */
	    public static final String PARAMETER_TASK_DEFINITION_CODE = "system.task.definition.code";
	
	    /**
	     * the definition name of current task
	     */
	    public static final String PARAMETER_TASK_DEFINITION_NAME = "system.task.definition.name";
	
	    /**
	     * the instance id of the workflow to which current task belongs
	     */
	    public static final String PARAMETER_WORKFLOW_INSTANCE_ID = "system.workflow.instance.id";
	
	    /**
	     * the definition code of the workflow to which current task belongs
	     */
	    public static final String PARAMETER_WORKFLOW_DEFINITION_CODE = "system.workflow.definition.code";
	
	    /**
	     * the definition name of the workflow to which current task belongs
	     */
	    public static final String PARAMETER_WORKFLOW_DEFINITION_NAME = "system.workflow.definition.name";
	
	    /**
	     * the code of the project to which current task belongs
	     */
	    public static final String PARAMETER_PROJECT_CODE = "system.project.code";
	
	    /**
	     * the name of the project to which current task belongs
	     */
	    public static final String PARAMETER_PROJECT_NAME = "system.project.name";
	    /**
	     * month_begin
	     */
	    public static final String MONTH_BEGIN = "month_begin";
	    /**
	     * add_months
	     */
	    public static final String ADD_MONTHS = "add_months";
	    /**
	     * month_end
	     */
	    public static final String MONTH_END = "month_end";
	    /**
	     * week_begin
	     */
	    public static final String WEEK_BEGIN = "week_begin";
	    /**
	     * week_end
	     */
	    public static final String WEEK_END = "week_end";
	    /**
	     * this_day
	     */
	    public static final String THIS_DAY = "this_day";
	    /**
	     * last_day
	     */
	    public static final String LAST_DAY = "last_day";
	
	    /**
	     * month_first_day
	     */
	    public static final String MONTH_FIRST_DAY = "month_first_day";
	
	    /**
	     * month_last_day
	     */
	    public static final String MONTH_LAST_DAY = "month_last_day";
	
	    /**
	     * week_first_day
	     */
	    public static final String WEEK_FIRST_DAY = "week_first_day";
	
	    /**
	     * week_last_day
	     */
	    public static final String WEEK_LAST_DAY = "week_last_day";
	
	    /**
	     * year_week
	     */
	    public static final String YEAR_WEEK = "year_week";
	    /**
	     * timestamp
	     */
	    public static final String TIMESTAMP = "timestamp";
	    public static final char SUBTRACT_CHAR = '-';
	    public static final char ADD_CHAR = '+';
	    public static final char MULTIPLY_CHAR = '*';
	    public static final char DIVISION_CHAR = '/';
	    public static final char LEFT_BRACE_CHAR = '(';
	    public static final char RIGHT_BRACE_CHAR = ')';
	    public static final String ADD_STRING = "+";
	    public static final String MULTIPLY_STRING = "*";
	    public static final String DIVISION_STRING = "/";
	    public static final String LEFT_BRACE_STRING = "(";
	    public static final char P = 'P';
	    public static final char N = 'N';
	    public static final String SUBTRACT_STRING = "-";
	    public static final String LOCAL_PARAMS_LIST = "localParamsList";
	    public static final String TASK_TYPE = "taskType";
	    public static final String QUEUE = "queue";
	    /**
	     * default display rows
	     */
	    public static final int DEFAULT_DISPLAY_ROWS = 10;
	
	    /**
	     * jar
	     */
	    public static final String JAR = "jar";
	
	    /**
	     * hadoop
	     */
	    public static final String HADOOP = "hadoop";
	
	    /**
	     * -D <property>=<value>
	     */
	    public static final String D = "-D";
	
	    /**
	     * datasource encryption salt
	     */
	    public static final String DATASOURCE_ENCRYPTION_SALT_DEFAULT = "!@#$%^&*";
	    public static final String DATASOURCE_ENCRYPTION_ENABLE = "datasource.encryption.enable";
	    public static final String DATASOURCE_ENCRYPTION_SALT = "datasource.encryption.salt";
	
	    /**
	     * kerberos
	     */
	    public static final String KERBEROS = "kerberos";
	
	    /**
	     * kerberos expire time
	     */
	    public static final String KERBEROS_EXPIRE_TIME = "kerberos.expire.time";
	
	    /**
	     * java.security.krb5.conf
	     */
	    public static final String JAVA_SECURITY_KRB5_CONF = "java.security.krb5.conf";
	
	    /**
	     * java.security.krb5.conf.path
	     */
	    public static final String JAVA_SECURITY_KRB5_CONF_PATH = "java.security.krb5.conf.path";
	
	    /**
	     * loginUserFromKeytab user
	     */
	    public static final String LOGIN_USER_KEY_TAB_USERNAME = "login.user.keytab.username";
	
	    /**
	     * loginUserFromKeytab path
	     */
	    public static final String LOGIN_USER_KEY_TAB_PATH = "login.user.keytab.path";
	
	    /**
	     * hadoop.security.authentication
	     */
	    public static final String HADOOP_SECURITY_AUTHENTICATION = "hadoop.security.authentication";
	
	    /**
	     * hadoop.security.authentication
	     */
	    public static final String HADOOP_SECURITY_AUTHENTICATION_STARTUP_STATE =
	            "hadoop.security.authentication.startup.state";
	
	    /**
	     * hdfs/s3 configuration
	     * resource.storage.upload.base.path
	     */
	    public static final String RESOURCE_UPLOAD_PATH = "resource.storage.upload.base.path";
	
	    /**
	     * data.quality.jar.dir
	     */
	    public static final String DATA_QUALITY_JAR_DIR = "data-quality.jar.dir";
	
	    public static final String TASK_TYPE_DATA_QUALITY = "DATA_QUALITY";
	
	    public static final Set<String> TASK_TYPE_SET_K8S = Sets.newHashSet("K8S", "KUBEFLOW");
	
	    /**
	     * azure config
	     */
	    public static final String AZURE_CLIENT_ID = "resource.azure.client.id";
	    public static final String AZURE_CLIENT_SECRET = "resource.azure.client.secret";
	    public static final String AZURE_ACCESS_SUB_ID = "resource.azure.subId";
	    public static final String AZURE_SECRET_TENANT_ID = "resource.azure.tenant.id";
	    public static final String QUERY_INTERVAL = "resource.query.interval";
	
	    /**
	     * use for k8s task
	     */
	    public static final String API_VERSION = "batch/v1";
	    public static final String RESTART_POLICY = "Never";
	    public static final String MEMORY = "memory";
	    public static final String CPU = "cpu";
	    public static final String LAYER_LABEL = "k8s.cn/layer";
	    public static final String LAYER_LABEL_VALUE = "batch";
	    public static final String NAME_LABEL = "k8s.cn/name";
	    public static final String TASK_INSTANCE_ID = "taskInstanceId";
	    public static final String MI = "Mi";
	    public static final int JOB_TTL_SECONDS = 300;
	    public static final int LOG_LINES = 500;
	    public static final String NAMESPACE_NAME = "name";
	    public static final String CLUSTER = "cluster";
	
	    /**
	     * spark / flink on k8s label name
	     */
	    public static final String UNIQUE_LABEL_NAME = "dolphinscheduler-label";
	
	    /**
	     * conda config used by jupyter task plugin
	     */
	    public static final String CONDA_PATH = "conda.path";
	
	    // Loop task constants
	    public static final Duration DEFAULT_LOOP_STATUS_INTERVAL = Duration.ofSeconds(5L);
	
	    /**
	     * sql params regex
	     */
	    public static final String GROUP_NAME1 = "paramName1";
	    public static final String GROUP_NAME2 = "paramName2";
	    public static final String SQL_PARAMS_REGEX =
	            String.format("['\"]\\$\\{(?<%s>.*?)}['\"]|\\$\\{(?<%s>.*?)}", GROUP_NAME1, GROUP_NAME2);
	    public static final Pattern SQL_PARAMS_PATTERN = Pattern.compile(SQL_PARAMS_REGEX);
	
	    public static final String AZURE_SQL_DATABASE_SPN = "https://database.windows.net/";
	    public static final String AZURE_SQL_DATABASE_TOKEN_SCOPE = "/.default";
	
	}
		
",
	role:"
	user	
",
,
	content:"
	//dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/api/TaskConstants.java
	/*
	 * Licensed to the Apache Software Foundation (ASF) under one or more
	 * contributor license agreements.  See the NOTICE file distributed with
	 * this work for additional information regarding copyright ownership.
	 * The ASF licenses this file to You under the Apache License, Version 2.0
	 * (the "License"); you may not use this file except in compliance with
	 * the License.  You may obtain a copy of the License at
	 *
	 *    http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	package org.apache.dolphinscheduler.plugin.task.api;
	
	import org.apache.dolphinscheduler.common.constants.DateConstants;
	
	import java.time.Duration;
	import java.util.Set;
	import java.util.regex.Pattern;
	
	import com.google.common.collect.Sets;
	
	public class TaskConstants {
	
	    private TaskConstants() {
	        throw new IllegalStateException("Utility class");
	    }
	
	    public static final String YARN_APPLICATION_REGEX = "application_\\d+_\\d+";
	
	    public static final String FLINK_APPLICATION_REGEX = "JobID \\w+";
	
	    public static final String DATASOURCE_PASSWORD_REGEX =
	            "(?<=((?i)password((\" : \")|(\":\")|(\\\\\":\\\\\")|(=')))).*?(?=((\")|(\\\\\")|(')))";
	
	    /**
	     * exit code kill
	     */
	    public static final int EXIT_CODE_KILL = 137;
	    public static final String PID = "pid";
	
	    /**
	     * QUESTION ?
	     */
	    public static final String QUESTION = "?";
	
	    /**
	     * comma ,
	     */
	    public static final String COMMA = ",";
	
	    /**
	     * hyphen
	     */
	    public static final String HYPHEN = "-";
	
	    /**
	     * slash /
	     */
	    public static final String SLASH = "/";
	
	    /**
	     * COLON :
	     */
	    public static final String COLON = ":";
	
	    /**
	     * SPACE " "
	     */
	    public static final String SPACE = " ";
	
	    /**
	     * SINGLE_SLASH /
	     */
	    public static final String SINGLE_SLASH = "/";
	
	    /**
	     * DOUBLE_SLASH //
	     */
	    public static final String DOUBLE_SLASH = "//";
	
	    /**
	     * SINGLE_QUOTES "'"
	     */
	    public static final String SINGLE_QUOTES = "'";
	    /**
	     * DOUBLE_QUOTES "\""
	     */
	    public static final String DOUBLE_QUOTES = "\"";
	
	    /**
	     * SEMICOLON ;
	     */
	    public static final String SEMICOLON = ";";
	
	    /**
	     * EQUAL SIGN
	     */
	    public static final String EQUAL_SIGN = "=";
	
	    /**
	     * UNDERLINE
	     */
	    public static final String UNDERLINE = "_";
	
	    /**
	     * sleep time
	     */
	    public static final int SLEEP_TIME_MILLIS = 1000;
	
	    /**
	     * exit code failure
	     */
	    public static final int EXIT_CODE_FAILURE = -1;
	
	    /**
	     * exit code success
	     */
	    public static final int EXIT_CODE_SUCCESS = 0;
	    /**
	     * running code
	     */
	    public static final int RUNNING_CODE = 1;
	
	    public static final String SH = "sh";
	
	    /**
	     * log flush interval?output when reach the interval
	     */
	    public static final int DEFAULT_LOG_FLUSH_INTERVAL = 1000;
	
	    /**
	     * pstree, get pud and sub pid
	     */
	    public static final String PSTREE = "pstree";
	
	    public static final String RWXR_XR_X = "rwxr-xr-x";
	
	    /**
	     * date format of yyyyMMddHHmmss
	     */
	    public static final String PARAMETER_FORMAT_TIME = "yyyyMMddHHmmss";
	
	    /**
	     * new
	     * schedule time
	     */
	    public static final String PARAMETER_SHECDULE_TIME = "schedule.time";
	
	    /**
	     * system date(yyyyMMddHHmmss)
	     */
	    public static final String PARAMETER_DATETIME = DateConstants.PARAMETER_DATETIME;
	
	    /**
	     * system date(yyyymmdd) today
	     */
	    public static final String PARAMETER_CURRENT_DATE = DateConstants.PARAMETER_CURRENT_DATE;
	
	    /**
	     * system date(yyyymmdd) yesterday
	     */
	    public static final String PARAMETER_BUSINESS_DATE = DateConstants.PARAMETER_BUSINESS_DATE;
	
	    /**
	     * the absolute path of current executing task
	     */
	    public static final String PARAMETER_TASK_EXECUTE_PATH = "system.task.execute.path";
	
	    /**
	     * the instance id of current task
	     */
	    public static final String PARAMETER_TASK_INSTANCE_ID = "system.task.instance.id";
	
	    /**
	     * the definition code of current task
	     */
	    public static final String PARAMETER_TASK_DEFINITION_CODE = "system.task.definition.code";
	
	    /**
	     * the definition name of current task
	     */
	    public static final String PARAMETER_TASK_DEFINITION_NAME = "system.task.definition.name";
	
	    /**
	     * the instance id of the workflow to which current task belongs
	     */
	    public static final String PARAMETER_WORKFLOW_INSTANCE_ID = "system.workflow.instance.id";
	
	    /**
	     * the definition code of the workflow to which current task belongs
	     */
	    public static final String PARAMETER_WORKFLOW_DEFINITION_CODE = "system.workflow.definition.code";
	
	    /**
	     * the definition name of the workflow to which current task belongs
	     */
	    public static final String PARAMETER_WORKFLOW_DEFINITION_NAME = "system.workflow.definition.name";
	
	    /**
	     * the code of the project to which current task belongs
	     */
	    public static final String PARAMETER_PROJECT_CODE = "system.project.code";
	
	    /**
	     * the name of the project to which current task belongs
	     */
	    public static final String PARAMETER_PROJECT_NAME = "system.project.name";
	    /**
	     * month_begin
	     */
	    public static final String MONTH_BEGIN = "month_begin";
	    /**
	     * add_months
	     */
	    public static final String ADD_MONTHS = "add_months";
	    /**
	     * month_end
	     */
	    public static final String MONTH_END = "month_end";
	    /**
	     * week_begin
	     */
	    public static final String WEEK_BEGIN = "week_begin";
	    /**
	     * week_end
	     */
	    public static final String WEEK_END = "week_end";
	    /**
	     * this_day
	     */
	    public static final String THIS_DAY = "this_day";
	    /**
	     * last_day
	     */
	    public static final String LAST_DAY = "last_day";
	
	    /**
	     * month_first_day
	     */
	    public static final String MONTH_FIRST_DAY = "month_first_day";
	
	    /**
	     * month_last_day
	     */
	    public static final String MONTH_LAST_DAY = "month_last_day";
	
	    /**
	     * week_first_day
	     */
	    public static final String WEEK_FIRST_DAY = "week_first_day";
	
	    /**
	     * week_last_day
	     */
	    public static final String WEEK_LAST_DAY = "week_last_day";
	
	    /**
	     * year_week
	     */
	    public static final String YEAR_WEEK = "year_week";
	    /**
	     * timestamp
	     */
	    public static final String TIMESTAMP = "timestamp";
	    public static final char SUBTRACT_CHAR = '-';
	    public static final char ADD_CHAR = '+';
	    public static final char MULTIPLY_CHAR = '*';
	    public static final char DIVISION_CHAR = '/';
	    public static final char LEFT_BRACE_CHAR = '(';
	    public static final char RIGHT_BRACE_CHAR = ')';
	    public static final String ADD_STRING = "+";
	    public static final String MULTIPLY_STRING = "*";
	    public static final String DIVISION_STRING = "/";
	    public static final String LEFT_BRACE_STRING = "(";
	    public static final char P = 'P';
	    public static final char N = 'N';
	    public static final String SUBTRACT_STRING = "-";
	    public static final String LOCAL_PARAMS_LIST = "localParamsList";
	    public static final String TASK_TYPE = "taskType";
	    public static final String QUEUE = "queue";
	    /**
	     * default display rows
	     */
	    public static final int DEFAULT_DISPLAY_ROWS = 10;
	
	    /**
	     * jar
	     */
	    public static final String JAR = "jar";
	
	    /**
	     * hadoop
	     */
	    public static final String HADOOP = "hadoop";
	
	    /**
	     * -D <property>=<value>
	     */
	    public static final String D = "-D";
	
	    /**
	     * java.security.krb5.conf
	     */
	    public static final String JAVA_SECURITY_KRB5_CONF = "java.security.krb5.conf";
	
	    /**
	     * java.security.krb5.conf.path
	     */
	    public static final String JAVA_SECURITY_KRB5_CONF_PATH = "java.security.krb5.conf.path";
	
	    /**
	     * hadoop.security.authentication
	     */
	    public static final String HADOOP_SECURITY_AUTHENTICATION_STARTUP_STATE =
	            "hadoop.security.authentication.startup.state";
	
	    public static final String TASK_TYPE_DATA_QUALITY = "DATA_QUALITY";
	
	    public static final Set<String> TASK_TYPE_SET_K8S = Sets.newHashSet("K8S", "KUBEFLOW");
	
	    /**
	     * azure config
	     */
	    public static final String AZURE_CLIENT_ID = "resource.azure.client.id";
	    public static final String AZURE_CLIENT_SECRET = "resource.azure.client.secret";
	    public static final String AZURE_ACCESS_SUB_ID = "resource.azure.subId";
	    public static final String AZURE_SECRET_TENANT_ID = "resource.azure.tenant.id";
	    public static final String QUERY_INTERVAL = "resource.query.interval";
	
	    /**
	     * use for k8s task
	     */
	    public static final String API_VERSION = "batch/v1";
	    public static final String RESTART_POLICY = "Never";
	    public static final String MEMORY = "memory";
	    public static final String CPU = "cpu";
	    public static final String LAYER_LABEL = "k8s.cn/layer";
	    public static final String LAYER_LABEL_VALUE = "batch";
	    public static final String NAME_LABEL = "k8s.cn/name";
	    public static final String TASK_INSTANCE_ID = "taskInstanceId";
	    public static final String MI = "Mi";
	    public static final int JOB_TTL_SECONDS = 300;
	    public static final int LOG_LINES = 500;
	    public static final String NAMESPACE_NAME = "name";
	    public static final String CLUSTER = "cluster";
	
	    /**
	     * spark / flink on k8s label name
	     */
	    public static final String UNIQUE_LABEL_NAME = "dolphinscheduler-label";
	
	    /**
	     * conda config used by jupyter task plugin
	     */
	    public static final String CONDA_PATH = "conda.path";
	
	    // Loop task constants
	    public static final Duration DEFAULT_LOOP_STATUS_INTERVAL = Duration.ofSeconds(5L);
	
	    /**
	     * sql params regex
	     */
	    public static final String GROUP_NAME1 = "paramName1";
	    public static final String GROUP_NAME2 = "paramName2";
	    public static final String SQL_PARAMS_REGEX =
	            String.format("['\"]\\$\\{(?<%s>.*?)}['\"]|\\$\\{(?<%s>.*?)}", GROUP_NAME1, GROUP_NAME2);
	    public static final Pattern SQL_PARAMS_PATTERN = Pattern.compile(SQL_PARAMS_REGEX);
	
	    public static final String LOGIN_USER_KEY_TAB_USERNAME = "login.user.keytab.username";
	
	    public static final String LOGIN_USER_KEY_TAB_PATH = "login.user.keytab.path";
	
	    /**
	     * fetch applicationId way
	     */
	    public static final String APPID_COLLECT = "appId.collect";
	    public static final String DEFAULT_COLLECT_WAY = "log";
	
	    public static final String WORKFLOW_INSTANCE_ID_MDC_KEY = "workflowInstanceId";
	    public static final String TASK_INSTANCE_ID_MDC_KEY = "taskInstanceId";
	
	    public static final String STAR = "*";
	}
		
",
	role:"
	user	
",
,
	content:"
	//dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/constants/DataSourceConstants.java
	/*
	 * Licensed to the Apache Software Foundation (ASF) under one or more
	 * contributor license agreements.  See the NOTICE file distributed with
	 * this work for additional information regarding copyright ownership.
	 * The ASF licenses this file to You under the Apache License, Version 2.0
	 * (the "License"); you may not use this file except in compliance with
	 * the License.  You may obtain a copy of the License at
	 *
	 *    http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	package org.apache.dolphinscheduler.common.constants;
	
	public class DataSourceConstants {
	
	    public static final String DATASOURCE = "datasource";
	
	    /**
	     * driver
	     */
	    public static final String ORG_POSTGRESQL_DRIVER = "org.postgresql.Driver";
	    public static final String COM_MYSQL_CJ_JDBC_DRIVER = "com.mysql.cj.jdbc.Driver";
	    public static final String COM_MYSQL_JDBC_DRIVER = "com.mysql.jdbc.Driver";
	    public static final String ORG_APACHE_HIVE_JDBC_HIVE_DRIVER = "org.apache.hive.jdbc.HiveDriver";
	    public static final String COM_CLICKHOUSE_JDBC_DRIVER = "com.clickhouse.jdbc.ClickHouseDriver";
	    public static final String COM_DATABEND_JDBC_DRIVER = "com.databend.jdbc.DatabendDriver";
	    public static final String COM_ORACLE_JDBC_DRIVER = "oracle.jdbc.OracleDriver";
	    public static final String COM_SQLSERVER_JDBC_DRIVER = "com.microsoft.sqlserver.jdbc.SQLServerDriver";
	    public static final String COM_DB2_JDBC_DRIVER = "com.ibm.db2.jcc.DB2Driver";
	    public static final String COM_PRESTO_JDBC_DRIVER = "com.facebook.presto.jdbc.PrestoDriver";
	    public static final String COM_REDSHIFT_JDBC_DRIVER = "com.amazon.redshift.jdbc42.Driver";
	    public static final String COM_ATHENA_JDBC_DRIVER = "com.simba.athena.jdbc.Driver";
	    public static final String COM_TRINO_JDBC_DRIVER = "io.trino.jdbc.TrinoDriver";
	    public static final String COM_DAMENG_JDBC_DRIVER = "dm.jdbc.driver.DmDriver";
	    public static final String ORG_APACHE_KYUUBI_JDBC_DRIVER = "org.apache.kyuubi.jdbc.KyuubiHiveDriver";
	    public static final String COM_OCEANBASE_JDBC_DRIVER = "com.oceanbase.jdbc.Driver";
	    public static final String NET_SNOWFLAKE_JDBC_DRIVER = "net.snowflake.client.jdbc.SnowflakeDriver";
	    public static final String COM_VERTICA_JDBC_DRIVER = "com.vertica.jdbc.Driver";
	    public static final String COM_HANA_DB_JDBC_DRIVER = "com.sap.db.jdbc.Driver";
	
	    /**
	     * validation Query
	     */
	    public static final String POSTGRESQL_VALIDATION_QUERY = "select version()";
	    public static final String MYSQL_VALIDATION_QUERY = "select 1";
	    public static final String HIVE_VALIDATION_QUERY = "select 1";
	    public static final String CLICKHOUSE_VALIDATION_QUERY = "select 1";
	    public static final String DATABEND_VALIDATION_QUERY = "select 1";
	    public static final String ORACLE_VALIDATION_QUERY = "select 1 from dual";
	    public static final String SQLSERVER_VALIDATION_QUERY = "select 1";
	    public static final String DB2_VALIDATION_QUERY = "select 1 from sysibm.sysdummy1";
	    public static final String PRESTO_VALIDATION_QUERY = "select 1";
	    public static final String REDHIFT_VALIDATION_QUERY = "select 1";
	    public static final String ATHENA_VALIDATION_QUERY = "select 1";
	    public static final String TRINO_VALIDATION_QUERY = "select 1";
	    public static final String DAMENG_VALIDATION_QUERY = "select 1";
	    public static final String SNOWFLAKE_VALIDATION_QUERY = "select 1";
	
	    public static final String KYUUBI_VALIDATION_QUERY = "select 1";
	    public static final String VERTICA_VALIDATION_QUERY = "select 1";
	
	    public static final String HANA_VALIDATION_QUERY = "select 1 from DUMMY";
	
	    /**
	     * jdbc url
	     */
	    public static final String JDBC_MYSQL = "jdbc:mysql://";
	    public static final String JDBC_MYSQL_LOADBALANCE = "jdbc:mysql:loadbalance://";
	    public static final String JDBC_POSTGRESQL = "jdbc:postgresql://";
	    public static final String JDBC_HIVE_2 = "jdbc:hive2://";
	    public static final String JDBC_KYUUBI = "jdbc:kyuubi://";
	    public static final String JDBC_CLICKHOUSE = "jdbc:clickhouse://";
	    public static final String JDBC_DATABEND = "jdbc:databend://";
	    public static final String JDBC_ORACLE_SID = "jdbc:oracle:thin:@";
	    public static final String JDBC_ORACLE_SERVICE_NAME = "jdbc:oracle:thin:@//";
	    public static final String JDBC_SQLSERVER = "jdbc:sqlserver://";
	    public static final String JDBC_DB2 = "jdbc:db2://";
	    public static final String JDBC_PRESTO = "jdbc:presto://";
	    public static final String JDBC_REDSHIFT = "jdbc:redshift://";
	    public static final String JDBC_REDSHIFT_IAM = "jdbc:redshift:iam://";
	    public static final String JDBC_ATHENA = "jdbc:awsathena://";
	    public static final String JDBC_TRINO = "jdbc:trino://";
	    public static final String JDBC_DAMENG = "jdbc:dm://";
	    public static final String JDBC_OCEANBASE = "jdbc:oceanbase://";
	    public static final String JDBC_SNOWFLAKE = "jdbc:snowflake://";
	    public static final String JDBC_VERTICA = "jdbc:vertica://";
	    public static final String JDBC_HANA = "jdbc:sap://";
	
	    /**
	     * database type
	     */
	    public static final String MYSQL = "MYSQL";
	    public static final String HIVE = "HIVE";
	
	    /**
	     * dataSource sensitive param
	     */
	    public static final String DATASOURCE_PASSWORD_REGEX =
	            "(?<=((?i)password((\" : \")|(\":\")|(\\\\\":\\\\\")|(=')))).*?(?=((\")|(\\\\\")|(')))";
	
	    /**
	     * datasource encryption salt
	     */
	    public static final String DATASOURCE_ENCRYPTION_SALT_DEFAULT = "!@#$%^&*";
	    public static final String DATASOURCE_ENCRYPTION_ENABLE = "datasource.encryption.enable";
	    public static final String DATASOURCE_ENCRYPTION_SALT = "datasource.encryption.salt";
	
	    /**
	     * datasource config
	     */
	    public static final String SPRING_DATASOURCE_MIN_IDLE = "spring.datasource.minIdle";
	
	    public static final String SPRING_DATASOURCE_MAX_ACTIVE = "spring.datasource.maxActive";
	
	    public static final String SPRING_DATASOURCE_TEST_ON_BORROW = "spring.datasource.testOnBorrow";
	
	    /**
	     * azure static websites
	     */
	    public static final String AZURE_SQL_DATABASE_SPN = "https://database.windows.net/";
	    public static final String AZURE_SQL_DATABASE_TOKEN_SCOPE = "/.default";
	
	}
		
",
	role:"
	user	
",
,
	content:"
	//dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/TaskInstance.java
	/*
	 * Licensed to the Apache Software Foundation (ASF) under one or more
	 * contributor license agreements.  See the NOTICE file distributed with
	 * this work for additional information regarding copyright ownership.
	 * The ASF licenses this file to You under the Apache License, Version 2.0
	 * (the "License"); you may not use this file except in compliance with
	 * the License.  You may obtain a copy of the License at
	 *
	 *    http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	package org.apache.dolphinscheduler.dao.entity;
	
	import org.apache.dolphinscheduler.common.enums.Flag;
	import org.apache.dolphinscheduler.common.enums.Priority;
	import org.apache.dolphinscheduler.common.enums.TaskExecuteType;
	import org.apache.dolphinscheduler.plugin.task.api.enums.TaskExecutionStatus;
	
	import java.io.Serializable;
	import java.util.Date;
	
	import lombok.Data;
	
	import com.baomidou.mybatisplus.annotation.FieldStrategy;
	import com.baomidou.mybatisplus.annotation.IdType;
	import com.baomidou.mybatisplus.annotation.TableField;
	import com.baomidou.mybatisplus.annotation.TableId;
	import com.baomidou.mybatisplus.annotation.TableName;
	
	@Data
	@TableName("t_ds_task_instance")
	public class TaskInstance implements Serializable {
	
	    @TableId(value = "id", type = IdType.AUTO)
	    private Integer id;
	
	    private String name;
	
	    private String taskType;
	
	    private int workflowInstanceId;
	
	    private String workflowInstanceName;
	
	    private Long projectCode;
	
	    private long taskCode;
	
	    private int taskDefinitionVersion;
	
	    @TableField(exist = false)
	    private String processDefinitionName;
	
	    @TableField(exist = false)
	    private int taskGroupPriority;
	
	    private TaskExecutionStatus state;
	
	    private Date firstSubmitTime;
	
	    private Date submitTime;
	
	    private Date startTime;
	
	    private Date endTime;
	
	    private String host;
	
	    private String executePath;
	
	    private String logPath;
	
	    private int retryTimes;
	
	    private Flag alertFlag;
	
	    @TableField(exist = false)
	    private WorkflowInstance workflowInstance;
	
	    @TableField(exist = false)
	    private WorkflowDefinition workflowDefinition;
	
	    @TableField(exist = false)
	    private TaskDefinition taskDefine;
	
	    private int pid;
	
	    private String appLink;
	
	    private Flag flag;
	
	    private Flag isCache;
	
	    @TableField(updateStrategy = FieldStrategy.IGNORED)
	    private String cacheKey;
	
	    @TableField(exist = false)
	    private String duration;
	
	    private int maxRetryTimes;
	
	    private int retryInterval;
	
	    private Priority taskInstancePriority;
	
	    @TableField(exist = false)
	    private Priority workflowInstancePriority;
	
	    private String workerGroup;
	
	    private Long environmentCode;
	
	    private String environmentConfig;
	
	    private int executorId;
	
	    private String varPool;
	
	    private String executorName;
	
	    private int delayTime;
	
	    private String taskParams;
	
	    private int dryRun;
	
	    private int taskGroupId;
	
	    private Integer cpuQuota;
	
	    private Integer memoryMax;
	
	    private TaskExecuteType taskExecuteType;
	
	    private int testFlag;
	
	    public void init(String host, Date startTime, String executePath) {
	        this.host = host;
	        this.startTime = startTime;
	        this.executePath = executePath;
	    }
	
	}
		
",
	role:"
	user	
",
,
	content:"
	//dolphinscheduler-extract/dolphinscheduler-extract-master/src/main/java/org/apache/dolphinscheduler/extract/master/dto/TaskInstanceExecuteDto.java
	/*
	 * Licensed to the Apache Software Foundation (ASF) under one or more
	 * contributor license agreements.  See the NOTICE file distributed with
	 * this work for additional information regarding copyright ownership.
	 * The ASF licenses this file to You under the Apache License, Version 2.0
	 * (the "License"); you may not use this file except in compliance with
	 * the License.  You may obtain a copy of the License at
	 *
	 *    http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	package org.apache.dolphinscheduler.extract.master.dto;
	
	import org.apache.dolphinscheduler.common.enums.Flag;
	import org.apache.dolphinscheduler.common.enums.Priority;
	import org.apache.dolphinscheduler.common.enums.TaskExecuteType;
	import org.apache.dolphinscheduler.plugin.task.api.enums.TaskExecutionStatus;
	
	import java.util.Date;
	import java.util.Map;
	
	import lombok.Data;
	
	@Data
	public class TaskInstanceExecuteDto {
	
	    private int id;
	
	    private String name;
	
	    private String taskType;
	
	    private int processInstanceId;
	
	    private long taskCode;
	
	    private int taskDefinitionVersion;
	
	    private String processInstanceName;
	
	    private int taskGroupPriority;
	
	    private TaskExecutionStatus state;
	
	    private Date firstSubmitTime;
	
	    private Date submitTime;
	
	    private Date startTime;
	
	    private Date endTime;
	
	    private String host;
	
	    private String executePath;
	
	    private String logPath;
	
	    private int retryTimes;
	
	    private Flag alertFlag;
	
	    private int pid;
	
	    private String appLink;
	
	    private Flag flag;
	
	    private String duration;
	
	    private int maxRetryTimes;
	
	    private int retryInterval;
	
	    private Priority taskInstancePriority;
	
	    private Priority processInstancePriority;
	
	    private String workerGroup;
	
	    private Long environmentCode;
	
	    private String environmentConfig;
	
	    private int executorId;
	
	    private String varPool;
	
	    private String executorName;
	
	    private Map<String, String> resources;
	
	    private int delayTime;
	
	    private String taskParams;
	
	    private int dryRun;
	
	    private int taskGroupId;
	
	    private Integer cpuQuota;
	
	    private Integer memoryMax;
	
	    private TaskExecuteType taskExecuteType;
	}
		
",
	role:"
	user	
",
,
	content:"
	//dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/controller/AccessTokenController.java
	/*
	 * Licensed to the Apache Software Foundation (ASF) under one or more
	 * contributor license agreements.  See the NOTICE file distributed with
	 * this work for additional information regarding copyright ownership.
	 * The ASF licenses this file to You under the Apache License, Version 2.0
	 * (the "License"); you may not use this file except in compliance with
	 * the License.  You may obtain a copy of the License at
	 *
	 *    http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	package org.apache.dolphinscheduler.api.controller;
	
	import static org.apache.dolphinscheduler.api.enums.Status.CREATE_ACCESS_TOKEN_ERROR;
	import static org.apache.dolphinscheduler.api.enums.Status.DELETE_ACCESS_TOKEN_ERROR;
	import static org.apache.dolphinscheduler.api.enums.Status.GENERATE_TOKEN_ERROR;
	import static org.apache.dolphinscheduler.api.enums.Status.QUERY_ACCESSTOKEN_BY_USER_ERROR;
	import static org.apache.dolphinscheduler.api.enums.Status.QUERY_ACCESSTOKEN_LIST_PAGING_ERROR;
	import static org.apache.dolphinscheduler.api.enums.Status.UPDATE_ACCESS_TOKEN_ERROR;
	
	import org.apache.dolphinscheduler.api.audit.OperatorLog;
	import org.apache.dolphinscheduler.api.audit.enums.AuditType;
	import org.apache.dolphinscheduler.api.exceptions.ApiException;
	import org.apache.dolphinscheduler.api.service.AccessTokenService;
	import org.apache.dolphinscheduler.api.utils.PageInfo;
	import org.apache.dolphinscheduler.api.utils.Result;
	import org.apache.dolphinscheduler.common.constants.Constants;
	import org.apache.dolphinscheduler.dao.entity.AccessToken;
	import org.apache.dolphinscheduler.dao.entity.User;
	import org.apache.dolphinscheduler.plugin.task.api.utils.ParameterUtils;
	
	import java.util.List;
	
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.http.HttpStatus;
	import org.springframework.web.bind.annotation.DeleteMapping;
	import org.springframework.web.bind.annotation.GetMapping;
	import org.springframework.web.bind.annotation.PathVariable;
	import org.springframework.web.bind.annotation.PostMapping;
	import org.springframework.web.bind.annotation.PutMapping;
	import org.springframework.web.bind.annotation.RequestAttribute;
	import org.springframework.web.bind.annotation.RequestMapping;
	import org.springframework.web.bind.annotation.RequestParam;
	import org.springframework.web.bind.annotation.ResponseStatus;
	import org.springframework.web.bind.annotation.RestController;
	
	import io.swagger.v3.oas.annotations.Operation;
	import io.swagger.v3.oas.annotations.Parameter;
	import io.swagger.v3.oas.annotations.Parameters;
	import io.swagger.v3.oas.annotations.media.Schema;
	import io.swagger.v3.oas.annotations.tags.Tag;
	
	/**
	 * access token controller
	 */
	@Tag(name = "ACCESS_TOKEN_TAG")
	@RestController
	@RequestMapping("/access-tokens")
	public class AccessTokenController extends BaseController {
	
	    @Autowired
	    private AccessTokenService accessTokenService;
	
	    /**
	     * create token
	     *
	     * @param loginUser login user
	     * @param userId token for user id
	     * @param expireTime expire time for the token
	     * @param token token string (if it is absent, it will be automatically generated)
	     * @return create result state code
	     */
	    @Operation(summary = "createToken", description = "CREATE_TOKEN_NOTES")
	    @Parameters({
	            @Parameter(name = "userId", description = "USER_ID", schema = @Schema(implementation = int.class), required = true),
	            @Parameter(name = "expireTime", description = "EXPIRE_TIME", schema = @Schema(implementation = String.class), required = true, example = "2021-12-31 00:00:00"),
	            @Parameter(name = "token", description = "TOKEN", required = false, schema = @Schema(implementation = String.class), example = "xxxx")
	    })
	    @PostMapping()
	    @ResponseStatus(HttpStatus.CREATED)
	    @ApiException(CREATE_ACCESS_TOKEN_ERROR)
	    @OperatorLog(auditType = AuditType.TOKEN_CREATE)
	    public Result<AccessToken> createToken(@Parameter(hidden = true) @RequestAttribute(value = Constants.SESSION_USER) User loginUser,
	                                           @RequestParam(value = "userId") int userId,
	                                           @RequestParam(value = "expireTime") String expireTime,
	                                           @RequestParam(value = "token", required = false) String token) {
	
	        AccessToken accessToken = accessTokenService.createToken(loginUser, userId, expireTime, token);
	        return Result.success(accessToken);
	    }
	
	    /**
	     * generate token string
	     *
	     * @param loginUser login user
	     * @param userId token for user
	     * @param expireTime expire time
	     * @return token string
	     */
	    @Parameter(hidden = true)
	    @PostMapping(value = "/generate")
	    @ResponseStatus(HttpStatus.CREATED)
	    @ApiException(GENERATE_TOKEN_ERROR)
	    public Result<String> generateToken(@RequestAttribute(value = Constants.SESSION_USER) User loginUser,
	                                        @RequestParam(value = "userId") int userId,
	                                        @RequestParam(value = "expireTime") String expireTime) {
	        String token = accessTokenService.generateToken(loginUser, userId, expireTime);
	        return Result.success(token);
	    }
	
	    /**
	     * query access token list paging
	     *
	     * @param loginUser login user
	     * @param pageNo page number
	     * @param searchVal search value
	     * @param pageSize page size
	     * @return token list of page number and page size
	     */
	    @Operation(summary = "queryAccessTokenList", description = "QUERY_ACCESS_TOKEN_LIST_NOTES")
	    @Parameters({
	            @Parameter(name = "searchVal", description = "SEARCH_VAL", schema = @Schema(implementation = String.class)),
	            @Parameter(name = "pageNo", description = "PAGE_NO", required = true, schema = @Schema(implementation = int.class), example = "1"),
	            @Parameter(name = "pageSize", description = "PAGE_SIZE", required = true, schema = @Schema(implementation = int.class), example = "20")
	    })
	    @GetMapping()
	    @ResponseStatus(HttpStatus.OK)
	    @ApiException(QUERY_ACCESSTOKEN_LIST_PAGING_ERROR)
	    public Result<PageInfo<AccessToken>> queryAccessTokenList(@Parameter(hidden = true) @RequestAttribute(value = Constants.SESSION_USER) User loginUser,
	                                                              @RequestParam("pageNo") Integer pageNo,
	                                                              @RequestParam(value = "searchVal", required = false) String searchVal,
	                                                              @RequestParam("pageSize") Integer pageSize) {
	
	        checkPageParams(pageNo, pageSize);
	        searchVal = ParameterUtils.handleEscapes(searchVal);
	        PageInfo<AccessToken> accessTokenPageInfo =
	                accessTokenService.queryAccessTokenList(loginUser, searchVal, pageNo, pageSize);
	        return Result.success(accessTokenPageInfo);
	    }
	
	    /**
	     * query access token for specified user
	     *
	     * @param loginUser login user
	     * @param userId user id
	     * @return token list for specified user
	     */
	    @Operation(summary = "queryAccessTokenByUser", description = "QUERY_ACCESS_TOKEN_BY_USER_NOTES")
	    @Parameters({
	            @Parameter(name = "userId", description = "USER_ID", schema = @Schema(implementation = int.class))
	    })
	    @GetMapping(value = "/user/{userId}")
	    @ResponseStatus(HttpStatus.OK)
	    @ApiException(QUERY_ACCESSTOKEN_BY_USER_ERROR)
	    public Result<List<AccessToken>> queryAccessTokenByUser(@Parameter(hidden = true) @RequestAttribute(value = Constants.SESSION_USER) User loginUser,
	                                                            @PathVariable("userId") Integer userId) {
	        List<AccessToken> accessTokens = accessTokenService.queryAccessTokenByUser(loginUser, userId);
	        return Result.success(accessTokens);
	    }
	
	    /**
	     * delete access token by id
	     *
	     * @param loginUser login user
	     * @param id token id
	     * @return delete result code
	     */
	    @Parameter(hidden = true)
	    @Operation(summary = "deleteToken", description = "DELETE_TOKEN_NOTES")
	    @DeleteMapping(value = "/{id}")
	    @ResponseStatus(HttpStatus.OK)
	    @ApiException(DELETE_ACCESS_TOKEN_ERROR)
	    @OperatorLog(auditType = AuditType.TOKEN_DELETE)
	    public Result<Boolean> delAccessTokenById(@Parameter(hidden = true) @RequestAttribute(value = Constants.SESSION_USER) User loginUser,
	                                              @PathVariable(value = "id") int id) {
	        accessTokenService.deleteAccessTokenById(loginUser, id);
	        return Result.success(false);
	    }
	
	    /**
	     * update token
	     *
	     * @param loginUser login user
	     * @param id token id
	     * @param userId token for user
	     * @param expireTime token expire time
	     * @param token token string (if it is absent, it will be automatically generated)
	     * @return updated access token entity
	     */
	    @Operation(summary = "updateToken", description = "UPDATE_TOKEN_NOTES")
	    @Parameters({
	            @Parameter(name = "id", description = "TOKEN_ID", required = true, schema = @Schema(implementation = int.class)),
	            @Parameter(name = "userId", description = "USER_ID", required = true, schema = @Schema(implementation = int.class)),
	            @Parameter(name = "expireTime", description = "EXPIRE_TIME", required = true, schema = @Schema(implementation = String.class), example = "2021-12-31 00:00:00"),
	            @Parameter(name = "token", description = "TOKEN", required = false, schema = @Schema(implementation = String.class), example = "xxxx")
	    })
	    @PutMapping(value = "/{id}")
	    @ResponseStatus(HttpStatus.OK)
	    @ApiException(UPDATE_ACCESS_TOKEN_ERROR)
	    @OperatorLog(auditType = AuditType.TOKEN_UPDATE)
	    public Result<AccessToken> updateToken(@Parameter(hidden = true) @RequestAttribute(value = Constants.SESSION_USER) User loginUser,
	                                           @PathVariable(value = "id") int id,
	                                           @RequestParam(value = "userId") int userId,
	                                           @RequestParam(value = "expireTime") String expireTime,
	                                           @RequestParam(value = "token", required = false) String token) {
	
	        AccessToken accessToken = accessTokenService.updateToken(loginUser, id, userId, expireTime, token);
	        return Result.success(accessToken);
	    }
	
	}
		
",
	role:"
	user	
",
,
	content:"
	//dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/AccessTokenService.java
	/*
	 * Licensed to the Apache Software Foundation (ASF) under one or more
	 * contributor license agreements.  See the NOTICE file distributed with
	 * this work for additional information regarding copyright ownership.
	 * The ASF licenses this file to You under the Apache License, Version 2.0
	 * (the "License"); you may not use this file except in compliance with
	 * the License.  You may obtain a copy of the License at
	 *
	 *    http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	package org.apache.dolphinscheduler.api.service;
	
	import org.apache.dolphinscheduler.api.utils.PageInfo;
	import org.apache.dolphinscheduler.dao.entity.AccessToken;
	import org.apache.dolphinscheduler.dao.entity.User;
	
	import java.util.List;
	
	/**
	 * access token service
	 */
	public interface AccessTokenService {
	
	    /**
	     * query access token list
	     *
	     * @param loginUser login user
	     * @param searchVal search value
	     * @param pageNo page number
	     * @param pageSize page size
	     * @return token list for page number and page size
	     */
	    PageInfo<AccessToken> queryAccessTokenList(User loginUser, String searchVal, Integer pageNo, Integer pageSize);
	
	    /**
	     * query access token for specified user
	     *
	     * @param loginUser login user
	     * @param userId user id
	     * @return token list for specified user
	     */
	    List<AccessToken> queryAccessTokenByUser(User loginUser, Integer userId);
	
	    /**
	     * create token
	     *
	     * @param userId token for user
	     * @param expireTime token expire time
	     * @param token token string (if it is absent, it will be automatically generated)
	     * @return create result code
	     */
	    AccessToken createToken(User loginUser, int userId, String expireTime, String token);
	
	    /**
	     * generate token
	     *
	     * @param userId token for user
	     * @param expireTime token expire time
	     * @return token string
	     */
	    String generateToken(User loginUser, int userId, String expireTime);
	
	    /**
	     * delete access token
	     *
	     * @param loginUser login user
	     * @param id token id
	     * @return delete result code
	     */
	    void deleteAccessTokenById(User loginUser, int id);
	
	    /**
	     * update token by id
	     *
	     * @param id token id
	     * @param userId token for user
	     * @param expireTime token expire time
	     * @param token token string (if it is absent, it will be automatically generated)
	     * @return updated access token entity
	     */
	    AccessToken updateToken(User loginUser, int id, int userId, String expireTime, String token);
	}
		
",
	role:"
	user	
",
,
	content:"
	//dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/dto/EnvironmentDto.java
	/*
	 * Licensed to the Apache Software Foundation (ASF) under one or more
	 * contributor license agreements.  See the NOTICE file distributed with
	 * this work for additional information regarding copyright ownership.
	 * The ASF licenses this file to You under the Apache License, Version 2.0
	 * (the "License"); you may not use this file except in compliance with
	 * the License.  You may obtain a copy of the License at
	 *
	 *    http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	package org.apache.dolphinscheduler.api.dto;
	
	import java.util.Date;
	import java.util.List;
	
	import lombok.Data;
	
	@Data
	public class EnvironmentDto {
	
	    private Integer id;
	
	    /**
	     * environment code
	     */
	    private Long code;
	
	    /**
	     * environment name
	     */
	    private String name;
	
	    /**
	     * config content
	     */
	    private String config;
	
	    private String description;
	
	    private List<String> workerGroups;
	
	    /**
	     * operator user id
	     */
	    private Integer operator;
	
	    private Date createTime;
	
	    private Date updateTime;
	}
		
",
	role:"
	user	
",
,
	content:"
	//dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/AccessToken.java
	/*
	 * Licensed to the Apache Software Foundation (ASF) under one or more
	 * contributor license agreements.  See the NOTICE file distributed with
	 * this work for additional information regarding copyright ownership.
	 * The ASF licenses this file to You under the Apache License, Version 2.0
	 * (the "License"); you may not use this file except in compliance with
	 * the License.  You may obtain a copy of the License at
	 *
	 *    http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	package org.apache.dolphinscheduler.dao.entity;
	
	import java.util.Date;
	import java.util.Objects;
	
	import lombok.Data;
	
	import com.baomidou.mybatisplus.annotation.IdType;
	import com.baomidou.mybatisplus.annotation.TableField;
	import com.baomidou.mybatisplus.annotation.TableId;
	import com.baomidou.mybatisplus.annotation.TableName;
	
	@Data
	@TableName("t_ds_access_token")
	public class AccessToken {
	
	    /**
	     * primary key
	     */
	    @TableId(value = "id", type = IdType.AUTO)
	    private Integer id;
	    /**
	     * user_id
	     */
	    @TableField(value = "user_id")
	    private int userId;
	    /**
	     * token
	     */
	    @TableField(value = "token")
	    private String token;
	    /**
	     * expire_time
	     */
	    @TableField(value = "expire_time")
	    private Date expireTime;
	    /**
	     * create_time
	     */
	    @TableField(value = "create_time")
	    private Date createTime;
	    /**
	     * update_time
	     */
	    @TableField(value = "update_time")
	    private Date updateTime;
	    @TableField(exist = false)
	    private String userName;
	
	    @Override
	    public boolean equals(Object o) {
	        if (this == o) {
	            return true;
	        }
	        if (o == null || getClass() != o.getClass()) {
	            return false;
	        }
	        AccessToken that = (AccessToken) o;
	
	        if (!Objects.equals(id, that.id)) {
	            return false;
	        }
	        if (userId != that.userId) {
	            return false;
	        }
	        if (userName != null && !userName.equals(that.userName)) {
	            return false;
	        }
	        if (token != null && !token.equals(that.token)) {
	            return false;
	        }
	        if (expireTime != null && !expireTime.equals(that.expireTime)) {
	            return false;
	        }
	        if (createTime != null && !createTime.equals(that.createTime)) {
	            return false;
	        }
	        if (updateTime != null && !updateTime.equals(that.updateTime)) {
	            return false;
	        }
	        return true;
	    }
	
	    @Override
	    public int hashCode() {
	        int result = id;
	        result = 31 * result + userId;
	        result = 31 * result + (userName != null ? userName.hashCode() : 0);
	        result = 31 * result + (token != null ? token.hashCode() : 0);
	        result = 31 * result + (expireTime != null ? expireTime.hashCode() : 0);
	        result = 31 * result + (createTime != null ? createTime.hashCode() : 0);
	        result = 31 * result + (updateTime != null ? updateTime.hashCode() : 0);
	        return result;
	    }
	}
		
",
	role:"
	user	
",
,
	content:"
	//dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/controller/AuditLogController.java
	/*
	 * Licensed to the Apache Software Foundation (ASF) under one or more
	 * contributor license agreements.  See the NOTICE file distributed with
	 * this work for additional information regarding copyright ownership.
	 * The ASF licenses this file to You under the Apache License, Version 2.0
	 * (the "License"); you may not use this file except in compliance with
	 * the License.  You may obtain a copy of the License at
	 *
	 *    http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	package org.apache.dolphinscheduler.api.controller;
	
	import static org.apache.dolphinscheduler.api.enums.Status.QUERY_AUDIT_LOG_LIST_PAGING;
	
	import org.apache.dolphinscheduler.api.dto.AuditDto;
	import org.apache.dolphinscheduler.api.dto.auditLog.AuditModelTypeDto;
	import org.apache.dolphinscheduler.api.dto.auditLog.AuditOperationTypeDto;
	import org.apache.dolphinscheduler.api.exceptions.ApiException;
	import org.apache.dolphinscheduler.api.service.AuditService;
	import org.apache.dolphinscheduler.api.utils.PageInfo;
	import org.apache.dolphinscheduler.api.utils.Result;
	import org.apache.dolphinscheduler.common.constants.Constants;
	import org.apache.dolphinscheduler.dao.entity.User;
	
	import java.util.List;
	
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.http.HttpStatus;
	import org.springframework.web.bind.annotation.GetMapping;
	import org.springframework.web.bind.annotation.RequestAttribute;
	import org.springframework.web.bind.annotation.RequestMapping;
	import org.springframework.web.bind.annotation.RequestParam;
	import org.springframework.web.bind.annotation.ResponseStatus;
	import org.springframework.web.bind.annotation.RestController;
	
	import io.swagger.v3.oas.annotations.Operation;
	import io.swagger.v3.oas.annotations.Parameter;
	import io.swagger.v3.oas.annotations.Parameters;
	import io.swagger.v3.oas.annotations.media.Schema;
	import io.swagger.v3.oas.annotations.tags.Tag;
	
	@Tag(name = "AUDIT_LOG_TAG")
	@RestController
	@RequestMapping("projects/audit")
	public class AuditLogController extends BaseController {
	
	    @Autowired
	    AuditService auditService;
	
	    /**
	     * query audit log list paging
	     *
	     * @param loginUser         login user
	     * @param pageNo            page number
	     * @param pageSize          page size
	     * @param modelTypes        model types
	     * @param operationTypes    operation types
	     * @param userName          user name
	     * @param modelName         model name
	     * @param startDate         start time
	     * @param endDate           end time
	     * @return      audit log content
	     */
	    @Operation(summary = "queryAuditLogListPaging", description = "QUERY_AUDIT_LOG")
	    @Parameters({
	            @Parameter(name = "startDate", description = "START_DATE", schema = @Schema(implementation = String.class)),
	            @Parameter(name = "endDate", description = "END_DATE", schema = @Schema(implementation = String.class)),
	            @Parameter(name = "objectTypes", description = "MODEL_TYPES", schema = @Schema(implementation = String.class)),
	            @Parameter(name = "operationTypes", description = "OPERATION_TYPES", schema = @Schema(implementation = String.class)),
	            @Parameter(name = "userName", description = "USER_NAME", schema = @Schema(implementation = String.class)),
	            @Parameter(name = "objectName", description = "MODEL_NAME", schema = @Schema(implementation = String.class)),
	            @Parameter(name = "pageNo", description = "PAGE_NO", required = true, schema = @Schema(implementation = int.class, example = "1")),
	            @Parameter(name = "pageSize", description = "PAGE_SIZE", required = true, schema = @Schema(implementation = int.class, example = "20"))
	    })
	    @GetMapping(value = "/audit-log-list")
	    @ResponseStatus(HttpStatus.OK)
	    @ApiException(QUERY_AUDIT_LOG_LIST_PAGING)
	    public Result<PageInfo<AuditDto>> queryAuditLogListPaging(@Parameter(hidden = true) @RequestAttribute(value = Constants.SESSION_USER) User loginUser,
	                                                              @RequestParam("pageNo") Integer pageNo,
	                                                              @RequestParam("pageSize") Integer pageSize,
	                                                              @RequestParam(value = "modelTypes", required = false) String modelTypes,
	                                                              @RequestParam(value = "operationTypes", required = false) String operationTypes,
	                                                              @RequestParam(value = "startDate", required = false) String startDate,
	                                                              @RequestParam(value = "endDate", required = false) String endDate,
	                                                              @RequestParam(value = "userName", required = false) String userName,
	                                                              @RequestParam(value = "modelName", required = false) String modelName) {
	        checkPageParams(pageNo, pageSize);
	        PageInfo<AuditDto> auditDtoPageInfo = auditService.queryLogListPaging(
	                modelTypes,
	                operationTypes,
	                startDate,
	                endDate,
	                userName,
	                modelName,
	                pageNo,
	                pageSize);
	        return Result.success(auditDtoPageInfo);
	    }
	
	    /**
	     * query audit log operation type list
	     *
	     * @return object type list
	     */
	    @Operation(summary = "queryAuditOperationTypeList", description = "QUERY_AUDIT_OPERATION_TYPE_LIST")
	    @GetMapping(value = "/audit-log-operation-type")
	    @ResponseStatus(HttpStatus.OK)
	    @ApiException(QUERY_AUDIT_LOG_LIST_PAGING)
	    public Result<List<AuditOperationTypeDto>> queryAuditOperationTypeList() {
	        return Result.success(AuditOperationTypeDto.getOperationTypeDtoList());
	    }
	
	    /**
	     * query audit log model type list
	     *
	     * @return model type list
	     */
	    @Operation(summary = "queryAuditModelTypeList", description = "QUERY_AUDIT_MODEL_TYPE_LIST")
	    @GetMapping(value = "/audit-log-model-type")
	    @ResponseStatus(HttpStatus.OK)
	    @ApiException(QUERY_AUDIT_LOG_LIST_PAGING)
	    public Result<List<AuditModelTypeDto>> queryAuditModelTypeList() {
	        return Result.success(AuditModelTypeDto.getModelTypeDtoList());
	    }
	}
		
",
	role:"
	user	
",
,
	content:"
	//dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/SchedulerService.java
	/*
	 * Licensed to the Apache Software Foundation (ASF) under one or more
	 * contributor license agreements.  See the NOTICE file distributed with
	 * this work for additional information regarding copyright ownership.
	 * The ASF licenses this file to You under the Apache License, Version 2.0
	 * (the "License"); you may not use this file except in compliance with
	 * the License.  You may obtain a copy of the License at
	 *
	 *    http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	package org.apache.dolphinscheduler.api.service;
	
	import org.apache.dolphinscheduler.api.dto.schedule.ScheduleCreateRequest;
	import org.apache.dolphinscheduler.api.dto.schedule.ScheduleFilterRequest;
	import org.apache.dolphinscheduler.api.dto.schedule.ScheduleUpdateRequest;
	import org.apache.dolphinscheduler.api.utils.PageInfo;
	import org.apache.dolphinscheduler.api.utils.Result;
	import org.apache.dolphinscheduler.common.enums.FailureStrategy;
	import org.apache.dolphinscheduler.common.enums.Priority;
	import org.apache.dolphinscheduler.common.enums.WarningType;
	import org.apache.dolphinscheduler.dao.entity.Schedule;
	import org.apache.dolphinscheduler.dao.entity.User;
	
	import java.util.List;
	import java.util.Map;
	
	public interface SchedulerService {
	
	    /**
	     * save schedule
	     *
	     * @param loginUser login user
	     * @param projectCode project code
	     * @param workflowDefinitionCode workflow definition code
	     * @param schedule scheduler
	     * @param warningType warning type
	     * @param warningGroupId warning group id
	     * @param failureStrategy failure strategy
	     * @param workflowInstancePriority workflow instance priority
	     * @param workerGroup worker group
	     * @param tenantCode tenant code
	     * @param environmentCode environment code
	     * @return create result code
	     */
	    Map<String, Object> insertSchedule(User loginUser,
	                                       long projectCode,
	                                       long workflowDefinitionCode,
	                                       String schedule,
	                                       WarningType warningType,
	                                       int warningGroupId,
	                                       FailureStrategy failureStrategy,
	                                       Priority workflowInstancePriority,
	                                       String workerGroup,
	                                       String tenantCode,
	                                       Long environmentCode);
	
	    /**
	     * save schedule V2
	     *
	     * @param loginUser             login user
	     * @param scheduleCreateRequest the new schedule object will be created
	     * @return Schedule object
	     */
	    Schedule createSchedulesV2(User loginUser,
	                               ScheduleCreateRequest scheduleCreateRequest);
	
	    /**
	     * updateWorkflowInstance schedule
	     *
	     * @param loginUser login user
	     * @param projectCode project code
	     * @param id scheduler id
	     * @param scheduleExpression scheduler
	     * @param warningType warning type
	     * @param warningGroupId warning group id
	     * @param failureStrategy failure strategy
	     * @param workerGroup worker group
	     * @param tenantCode tenant code
	     * @param environmentCode environment code
	     * @param workflowInstancePriority workflow instance priority
	     * @return update result code
	     */
	    Map<String, Object> updateSchedule(User loginUser,
	                                       long projectCode,
	                                       Integer id,
	                                       String scheduleExpression,
	                                       WarningType warningType,
	                                       int warningGroupId,
	                                       FailureStrategy failureStrategy,
	                                       Priority workflowInstancePriority,
	                                       String workerGroup,
	                                       String tenantCode,
	                                       Long environmentCode);
	
	    /**
	     * update schedule object V2
	     *
	     * @param loginUser login user
	     * @param scheduleId scheduler id
	     * @param scheduleUpdateRequest the schedule object will be updated
	     * @return Schedule object
	     */
	    Schedule updateSchedulesV2(User loginUser,
	                               Integer scheduleId,
	                               ScheduleUpdateRequest scheduleUpdateRequest);
	
	    /**
	     * get schedule object
	     *
	     * @param loginUser login user
	     * @param scheduleId scheduler id
	     * @return Schedule object
	     */
	    Schedule getSchedule(User loginUser,
	                         Integer scheduleId);
	
	    /**
	     * query schedule
	     *
	     * @param loginUser login user
	     * @param projectCode project code
	     * @param workflowDefinitionCode workflow definition code
	     * @param pageNo page number
	     * @param pageSize page size
	     * @param searchVal search value
	     * @return schedule list page
	     */
	    Result querySchedule(User loginUser, long projectCode, long workflowDefinitionCode, String searchVal,
	                         Integer pageNo, Integer pageSize);
	
	    List<Schedule> queryScheduleByWorkflowDefinitionCodes(List<Long> workflowDefinitionCodes);
	
	    /**
	     * query schedule V2
	     *
	     * @param loginUser login user
	     * @param scheduleFilterRequest schedule filter request
	     * @return schedule list page
	     */
	    PageInfo<Schedule> filterSchedules(User loginUser,
	                                       ScheduleFilterRequest scheduleFilterRequest);
	
	    /**
	     * query schedule list
	     *
	     * @param loginUser   login user
	     * @param projectCode project code
	     * @return schedule list
	     */
	    Map<String, Object> queryScheduleList(User loginUser, long projectCode);
	
	    /**
	     * delete schedule by id
	     *
	     * @param loginUser login user
	     * @param scheduleId schedule id
	     */
	    void deleteSchedulesById(User loginUser, Integer scheduleId);
	
	    /**
	     * preview schedule
	     *
	     * @param loginUser login user
	     * @param schedule schedule expression
	     * @return the next five fire time
	     */
	    Map<String, Object> previewSchedule(User loginUser, String schedule);
	
	    /**
	     * update workflow definition schedule
	     *
	     * @param loginUser login user
	     * @param projectCode project code
	     * @param workflowDefinitionCode workflow definition code
	     * @param scheduleExpression scheduleExpression
	     * @param warningType warning type
	     * @param warningGroupId warning group id
	     * @param failureStrategy failure strategy
	     * @param workerGroup worker group
	     * @param tenantCode tenant code
	     * @param workflowInstancePriority workflow instance priority
	     * @return update result code
	     */
	    Map<String, Object> updateScheduleByWorkflowDefinitionCode(User loginUser,
	                                                               long projectCode,
	                                                               long workflowDefinitionCode,
	                                                               String scheduleExpression,
	                                                               WarningType warningType,
	                                                               int warningGroupId,
	                                                               FailureStrategy failureStrategy,
	                                                               Priority workflowInstancePriority,
	                                                               String workerGroup,
	                                                               String tenantCode,
	                                                               long environmentCode);
	
	    /**
	     * Online the scheduler by scheduler id, if the related workflow definition is not online will throw exception.
	     */
	    void onlineScheduler(User loginUser, Long projectCode, Integer schedulerId);
	
	    /**
	     * Do online scheduler by workflow code, this method will not do permission check.
	     */
	    void onlineSchedulerByWorkflowCode(Long workflowDefinitionCode);
	
	    /**
	     * Offline the scheduler by scheduler id, will not offline the related workflow definition.
	     */
	    void offlineScheduler(User loginUser, Long projectCode, Integer schedulerId);
	
	    /**
	     * Do offline scheduler by workflow code, this method will not do permission check.
	     */
	    void offlineSchedulerByWorkflowCode(Long workflowDefinitionCode);
	}
		
",
	role:"
	user	
",
,
	content:"
	//dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/impl/SchedulerServiceImpl.java
	/*
	 * Licensed to the Apache Software Foundation (ASF) under one or more
	 * contributor license agreements.  See the NOTICE file distributed with
	 * this work for additional information regarding copyright ownership.
	 * The ASF licenses this file to You under the Apache License, Version 2.0
	 * (the "License"); you may not use this file except in compliance with
	 * the License.  You may obtain a copy of the License at
	 *
	 *    http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	package org.apache.dolphinscheduler.api.service.impl;
	
	import static org.apache.dolphinscheduler.api.constants.ApiFuncIdentificationConstant.PROJECT;
	import static org.apache.dolphinscheduler.api.constants.ApiFuncIdentificationConstant.WORKFLOW_ONLINE_OFFLINE;
	
	import org.apache.dolphinscheduler.api.dto.ScheduleParam;
	import org.apache.dolphinscheduler.api.dto.schedule.ScheduleCreateRequest;
	import org.apache.dolphinscheduler.api.dto.schedule.ScheduleFilterRequest;
	import org.apache.dolphinscheduler.api.dto.schedule.ScheduleUpdateRequest;
	import org.apache.dolphinscheduler.api.enums.Status;
	import org.apache.dolphinscheduler.api.exceptions.ServiceException;
	import org.apache.dolphinscheduler.api.service.ExecutorService;
	import org.apache.dolphinscheduler.api.service.ProjectService;
	import org.apache.dolphinscheduler.api.service.SchedulerService;
	import org.apache.dolphinscheduler.api.utils.PageInfo;
	import org.apache.dolphinscheduler.api.utils.Result;
	import org.apache.dolphinscheduler.api.vo.ScheduleVO;
	import org.apache.dolphinscheduler.common.constants.Constants;
	import org.apache.dolphinscheduler.common.enums.FailureStrategy;
	import org.apache.dolphinscheduler.common.enums.Priority;
	import org.apache.dolphinscheduler.common.enums.ReleaseState;
	import org.apache.dolphinscheduler.common.enums.UserType;
	import org.apache.dolphinscheduler.common.enums.WarningType;
	import org.apache.dolphinscheduler.common.utils.DateUtils;
	import org.apache.dolphinscheduler.common.utils.JSONUtils;
	import org.apache.dolphinscheduler.dao.entity.Environment;
	import org.apache.dolphinscheduler.dao.entity.Project;
	import org.apache.dolphinscheduler.dao.entity.Schedule;
	import org.apache.dolphinscheduler.dao.entity.Tenant;
	import org.apache.dolphinscheduler.dao.entity.User;
	import org.apache.dolphinscheduler.dao.entity.WorkflowDefinition;
	import org.apache.dolphinscheduler.dao.mapper.EnvironmentMapper;
	import org.apache.dolphinscheduler.dao.mapper.ProjectMapper;
	import org.apache.dolphinscheduler.dao.mapper.ScheduleMapper;
	import org.apache.dolphinscheduler.dao.mapper.TenantMapper;
	import org.apache.dolphinscheduler.dao.mapper.WorkflowDefinitionMapper;
	import org.apache.dolphinscheduler.scheduler.api.SchedulerApi;
	import org.apache.dolphinscheduler.service.cron.CronUtils;
	import org.apache.dolphinscheduler.service.exceptions.CronParseException;
	
	import org.apache.commons.collections4.CollectionUtils;
	import org.apache.commons.lang3.StringUtils;
	
	import java.lang.reflect.InvocationTargetException;
	import java.time.ZoneId;
	import java.time.ZonedDateTime;
	import java.util.ArrayList;
	import java.util.Collections;
	import java.util.Date;
	import java.util.HashMap;
	import java.util.List;
	import java.util.Map;
	import java.util.TimeZone;
	import java.util.stream.Collectors;
	
	import lombok.NonNull;
	import lombok.extern.slf4j.Slf4j;
	
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.stereotype.Service;
	import org.springframework.transaction.annotation.Transactional;
	
	import com.baomidou.mybatisplus.core.metadata.IPage;
	import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
	import com.cronutils.model.Cron;
	
	@Service
	@Slf4j
	public class SchedulerServiceImpl extends BaseServiceImpl implements SchedulerService {
	
	    @Autowired
	    private ProjectService projectService;
	
	    @Autowired
	    private ExecutorService executorService;
	
	    @Autowired
	    private ScheduleMapper scheduleMapper;
	
	    @Autowired
	    private ProjectMapper projectMapper;
	
	    @Autowired
	    private WorkflowDefinitionMapper workflowDefinitionMapper;
	
	    @Autowired
	    private SchedulerApi schedulerApi;
	
	    @Autowired
	    private EnvironmentMapper environmentMapper;
	
	    @Autowired
	    private TenantMapper tenantMapper;
	
	    /**
	     * save schedule
	     *
	     * @param loginUser               login user
	     * @param projectCode             project name
	     * @param workflowDefinitionCode       workflow definition code
	     * @param schedule                scheduler
	     * @param warningType             warning type
	     * @param warningGroupId          warning group id
	     * @param failureStrategy         failure strategy
	     * @param workflowInstancePriority workflow instance priority
	     * @param workerGroup             worker group
	     * @param tenantCode              tenant code
	     * @param environmentCode         environment code
	     * @return create result code
	     */
	    @Override
	    @Transactional
	    public Map<String, Object> insertSchedule(User loginUser,
	                                              long projectCode,
	                                              long workflowDefinitionCode,
	                                              String schedule,
	                                              WarningType warningType,
	                                              int warningGroupId,
	                                              FailureStrategy failureStrategy,
	                                              Priority workflowInstancePriority,
	                                              String workerGroup,
	                                              String tenantCode,
	                                              Long environmentCode) {
	
	        Map<String, Object> result = new HashMap<>();
	
	        Project project = projectMapper.queryByCode(projectCode);
	
	        // check project auth
	        boolean hasProjectAndPerm = projectService.hasProjectAndPerm(loginUser, project, result, null);
	        if (!hasProjectAndPerm) {
	            return result;
	        }
	
	        // check workflow define release state
	        WorkflowDefinition workflowDefinition = workflowDefinitionMapper.queryByCode(workflowDefinitionCode);
	        executorService.checkWorkflowDefinitionValid(projectCode, workflowDefinition, workflowDefinitionCode,
	                workflowDefinition.getVersion());
	
	        Schedule scheduleExists =
	                scheduleMapper.queryByWorkflowDefinitionCode(workflowDefinitionCode);
	        if (scheduleExists != null) {
	            log.error("Schedule already exist, scheduleId:{}, workflowDefinitionCode:{}", scheduleExists.getId(),
	                    workflowDefinitionCode);
	            putMsg(result, Status.SCHEDULE_ALREADY_EXISTS, workflowDefinitionCode, scheduleExists.getId());
	            return result;
	        }
	
	        Schedule scheduleObj = new Schedule();
	        Date now = new Date();
	
	        checkValidTenant(tenantCode);
	
	        scheduleObj.setTenantCode(tenantCode);
	        scheduleObj.setProjectName(project.getName());
	        scheduleObj.setWorkflowDefinitionCode(workflowDefinitionCode);
	        scheduleObj.setWorkflowDefinitionName(workflowDefinition.getName());
	
	        ScheduleParam scheduleParam = JSONUtils.parseObject(schedule, ScheduleParam.class);
	        if (DateUtils.differSec(scheduleParam.getStartTime(), scheduleParam.getEndTime()) == 0) {
	            log.warn("The start time must not be the same as the end or time can not be null.");
	            putMsg(result, Status.SCHEDULE_START_TIME_END_TIME_SAME);
	            return result;
	        }
	        if (scheduleParam.getStartTime().getTime() > scheduleParam.getEndTime().getTime()) {
	            log.warn("The start time must smaller than end time");
	            putMsg(result, Status.START_TIME_BIGGER_THAN_END_TIME_ERROR);
	            return result;
	        }
	
	        scheduleObj.setStartTime(scheduleParam.getStartTime());
	        scheduleObj.setEndTime(scheduleParam.getEndTime());
	        if (!CronUtils.isValidExpression(scheduleParam.getCrontab())) {
	            log.error("Schedule crontab verify failure, crontab:{}.", scheduleParam.getCrontab());
	            putMsg(result, Status.REQUEST_PARAMS_NOT_VALID_ERROR, scheduleParam.getCrontab());
	            return result;
	        }
	        scheduleObj.setCrontab(scheduleParam.getCrontab());
	        scheduleObj.setTimezoneId(scheduleParam.getTimezoneId());
	        scheduleObj.setWarningType(warningType);
	        scheduleObj.setWarningGroupId(warningGroupId);
	        scheduleObj.setFailureStrategy(failureStrategy);
	        scheduleObj.setCreateTime(now);
	        scheduleObj.setUpdateTime(now);
	        scheduleObj.setUserId(loginUser.getId());
	        scheduleObj.setUserName(loginUser.getUserName());
	        scheduleObj.setReleaseState(ReleaseState.OFFLINE);
	        scheduleObj.setWorkflowInstancePriority(workflowInstancePriority);
	        scheduleObj.setWorkerGroup(workerGroup);
	        scheduleObj.setEnvironmentCode(environmentCode);
	        scheduleMapper.insert(scheduleObj);
	
	        /**
	         * updateWorkflowInstance receivers and cc by workflow definition id
	         */
	        workflowDefinition.setWarningGroupId(warningGroupId);
	        workflowDefinitionMapper.updateById(workflowDefinition);
	
	        // return scheduler object with ID
	        result.put(Constants.DATA_LIST, scheduleMapper.selectById(scheduleObj.getId()));
	        putMsg(result, Status.SUCCESS);
	        log.info("Schedule create complete, projectCode:{}, workflowDefinitionCode:{}, scheduleId:{}.",
	                projectCode, workflowDefinitionCode, scheduleObj.getId());
	        result.put("scheduleId", scheduleObj.getId());
	        return result;
	    }
	
	    protected void projectPermCheckByWorkflowCode(User loginUser, long workflowDefinitionCode) {
	        WorkflowDefinition workflowDefinition = workflowDefinitionMapper.queryByCode(workflowDefinitionCode);
	        if (workflowDefinition == null) {
	            throw new ServiceException(Status.WORKFLOW_DEFINITION_NOT_EXIST, workflowDefinitionCode);
	        }
	        Project project = projectMapper.queryByCode(workflowDefinition.getProjectCode());
	        // check project auth
	        this.projectService.checkProjectAndAuthThrowException(loginUser, project, null);
	    }
	
	    private void scheduleParamCheck(String scheduleParamStr) {
	        ScheduleParam scheduleParam = JSONUtils.parseObject(scheduleParamStr, ScheduleParam.class);
	        if (scheduleParam == null) {
	            throw new ServiceException(Status.PARSE_SCHEDULE_PARAM_ERROR, scheduleParamStr);
	        }
	        if (DateUtils.differSec(scheduleParam.getStartTime(), scheduleParam.getEndTime()) == 0) {
	            throw new ServiceException(Status.SCHEDULE_START_TIME_END_TIME_SAME);
	        }
	        if (scheduleParam.getStartTime().getTime() > scheduleParam.getEndTime().getTime()) {
	            throw new ServiceException(Status.START_TIME_BIGGER_THAN_END_TIME_ERROR);
	        }
	        if (!CronUtils.isValidExpression(scheduleParam.getCrontab())) {
	            throw new ServiceException(Status.SCHEDULE_CRON_CHECK_FAILED, scheduleParam.getCrontab());
	        }
	    }
	
	    /**
	     * save schedule V2, will also change workflow definition's warningGroupId if schedule's warningGroupId be set
	     *
	     * @param loginUser               login user
	     * @param scheduleCreateRequest   schedule create object
	     * @return Schedule object just be created
	     */
	    @Override
	    @Transactional
	    public Schedule createSchedulesV2(User loginUser,
	                                      ScheduleCreateRequest scheduleCreateRequest) {
	        this.projectPermCheckByWorkflowCode(loginUser, scheduleCreateRequest.getWorkflowDefinitionCode());
	
	        WorkflowDefinition workflowDefinition =
	                workflowDefinitionMapper.queryByCode(scheduleCreateRequest.getWorkflowDefinitionCode());
	
	        // check workflow define release state
	        executorService.checkWorkflowDefinitionValid(workflowDefinition.getProjectCode(), workflowDefinition,
	                workflowDefinition.getCode(), workflowDefinition.getVersion());
	
	        Schedule scheduleExists =
	                scheduleMapper.queryByWorkflowDefinitionCode(scheduleCreateRequest.getWorkflowDefinitionCode());
	        if (scheduleExists != null) {
	            throw new ServiceException(Status.SCHEDULE_ALREADY_EXISTS,
	                    scheduleCreateRequest.getWorkflowDefinitionCode(),
	                    scheduleExists.getId());
	        }
	
	        checkValidTenant(scheduleCreateRequest.getTenantCode());
	
	        Schedule schedule = scheduleCreateRequest.convert2Schedule();
	        Environment environment = environmentMapper.queryByEnvironmentCode(schedule.getEnvironmentCode());
	        if (environment == null) {
	            throw new ServiceException(Status.QUERY_ENVIRONMENT_BY_CODE_ERROR, schedule.getEnvironmentCode());
	        }
	
	        schedule.setUserId(loginUser.getId());
	        // give more detail when return schedule object
	        schedule.setUserName(loginUser.getUserName());
	        schedule.setWorkflowDefinitionName(workflowDefinition.getName());
	
	        this.scheduleParamCheck(scheduleCreateRequest.getScheduleParam());
	        int create = scheduleMapper.insert(schedule);
	        if (create <= 0) {
	            throw new ServiceException(Status.CREATE_SCHEDULE_ERROR);
	        }
	        // updateWorkflowInstance receivers and cc by workflow definition id
	        workflowDefinition.setWarningGroupId(schedule.getWarningGroupId());
	        workflowDefinitionMapper.updateById(workflowDefinition);
	        return schedule;
	    }
	
	    /**
	     * updateWorkflowInstance schedule
	     *
	     * @param loginUser               login user
	     * @param projectCode             project code
	     * @param id                      scheduler id
	     * @param scheduleExpression      scheduler
	     * @param warningType             warning type
	     * @param warningGroupId          warning group id
	     * @param failureStrategy         failure strategy
	     * @param workerGroup             worker group
	     * @param tenantCode              tenant code
	     * @param environmentCode         environment code
	     * @param workflowInstancePriority workflow instance priority
	     * @return update result code
	     */
	    @Override
	    @Transactional
	    public Map<String, Object> updateSchedule(User loginUser,
	                                              long projectCode,
	                                              Integer id,
	                                              String scheduleExpression,
	                                              WarningType warningType,
	                                              int warningGroupId,
	                                              FailureStrategy failureStrategy,
	                                              Priority workflowInstancePriority,
	                                              String workerGroup,
	                                              String tenantCode,
	                                              Long environmentCode) {
	        Map<String, Object> result = new HashMap<>();
	
	        Project project = projectMapper.queryByCode(projectCode);
	
	        // check project auth
	        boolean hasProjectAndPerm = projectService.hasProjectAndPerm(loginUser, project, result, null);
	        if (!hasProjectAndPerm) {
	            return result;
	        }
	
	        // check schedule exists
	        Schedule schedule = scheduleMapper.selectById(id);
	
	        if (schedule == null) {
	            log.error("Schedule does not exist, scheduleId:{}.", id);
	            putMsg(result, Status.SCHEDULE_NOT_EXISTS, id);
	            return result;
	        }
	
	        WorkflowDefinition workflowDefinition =
	                workflowDefinitionMapper.queryByCode(schedule.getWorkflowDefinitionCode());
	        if (workflowDefinition == null || projectCode != workflowDefinition.getProjectCode()) {
	            log.error("workflow definition does not exist, workflowDefinitionCode:{}.",
	                    schedule.getWorkflowDefinitionCode());
	            putMsg(result, Status.WORKFLOW_DEFINITION_NOT_EXIST, String.valueOf(schedule.getWorkflowDefinitionCode()));
	            return result;
	        }
	
	        updateSchedule(result, schedule, workflowDefinition, scheduleExpression, warningType, warningGroupId,
	                failureStrategy, workflowInstancePriority, workerGroup, tenantCode, environmentCode);
	        return result;
	    }
	
	    /**
	     * update schedule object V2
	     *
	     * @param loginUser login user
	     * @param scheduleId scheduler id
	     * @param scheduleUpdateRequest the schedule object will be updated
	     * @return Schedule object
	     */
	    @Override
	    @Transactional
	    public Schedule updateSchedulesV2(User loginUser,
	                                      Integer scheduleId,
	                                      ScheduleUpdateRequest scheduleUpdateRequest) {
	        Schedule schedule = scheduleMapper.selectById(scheduleId);
	        if (schedule == null) {
	            throw new ServiceException(Status.SCHEDULE_NOT_EXISTS, scheduleId);
	        }
	
	        Schedule scheduleUpdate;
	        try {
	            scheduleUpdate = scheduleUpdateRequest.mergeIntoSchedule(schedule);
	            // check update params
	            this.scheduleParamCheck(scheduleUpdateRequest.updateScheduleParam(scheduleUpdate));
	        } catch (InvocationTargetException | IllegalAccessException | InstantiationException
	                | NoSuchMethodException e) {
	            throw new ServiceException(Status.REQUEST_PARAMS_NOT_VALID_ERROR, scheduleUpdateRequest.toString());
	        }
	        // check update params
	        this.projectPermCheckByWorkflowCode(loginUser, scheduleUpdate.getWorkflowDefinitionCode());
	
	        if (scheduleUpdate.getEnvironmentCode() != null) {
	            Environment environment = environmentMapper.queryByEnvironmentCode(scheduleUpdate.getEnvironmentCode());
	            if (environment == null) {
	                throw new ServiceException(Status.QUERY_ENVIRONMENT_BY_CODE_ERROR, scheduleUpdate.getEnvironmentCode());
	            }
	        }
	
	        int update = scheduleMapper.updateById(scheduleUpdate);
	        if (update <= 0) {
	            throw new ServiceException(Status.UPDATE_SCHEDULE_ERROR);
	        }
	        return scheduleUpdate;
	    }
	
	    /**
	     * get schedule object
	     *
	     * @param loginUser login user
	     * @param scheduleId scheduler id
	     * @return Schedule object
	     */
	    @Override
	    @Transactional
	    public Schedule getSchedule(User loginUser,
	                                Integer scheduleId) {
	        Schedule schedule = scheduleMapper.selectById(scheduleId);
	        if (schedule == null) {
	            throw new ServiceException(Status.SCHEDULE_NOT_EXISTS, scheduleId);
	        }
	        this.projectPermCheckByWorkflowCode(loginUser, schedule.getWorkflowDefinitionCode());
	        return schedule;
	    }
	
	    /**
	     * query schedule
	     *
	     * @param loginUser         login user
	     * @param projectCode       project code
	     * @param workflowDefinitionCode workflow definition code
	     * @param pageNo            page number
	     * @param pageSize          page size
	     * @param searchVal         search value
	     * @return schedule list page
	     */
	    @Override
	    public Result querySchedule(User loginUser, long projectCode, long workflowDefinitionCode, String searchVal,
	                                Integer pageNo, Integer pageSize) {
	        Result result = new Result();
	
	        Project project = projectMapper.queryByCode(projectCode);
	
	        // check project auth
	        boolean hasProjectAndPerm = projectService.hasProjectAndPerm(loginUser, project, result, PROJECT);
	        if (!hasProjectAndPerm) {
	            return result;
	        }
	
	        if (workflowDefinitionCode != 0) {
	            WorkflowDefinition workflowDefinition = workflowDefinitionMapper.queryByCode(workflowDefinitionCode);
	            if (workflowDefinition == null || projectCode != workflowDefinition.getProjectCode()) {
	                log.error("workflow definition does not exist, workflowDefinitionCode:{}.", workflowDefinitionCode);
	                putMsg(result, Status.WORKFLOW_DEFINITION_NOT_EXIST, String.valueOf(workflowDefinitionCode));
	                return result;
	            }
	        }
	
	        Page<Schedule> page = new Page<>(pageNo, pageSize);
	
	        IPage<Schedule> schedulePage =
	                scheduleMapper.queryByProjectAndWorkflowDefinitionCodePaging(page, projectCode, workflowDefinitionCode,
	                        searchVal);
	
	        List<ScheduleVO> scheduleList = new ArrayList<>();
	        for (Schedule schedule : schedulePage.getRecords()) {
	            scheduleList.add(new ScheduleVO(schedule));
	        }
	
	        PageInfo<ScheduleVO> pageInfo = new PageInfo<>(pageNo, pageSize);
	        pageInfo.setTotal((int) schedulePage.getTotal());
	        pageInfo.setTotalList(scheduleList);
	        result.setData(pageInfo);
	        putMsg(result, Status.SUCCESS);
	        return result;
	    }
	
	    public List<Schedule> queryScheduleByWorkflowDefinitionCodes(@NonNull List<Long> workflowDefinitionCodes) {
	        if (CollectionUtils.isEmpty(workflowDefinitionCodes)) {
	            return Collections.emptyList();
	        }
	        return scheduleMapper.querySchedulesByWorkflowDefinitionCodes(workflowDefinitionCodes);
	    }
	
	    /**
	     * query schedule
	     *
	     * @param loginUser login user
	     * @param scheduleFilterRequest schedule filter request
	     * @return schedule list page
	     */
	    @Override
	    @Transactional
	    public PageInfo<Schedule> filterSchedules(User loginUser,
	                                              ScheduleFilterRequest scheduleFilterRequest) {
	        if (scheduleFilterRequest.getProjectName() != null) {
	            Project project = projectMapper.queryByName(scheduleFilterRequest.getProjectName());
	            // check project auth
	            projectService.checkProjectAndAuthThrowException(loginUser, project, null);
	        }
	        Page<Schedule> page = new Page<>(scheduleFilterRequest.getPageNo(), scheduleFilterRequest.getPageSize());
	        IPage<Schedule> scheduleIPage = scheduleMapper.filterSchedules(page, scheduleFilterRequest.convert2Schedule());
	
	        PageInfo<Schedule> pageInfo =
	                new PageInfo<>(scheduleFilterRequest.getPageNo(), scheduleFilterRequest.getPageSize());
	        pageInfo.setTotal((int) scheduleIPage.getTotal());
	        pageInfo.setTotalList(scheduleIPage.getRecords());
	
	        return pageInfo;
	    }
	
	    /**
	     * query schedule list
	     *
	     * @param loginUser   login user
	     * @param projectCode project code
	     * @return schedule list
	     */
	    @Override
	    public Map<String, Object> queryScheduleList(User loginUser, long projectCode) {
	        Map<String, Object> result = new HashMap<>();
	        Project project = projectMapper.queryByCode(projectCode);
	
	        // check project auth
	        boolean hasProjectAndPerm = projectService.hasProjectAndPerm(loginUser, project, result, null);
	        if (!hasProjectAndPerm) {
	            return result;
	        }
	
	        List<Schedule> schedules = scheduleMapper.querySchedulerListByProjectName(project.getName());
	        List<ScheduleVO> scheduleList = new ArrayList<>();
	        for (Schedule schedule : schedules) {
	            scheduleList.add(new ScheduleVO(schedule));
	        }
	
	        result.put(Constants.DATA_LIST, scheduleList);
	        putMsg(result, Status.SUCCESS);
	
	        return result;
	    }
	
	    /**
	     * check valid
	     *
	     * @param result result
	     * @param bool   bool
	     * @param status status
	     * @return check result code
	     */
	    private boolean checkValid(Map<String, Object> result, boolean bool, Status status) {
	        // timeout is valid
	        if (bool) {
	            putMsg(result, status);
	            return true;
	        }
	        return false;
	    }
	
	    /**
	     * delete schedule by id
	     *
	     * @param loginUser   login user
	     * @param scheduleId  schedule id
	     */
	    @Override
	    public void deleteSchedulesById(User loginUser, Integer scheduleId) {
	        Schedule schedule = scheduleMapper.selectById(scheduleId);
	        if (schedule == null) {
	            throw new ServiceException(Status.SCHEDULE_NOT_EXISTS, scheduleId);
	        }
	        // check schedule is already online
	        if (schedule.getReleaseState() == ReleaseState.ONLINE) {
	            throw new ServiceException(Status.SCHEDULE_STATE_ONLINE, scheduleId);
	        }
	        // Determine if the login user is the owner of the schedule
	        if (loginUser.getId() != schedule.getUserId() && loginUser.getUserType() != UserType.ADMIN_USER) {
	            throw new ServiceException(Status.USER_NO_OPERATION_PERM);
	        }
	
	        this.projectPermCheckByWorkflowCode(loginUser, schedule.getWorkflowDefinitionCode());
	        int delete = scheduleMapper.deleteById(scheduleId);
	        if (delete <= 0) {
	            throw new ServiceException(Status.DELETE_SCHEDULE_BY_ID_ERROR);
	        }
	    }
	
	    /**
	     * preview schedule
	     *
	     * @param loginUser login user
	     * @param schedule  schedule expression
	     * @return the next five fire time
	     */
	    @Override
	    public Map<String, Object> previewSchedule(User loginUser, String schedule) {
	        Map<String, Object> result = new HashMap<>();
	        Cron cron;
	        ScheduleParam scheduleParam = JSONUtils.parseObject(schedule, ScheduleParam.class);
	
	        assert scheduleParam != null;
	        ZoneId zoneId = TimeZone.getTimeZone(scheduleParam.getTimezoneId()).toZoneId();
	        ZonedDateTime now = ZonedDateTime.now(zoneId);
	        ZonedDateTime startTime = ZonedDateTime.ofInstant(scheduleParam.getStartTime().toInstant(), zoneId);
	        ZonedDateTime endTime = ZonedDateTime.ofInstant(scheduleParam.getEndTime().toInstant(), zoneId);
	        startTime = now.isAfter(startTime) ? now : startTime;
	
	        try {
	            cron = CronUtils.parse2Cron(scheduleParam.getCrontab());
	        } catch (CronParseException e) {
	            log.error("Parse cron to cron expression error, crontab:{}.", scheduleParam.getCrontab(), e);
	            putMsg(result, Status.PARSE_TO_CRON_EXPRESSION_ERROR);
	            return result;
	        }
	        List<ZonedDateTime> selfFireDateList =
	                CronUtils.getSelfFireDateList(startTime, endTime, cron, Constants.PREVIEW_SCHEDULE_EXECUTE_COUNT);
	        List<String> previewDateList =
	                selfFireDateList.stream().map(t -> DateUtils.dateToString(t, zoneId)).collect(Collectors.toList());
	        result.put(Constants.DATA_LIST, previewDateList);
	        putMsg(result, Status.SUCCESS);
	        return result;
	    }
	
	    /**
	     * update workflow definition schedule
	     *
	     * @param loginUser               login user
	     * @param projectCode             project code
	     * @param workflowDefinitionCode   workflow definition code
	     * @param scheduleExpression      scheduleExpression
	     * @param warningType             warning type
	     * @param warningGroupId          warning group id
	     * @param failureStrategy         failure strategy
	     * @param workerGroup             worker group
	     * @param tenantCode              tenant code
	     * @param workflowInstancePriority workflow instance priority
	     * @return update result code
	     */
	    @Override
	    public Map<String, Object> updateScheduleByWorkflowDefinitionCode(User loginUser,
	                                                                      long projectCode,
	                                                                      long workflowDefinitionCode,
	                                                                      String scheduleExpression,
	                                                                      WarningType warningType,
	                                                                      int warningGroupId,
	                                                                      FailureStrategy failureStrategy,
	                                                                      Priority workflowInstancePriority,
	                                                                      String workerGroup,
	                                                                      String tenantCode,
	                                                                      long environmentCode) {
	        Project project = projectMapper.queryByCode(projectCode);
	        // check user access for project
	        Map<String, Object> result = projectService.checkProjectAndAuth(loginUser, project, projectCode, null);
	        if (result.get(Constants.STATUS) != Status.SUCCESS) {
	            return result;
	        }
	        // check schedule exists
	        Schedule schedule = scheduleMapper.queryByWorkflowDefinitionCode(workflowDefinitionCode);
	        if (schedule == null) {
	            log.error("Schedule of workflow definition does not exist, workflowDefinitionCode:{}.",
	                    workflowDefinitionCode);
	            putMsg(result, Status.SCHEDULE_CRON_NOT_EXISTS, workflowDefinitionCode);
	            return result;
	        }
	
	        WorkflowDefinition workflowDefinition = workflowDefinitionMapper.queryByCode(workflowDefinitionCode);
	        if (workflowDefinition == null || projectCode != workflowDefinition.getProjectCode()) {
	            log.error("workflow definition does not exist, workflowDefinitionCode:{}.", workflowDefinitionCode);
	            putMsg(result, Status.WORKFLOW_DEFINITION_NOT_EXIST, String.valueOf(workflowDefinitionCode));
	            return result;
	        }
	
	        updateSchedule(result, schedule, workflowDefinition, scheduleExpression, warningType, warningGroupId,
	                failureStrategy, workflowInstancePriority, workerGroup, tenantCode, environmentCode);
	        return result;
	    }
	
	    @Transactional
	    @Override
	    public void onlineScheduler(User loginUser, Long projectCode, Integer schedulerId) {
	        projectService.checkProjectAndAuthThrowException(loginUser, projectCode, WORKFLOW_ONLINE_OFFLINE);
	        Schedule schedule = scheduleMapper.selectById(schedulerId);
	        doOnlineScheduler(schedule);
	    }
	
	    @Transactional
	    @Override
	    public void onlineSchedulerByWorkflowCode(Long workflowDefinitionCode) {
	        Schedule schedule = scheduleMapper.queryByWorkflowDefinitionCode(workflowDefinitionCode);
	        doOnlineScheduler(schedule);
	    }
	
	    private void doOnlineScheduler(Schedule schedule) {
	        if (schedule == null) {
	            return;
	        }
	        if (ReleaseState.ONLINE.equals(schedule.getReleaseState())) {
	            log.debug("The schedule is already online, scheduleId:{}.", schedule.getId());
	            return;
	        }
	        WorkflowDefinition workflowDefinition =
	                workflowDefinitionMapper.queryByCode(schedule.getWorkflowDefinitionCode());
	        if (!ReleaseState.ONLINE.equals(workflowDefinition.getReleaseState())) {
	            throw new ServiceException(Status.WORKFLOW_DEFINITION_NOT_RELEASE, workflowDefinition.getName());
	        }
	
	        schedule.setReleaseState(ReleaseState.ONLINE);
	        scheduleMapper.updateById(schedule);
	
	        Project project = projectMapper.queryByCode(workflowDefinition.getProjectCode());
	        schedulerApi.insertOrUpdateScheduleTask(project.getId(), schedule);
	    }
	
	    @Transactional
	    @Override
	    public void offlineScheduler(User loginUser, Long projectCode, Integer schedulerId) {
	        projectService.checkProjectAndAuthThrowException(loginUser, projectCode, WORKFLOW_ONLINE_OFFLINE);
	        Schedule schedule = scheduleMapper.selectById(schedulerId);
	        doOfflineScheduler(schedule);
	    }
	
	    @Transactional
	    @Override
	    public void offlineSchedulerByWorkflowCode(Long workflowDefinitionCode) {
	        Schedule schedule = scheduleMapper.queryByWorkflowDefinitionCode(workflowDefinitionCode);
	        doOfflineScheduler(schedule);
	    }
	
	    private void doOfflineScheduler(Schedule schedule) {
	        if (schedule == null) {
	            return;
	        }
	        if (ReleaseState.OFFLINE.equals(schedule.getReleaseState())) {
	            log.debug("The schedule is already offline, scheduleId:{}.", schedule.getId());
	            return;
	        }
	        schedule.setReleaseState(ReleaseState.OFFLINE);
	        scheduleMapper.updateById(schedule);
	        WorkflowDefinition workflowDefinition =
	                workflowDefinitionMapper.queryByCode(schedule.getWorkflowDefinitionCode());
	        Project project = projectMapper.queryByCode(workflowDefinition.getProjectCode());
	        schedulerApi.deleteScheduleTask(project.getId(), schedule.getId());
	    }
	
	    private void updateSchedule(Map<String, Object> result, Schedule schedule, WorkflowDefinition workflowDefinition,
	                                String scheduleExpression, WarningType warningType, int warningGroupId,
	                                FailureStrategy failureStrategy, Priority workflowInstancePriority, String workerGroup,
	                                String tenantCode,
	                                long environmentCode) {
	        if (checkValid(result, schedule.getReleaseState() == ReleaseState.ONLINE,
	                Status.SCHEDULE_CRON_ONLINE_FORBID_UPDATE)) {
	            log.warn("Schedule can not be updated due to schedule is {}, scheduleId:{}.",
	                    ReleaseState.ONLINE.getDescp(), schedule.getId());
	            return;
	        }
	
	        Date now = new Date();
	
	        checkValidTenant(tenantCode);
	        schedule.setTenantCode(tenantCode);
	
	        // updateWorkflowInstance param
	        if (!StringUtils.isEmpty(scheduleExpression)) {
	            ScheduleParam scheduleParam = JSONUtils.parseObject(scheduleExpression, ScheduleParam.class);
	            if (scheduleParam == null) {
	                log.warn("Parameter scheduleExpression is invalid, so parse cron error.");
	                putMsg(result, Status.PARSE_TO_CRON_EXPRESSION_ERROR);
	                return;
	            }
	            if (DateUtils.differSec(scheduleParam.getStartTime(), scheduleParam.getEndTime()) == 0) {
	                log.warn("The start time must not be the same as the end or time can not be null.");
	                putMsg(result, Status.SCHEDULE_START_TIME_END_TIME_SAME);
	                return;
	            }
	            if (scheduleParam.getStartTime().getTime() > scheduleParam.getEndTime().getTime()) {
	                log.warn("The start time must smaller than end time");
	                putMsg(result, Status.START_TIME_BIGGER_THAN_END_TIME_ERROR);
	                return;
	            }
	
	            schedule.setStartTime(scheduleParam.getStartTime());
	            schedule.setEndTime(scheduleParam.getEndTime());
	            if (!CronUtils.isValidExpression(scheduleParam.getCrontab())) {
	                log.error("Schedule crontab verify failure, crontab:{}.", scheduleParam.getCrontab());
	                putMsg(result, Status.SCHEDULE_CRON_CHECK_FAILED, scheduleParam.getCrontab());
	                return;
	            }
	            schedule.setCrontab(scheduleParam.getCrontab());
	            schedule.setTimezoneId(scheduleParam.getTimezoneId());
	        }
	
	        if (warningType != null) {
	            schedule.setWarningType(warningType);
	        }
	
	        schedule.setWarningGroupId(warningGroupId);
	
	        if (failureStrategy != null) {
	            schedule.setFailureStrategy(failureStrategy);
	        }
	
	        schedule.setWorkerGroup(workerGroup);
	        schedule.setEnvironmentCode(environmentCode);
	        schedule.setUpdateTime(now);
	        schedule.setWorkflowInstancePriority(workflowInstancePriority);
	        scheduleMapper.updateById(schedule);
	
	        workflowDefinition.setWarningGroupId(warningGroupId);
	
	        workflowDefinitionMapper.updateById(workflowDefinition);
	
	        log.info("Schedule update complete, projectCode:{}, workflowDefinitionCode:{}, scheduleId:{}.",
	                workflowDefinition.getProjectCode(), workflowDefinition.getCode(), schedule.getId());
	        result.put(Constants.DATA_LIST, schedule);
	        putMsg(result, Status.SUCCESS);
	    }
	
	    /**
	     * check valid tenant
	     *
	     * @param tenantCode
	     */
	    private void checkValidTenant(String tenantCode) {
	        if (!Constants.DEFAULT.equals(tenantCode)) {
	            Tenant tenant = tenantMapper.queryByTenantCode(tenantCode);
	            if (tenant == null) {
	                throw new ServiceException(Status.TENANT_NOT_EXIST, tenantCode);
	            }
	        }
	    }
	}
		
",
	role:"
	user	
",
,
	content:"
	//dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/controller/ProjectParameterController.java
	/*
	 * Licensed to the Apache Software Foundation (ASF) under one or more
	 * contributor license agreements.  See the NOTICE file distributed with
	 * this work for additional information regarding copyright ownership.
	 * The ASF licenses this file to You under the Apache License, Version 2.0
	 * (the "License"); you may not use this file except in compliance with
	 * the License.  You may obtain a copy of the License at
	 *
	 *    http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	package org.apache.dolphinscheduler.api.controller;
	
	import static org.apache.dolphinscheduler.api.enums.Status.CREATE_PROJECT_PARAMETER_ERROR;
	import static org.apache.dolphinscheduler.api.enums.Status.DELETE_PROJECT_PARAMETER_ERROR;
	import static org.apache.dolphinscheduler.api.enums.Status.QUERY_PROJECT_PARAMETER_ERROR;
	import static org.apache.dolphinscheduler.api.enums.Status.UPDATE_PROJECT_PARAMETER_ERROR;
	
	import org.apache.dolphinscheduler.api.exceptions.ApiException;
	import org.apache.dolphinscheduler.api.service.ProjectParameterService;
	import org.apache.dolphinscheduler.api.utils.Result;
	import org.apache.dolphinscheduler.common.constants.Constants;
	import org.apache.dolphinscheduler.dao.entity.User;
	import org.apache.dolphinscheduler.plugin.task.api.utils.ParameterUtils;
	
	import lombok.extern.slf4j.Slf4j;
	
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.http.HttpStatus;
	import org.springframework.web.bind.annotation.GetMapping;
	import org.springframework.web.bind.annotation.PathVariable;
	import org.springframework.web.bind.annotation.PostMapping;
	import org.springframework.web.bind.annotation.PutMapping;
	import org.springframework.web.bind.annotation.RequestAttribute;
	import org.springframework.web.bind.annotation.RequestMapping;
	import org.springframework.web.bind.annotation.RequestParam;
	import org.springframework.web.bind.annotation.ResponseStatus;
	import org.springframework.web.bind.annotation.RestController;
	
	import io.swagger.v3.oas.annotations.Operation;
	import io.swagger.v3.oas.annotations.Parameter;
	import io.swagger.v3.oas.annotations.Parameters;
	import io.swagger.v3.oas.annotations.media.Schema;
	import io.swagger.v3.oas.annotations.tags.Tag;
	
	@Tag(name = "PROJECT_PARAMETER_TAG")
	@RestController
	@RequestMapping("projects/{projectCode}/project-parameter")
	@Slf4j
	public class ProjectParameterController extends BaseController {
	
	    @Autowired
	    private ProjectParameterService projectParameterService;
	
	    @Operation(summary = "createProjectParameter", description = "CREATE_PROJECT_PARAMETER_NOTES")
	    @Parameters({
	            @Parameter(name = "projectParameterName", description = "PROJECT_PARAMETER_NAME", schema = @Schema(implementation = String.class)),
	            @Parameter(name = "projectParameterValue", description = "PROJECT_PARAMETER_VALUE", schema = @Schema(implementation = String.class)),
	            @Parameter(name = "projectParameterDataType", description = "PROJECT_PARAMETER_DATA_TYPE", schema = @Schema(implementation = String.class))
	    })
	    @PostMapping()
	    @ResponseStatus(HttpStatus.CREATED)
	    @ApiException(CREATE_PROJECT_PARAMETER_ERROR)
	    public Result createProjectParameter(@Parameter(hidden = true) @RequestAttribute(value = Constants.SESSION_USER) User loginUser,
	                                         @Parameter(name = "projectCode", description = "PROJECT_CODE", required = true) @PathVariable long projectCode,
	                                         @RequestParam("projectParameterName") String projectParameterName,
	                                         @RequestParam(value = "projectParameterValue") String projectParameterValue,
	                                         @RequestParam(value = "projectParameterDataType", defaultValue = "VARCHAR") String projectParameterDataType) {
	        return projectParameterService.createProjectParameter(loginUser, projectCode, projectParameterName,
	                projectParameterValue, projectParameterDataType);
	    }
	
	    @Operation(summary = "updateProjectParameter", description = "UPDATE_PROJECT_PARAMETER_NOTES")
	    @Parameters({
	            @Parameter(name = "code", description = "PROJECT_PARAMETER_CODE", schema = @Schema(implementation = long.class, example = "123456")),
	            @Parameter(name = "projectParameterName", description = "PROJECT_PARAMETER_NAME", schema = @Schema(implementation = String.class)),
	            @Parameter(name = "projectParameterValue", description = "PROJECT_PARAMETER_VALUE", schema = @Schema(implementation = String.class)),
	            @Parameter(name = "projectParameterDataType", description = "PROJECT_PARAMETER_DATA_TYPE", schema = @Schema(implementation = String.class))
	    })
	    @PutMapping(value = "/{code}")
	    @ResponseStatus(HttpStatus.OK)
	    @ApiException(UPDATE_PROJECT_PARAMETER_ERROR)
	    public Result updateProjectParameter(@Parameter(hidden = true) @RequestAttribute(value = Constants.SESSION_USER) User loginUser,
	                                         @Parameter(name = "projectCode", description = "PROJECT_CODE", required = true) @PathVariable long projectCode,
	                                         @PathVariable("code") Long code,
	                                         @RequestParam("projectParameterName") String projectParameterName,
	                                         @RequestParam(value = "projectParameterValue") String projectParameterValue,
	                                         @RequestParam(value = "projectParameterDataType") String projectParameterDataType) {
	        return projectParameterService.updateProjectParameter(loginUser, projectCode, code, projectParameterName,
	                projectParameterValue, projectParameterDataType);
	    }
	
	    @Operation(summary = "deleteProjectParametersByCode", description = "DELETE_PROJECT_PARAMETER_NOTES")
	    @Parameters({
	            @Parameter(name = "code", description = "PROJECT_PARAMETER_CODE", required = true, schema = @Schema(implementation = String.class))
	    })
	    @PostMapping(value = "/delete")
	    @ResponseStatus(HttpStatus.OK)
	    @ApiException(DELETE_PROJECT_PARAMETER_ERROR)
	    public Result deleteProjectParametersByCode(@Parameter(hidden = true) @RequestAttribute(value = Constants.SESSION_USER) User loginUser,
	                                                @Parameter(name = "projectCode", description = "PROJECT_CODE", required = true) @PathVariable long projectCode,
	                                                @RequestParam("code") long code) {
	
	        return projectParameterService.deleteProjectParametersByCode(loginUser, projectCode, code);
	    }
	
	    @Operation(summary = "batchDeleteProjectParametersByCodes", description = "DELETE_PROJECT_PARAMETER_NOTES")
	    @Parameters({
	            @Parameter(name = "codes", description = "PROJECT_PARAMETER_CODE", required = true, schema = @Schema(implementation = String.class))
	    })
	    @PostMapping(value = "/batch-delete")
	    @ResponseStatus(HttpStatus.OK)
	    @ApiException(DELETE_PROJECT_PARAMETER_ERROR)
	    public Result batchDeleteProjectParametersByCodes(@Parameter(hidden = true) @RequestAttribute(value = Constants.SESSION_USER) User loginUser,
	                                                      @Parameter(name = "projectCode", description = "PROJECT_CODE", required = true) @PathVariable long projectCode,
	                                                      @RequestParam("codes") String codes) {
	
	        return projectParameterService.batchDeleteProjectParametersByCodes(loginUser, projectCode, codes);
	    }
	
	    @Operation(summary = "queryProjectParameterListPaging", description = "QUERY_PROJECT_PARAMETER_LIST_PAGING_NOTES")
	    @Parameters({
	            @Parameter(name = "searchVal", description = "SEARCH_VAL", required = false, schema = @Schema(implementation = String.class)),
	            @Parameter(name = "pageNo", description = "PAGE_NO", required = true, schema = @Schema(implementation = int.class, example = "1")),
	            @Parameter(name = "pageSize", description = "PAGE_SIZE", required = true, schema = @Schema(implementation = int.class, example = "10"))
	    })
	    @GetMapping()
	    @ResponseStatus(HttpStatus.OK)
	    @ApiException(QUERY_PROJECT_PARAMETER_ERROR)
	    public Result queryProjectParameterListPaging(
	                                                  @Parameter(hidden = true) @RequestAttribute(value = Constants.SESSION_USER) User loginUser,
	                                                  @Parameter(name = "projectCode", description = "PROJECT_CODE", required = true) @PathVariable long projectCode,
	                                                  @RequestParam(value = "searchVal", required = false) String searchVal,
	                                                  @RequestParam(value = "projectParameterDataType", required = false) String projectParameterDataType,
	                                                  @RequestParam("pageNo") Integer pageNo,
	                                                  @RequestParam("pageSize") Integer pageSize) {
	
	        checkPageParams(pageNo, pageSize);
	        searchVal = ParameterUtils.handleEscapes(searchVal);
	        return projectParameterService.queryProjectParameterListPaging(loginUser, projectCode, pageSize, pageNo,
	                searchVal, projectParameterDataType);
	    }
	
	    @Operation(summary = "queryProjectParameterByCode", description = "QUERY_PROJECT_PARAMETER_NOTES")
	    @Parameters({
	            @Parameter(name = "code", description = "PROJECT_PARAMETER_CODE", schema = @Schema(implementation = long.class, example = "123456"))
	    })
	    @GetMapping(value = "/{code}")
	    @ResponseStatus(HttpStatus.OK)
	    @ApiException(QUERY_PROJECT_PARAMETER_ERROR)
	    public Result queryProjectParameterByCode(@Parameter(hidden = true) @RequestAttribute(value = Constants.SESSION_USER) User loginUser,
	                                              @Parameter(name = "projectCode", description = "PROJECT_CODE", required = true) @PathVariable long projectCode,
	                                              @PathVariable("code") long code) {
	        return projectParameterService.queryProjectParameterByCode(loginUser, projectCode, code);
	    }
	
	}
		
",
	role:"
	user	
",
,
	content:"
	//dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProjectParameterService.java
	/*
	 * Licensed to the Apache Software Foundation (ASF) under one or more
	 * contributor license agreements.  See the NOTICE file distributed with
	 * this work for additional information regarding copyright ownership.
	 * The ASF licenses this file to You under the Apache License, Version 2.0
	 * (the "License"); you may not use this file except in compliance with
	 * the License.  You may obtain a copy of the License at
	 *
	 *    http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	package org.apache.dolphinscheduler.api.service;
	
	import org.apache.dolphinscheduler.api.utils.Result;
	import org.apache.dolphinscheduler.dao.entity.User;
	
	public interface ProjectParameterService {
	
	    Result createProjectParameter(User loginUser, long projectCode, String projectParameterName,
	                                  String projectParameterValue, String projectParameterDataType);
	
	    Result updateProjectParameter(User loginUser, long projectCode, long code, String projectParameterName,
	                                  String projectParameterValue, String projectParameterDataType);
	
	    Result deleteProjectParametersByCode(User loginUser, long projectCode, long code);
	
	    Result batchDeleteProjectParametersByCodes(User loginUser, long projectCode, String codes);
	
	    Result queryProjectParameterListPaging(User loginUser, long projectCode, Integer pageSize, Integer pageNo,
	                                           String searchVal, String projectParameterDataType);
	
	    Result queryProjectParameterByCode(User loginUser, long projectCode, long code);
	}
		
",
	role:"
	user	
",
,
	content:"
	//dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/impl/TenantServiceImpl.java
	/*
	 * Licensed to the Apache Software Foundation (ASF) under one or more
	 * contributor license agreements.  See the NOTICE file distributed with
	 * this work for additional information regarding copyright ownership.
	 * The ASF licenses this file to You under the Apache License, Version 2.0
	 * (the "License"); you may not use this file except in compliance with
	 * the License.  You may obtain a copy of the License at
	 *
	 *    http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	package org.apache.dolphinscheduler.api.service.impl;
	
	import static org.apache.dolphinscheduler.api.constants.ApiFuncIdentificationConstant.TENANT_CREATE;
	import static org.apache.dolphinscheduler.api.constants.ApiFuncIdentificationConstant.TENANT_DELETE;
	import static org.apache.dolphinscheduler.api.constants.ApiFuncIdentificationConstant.TENANT_UPDATE;
	import static org.apache.dolphinscheduler.common.constants.Constants.TENANT_FULL_NAME_MAX_LENGTH;
	
	import org.apache.dolphinscheduler.api.enums.Status;
	import org.apache.dolphinscheduler.api.exceptions.ServiceException;
	import org.apache.dolphinscheduler.api.service.QueueService;
	import org.apache.dolphinscheduler.api.service.TenantService;
	import org.apache.dolphinscheduler.api.utils.PageInfo;
	import org.apache.dolphinscheduler.api.utils.RegexUtils;
	import org.apache.dolphinscheduler.common.constants.Constants;
	import org.apache.dolphinscheduler.common.enums.AuthorizationType;
	import org.apache.dolphinscheduler.dao.entity.Queue;
	import org.apache.dolphinscheduler.dao.entity.Schedule;
	import org.apache.dolphinscheduler.dao.entity.Tenant;
	import org.apache.dolphinscheduler.dao.entity.User;
	import org.apache.dolphinscheduler.dao.entity.WorkflowInstance;
	import org.apache.dolphinscheduler.dao.mapper.ScheduleMapper;
	import org.apache.dolphinscheduler.dao.mapper.TenantMapper;
	import org.apache.dolphinscheduler.dao.mapper.UserMapper;
	import org.apache.dolphinscheduler.dao.mapper.WorkflowInstanceMapper;
	import org.apache.dolphinscheduler.plugin.storage.api.StorageOperator;
	
	import org.apache.commons.collections4.CollectionUtils;
	import org.apache.commons.lang3.StringUtils;
	
	import java.util.ArrayList;
	import java.util.Collections;
	import java.util.HashMap;
	import java.util.List;
	import java.util.Map;
	import java.util.Objects;
	import java.util.Set;
	
	import lombok.extern.slf4j.Slf4j;
	
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.stereotype.Service;
	import org.springframework.transaction.annotation.Transactional;
	
	import com.baomidou.mybatisplus.core.metadata.IPage;
	import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
	
	@Service
	@Slf4j
	public class TenantServiceImpl extends BaseServiceImpl implements TenantService {
	
	    @Autowired
	    private TenantMapper tenantMapper;
	
	    @Autowired
	    private WorkflowInstanceMapper workflowInstanceMapper;
	
	    @Autowired
	    private ScheduleMapper scheduleMapper;
	
	    @Autowired
	    private UserMapper userMapper;
	
	    @Autowired
	    private QueueService queueService;
	
	    @Autowired(required = false)
	    private StorageOperator storageOperator;
	
	    /**
	     * Check the tenant new object valid or not
	     *
	     * @param tenant The tenant object want to create
	     */
	    private void createTenantValid(Tenant tenant) throws ServiceException {
	        if (StringUtils.isEmpty(tenant.getTenantCode())) {
	            throw new ServiceException(Status.REQUEST_PARAMS_NOT_VALID_ERROR, tenant.getTenantCode());
	        } else if (StringUtils.length(tenant.getTenantCode()) > TENANT_FULL_NAME_MAX_LENGTH) {
	            throw new ServiceException(Status.TENANT_FULL_NAME_TOO_LONG_ERROR);
	        } else if (!RegexUtils.isValidLinuxUserName(tenant.getTenantCode())) {
	            throw new ServiceException(Status.CHECK_OS_TENANT_CODE_ERROR);
	        } else if (checkTenantExists(tenant.getTenantCode())) {
	            throw new ServiceException(Status.OS_TENANT_CODE_EXIST, tenant.getTenantCode());
	        }
	    }
	
	    /**
	     * Check tenant update object valid or not
	     *
	     * @param existsTenant The exists queue object
	     * @param updateTenant The queue object want to update
	     */
	    private void updateTenantValid(Tenant existsTenant, Tenant updateTenant) throws ServiceException {
	        // Check the exists tenant
	        if (Objects.isNull(existsTenant)) {
	            log.error("Tenant does not exist.");
	            throw new ServiceException(Status.TENANT_NOT_EXIST);
	        }
	        // Check the update tenant parameters
	        else if (StringUtils.isEmpty(updateTenant.getTenantCode())) {
	            throw new ServiceException(Status.REQUEST_PARAMS_NOT_VALID_ERROR, updateTenant.getTenantCode());
	        } else if (StringUtils.length(updateTenant.getTenantCode()) > TENANT_FULL_NAME_MAX_LENGTH) {
	            throw new ServiceException(Status.TENANT_FULL_NAME_TOO_LONG_ERROR);
	        } else if (!RegexUtils.isValidLinuxUserName(updateTenant.getTenantCode())) {
	            throw new ServiceException(Status.CHECK_OS_TENANT_CODE_ERROR);
	        } else if (!Objects.equals(existsTenant.getTenantCode(), updateTenant.getTenantCode())
	                && checkTenantExists(updateTenant.getTenantCode())) {
	            throw new ServiceException(Status.OS_TENANT_CODE_EXIST, updateTenant.getTenantCode());
	        }
	    }
	
	    /**
	     * create tenant
	     *
	     * @param loginUser login user
	     * @param tenantCode tenant code
	     * @param queueId queue id
	     * @param desc description
	     * @return create result code
	     */
	    @Override
	    @Transactional(rollbackFor = Exception.class)
	    public Tenant createTenant(User loginUser,
	                               String tenantCode,
	                               int queueId,
	                               String desc) {
	        if (!canOperatorPermissions(loginUser, null, AuthorizationType.TENANT, TENANT_CREATE)) {
	            throw new ServiceException(Status.USER_NO_OPERATION_PERM);
	        }
	        if (checkDescriptionLength(desc)) {
	            throw new ServiceException(Status.DESCRIPTION_TOO_LONG_ERROR);
	        }
	        Tenant tenant = new Tenant(tenantCode, desc, queueId);
	        createTenantValid(tenant);
	        tenantMapper.insert(tenant);
	
	        return tenant;
	    }
	
	    /**
	     * query tenant list paging
	     *
	     * @param loginUser login user
	     * @param searchVal search value
	     * @param pageNo    page number
	     * @param pageSize  page size
	     * @return tenant list page
	     */
	    @Override
	    public PageInfo<Tenant> queryTenantList(User loginUser, String searchVal, Integer pageNo, Integer pageSize) {
	
	        Set<Integer> ids = resourcePermissionCheckService.userOwnedResourceIdsAcquisition(AuthorizationType.TENANT,
	                loginUser.getId(), log);
	        if (CollectionUtils.isEmpty(ids)) {
	            return new PageInfo<>(pageNo, pageSize);
	        }
	        Page<Tenant> page = new Page<>(pageNo, pageSize);
	        IPage<Tenant> tenantPage = tenantMapper.queryTenantPaging(page, new ArrayList<>(ids), searchVal);
	        return PageInfo.of(tenantPage);
	    }
	
	    /**
	     * updateWorkflowInstance tenant
	     *
	     * @param loginUser login user
	     * @param id tenant id
	     * @param tenantCode tenant code
	     * @param queueId queue id
	     * @param desc description
	     * @return update result code
	     * @throws Exception exception
	     */
	    @Override
	    public void updateTenant(User loginUser,
	                             int id,
	                             String tenantCode,
	                             int queueId,
	                             String desc) throws Exception {
	
	        if (!canOperatorPermissions(loginUser, null, AuthorizationType.TENANT, TENANT_UPDATE)) {
	            throw new ServiceException(Status.USER_NO_OPERATION_PERM);
	        }
	        if (checkDescriptionLength(desc)) {
	            throw new ServiceException(Status.DESCRIPTION_TOO_LONG_ERROR);
	        }
	        Tenant updateTenant = new Tenant(id, tenantCode, desc, queueId);
	        Tenant existsTenant = tenantMapper.queryById(id);
	        updateTenantValid(existsTenant, updateTenant);
	
	        updateTenant.setCreateTime(existsTenant.getCreateTime());
	        int update = tenantMapper.updateById(updateTenant);
	        if (update <= 0) {
	            throw new ServiceException(Status.UPDATE_TENANT_ERROR);
	        }
	    }
	
	    /**
	     * delete tenant
	     *
	     * @param loginUser login user
	     * @param id        tenant id
	     * @return delete result code
	     * @throws Exception exception
	     */
	    @Override
	    @Transactional()
	    public void deleteTenantById(User loginUser, int id) throws Exception {
	
	        if (!canOperatorPermissions(loginUser, null, AuthorizationType.TENANT, TENANT_DELETE)) {
	            throw new ServiceException(Status.USER_NO_OPERATION_PERM);
	        }
	
	        Tenant tenant = tenantMapper.queryById(id);
	        if (Objects.isNull(tenant)) {
	            throw new ServiceException(Status.TENANT_NOT_EXIST);
	        }
	
	        List<WorkflowInstance> workflowInstances = getWorkflowInstancesByTenant(tenant);
	        if (CollectionUtils.isNotEmpty(workflowInstances)) {
	            throw new ServiceException(Status.DELETE_TENANT_BY_ID_FAIL, workflowInstances.size());
	        }
	
	        List<Schedule> schedules = scheduleMapper.queryScheduleListByTenant(tenant.getTenantCode());
	        if (CollectionUtils.isNotEmpty(schedules)) {
	            throw new ServiceException(Status.DELETE_TENANT_BY_ID_FAIL_DEFINES, schedules.size());
	        }
	
	        List<User> userList = userMapper.queryUserListByTenant(tenant.getId());
	        if (CollectionUtils.isNotEmpty(userList)) {
	            throw new ServiceException(Status.DELETE_TENANT_BY_ID_FAIL_USERS, userList.size());
	        }
	
	        int delete = tenantMapper.deleteById(id);
	        if (delete <= 0) {
	            throw new ServiceException(Status.DELETE_TENANT_BY_ID_ERROR);
	        }
	
	        workflowInstanceMapper.updateWorkflowInstanceByTenantCode(tenant.getTenantCode(), Constants.DEFAULT);
	    }
	
	    private List<WorkflowInstance> getWorkflowInstancesByTenant(Tenant tenant) {
	        return workflowInstanceMapper.queryByTenantCodeAndStatus(tenant.getTenantCode(),
	                org.apache.dolphinscheduler.service.utils.Constants.NOT_TERMINATED_STATES);
	    }
	
	    /**
	     * query tenant list
	     *
	     * @param loginUser login user
	     * @return tenant list
	     */
	    @Override
	    public List<Tenant> queryTenantList(User loginUser) {
	
	        Set<Integer> ids = resourcePermissionCheckService.userOwnedResourceIdsAcquisition(AuthorizationType.TENANT,
	                loginUser.getId(), log);
	        if (CollectionUtils.isEmpty(ids)) {
	            return Collections.emptyList();
	        }
	        return tenantMapper.selectBatchIds(ids);
	    }
	
	    /**
	     * verify tenant code
	     *
	     * @param tenantCode tenant code
	     * @return true if tenant code can use, otherwise return false
	     */
	    @Override
	    public void verifyTenantCode(String tenantCode) {
	        if (checkTenantExists(tenantCode)) {
	            throw new ServiceException(Status.OS_TENANT_CODE_EXIST, tenantCode);
	        }
	    }
	
	    /**
	     * check tenant exists
	     *
	     * @param tenantCode tenant code
	     * @return ture if the tenant code exists, otherwise return false
	     */
	    private boolean checkTenantExists(String tenantCode) {
	        Boolean existTenant = tenantMapper.existTenant(tenantCode);
	        return Boolean.TRUE.equals(existTenant);
	    }
	
	    /**
	     * query tenant by tenant code
	     *
	     * @param tenantCode tenant code
	     * @return tenant detail information
	     */
	    @Override
	    public Map<String, Object> queryByTenantCode(String tenantCode) {
	        Map<String, Object> result = new HashMap<>();
	        Tenant tenant = tenantMapper.queryByTenantCode(tenantCode);
	        if (tenant != null) {
	            result.put(Constants.DATA_LIST, tenant);
	            putMsg(result, Status.SUCCESS);
	        }
	        return result;
	    }
	
	    /**
	     * Make sure tenant with given name exists, and create the tenant if not exists
	     * ONLY for python gateway server, and should not use this in web ui function
	     *
	     * @param tenantCode tenant code
	     * @param desc The description of tenant object
	     * @param queue The value of queue which current tenant belong
	     * @param queueName The name of queue which current tenant belong
	     * @return Tenant object
	     */
	    @Override
	    public Tenant createTenantIfNotExists(String tenantCode, String desc, String queue, String queueName) {
	        if (checkTenantExists(tenantCode)) {
	            return tenantMapper.queryByTenantCode(tenantCode);
	        }
	        Queue queueObj = queueService.createQueueIfNotExists(queue, queueName);
	        Tenant tenant = new Tenant(tenantCode, desc, queueObj.getId());
	        createTenantValid(tenant);
	        tenantMapper.insert(tenant);
	        return tenant;
	    }
	}
		
",
	role:"
	user	
",
,
	content:"
	//dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/impl/UsersServiceImpl.java
	/*
	 * Licensed to the Apache Software Foundation (ASF) under one or more
	 * contributor license agreements.  See the NOTICE file distributed with
	 * this work for additional information regarding copyright ownership.
	 * The ASF licenses this file to You under the Apache License, Version 2.0
	 * (the "License"); you may not use this file except in compliance with
	 * the License.  You may obtain a copy of the License at
	 *
	 *    http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	package org.apache.dolphinscheduler.api.service.impl;
	
	import static org.apache.dolphinscheduler.api.constants.ApiFuncIdentificationConstant.USER_MANAGER;
	
	import org.apache.dolphinscheduler.api.enums.Status;
	import org.apache.dolphinscheduler.api.exceptions.ServiceException;
	import org.apache.dolphinscheduler.api.service.MetricsCleanUpService;
	import org.apache.dolphinscheduler.api.service.SessionService;
	import org.apache.dolphinscheduler.api.service.UsersService;
	import org.apache.dolphinscheduler.api.utils.CheckUtils;
	import org.apache.dolphinscheduler.api.utils.PageInfo;
	import org.apache.dolphinscheduler.api.utils.Result;
	import org.apache.dolphinscheduler.common.constants.Constants;
	import org.apache.dolphinscheduler.common.enums.AuthorizationType;
	import org.apache.dolphinscheduler.common.enums.Flag;
	import org.apache.dolphinscheduler.common.enums.UserType;
	import org.apache.dolphinscheduler.common.utils.EncryptionUtils;
	import org.apache.dolphinscheduler.dao.entity.AlertGroup;
	import org.apache.dolphinscheduler.dao.entity.DatasourceUser;
	import org.apache.dolphinscheduler.dao.entity.K8sNamespaceUser;
	import org.apache.dolphinscheduler.dao.entity.Project;
	import org.apache.dolphinscheduler.dao.entity.ProjectUser;
	import org.apache.dolphinscheduler.dao.entity.Tenant;
	import org.apache.dolphinscheduler.dao.entity.User;
	import org.apache.dolphinscheduler.dao.mapper.AccessTokenMapper;
	import org.apache.dolphinscheduler.dao.mapper.AlertGroupMapper;
	import org.apache.dolphinscheduler.dao.mapper.DataSourceUserMapper;
	import org.apache.dolphinscheduler.dao.mapper.K8sNamespaceUserMapper;
	import org.apache.dolphinscheduler.dao.mapper.ProjectMapper;
	import org.apache.dolphinscheduler.dao.mapper.ProjectUserMapper;
	import org.apache.dolphinscheduler.dao.mapper.TenantMapper;
	import org.apache.dolphinscheduler.dao.mapper.UserMapper;
	import org.apache.dolphinscheduler.plugin.storage.api.StorageOperator;
	
	import org.apache.commons.collections4.CollectionUtils;
	import org.apache.commons.lang3.StringUtils;
	
	import java.io.IOException;
	import java.text.MessageFormat;
	import java.util.ArrayList;
	import java.util.Arrays;
	import java.util.Date;
	import java.util.HashMap;
	import java.util.HashSet;
	import java.util.List;
	import java.util.Map;
	import java.util.Objects;
	import java.util.Set;
	import java.util.TimeZone;
	import java.util.stream.Collectors;
	
	import lombok.extern.slf4j.Slf4j;
	
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.stereotype.Service;
	import org.springframework.transaction.annotation.Transactional;
	
	import com.baomidou.mybatisplus.core.metadata.IPage;
	import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
	
	/**
	 * users service impl
	 */
	@Service
	@Slf4j
	public class UsersServiceImpl extends BaseServiceImpl implements UsersService {
	
	    @Autowired
	    private AccessTokenMapper accessTokenMapper;
	
	    @Autowired
	    private UserMapper userMapper;
	
	    @Autowired
	    private TenantMapper tenantMapper;
	
	    @Autowired
	    private ProjectUserMapper projectUserMapper;
	
	    @Autowired
	    private DataSourceUserMapper datasourceUserMapper;
	
	    @Autowired
	    private AlertGroupMapper alertGroupMapper;
	
	    @Autowired
	    private ProjectMapper projectMapper;
	
	    @Autowired(required = false)
	    private StorageOperator storageOperator;
	
	    @Autowired
	    private K8sNamespaceUserMapper k8sNamespaceUserMapper;
	
	    @Autowired
	    private MetricsCleanUpService metricsCleanUpService;
	
	    @Autowired
	    private SessionService sessionService;
	
	    /**
	     * create user, only system admin have permission
	     *
	     * @param loginUser    login user
	     * @param userName     user name
	     * @param userPassword user password
	     * @param email        email
	     * @param tenantId     tenant id
	     * @param phone        phone
	     * @param queue        queue
	     * @return create result code
	     * @throws Exception exception
	     */
	    @Override
	    @Transactional(rollbackFor = Exception.class)
	    public Map<String, Object> createUser(User loginUser,
	                                          String userName,
	                                          String userPassword,
	                                          String email,
	                                          int tenantId,
	                                          String phone,
	                                          String queue,
	                                          int state) throws Exception {
	        Map<String, Object> result = new HashMap<>();
	
	        // check all user params
	        String msg = this.checkUserParams(userName, userPassword, email, phone);
	        if (resourcePermissionCheckService.functionDisabled()) {
	            putMsg(result, Status.FUNCTION_DISABLED, msg);
	            return result;
	        }
	
	        if (!isAdmin(loginUser)) {
	            putMsg(result, Status.USER_NO_OPERATION_PERM);
	            return result;
	        }
	
	        if (!StringUtils.isEmpty(msg)) {
	            putMsg(result, Status.REQUEST_PARAMS_NOT_VALID_ERROR, msg);
	            return result;
	        }
	
	        if (!checkTenantExists(tenantId)) {
	            log.warn("Tenant does not exist, tenantId:{}.", tenantId);
	            putMsg(result, Status.TENANT_NOT_EXIST);
	            return result;
	        }
	
	        User user = createUser(userName, userPassword, email, tenantId, phone, queue, state);
	
	        log.info("User is created and id is {}.", user.getId());
	        result.put(Constants.DATA_LIST, user);
	        putMsg(result, Status.SUCCESS);
	        return result;
	    }
	
	    @Override
	    @Transactional
	    public User createUser(String userName,
	                           String userPassword,
	                           String email,
	                           int tenantId,
	                           String phone,
	                           String queue,
	                           int state) {
	        User user = new User();
	        Date now = new Date();
	
	        user.setUserName(userName);
	        user.setUserPassword(EncryptionUtils.getMd5(userPassword));
	        user.setEmail(email);
	        user.setTenantId(tenantId);
	        user.setPhone(phone);
	        user.setState(state);
	        // create general users, administrator users are currently built-in
	        user.setUserType(UserType.GENERAL_USER);
	        user.setCreateTime(now);
	        user.setUpdateTime(now);
	        if (StringUtils.isEmpty(queue)) {
	            queue = "";
	        }
	        user.setQueue(queue);
	
	        // save user
	        userMapper.insert(user);
	        return user;
	    }
	
	    /***
	     * create User for ldapCasdoor SSO and OAuth2.0 login
	     */
	    @Override
	    @Transactional
	    public User createUser(UserType userType, String userId, String email) {
	        User user = new User();
	        Date now = new Date();
	
	        user.setUserName(userId);
	        user.setEmail(email);
	        // create general users, administrator users are currently built-in
	        user.setUserType(userType);
	        user.setCreateTime(now);
	        user.setUpdateTime(now);
	        user.setTenantId(-1);
	        user.setQueue("");
	        user.setState(Flag.YES.getCode());
	
	        // save user
	        userMapper.insert(user);
	        return user;
	    }
	
	    /**
	     * get user by user name
	     *
	     * @param userName user name
	     * @return exist user or null
	     */
	    @Override
	    public User getUserByUserName(String userName) {
	        return userMapper.queryByUserNameAccurately(userName);
	    }
	
	    /**
	     * query user by id
	     *
	     * @param id id
	     * @return user info
	     */
	    @Override
	    public User queryUser(int id) {
	        return userMapper.selectById(id);
	    }
	
	    @Override
	    public List<User> queryUser(List<Integer> ids) {
	        if (CollectionUtils.isEmpty(ids)) {
	            return new ArrayList<>();
	        }
	        return userMapper.selectByIds(ids);
	    }
	
	    /**
	     * query user
	     *
	     * @param name name
	     * @return user info
	     */
	    @Override
	    public User queryUser(String name) {
	        return userMapper.queryByUserNameAccurately(name);
	    }
	
	    /**
	     * query user
	     *
	     * @param name     name
	     * @param password password
	     * @return user info
	     */
	    @Override
	    public User queryUser(String name, String password) {
	        String md5 = EncryptionUtils.getMd5(password);
	        return userMapper.queryUserByNamePassword(name, md5);
	    }
	
	    /**
	     * get user id by user name
	     *
	     * @param name user name
	     * @return if name empty 0, user not exists -1, user exist user id
	     */
	    @Override
	    public int getUserIdByName(String name) {
	        // executor name query
	        int executorId = 0;
	        if (StringUtils.isNotEmpty(name)) {
	            User executor = queryUser(name);
	            if (null != executor) {
	                executorId = executor.getId();
	            } else {
	                executorId = -1;
	            }
	        }
	
	        return executorId;
	    }
	
	    /**
	     * query user list
	     *
	     * @param loginUser login user
	     * @param pageNo    page number
	     * @param searchVal search value
	     * @param pageSize  page size
	     * @return user list page
	     */
	    @Override
	    public Result<Object> queryUserList(User loginUser, String searchVal, Integer pageNo, Integer pageSize) {
	        Result<Object> result = new Result<>();
	        if (resourcePermissionCheckService.functionDisabled()) {
	            putMsg(result, Status.FUNCTION_DISABLED);
	            return result;
	        }
	        if (!isAdmin(loginUser)) {
	            log.warn("User does not have permission for this feature, userId:{}, userName:{}.", loginUser.getId(),
	                    loginUser.getUserName());
	            putMsg(result, Status.USER_NO_OPERATION_PERM);
	            return result;
	        }
	
	        Page<User> page = new Page<>(pageNo, pageSize);
	
	        IPage<User> scheduleList = userMapper.queryUserPaging(page, searchVal);
	
	        PageInfo<User> pageInfo = new PageInfo<>(pageNo, pageSize);
	        pageInfo.setTotal((int) scheduleList.getTotal());
	        pageInfo.setTotalList(scheduleList.getRecords());
	        result.setData(pageInfo);
	        putMsg(result, Status.SUCCESS);
	
	        return result;
	    }
	
	    @Override
	    @Transactional
	    public User updateUser(User loginUser,
	                           Integer userId,
	                           String userName,
	                           String userPassword,
	                           String email,
	                           Integer tenantId,
	                           String phone,
	                           String queue,
	                           int state,
	                           String timeZone) {
	        if (resourcePermissionCheckService.functionDisabled()) {
	            throw new ServiceException(Status.FUNCTION_DISABLED);
	        }
	        if (!canOperator(loginUser, userId)) {
	            throw new ServiceException(Status.USER_NO_OPERATION_PERM);
	        }
	        User user = userMapper.selectById(userId);
	        if (user == null) {
	            throw new ServiceException(Status.USER_NOT_EXIST, userId);
	        }
	
	        // non-admin should not modify tenantId and queue
	        if (!isAdmin(loginUser)) {
	            if (tenantId != null && user.getTenantId() != tenantId) {
	                throw new ServiceException(Status.USER_NO_OPERATION_PERM);
	            }
	            if (StringUtils.isNotEmpty(queue) && !StringUtils.equals(queue, user.getQueue())) {
	                throw new ServiceException(Status.USER_NO_OPERATION_PERM);
	            }
	        }
	
	        if (StringUtils.isNotEmpty(userName)) {
	
	            if (!CheckUtils.checkUserName(userName)) {
	                throw new ServiceException(Status.REQUEST_PARAMS_NOT_VALID_ERROR, userName);
	            }
	
	            // todo: use the db unique index
	            User tempUser = userMapper.queryByUserNameAccurately(userName);
	            if (tempUser != null && !userId.equals(tempUser.getId())) {
	                throw new ServiceException(Status.USER_NAME_EXIST);
	            }
	            user.setUserName(userName);
	        }
	
	        if (StringUtils.isNotEmpty(userPassword)) {
	            if (!CheckUtils.checkPasswordLength(userPassword)) {
	                throw new ServiceException(Status.USER_PASSWORD_LENGTH_ERROR);
	            }
	            user.setUserPassword(EncryptionUtils.getMd5(userPassword));
	            sessionService.expireSession(user.getId());
	        }
	
	        if (StringUtils.isNotEmpty(email)) {
	            if (!CheckUtils.checkEmail(email)) {
	                throw new ServiceException(Status.REQUEST_PARAMS_NOT_VALID_ERROR, email);
	            }
	            user.setEmail(email);
	        }
	
	        if (StringUtils.isNotEmpty(phone) && !CheckUtils.checkPhone(phone)) {
	            throw new ServiceException(Status.REQUEST_PARAMS_NOT_VALID_ERROR, phone);
	        }
	
	        if (state == 0 && user.getState() != state && Objects.equals(loginUser.getId(), user.getId())) {
	            throw new ServiceException(Status.NOT_ALLOW_TO_DISABLE_OWN_ACCOUNT);
	        }
	
	        if (StringUtils.isNotEmpty(timeZone)) {
	            if (!CheckUtils.checkTimeZone(timeZone)) {
	                throw new ServiceException(Status.TIME_ZONE_ILLEGAL, timeZone);
	            }
	            user.setTimeZone(timeZone);
	        }
	
	        user.setPhone(phone);
	        user.setQueue(queue);
	        user.setState(state);
	        user.setUpdateTime(new Date());
	        user.setTenantId(tenantId);
	        // updateWorkflowInstance user
	        if (userMapper.updateById(user) <= 0) {
	            throw new ServiceException(Status.UPDATE_USER_ERROR);
	        }
	        return user;
	    }
	
	    /**
	     * delete user
	     *
	     * @param loginUser login user
	     * @param id        user id
	     * @return delete result code
	     * @throws Exception exception when operate hdfs
	     */
	    @Override
	    @Transactional
	    public Map<String, Object> deleteUserById(User loginUser, int id) throws IOException {
	        Map<String, Object> result = new HashMap<>();
	        if (resourcePermissionCheckService.functionDisabled()) {
	            putMsg(result, Status.FUNCTION_DISABLED);
	            return result;
	        }
	        // only admin can operate
	        if (!isAdmin(loginUser)) {
	            log.warn("User does not have permission for this feature, userId:{}, userName:{}.", loginUser.getId(),
	                    loginUser.getUserName());
	            putMsg(result, Status.USER_NO_OPERATION_PERM, id);
	            return result;
	        }
	        // check exist
	        User tempUser = userMapper.selectById(id);
	        if (tempUser == null) {
	            log.error("User does not exist, userId:{}.", id);
	            putMsg(result, Status.USER_NOT_EXIST, id);
	            return result;
	        }
	        // check if is a project owner
	        List<Project> projects = projectMapper.queryProjectCreatedByUser(id);
	        if (CollectionUtils.isNotEmpty(projects)) {
	            String projectNames = projects.stream().map(Project::getName).collect(Collectors.joining(","));
	            putMsg(result, Status.TRANSFORM_PROJECT_OWNERSHIP, projectNames);
	            log.warn("Please transfer the project ownership before deleting the user, userId:{}, projects:{}.", id,
	                    projectNames);
	            return result;
	        }
	        // delete user
	        userMapper.queryTenantCodeByUserId(id);
	
	        accessTokenMapper.deleteAccessTokenByUserId(id);
	        sessionService.expireSession(id);
	
	        if (userMapper.deleteById(id) > 0) {
	            metricsCleanUpService.cleanUpApiResponseTimeMetricsByUserId(id);
	            log.info("User is deleted and id is :{}.", id);
	            putMsg(result, Status.SUCCESS);
	            return result;
	        } else {
	            log.error("User delete error, userId:{}.", id);
	            putMsg(result, Status.DELETE_USER_BY_ID_ERROR);
	            return result;
	        }
	    }
	
	    /**
	     * revoke the project permission for specified user by id
	     *
	     * @param loginUser  Login user
	     * @param userId     User id
	     * @param projectIds project id array
	     * @return
	     */
	    @Override
	    @Transactional(rollbackFor = RuntimeException.class)
	    public Map<String, Object> revokeProjectById(User loginUser, int userId, String projectIds) {
	        Map<String, Object> result = new HashMap<>();
	        result.put(Constants.STATUS, false);
	
	        if (resourcePermissionCheckService.functionDisabled()) {
	            putMsg(result, Status.FUNCTION_DISABLED);
	            return result;
	        }
	        // 1. only admin can operate
	        if (this.check(result, !this.isAdmin(loginUser), Status.USER_NO_OPERATION_PERM)) {
	            return result;
	        }
	
	        // 2. check if user is existed
	        User user = this.userMapper.selectById(userId);
	        if (user == null) {
	            this.putMsg(result, Status.USER_NOT_EXIST, userId);
	            return result;
	        }
	
	        Arrays.stream(projectIds.split(",")).distinct().forEach(projectId -> {
	            // 3. check if project is existed
	            Project project = this.projectMapper.queryDetailById(Integer.parseInt(projectId));
	            if (project == null) {
	                this.putMsg(result, Status.PROJECT_NOT_FOUND, Integer.parseInt(projectId));
	            } else {
	                // 4. delete the relationship between project and user
	                this.projectUserMapper.deleteProjectRelation(project.getId(), user.getId());
	            }
	        });
	
	        this.putMsg(result, Status.SUCCESS);
	        return result;
	    }
	
	    /**
	     * grant project with read permission
	     *
	     * @param loginUser  login user
	     * @param userId     user id
	     * @param projectIds project id array
	     * @return grant result code
	     */
	    @Override
	    @Transactional(rollbackFor = RuntimeException.class)
	    public Map<String, Object> grantProjectWithReadPerm(User loginUser, int userId, String projectIds) {
	        Map<String, Object> result = new HashMap<>();
	        result.put(Constants.STATUS, false);
	
	        if (resourcePermissionCheckService.functionDisabled()) {
	            putMsg(result, Status.FUNCTION_DISABLED);
	            return result;
	        }
	
	        if (!isAdmin(loginUser)) {
	            putMsg(result, Status.NO_CURRENT_OPERATING_PERMISSION);
	            return result;
	        }
	
	        // check exist
	        User tempUser = userMapper.selectById(userId);
	        if (tempUser == null) {
	            putMsg(result, Status.USER_NOT_EXIST, userId);
	            return result;
	        }
	
	        if (check(result, StringUtils.isEmpty(projectIds), Status.SUCCESS)) {
	            return result;
	        }
	        Arrays.stream(projectIds.split(Constants.COMMA)).distinct().forEach(projectId -> {
	            ProjectUser projectUserOld = projectUserMapper.queryProjectRelation(Integer.parseInt(projectId), userId);
	            if (projectUserOld != null) {
	                projectUserMapper.deleteProjectRelation(Integer.parseInt(projectId), userId);
	            }
	            Date now = new Date();
	            ProjectUser projectUser = new ProjectUser();
	            projectUser.setUserId(userId);
	            projectUser.setProjectId(Integer.parseInt(projectId));
	            projectUser.setPerm(Constants.READ_PERMISSION);
	            projectUser.setCreateTime(now);
	            projectUser.setUpdateTime(now);
	            projectUserMapper.insert(projectUser);
	        });
	        putMsg(result, Status.SUCCESS);
	
	        return result;
	    }
	
	    /**
	     * grant project
	     *
	     * @param loginUser  login user
	     * @param userId     user id
	     * @param projectIds project id array
	     * @return grant result code
	     */
	    @Override
	    @Transactional
	    public Map<String, Object> grantProject(User loginUser, int userId, String projectIds) {
	        Map<String, Object> result = new HashMap<>();
	        result.put(Constants.STATUS, false);
	
	        if (resourcePermissionCheckService.functionDisabled()) {
	            putMsg(result, Status.FUNCTION_DISABLED);
	            return result;
	        }
	
	        // check exist
	        User tempUser = userMapper.selectById(userId);
	        if (tempUser == null) {
	            log.error("User does not exist, userId:{}.", userId);
	            putMsg(result, Status.USER_NOT_EXIST, userId);
	            return result;
	        }
	
	        if (!isAdmin(loginUser)) {
	            putMsg(result, Status.NO_CURRENT_OPERATING_PERMISSION);
	            return result;
	        }
	
	        if (check(result, StringUtils.isEmpty(projectIds), Status.SUCCESS)) {
	            log.warn("Parameter projectIds is empty.");
	            return result;
	        }
	        Arrays.stream(projectIds.split(",")).distinct().forEach(projectId -> {
	            ProjectUser projectUserOld = projectUserMapper.queryProjectRelation(Integer.parseInt(projectId), userId);
	            if (projectUserOld != null) {
	                projectUserMapper.deleteProjectRelation(Integer.parseInt(projectId), userId);
	            }
	            Date now = new Date();
	            ProjectUser projectUser = new ProjectUser();
	            projectUser.setUserId(userId);
	            projectUser.setProjectId(Integer.parseInt(projectId));
	            projectUser.setPerm(Constants.AUTHORIZE_WRITABLE_PERM);
	            projectUser.setCreateTime(now);
	            projectUser.setUpdateTime(now);
	            projectUserMapper.insert(projectUser);
	        });
	        putMsg(result, Status.SUCCESS);
	
	        return result;
	    }
	
	    /**
	     * grant project by code
	     *
	     * @param loginUser   login user
	     * @param userId      user id
	     * @param projectCode project code
	     * @return grant result code
	     */
	    @Override
	    public Map<String, Object> grantProjectByCode(final User loginUser, final int userId, final long projectCode) {
	        Map<String, Object> result = new HashMap<>();
	        result.put(Constants.STATUS, false);
	
	        if (resourcePermissionCheckService.functionDisabled()) {
	            putMsg(result, Status.FUNCTION_DISABLED);
	            return result;
	        }
	
	        // 1. check if user is existed
	        User tempUser = this.userMapper.selectById(userId);
	        if (tempUser == null) {
	            log.error("User does not exist, userId:{}.", userId);
	            this.putMsg(result, Status.USER_NOT_EXIST, userId);
	            return result;
	        }
	
	        // 2. check if project is existed
	        Project project = this.projectMapper.queryByCode(projectCode);
	        if (project == null) {
	            log.error("Project does not exist, projectCode:{}.", projectCode);
	            this.putMsg(result, Status.PROJECT_NOT_FOUND, projectCode);
	            return result;
	        }
	
	        // 3. only project owner can operate
	        if (!this.canOperator(loginUser, project.getUserId())) {
	            log.warn("User does not have permission for project, userId:{}, userName:{}, projectCode:{}.",
	                    loginUser.getId(), loginUser.getUserName(), projectCode);
	            this.putMsg(result, Status.USER_NO_OPERATION_PERM);
	            return result;
	        }
	
	        // 4. maintain the relationship between project and user if not exists
	        ProjectUser projectUser = projectUserMapper.queryProjectRelation(project.getId(), userId);
	        if (projectUser == null) {
	            Date today = new Date();
	            projectUser = new ProjectUser();
	            projectUser.setUserId(userId);
	            projectUser.setProjectId(project.getId());
	            projectUser.setPerm(Constants.AUTHORIZE_WRITABLE_PERM);
	            projectUser.setCreateTime(today);
	            projectUser.setUpdateTime(today);
	            this.projectUserMapper.insert(projectUser);
	        }
	        log.info("User is granted permission for projects, userId:{}, projectCode:{}.", userId, projectCode);
	        this.putMsg(result, Status.SUCCESS);
	        return result;
	    }
	
	    /**
	     * revoke the project permission for specified user.
	     *
	     * @param loginUser   Login user
	     * @param userId      User id
	     * @param projectCode Project Code
	     * @return
	     */
	    @Override
	    public Map<String, Object> revokeProject(User loginUser, int userId, long projectCode) {
	        Map<String, Object> result = new HashMap<>();
	        result.put(Constants.STATUS, false);
	
	        if (resourcePermissionCheckService.functionDisabled()) {
	            putMsg(result, Status.FUNCTION_DISABLED);
	            return result;
	        }
	        // 1. only admin can operate
	        if (this.check(result, !this.isAdmin(loginUser), Status.USER_NO_OPERATION_PERM)) {
	            log.warn("Only admin can revoke the project permission.");
	            return result;
	        }
	
	        // 2. check if user is existed
	        User user = this.userMapper.selectById(userId);
	        if (user == null) {
	            log.error("User does not exist, userId:{}.", userId);
	            this.putMsg(result, Status.USER_NOT_EXIST, userId);
	            return result;
	        }
	
	        // 3. check if project is existed
	        Project project = this.projectMapper.queryByCode(projectCode);
	        if (project == null) {
	            log.error("Project does not exist, projectCode:{}.", projectCode);
	            this.putMsg(result, Status.PROJECT_NOT_FOUND, projectCode);
	            return result;
	        }
	
	        // 4. delete th relationship between project and user
	        this.projectUserMapper.deleteProjectRelation(project.getId(), user.getId());
	        log.info("User is revoked permission for projects, userId:{}, projectCode:{}.", userId, projectCode);
	        this.putMsg(result, Status.SUCCESS);
	        return result;
	    }
	
	    /**
	     * grant namespace
	     *
	     * @param loginUser    login user
	     * @param userId       user id
	     * @param namespaceIds namespace id array
	     * @return grant result code
	     */
	    @Override
	    @Transactional
	    public Map<String, Object> grantNamespaces(User loginUser, int userId, String namespaceIds) {
	        Map<String, Object> result = new HashMap<>();
	        result.put(Constants.STATUS, false);
	        if (resourcePermissionCheckService.functionDisabled()) {
	            putMsg(result, Status.FUNCTION_DISABLED);
	            return result;
	        }
	        // only admin can operate
	        if (this.check(result, !this.isAdmin(loginUser), Status.USER_NO_OPERATION_PERM)) {
	            log.warn("Only admin can grant namespaces.");
	            return result;
	        }
	
	        // check exist
	        User tempUser = userMapper.selectById(userId);
	        if (tempUser == null) {
	            log.error("User does not exist, userId:{}.", userId);
	            putMsg(result, Status.USER_NOT_EXIST, userId);
	            return result;
	        }
	
	        k8sNamespaceUserMapper.deleteNamespaceRelation(0, userId);
	        if (StringUtils.isNotEmpty(namespaceIds)) {
	            String[] namespaceIdArr = namespaceIds.split(",");
	            for (String namespaceId : namespaceIdArr) {
	                Date now = new Date();
	                K8sNamespaceUser namespaceUser = new K8sNamespaceUser();
	                namespaceUser.setUserId(userId);
	                namespaceUser.setNamespaceId(Integer.parseInt(namespaceId));
	                namespaceUser.setPerm(7);
	                namespaceUser.setCreateTime(now);
	                namespaceUser.setUpdateTime(now);
	                k8sNamespaceUserMapper.insert(namespaceUser);
	            }
	        }
	
	        log.info("User is granted permission for namespace, userId:{}.", tempUser.getId());
	
	        putMsg(result, Status.SUCCESS);
	
	        return result;
	    }
	
	    /**
	     * grant datasource
	     *
	     * @param loginUser     login user
	     * @param userId        user id
	     * @param datasourceIds data source id array
	     * @return grant result code
	     */
	    @Override
	    @Transactional
	    public Map<String, Object> grantDataSource(User loginUser, int userId, String datasourceIds) {
	        Map<String, Object> result = new HashMap<>();
	        result.put(Constants.STATUS, false);
	
	        if (resourcePermissionCheckService.functionDisabled()) {
	            putMsg(result, Status.FUNCTION_DISABLED);
	            return result;
	        }
	        // only admin can operate
	        if (this.check(result, !this.isAdmin(loginUser), Status.USER_NO_OPERATION_PERM)) {
	            log.warn("Only admin can grant datasource.");
	            return result;
	        }
	        User user = userMapper.selectById(userId);
	        if (user == null) {
	            putMsg(result, Status.USER_NOT_EXIST, userId);
	            return result;
	        }
	
	        datasourceUserMapper.deleteByUserId(userId);
	
	        if (check(result, StringUtils.isEmpty(datasourceIds), Status.SUCCESS)) {
	            return result;
	        }
	
	        String[] datasourceIdArr = datasourceIds.split(",");
	
	        for (String datasourceId : datasourceIdArr) {
	            Date now = new Date();
	
	            DatasourceUser datasourceUser = new DatasourceUser();
	            datasourceUser.setUserId(userId);
	            datasourceUser.setDatasourceId(Integer.parseInt(datasourceId));
	            datasourceUser.setPerm(Constants.AUTHORIZE_WRITABLE_PERM);
	            datasourceUser.setCreateTime(now);
	            datasourceUser.setUpdateTime(now);
	            datasourceUserMapper.insert(datasourceUser);
	        }
	
	        putMsg(result, Status.SUCCESS);
	
	        return result;
	    }
	
	    /**
	     * query user info
	     *
	     * @param loginUser login user
	     * @return user info
	     */
	    @Override
	    public Map<String, Object> getUserInfo(User loginUser) {
	
	        Map<String, Object> result = new HashMap<>();
	
	        if (resourcePermissionCheckService.functionDisabled()) {
	            putMsg(result, Status.FUNCTION_DISABLED);
	            return result;
	        }
	        User user = null;
	        if (loginUser.getUserType() == UserType.ADMIN_USER) {
	            user = loginUser;
	        } else {
	            user = userMapper.queryDetailsById(loginUser.getId());
	
	            List<AlertGroup> alertGroups = alertGroupMapper.queryByUserId(loginUser.getId());
	
	            StringBuilder sb = new StringBuilder();
	
	            if (alertGroups != null && !alertGroups.isEmpty()) {
	                for (int i = 0; i < alertGroups.size() - 1; i++) {
	                    sb.append(alertGroups.get(i).getGroupName()).append(",");
	                }
	                sb.append(alertGroups.get(alertGroups.size() - 1));
	                user.setAlertGroup(sb.toString());
	            }
	        }
	
	        Tenant tenant = tenantMapper.selectById(user.getTenantId());
	        if (tenant != null) {
	            user.setTenantCode(tenant.getTenantCode());
	        }
	
	        // add system default timezone if not user timezone
	        if (StringUtils.isEmpty(user.getTimeZone())) {
	            user.setTimeZone(TimeZone.getDefault().toZoneId().getId());
	        }
	
	        // remove password
	        user.setUserPassword(null);
	
	        result.put(Constants.DATA_LIST, user);
	
	        putMsg(result, Status.SUCCESS);
	        return result;
	    }
	
	    /**
	     * query user list
	     *
	     * @param loginUser login user
	     * @return user list
	     */
	    @Override
	    public Map<String, Object> queryAllGeneralUsers(User loginUser) {
	        Map<String, Object> result = new HashMap<>();
	        if (resourcePermissionCheckService.functionDisabled()) {
	            putMsg(result, Status.FUNCTION_DISABLED);
	            return result;
	        }
	        // only admin can operate
	        if (check(result, !isAdmin(loginUser), Status.USER_NO_OPERATION_PERM)) {
	            log.warn("Only admin can query all general users.");
	            return result;
	        }
	
	        List<User> userList = userMapper.queryAllGeneralUser();
	        result.put(Constants.DATA_LIST, userList);
	        putMsg(result, Status.SUCCESS);
	
	        return result;
	    }
	
	    /**
	     * query user list
	     *
	     * @param loginUser login user
	     * @return user list
	     */
	    @Override
	    public Map<String, Object> queryUserList(User loginUser) {
	        Map<String, Object> result = new HashMap<>();
	        // only admin can operate
	        if (!canOperatorPermissions(loginUser, null, AuthorizationType.ACCESS_TOKEN, USER_MANAGER)) {
	            putMsg(result, Status.USER_NO_OPERATION_PERM);
	            return result;
	        }
	        List<User> userList = userMapper.queryEnabledUsers();
	        result.put(Constants.DATA_LIST, userList);
	        putMsg(result, Status.SUCCESS);
	
	        return result;
	    }
	
	    /**
	     * verify user name exists
	     *
	     * @param userName user name
	     * @return true if user name not exists, otherwise return false
	     */
	    @Override
	    public Result<Object> verifyUserName(String userName) {
	
	        Result<Object> result = new Result<>();
	        User user = userMapper.queryByUserNameAccurately(userName);
	        if (user != null) {
	            putMsg(result, Status.USER_NAME_EXIST);
	        } else {
	            putMsg(result, Status.SUCCESS);
	        }
	
	        return result;
	    }
	
	    /**
	     * unauthorized user
	     *
	     * @param loginUser    login user
	     * @param alertgroupId alert group id
	     * @return unauthorize result code
	     */
	    @Override
	    public Map<String, Object> unauthorizedUser(User loginUser, Integer alertgroupId) {
	
	        Map<String, Object> result = new HashMap<>();
	        if (resourcePermissionCheckService.functionDisabled()) {
	            putMsg(result, Status.FUNCTION_DISABLED);
	            return result;
	        }
	        // only admin can operate
	        if (check(result, !isAdmin(loginUser), Status.USER_NO_OPERATION_PERM)) {
	            log.warn("Only admin can deauthorize user.");
	            return result;
	        }
	
	        List<User> userList = userMapper.selectList(null);
	        List<User> resultUsers = new ArrayList<>();
	        Set<User> userSet = null;
	        if (userList != null && !userList.isEmpty()) {
	            userSet = new HashSet<>(userList);
	
	            List<User> authedUserList = userMapper.queryUserListByAlertGroupId(alertgroupId);
	
	            Set<User> authedUserSet = null;
	            if (authedUserList != null && !authedUserList.isEmpty()) {
	                authedUserSet = new HashSet<>(authedUserList);
	                userSet.removeAll(authedUserSet);
	            }
	            resultUsers = new ArrayList<>(userSet);
	        }
	        result.put(Constants.DATA_LIST, resultUsers);
	        putMsg(result, Status.SUCCESS);
	
	        return result;
	    }
	
	    /**
	     * authorized user
	     *
	     * @param loginUser    login user
	     * @param alertGroupId alert group id
	     * @return authorized result code
	     */
	    @Override
	    public Map<String, Object> authorizedUser(User loginUser, Integer alertGroupId) {
	        Map<String, Object> result = new HashMap<>();
	        if (resourcePermissionCheckService.functionDisabled()) {
	            putMsg(result, Status.FUNCTION_DISABLED);
	            return result;
	        }
	        // only admin can operate
	        if (check(result, !isAdmin(loginUser), Status.USER_NO_OPERATION_PERM)) {
	            log.warn("Only admin can authorize user.");
	            return result;
	        }
	        List<User> userList = userMapper.queryUserListByAlertGroupId(alertGroupId);
	        result.put(Constants.DATA_LIST, userList);
	        putMsg(result, Status.SUCCESS);
	
	        return result;
	    }
	
	    /**
	     * @param tenantId tenant id
	     * @return true if tenant exists, otherwise return false
	     */
	    private boolean checkTenantExists(int tenantId) {
	        return tenantMapper.queryById(tenantId) != null;
	    }
	
	    /**
	     * @return if check failed return the field, otherwise return null
	     */
	    private String checkUserParams(String userName, String password, String email, String phone) {
	
	        String msg = null;
	        if (!CheckUtils.checkUserName(userName)) {
	            log.warn("Parameter userName check failed.");
	            msg = userName;
	        } else if (!CheckUtils.checkPassword(password)) {
	            log.warn("Parameter password check failed.");
	            msg = password;
	        } else if (!CheckUtils.checkEmail(email)) {
	            log.warn("Parameter email check failed.");
	            msg = email;
	        } else if (!CheckUtils.checkPhone(phone)) {
	            log.warn("Parameter phone check failed.");
	            msg = phone;
	        }
	
	        return msg;
	    }
	
	    /**
	     * registry user, default state is 0, default tenant_id is 1, no phone, no queue
	     *
	     * @param userName       user name
	     * @param userPassword   user password
	     * @param repeatPassword repeat password
	     * @param email          email
	     * @return registry result code
	     * @throws Exception exception
	     */
	    @Override
	    @Transactional
	    public Map<String, Object> registerUser(String userName, String userPassword, String repeatPassword, String email) {
	        Map<String, Object> result = new HashMap<>();
	
	        // check user params
	        String msg = this.checkUserParams(userName, userPassword, email, "");
	        if (resourcePermissionCheckService.functionDisabled()) {
	            putMsg(result, Status.FUNCTION_DISABLED);
	            return result;
	        }
	        if (!StringUtils.isEmpty(msg)) {
	            putMsg(result, Status.REQUEST_PARAMS_NOT_VALID_ERROR, msg);
	            return result;
	        }
	
	        if (!userPassword.equals(repeatPassword)) {
	            putMsg(result, Status.REQUEST_PARAMS_NOT_VALID_ERROR, "two passwords are not same");
	            return result;
	        }
	        User user = createUser(userName, userPassword, email, -1, "", "", Flag.NO.ordinal());
	        putMsg(result, Status.SUCCESS);
	        result.put(Constants.DATA_LIST, user);
	        return result;
	    }
	
	    /**
	     * activate user, only system admin have permission, change user state code 0 to 1
	     *
	     * @param loginUser login user
	     * @param userName  user name
	     * @return create result code
	     */
	    @Override
	    public Map<String, Object> activateUser(User loginUser, String userName) {
	        Map<String, Object> result = new HashMap<>();
	        result.put(Constants.STATUS, false);
	        if (resourcePermissionCheckService.functionDisabled()) {
	            putMsg(result, Status.FUNCTION_DISABLED);
	            return result;
	        }
	        if (!isAdmin(loginUser)) {
	            putMsg(result, Status.USER_NO_OPERATION_PERM);
	            return result;
	        }
	
	        if (!CheckUtils.checkUserName(userName)) {
	            putMsg(result, Status.REQUEST_PARAMS_NOT_VALID_ERROR, userName);
	            return result;
	        }
	
	        User user = userMapper.queryByUserNameAccurately(userName);
	
	        if (user == null) {
	            putMsg(result, Status.USER_NOT_EXIST, userName);
	            return result;
	        }
	
	        if (user.getState() != Flag.NO.ordinal()) {
	            putMsg(result, Status.REQUEST_PARAMS_NOT_VALID_ERROR, userName);
	            return result;
	        }
	
	        user.setState(Flag.YES.ordinal());
	        Date now = new Date();
	        user.setUpdateTime(now);
	        userMapper.updateById(user);
	
	        User responseUser = userMapper.queryByUserNameAccurately(userName);
	        putMsg(result, Status.SUCCESS);
	        result.put(Constants.DATA_LIST, responseUser);
	        return result;
	    }
	
	    /**
	     * activate user, only system admin have permission, change users state code 0 to 1
	     *
	     * @param loginUser login user
	     * @param userNames user name
	     * @return create result code
	     */
	    @Override
	    public Map<String, Object> batchActivateUser(User loginUser, List<String> userNames) {
	        Map<String, Object> result = new HashMap<>();
	
	        if (resourcePermissionCheckService.functionDisabled()) {
	            putMsg(result, Status.FUNCTION_DISABLED);
	            return result;
	        }
	        if (!isAdmin(loginUser)) {
	            putMsg(result, Status.USER_NO_OPERATION_PERM);
	            return result;
	        }
	
	        int totalSuccess = 0;
	        List<String> successUserNames = new ArrayList<>();
	        Map<String, Object> successRes = new HashMap<>();
	        int totalFailed = 0;
	        List<Map<String, String>> failedInfo = new ArrayList<>();
	        Map<String, Object> failedRes = new HashMap<>();
	        for (String userName : userNames) {
	            Map<String, Object> tmpResult = activateUser(loginUser, userName);
	            if (tmpResult.get(Constants.STATUS) != Status.SUCCESS) {
	                totalFailed++;
	                Map<String, String> failedBody = new HashMap<>();
	                failedBody.put("userName", userName);
	                Status status = (Status) tmpResult.get(Constants.STATUS);
	                String errorMessage = MessageFormat.format(status.getMsg(), userName);
	                failedBody.put("msg", errorMessage);
	                failedInfo.add(failedBody);
	            } else {
	                totalSuccess++;
	                successUserNames.add(userName);
	            }
	        }
	        successRes.put("sum", totalSuccess);
	        successRes.put("userName", successUserNames);
	        failedRes.put("sum", totalFailed);
	        failedRes.put("info", failedInfo);
	        Map<String, Object> res = new HashMap<>();
	        res.put("success", successRes);
	        res.put("failed", failedRes);
	        putMsg(result, Status.SUCCESS);
	        result.put(Constants.DATA_LIST, res);
	        return result;
	    }
	
	    /**
	     * Make sure user with given name exists, and create the user if not exists
	     * <p>
	     * ONLY for python gateway server, and should not use this in web ui function
	     *
	     * @param userName     user name
	     * @param userPassword user password
	     * @param email        user email
	     * @param phone        user phone
	     * @param tenantCode   tenant code
	     * @param queue        queue
	     * @param state        state
	     * @return create result code
	     */
	    @Override
	    @Transactional
	    public User createUserIfNotExists(String userName,
	                                      String userPassword,
	                                      String email,
	                                      String phone,
	                                      String tenantCode,
	                                      String queue,
	                                      int state) {
	        User user = userMapper.queryByUserNameAccurately(userName);
	        if (Objects.isNull(user)) {
	            Tenant tenant = tenantMapper.queryByTenantCode(tenantCode);
	            user = createUser(userName, userPassword, email, tenant.getId(), phone, queue, state);
	            return user;
	        }
	
	        updateUser(user, user.getId(), userName, userPassword, email, user.getTenantId(), phone, queue, state, null);
	        user = userMapper.queryDetailsById(user.getId());
	        return user;
	    }
	}
		
",
	role:"
	user	
",
,

],
model:"
gpt-4-1106-preview
",
response_format:
{
	type:"
	json_object	
",

}
temperature:"0.9",
