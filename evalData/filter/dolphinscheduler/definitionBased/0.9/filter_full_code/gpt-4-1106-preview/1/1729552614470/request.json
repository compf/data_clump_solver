{
    "messages": [
        {
            "content": "\nI will provide you Java files that contain data clumps.\nChoose one data clump that you think is most important and should be refactored.\n\nA data clump exists if\n1) two methods (in the same or in different classes) have at least 3 common parameters\n    and one of those methods does not override the other,\n\nor  \n2) At least three fields in a class are common with the parameters of a method (in the same or in a different class),\n\nor\n3) Two different classes have at least three common fields\n\n\nReturn the key of that data clump.\nJustify your response. \nUse the following  output format in JSON:\n\nThe \"reason\" attribute should be equal to as follows:\n        \"size\" -> if you choose the data clump because of its large number of parameters/fields\n        \"occurrence\" -> if you choose the data clump because it occurs very often and leads to much duplication\n        \"affected_files\" -> if you choose this data clump because many files are affected by this data clump\n        \"domain\" -> if you choose this data clump because the variables share a common domain so that extracting a class is a good idea\n        \"other\" -> if none of the options above fits\n\n### JSON\n{\n    \"key\":\"<a portion of the source code, as submitted, that shows where the data clump is located\",,\n    \"reason\":\"<as explained above>,\n    \"justification\":\"<Your justification which explains the 'reason' in more details>\",\n    \"suggestedName\":\"<A suitable name for an extracted class if the data clumps variables were to be extracted>\"\n\n}\n\n### END JSON\n",
            "role": "user"
        },
        {
            "content": "//dolphinscheduler-datasource-plugin/dolphinscheduler-datasource-api/src/main/java/org/apache/dolphinscheduler/plugin/datasource/api/constants/DataSourceConstants.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.dolphinscheduler.plugin.datasource.api.constants;\n\nimport org.apache.dolphinscheduler.common.constants.DateConstants;\n\nimport java.time.Duration;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\nimport lombok.experimental.UtilityClass;\n\nimport com.google.common.collect.Sets;\n\n@UtilityClass\npublic class DataSourceConstants {\n\n    public static final String ORG_POSTGRESQL_DRIVER = \"org.postgresql.Driver\";\n    public static final String COM_MYSQL_CJ_JDBC_DRIVER = \"com.mysql.cj.jdbc.Driver\";\n    public static final String COM_MYSQL_JDBC_DRIVER = \"com.mysql.jdbc.Driver\";\n    public static final String ORG_APACHE_HIVE_JDBC_HIVE_DRIVER = \"org.apache.hive.jdbc.HiveDriver\";\n    public static final String COM_CLICKHOUSE_JDBC_DRIVER = \"com.clickhouse.jdbc.ClickHouseDriver\";\n    public static final String COM_DATABEND_JDBC_DRIVER = \"com.databend.jdbc.DatabendDriver\";\n    public static final String COM_ORACLE_JDBC_DRIVER = \"oracle.jdbc.OracleDriver\";\n    public static final String COM_SQLSERVER_JDBC_DRIVER = \"com.microsoft.sqlserver.jdbc.SQLServerDriver\";\n    public static final String COM_DB2_JDBC_DRIVER = \"com.ibm.db2.jcc.DB2Driver\";\n    public static final String COM_PRESTO_JDBC_DRIVER = \"com.facebook.presto.jdbc.PrestoDriver\";\n    public static final String COM_REDSHIFT_JDBC_DRIVER = \"com.amazon.redshift.jdbc42.Driver\";\n    public static final String COM_ATHENA_JDBC_DRIVER = \"com.simba.athena.jdbc.Driver\";\n    public static final String COM_TRINO_JDBC_DRIVER = \"io.trino.jdbc.TrinoDriver\";\n    public static final String COM_DAMENG_JDBC_DRIVER = \"dm.jdbc.driver.DmDriver\";\n    public static final String ORG_APACHE_KYUUBI_JDBC_DRIVER = \"org.apache.kyuubi.jdbc.KyuubiHiveDriver\";\n    public static final String COM_OCEANBASE_JDBC_DRIVER = \"com.oceanbase.jdbc.Driver\";\n    public static final String NET_SNOWFLAKE_JDBC_DRIVER = \"net.snowflake.client.jdbc.SnowflakeDriver\";\n    public static final String COM_VERTICA_JDBC_DRIVER = \"com.vertica.jdbc.Driver\";\n    public static final String COM_HANA_DB_JDBC_DRIVER = \"com.sap.db.jdbc.Driver\";\n\n    public static final String JDBC_MYSQL = \"jdbc:mysql://\";\n    public static final String JDBC_MYSQL_LOADBALANCE = \"jdbc:mysql:loadbalance://\";\n    public static final String JDBC_POSTGRESQL = \"jdbc:postgresql://\";\n    public static final String JDBC_HIVE_2 = \"jdbc:hive2://\";\n    public static final String JDBC_KYUUBI = \"jdbc:kyuubi://\";\n    public static final String JDBC_CLICKHOUSE = \"jdbc:clickhouse://\";\n    public static final String JDBC_DATABEND = \"jdbc:databend://\";\n    public static final String JDBC_ORACLE_SID = \"jdbc:oracle:thin:@\";\n    public static final String JDBC_ORACLE_SERVICE_NAME = \"jdbc:oracle:thin:@//\";\n    public static final String JDBC_SQLSERVER = \"jdbc:sqlserver://\";\n    public static final String JDBC_DB2 = \"jdbc:db2://\";\n    public static final String JDBC_PRESTO = \"jdbc:presto://\";\n    public static final String JDBC_REDSHIFT = \"jdbc:redshift://\";\n    public static final String JDBC_REDSHIFT_IAM = \"jdbc:redshift:iam://\";\n    public static final String JDBC_ATHENA = \"jdbc:awsathena://\";\n    public static final String JDBC_TRINO = \"jdbc:trino://\";\n    public static final String JDBC_DAMENG = \"jdbc:dm://\";\n    public static final String JDBC_OCEANBASE = \"jdbc:oceanbase://\";\n    public static final String JDBC_SNOWFLAKE = \"jdbc:snowflake://\";\n    public static final String JDBC_VERTICA = \"jdbc:vertica://\";\n    public static final String JDBC_HANA = \"jdbc:sap://\";\n\n    public static final String POSTGRESQL_VALIDATION_QUERY = \"select version()\";\n    public static final String MYSQL_VALIDATION_QUERY = \"select 1\";\n    public static final String HIVE_VALIDATION_QUERY = \"select 1\";\n    public static final String CLICKHOUSE_VALIDATION_QUERY = \"select 1\";\n    public static final String DATABEND_VALIDATION_QUERY = \"select 1\";\n    public static final String ORACLE_VALIDATION_QUERY = \"select 1 from dual\";\n    public static final String SQLSERVER_VALIDATION_QUERY = \"select 1\";\n    public static final String DB2_VALIDATION_QUERY = \"select 1 from sysibm.sysdummy1\";\n    public static final String PRESTO_VALIDATION_QUERY = \"select 1\";\n    public static final String REDHIFT_VALIDATION_QUERY = \"select 1\";\n    public static final String ATHENA_VALIDATION_QUERY = \"select 1\";\n    public static final String TRINO_VALIDATION_QUERY = \"select 1\";\n    public static final String DAMENG_VALIDATION_QUERY = \"select 1\";\n    public static final String SNOWFLAKE_VALIDATION_QUERY = \"select 1\";\n\n    public static final String KYUUBI_VALIDATION_QUERY = \"select 1\";\n    public static final String VERTICA_VALIDATION_QUERY = \"select 1\";\n\n    public static final String HANA_VALIDATION_QUERY = \"select 1 from DUMMY\";\n\n    public static final String SPRING_DATASOURCE_MIN_IDLE = \"spring.datasource.minIdle\";\n\n    public static final String SPRING_DATASOURCE_MAX_ACTIVE = \"spring.datasource.maxActive\";\n\n    public static final String SUPPORT_HIVE_ONE_SESSION = \"support.hive.oneSession\";\n    /**\n     * QUESTION ?\n     */\n    public static final String QUESTION = \"?\";\n\n    /**\n     * comma ,\n     */\n    public static final String COMMA = \",\";\n\n    /**\n     * hyphen\n     */\n    public static final String HYPHEN = \"-\";\n\n    /**\n     * slash /\n     */\n    public static final String SLASH = \"/\";\n\n    /**\n     * COLON :\n     */\n    public static final String COLON = \":\";\n\n    /**\n     * SPACE \" \"\n     */\n    public static final String SPACE = \" \";\n\n    /**\n     * SINGLE_SLASH /\n     */\n    public static final String SINGLE_SLASH = \"/\";\n\n    /**\n     * DOUBLE_SLASH //\n     */\n    public static final String DOUBLE_SLASH = \"//\";\n\n    /**\n     * SINGLE_QUOTES \"'\"\n     */\n    public static final String SINGLE_QUOTES = \"'\";\n    /**\n     * DOUBLE_QUOTES \"\\\"\"\n     */\n    public static final String DOUBLE_QUOTES = \"\\\"\";\n\n    /**\n     * SEMICOLON ;\n     */\n    public static final String SEMICOLON = \";\";\n\n    /**\n     * EQUAL SIGN\n     */\n    public static final String EQUAL_SIGN = \"=\";\n    /**\n     * AT SIGN\n     */\n    public static final String AT_SIGN = \"@\";\n    /**\n     * UNDERLINE\n     */\n    public static final String UNDERLINE = \"_\";\n\n    /**\n     * sleep time\n     */\n    public static final int SLEEP_TIME_MILLIS = 1000;\n\n    /**\n     * exit code failure\n     */\n    public static final int EXIT_CODE_FAILURE = -1;\n\n    /**\n     * exit code success\n     */\n    public static final int EXIT_CODE_SUCCESS = 0;\n    /**\n     * running code\n     */\n    public static final int RUNNING_CODE = 1;\n\n    public static final String SH = \"sh\";\n\n    /**\n     * log flush interval?output when reach the interval\n     */\n    public static final int DEFAULT_LOG_FLUSH_INTERVAL = 1000;\n\n    /**\n     * pstree, get pud and sub pid\n     */\n    public static final String PSTREE = \"pstree\";\n\n    public static final String RWXR_XR_X = \"rwxr-xr-x\";\n\n    /**\n     * date format of yyyyMMddHHmmss\n     */\n    public static final String PARAMETER_FORMAT_TIME = \"yyyyMMddHHmmss\";\n\n    /**\n     * new\n     * schedule time\n     */\n    public static final String PARAMETER_SHECDULE_TIME = \"schedule.time\";\n\n    /**\n     * system date(yyyyMMddHHmmss)\n     */\n    public static final String PARAMETER_DATETIME = DateConstants.PARAMETER_DATETIME;\n\n    /**\n     * system date(yyyymmdd) today\n     */\n    public static final String PARAMETER_CURRENT_DATE = DateConstants.PARAMETER_CURRENT_DATE;\n\n    /**\n     * system date(yyyymmdd) yesterday\n     */\n    public static final String PARAMETER_BUSINESS_DATE = DateConstants.PARAMETER_BUSINESS_DATE;\n\n    /**\n     * the absolute path of current executing task\n     */\n    public static final String PARAMETER_TASK_EXECUTE_PATH = \"system.task.execute.path\";\n\n    /**\n     * the instance id of current task\n     */\n    public static final String PARAMETER_TASK_INSTANCE_ID = \"system.task.instance.id\";\n\n    /**\n     * the definition code of current task\n     */\n    public static final String PARAMETER_TASK_DEFINITION_CODE = \"system.task.definition.code\";\n\n    /**\n     * the definition name of current task\n     */\n    public static final String PARAMETER_TASK_DEFINITION_NAME = \"system.task.definition.name\";\n\n    /**\n     * the instance id of the workflow to which current task belongs\n     */\n    public static final String PARAMETER_WORKFLOW_INSTANCE_ID = \"system.workflow.instance.id\";\n\n    /**\n     * the definition code of the workflow to which current task belongs\n     */\n    public static final String PARAMETER_WORKFLOW_DEFINITION_CODE = \"system.workflow.definition.code\";\n\n    /**\n     * the definition name of the workflow to which current task belongs\n     */\n    public static final String PARAMETER_WORKFLOW_DEFINITION_NAME = \"system.workflow.definition.name\";\n\n    /**\n     * the code of the project to which current task belongs\n     */\n    public static final String PARAMETER_PROJECT_CODE = \"system.project.code\";\n\n    /**\n     * the name of the project to which current task belongs\n     */\n    public static final String PARAMETER_PROJECT_NAME = \"system.project.name\";\n    /**\n     * month_begin\n     */\n    public static final String MONTH_BEGIN = \"month_begin\";\n    /**\n     * add_months\n     */\n    public static final String ADD_MONTHS = \"add_months\";\n    /**\n     * month_end\n     */\n    public static final String MONTH_END = \"month_end\";\n    /**\n     * week_begin\n     */\n    public static final String WEEK_BEGIN = \"week_begin\";\n    /**\n     * week_end\n     */\n    public static final String WEEK_END = \"week_end\";\n    /**\n     * this_day\n     */\n    public static final String THIS_DAY = \"this_day\";\n    /**\n     * last_day\n     */\n    public static final String LAST_DAY = \"last_day\";\n\n    /**\n     * month_first_day\n     */\n    public static final String MONTH_FIRST_DAY = \"month_first_day\";\n\n    /**\n     * month_last_day\n     */\n    public static final String MONTH_LAST_DAY = \"month_last_day\";\n\n    /**\n     * week_first_day\n     */\n    public static final String WEEK_FIRST_DAY = \"week_first_day\";\n\n    /**\n     * week_last_day\n     */\n    public static final String WEEK_LAST_DAY = \"week_last_day\";\n\n    /**\n     * year_week\n     */\n    public static final String YEAR_WEEK = \"year_week\";\n    /**\n     * timestamp\n     */\n    public static final String TIMESTAMP = \"timestamp\";\n    public static final char SUBTRACT_CHAR = '-';\n    public static final char ADD_CHAR = '+';\n    public static final char MULTIPLY_CHAR = '*';\n    public static final char DIVISION_CHAR = '/';\n    public static final char LEFT_BRACE_CHAR = '(';\n    public static final char RIGHT_BRACE_CHAR = ')';\n    public static final String ADD_STRING = \"+\";\n    public static final String MULTIPLY_STRING = \"*\";\n    public static final String DIVISION_STRING = \"/\";\n    public static final String LEFT_BRACE_STRING = \"(\";\n    public static final char P = 'P';\n    public static final char N = 'N';\n    public static final String SUBTRACT_STRING = \"-\";\n    public static final String LOCAL_PARAMS_LIST = \"localParamsList\";\n    public static final String TASK_TYPE = \"taskType\";\n    public static final String QUEUE = \"queue\";\n    /**\n     * default display rows\n     */\n    public static final int DEFAULT_DISPLAY_ROWS = 10;\n\n    /**\n     * jar\n     */\n    public static final String JAR = \"jar\";\n\n    /**\n     * hadoop\n     */\n    public static final String HADOOP = \"hadoop\";\n\n    /**\n     * -D <property>=<value>\n     */\n    public static final String D = \"-D\";\n\n    /**\n     * datasource encryption salt\n     */\n    public static final String DATASOURCE_ENCRYPTION_SALT_DEFAULT = \"!@#$%^&*\";\n    public static final String DATASOURCE_ENCRYPTION_ENABLE = \"datasource.encryption.enable\";\n    public static final String DATASOURCE_ENCRYPTION_SALT = \"datasource.encryption.salt\";\n\n    /**\n     * kerberos\n     */\n    public static final String KERBEROS = \"kerberos\";\n\n    /**\n     * kerberos expire time\n     */\n    public static final String KERBEROS_EXPIRE_TIME = \"kerberos.expire.time\";\n\n    /**\n     * java.security.krb5.conf\n     */\n    public static final String JAVA_SECURITY_KRB5_CONF = \"java.security.krb5.conf\";\n\n    /**\n     * java.security.krb5.conf.path\n     */\n    public static final String JAVA_SECURITY_KRB5_CONF_PATH = \"java.security.krb5.conf.path\";\n\n    /**\n     * loginUserFromKeytab user\n     */\n    public static final String LOGIN_USER_KEY_TAB_USERNAME = \"login.user.keytab.username\";\n\n    /**\n     * loginUserFromKeytab path\n     */\n    public static final String LOGIN_USER_KEY_TAB_PATH = \"login.user.keytab.path\";\n\n    /**\n     * hadoop.security.authentication\n     */\n    public static final String HADOOP_SECURITY_AUTHENTICATION = \"hadoop.security.authentication\";\n\n    /**\n     * hadoop.security.authentication\n     */\n    public static final String HADOOP_SECURITY_AUTHENTICATION_STARTUP_STATE =\n            \"hadoop.security.authentication.startup.state\";\n\n    /**\n     * hdfs/s3 configuration\n     * resource.storage.upload.base.path\n     */\n    public static final String RESOURCE_UPLOAD_PATH = \"resource.storage.upload.base.path\";\n\n    /**\n     * data.quality.jar.dir\n     */\n    public static final String DATA_QUALITY_JAR_DIR = \"data-quality.jar.dir\";\n\n    public static final String TASK_TYPE_DATA_QUALITY = \"DATA_QUALITY\";\n\n    public static final Set<String> TASK_TYPE_SET_K8S = Sets.newHashSet(\"K8S\", \"KUBEFLOW\");\n\n    /**\n     * azure config\n     */\n    public static final String AZURE_CLIENT_ID = \"resource.azure.client.id\";\n    public static final String AZURE_CLIENT_SECRET = \"resource.azure.client.secret\";\n    public static final String AZURE_ACCESS_SUB_ID = \"resource.azure.subId\";\n    public static final String AZURE_SECRET_TENANT_ID = \"resource.azure.tenant.id\";\n    public static final String QUERY_INTERVAL = \"resource.query.interval\";\n\n    /**\n     * use for k8s task\n     */\n    public static final String API_VERSION = \"batch/v1\";\n    public static final String RESTART_POLICY = \"Never\";\n    public static final String MEMORY = \"memory\";\n    public static final String CPU = \"cpu\";\n    public static final String LAYER_LABEL = \"k8s.cn/layer\";\n    public static final String LAYER_LABEL_VALUE = \"batch\";\n    public static final String NAME_LABEL = \"k8s.cn/name\";\n    public static final String TASK_INSTANCE_ID = \"taskInstanceId\";\n    public static final String MI = \"Mi\";\n    public static final int JOB_TTL_SECONDS = 300;\n    public static final int LOG_LINES = 500;\n    public static final String NAMESPACE_NAME = \"name\";\n    public static final String CLUSTER = \"cluster\";\n\n    /**\n     * spark / flink on k8s label name\n     */\n    public static final String UNIQUE_LABEL_NAME = \"dolphinscheduler-label\";\n\n    /**\n     * conda config used by jupyter task plugin\n     */\n    public static final String CONDA_PATH = \"conda.path\";\n\n    // Loop task constants\n    public static final Duration DEFAULT_LOOP_STATUS_INTERVAL = Duration.ofSeconds(5L);\n\n    /**\n     * sql params regex\n     */\n    public static final String GROUP_NAME1 = \"paramName1\";\n    public static final String GROUP_NAME2 = \"paramName2\";\n    public static final String SQL_PARAMS_REGEX =\n            String.format(\"['\\\"]\\\\$\\\\{(?<%s>.*?)}['\\\"]|\\\\$\\\\{(?<%s>.*?)}\", GROUP_NAME1, GROUP_NAME2);\n    public static final Pattern SQL_PARAMS_PATTERN = Pattern.compile(SQL_PARAMS_REGEX);\n\n    public static final String AZURE_SQL_DATABASE_SPN = \"https://database.windows.net/\";\n    public static final String AZURE_SQL_DATABASE_TOKEN_SCOPE = \"/.default\";\n\n}\n",
            "role": "user"
        },
        {
            "content": "//dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/api/TaskConstants.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.dolphinscheduler.plugin.task.api;\n\nimport org.apache.dolphinscheduler.common.constants.DateConstants;\n\nimport java.time.Duration;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\nimport com.google.common.collect.Sets;\n\npublic class TaskConstants {\n\n    private TaskConstants() {\n        throw new IllegalStateException(\"Utility class\");\n    }\n\n    public static final String YARN_APPLICATION_REGEX = \"application_\\\\d+_\\\\d+\";\n\n    public static final String FLINK_APPLICATION_REGEX = \"JobID \\\\w+\";\n\n    public static final String DATASOURCE_PASSWORD_REGEX =\n            \"(?<=((?i)password((\\\" : \\\")|(\\\":\\\")|(\\\\\\\\\\\":\\\\\\\\\\\")|(=')))).*?(?=((\\\")|(\\\\\\\\\\\")|(')))\";\n\n    /**\n     * exit code kill\n     */\n    public static final int EXIT_CODE_KILL = 137;\n    public static final String PID = \"pid\";\n\n    /**\n     * QUESTION ?\n     */\n    public static final String QUESTION = \"?\";\n\n    /**\n     * comma ,\n     */\n    public static final String COMMA = \",\";\n\n    /**\n     * hyphen\n     */\n    public static final String HYPHEN = \"-\";\n\n    /**\n     * slash /\n     */\n    public static final String SLASH = \"/\";\n\n    /**\n     * COLON :\n     */\n    public static final String COLON = \":\";\n\n    /**\n     * SPACE \" \"\n     */\n    public static final String SPACE = \" \";\n\n    /**\n     * SINGLE_SLASH /\n     */\n    public static final String SINGLE_SLASH = \"/\";\n\n    /**\n     * DOUBLE_SLASH //\n     */\n    public static final String DOUBLE_SLASH = \"//\";\n\n    /**\n     * SINGLE_QUOTES \"'\"\n     */\n    public static final String SINGLE_QUOTES = \"'\";\n    /**\n     * DOUBLE_QUOTES \"\\\"\"\n     */\n    public static final String DOUBLE_QUOTES = \"\\\"\";\n\n    /**\n     * SEMICOLON ;\n     */\n    public static final String SEMICOLON = \";\";\n\n    /**\n     * EQUAL SIGN\n     */\n    public static final String EQUAL_SIGN = \"=\";\n\n    /**\n     * UNDERLINE\n     */\n    public static final String UNDERLINE = \"_\";\n\n    /**\n     * sleep time\n     */\n    public static final int SLEEP_TIME_MILLIS = 1000;\n\n    /**\n     * exit code failure\n     */\n    public static final int EXIT_CODE_FAILURE = -1;\n\n    /**\n     * exit code success\n     */\n    public static final int EXIT_CODE_SUCCESS = 0;\n    /**\n     * running code\n     */\n    public static final int RUNNING_CODE = 1;\n\n    public static final String SH = \"sh\";\n\n    /**\n     * log flush interval?output when reach the interval\n     */\n    public static final int DEFAULT_LOG_FLUSH_INTERVAL = 1000;\n\n    /**\n     * pstree, get pud and sub pid\n     */\n    public static final String PSTREE = \"pstree\";\n\n    public static final String RWXR_XR_X = \"rwxr-xr-x\";\n\n    /**\n     * date format of yyyyMMddHHmmss\n     */\n    public static final String PARAMETER_FORMAT_TIME = \"yyyyMMddHHmmss\";\n\n    /**\n     * new\n     * schedule time\n     */\n    public static final String PARAMETER_SHECDULE_TIME = \"schedule.time\";\n\n    /**\n     * system date(yyyyMMddHHmmss)\n     */\n    public static final String PARAMETER_DATETIME = DateConstants.PARAMETER_DATETIME;\n\n    /**\n     * system date(yyyymmdd) today\n     */\n    public static final String PARAMETER_CURRENT_DATE = DateConstants.PARAMETER_CURRENT_DATE;\n\n    /**\n     * system date(yyyymmdd) yesterday\n     */\n    public static final String PARAMETER_BUSINESS_DATE = DateConstants.PARAMETER_BUSINESS_DATE;\n\n    /**\n     * the absolute path of current executing task\n     */\n    public static final String PARAMETER_TASK_EXECUTE_PATH = \"system.task.execute.path\";\n\n    /**\n     * the instance id of current task\n     */\n    public static final String PARAMETER_TASK_INSTANCE_ID = \"system.task.instance.id\";\n\n    /**\n     * the definition code of current task\n     */\n    public static final String PARAMETER_TASK_DEFINITION_CODE = \"system.task.definition.code\";\n\n    /**\n     * the definition name of current task\n     */\n    public static final String PARAMETER_TASK_DEFINITION_NAME = \"system.task.definition.name\";\n\n    /**\n     * the instance id of the workflow to which current task belongs\n     */\n    public static final String PARAMETER_WORKFLOW_INSTANCE_ID = \"system.workflow.instance.id\";\n\n    /**\n     * the definition code of the workflow to which current task belongs\n     */\n    public static final String PARAMETER_WORKFLOW_DEFINITION_CODE = \"system.workflow.definition.code\";\n\n    /**\n     * the definition name of the workflow to which current task belongs\n     */\n    public static final String PARAMETER_WORKFLOW_DEFINITION_NAME = \"system.workflow.definition.name\";\n\n    /**\n     * the code of the project to which current task belongs\n     */\n    public static final String PARAMETER_PROJECT_CODE = \"system.project.code\";\n\n    /**\n     * the name of the project to which current task belongs\n     */\n    public static final String PARAMETER_PROJECT_NAME = \"system.project.name\";\n    /**\n     * month_begin\n     */\n    public static final String MONTH_BEGIN = \"month_begin\";\n    /**\n     * add_months\n     */\n    public static final String ADD_MONTHS = \"add_months\";\n    /**\n     * month_end\n     */\n    public static final String MONTH_END = \"month_end\";\n    /**\n     * week_begin\n     */\n    public static final String WEEK_BEGIN = \"week_begin\";\n    /**\n     * week_end\n     */\n    public static final String WEEK_END = \"week_end\";\n    /**\n     * this_day\n     */\n    public static final String THIS_DAY = \"this_day\";\n    /**\n     * last_day\n     */\n    public static final String LAST_DAY = \"last_day\";\n\n    /**\n     * month_first_day\n     */\n    public static final String MONTH_FIRST_DAY = \"month_first_day\";\n\n    /**\n     * month_last_day\n     */\n    public static final String MONTH_LAST_DAY = \"month_last_day\";\n\n    /**\n     * week_first_day\n     */\n    public static final String WEEK_FIRST_DAY = \"week_first_day\";\n\n    /**\n     * week_last_day\n     */\n    public static final String WEEK_LAST_DAY = \"week_last_day\";\n\n    /**\n     * year_week\n     */\n    public static final String YEAR_WEEK = \"year_week\";\n    /**\n     * timestamp\n     */\n    public static final String TIMESTAMP = \"timestamp\";\n    public static final char SUBTRACT_CHAR = '-';\n    public static final char ADD_CHAR = '+';\n    public static final char MULTIPLY_CHAR = '*';\n    public static final char DIVISION_CHAR = '/';\n    public static final char LEFT_BRACE_CHAR = '(';\n    public static final char RIGHT_BRACE_CHAR = ')';\n    public static final String ADD_STRING = \"+\";\n    public static final String MULTIPLY_STRING = \"*\";\n    public static final String DIVISION_STRING = \"/\";\n    public static final String LEFT_BRACE_STRING = \"(\";\n    public static final char P = 'P';\n    public static final char N = 'N';\n    public static final String SUBTRACT_STRING = \"-\";\n    public static final String LOCAL_PARAMS_LIST = \"localParamsList\";\n    public static final String TASK_TYPE = \"taskType\";\n    public static final String QUEUE = \"queue\";\n    /**\n     * default display rows\n     */\n    public static final int DEFAULT_DISPLAY_ROWS = 10;\n\n    /**\n     * jar\n     */\n    public static final String JAR = \"jar\";\n\n    /**\n     * hadoop\n     */\n    public static final String HADOOP = \"hadoop\";\n\n    /**\n     * -D <property>=<value>\n     */\n    public static final String D = \"-D\";\n\n    /**\n     * java.security.krb5.conf\n     */\n    public static final String JAVA_SECURITY_KRB5_CONF = \"java.security.krb5.conf\";\n\n    /**\n     * java.security.krb5.conf.path\n     */\n    public static final String JAVA_SECURITY_KRB5_CONF_PATH = \"java.security.krb5.conf.path\";\n\n    /**\n     * hadoop.security.authentication\n     */\n    public static final String HADOOP_SECURITY_AUTHENTICATION_STARTUP_STATE =\n            \"hadoop.security.authentication.startup.state\";\n\n    public static final String TASK_TYPE_DATA_QUALITY = \"DATA_QUALITY\";\n\n    public static final Set<String> TASK_TYPE_SET_K8S = Sets.newHashSet(\"K8S\", \"KUBEFLOW\");\n\n    /**\n     * azure config\n     */\n    public static final String AZURE_CLIENT_ID = \"resource.azure.client.id\";\n    public static final String AZURE_CLIENT_SECRET = \"resource.azure.client.secret\";\n    public static final String AZURE_ACCESS_SUB_ID = \"resource.azure.subId\";\n    public static final String AZURE_SECRET_TENANT_ID = \"resource.azure.tenant.id\";\n    public static final String QUERY_INTERVAL = \"resource.query.interval\";\n\n    /**\n     * use for k8s task\n     */\n    public static final String API_VERSION = \"batch/v1\";\n    public static final String RESTART_POLICY = \"Never\";\n    public static final String MEMORY = \"memory\";\n    public static final String CPU = \"cpu\";\n    public static final String LAYER_LABEL = \"k8s.cn/layer\";\n    public static final String LAYER_LABEL_VALUE = \"batch\";\n    public static final String NAME_LABEL = \"k8s.cn/name\";\n    public static final String TASK_INSTANCE_ID = \"taskInstanceId\";\n    public static final String MI = \"Mi\";\n    public static final int JOB_TTL_SECONDS = 300;\n    public static final int LOG_LINES = 500;\n    public static final String NAMESPACE_NAME = \"name\";\n    public static final String CLUSTER = \"cluster\";\n\n    /**\n     * spark / flink on k8s label name\n     */\n    public static final String UNIQUE_LABEL_NAME = \"dolphinscheduler-label\";\n\n    /**\n     * conda config used by jupyter task plugin\n     */\n    public static final String CONDA_PATH = \"conda.path\";\n\n    // Loop task constants\n    public static final Duration DEFAULT_LOOP_STATUS_INTERVAL = Duration.ofSeconds(5L);\n\n    /**\n     * sql params regex\n     */\n    public static final String GROUP_NAME1 = \"paramName1\";\n    public static final String GROUP_NAME2 = \"paramName2\";\n    public static final String SQL_PARAMS_REGEX =\n            String.format(\"['\\\"]\\\\$\\\\{(?<%s>.*?)}['\\\"]|\\\\$\\\\{(?<%s>.*?)}\", GROUP_NAME1, GROUP_NAME2);\n    public static final Pattern SQL_PARAMS_PATTERN = Pattern.compile(SQL_PARAMS_REGEX);\n\n    public static final String LOGIN_USER_KEY_TAB_USERNAME = \"login.user.keytab.username\";\n\n    public static final String LOGIN_USER_KEY_TAB_PATH = \"login.user.keytab.path\";\n\n    /**\n     * fetch applicationId way\n     */\n    public static final String APPID_COLLECT = \"appId.collect\";\n    public static final String DEFAULT_COLLECT_WAY = \"log\";\n\n    public static final String WORKFLOW_INSTANCE_ID_MDC_KEY = \"workflowInstanceId\";\n    public static final String TASK_INSTANCE_ID_MDC_KEY = \"taskInstanceId\";\n\n    public static final String STAR = \"*\";\n}\n",
            "role": "user"
        },
        {
            "content": "//dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/constants/DataSourceConstants.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.dolphinscheduler.common.constants;\n\npublic class DataSourceConstants {\n\n    public static final String DATASOURCE = \"datasource\";\n\n    /**\n     * driver\n     */\n    public static final String ORG_POSTGRESQL_DRIVER = \"org.postgresql.Driver\";\n    public static final String COM_MYSQL_CJ_JDBC_DRIVER = \"com.mysql.cj.jdbc.Driver\";\n    public static final String COM_MYSQL_JDBC_DRIVER = \"com.mysql.jdbc.Driver\";\n    public static final String ORG_APACHE_HIVE_JDBC_HIVE_DRIVER = \"org.apache.hive.jdbc.HiveDriver\";\n    public static final String COM_CLICKHOUSE_JDBC_DRIVER = \"com.clickhouse.jdbc.ClickHouseDriver\";\n    public static final String COM_DATABEND_JDBC_DRIVER = \"com.databend.jdbc.DatabendDriver\";\n    public static final String COM_ORACLE_JDBC_DRIVER = \"oracle.jdbc.OracleDriver\";\n    public static final String COM_SQLSERVER_JDBC_DRIVER = \"com.microsoft.sqlserver.jdbc.SQLServerDriver\";\n    public static final String COM_DB2_JDBC_DRIVER = \"com.ibm.db2.jcc.DB2Driver\";\n    public static final String COM_PRESTO_JDBC_DRIVER = \"com.facebook.presto.jdbc.PrestoDriver\";\n    public static final String COM_REDSHIFT_JDBC_DRIVER = \"com.amazon.redshift.jdbc42.Driver\";\n    public static final String COM_ATHENA_JDBC_DRIVER = \"com.simba.athena.jdbc.Driver\";\n    public static final String COM_TRINO_JDBC_DRIVER = \"io.trino.jdbc.TrinoDriver\";\n    public static final String COM_DAMENG_JDBC_DRIVER = \"dm.jdbc.driver.DmDriver\";\n    public static final String ORG_APACHE_KYUUBI_JDBC_DRIVER = \"org.apache.kyuubi.jdbc.KyuubiHiveDriver\";\n    public static final String COM_OCEANBASE_JDBC_DRIVER = \"com.oceanbase.jdbc.Driver\";\n    public static final String NET_SNOWFLAKE_JDBC_DRIVER = \"net.snowflake.client.jdbc.SnowflakeDriver\";\n    public static final String COM_VERTICA_JDBC_DRIVER = \"com.vertica.jdbc.Driver\";\n    public static final String COM_HANA_DB_JDBC_DRIVER = \"com.sap.db.jdbc.Driver\";\n\n    /**\n     * validation Query\n     */\n    public static final String POSTGRESQL_VALIDATION_QUERY = \"select version()\";\n    public static final String MYSQL_VALIDATION_QUERY = \"select 1\";\n    public static final String HIVE_VALIDATION_QUERY = \"select 1\";\n    public static final String CLICKHOUSE_VALIDATION_QUERY = \"select 1\";\n    public static final String DATABEND_VALIDATION_QUERY = \"select 1\";\n    public static final String ORACLE_VALIDATION_QUERY = \"select 1 from dual\";\n    public static final String SQLSERVER_VALIDATION_QUERY = \"select 1\";\n    public static final String DB2_VALIDATION_QUERY = \"select 1 from sysibm.sysdummy1\";\n    public static final String PRESTO_VALIDATION_QUERY = \"select 1\";\n    public static final String REDHIFT_VALIDATION_QUERY = \"select 1\";\n    public static final String ATHENA_VALIDATION_QUERY = \"select 1\";\n    public static final String TRINO_VALIDATION_QUERY = \"select 1\";\n    public static final String DAMENG_VALIDATION_QUERY = \"select 1\";\n    public static final String SNOWFLAKE_VALIDATION_QUERY = \"select 1\";\n\n    public static final String KYUUBI_VALIDATION_QUERY = \"select 1\";\n    public static final String VERTICA_VALIDATION_QUERY = \"select 1\";\n\n    public static final String HANA_VALIDATION_QUERY = \"select 1 from DUMMY\";\n\n    /**\n     * jdbc url\n     */\n    public static final String JDBC_MYSQL = \"jdbc:mysql://\";\n    public static final String JDBC_MYSQL_LOADBALANCE = \"jdbc:mysql:loadbalance://\";\n    public static final String JDBC_POSTGRESQL = \"jdbc:postgresql://\";\n    public static final String JDBC_HIVE_2 = \"jdbc:hive2://\";\n    public static final String JDBC_KYUUBI = \"jdbc:kyuubi://\";\n    public static final String JDBC_CLICKHOUSE = \"jdbc:clickhouse://\";\n    public static final String JDBC_DATABEND = \"jdbc:databend://\";\n    public static final String JDBC_ORACLE_SID = \"jdbc:oracle:thin:@\";\n    public static final String JDBC_ORACLE_SERVICE_NAME = \"jdbc:oracle:thin:@//\";\n    public static final String JDBC_SQLSERVER = \"jdbc:sqlserver://\";\n    public static final String JDBC_DB2 = \"jdbc:db2://\";\n    public static final String JDBC_PRESTO = \"jdbc:presto://\";\n    public static final String JDBC_REDSHIFT = \"jdbc:redshift://\";\n    public static final String JDBC_REDSHIFT_IAM = \"jdbc:redshift:iam://\";\n    public static final String JDBC_ATHENA = \"jdbc:awsathena://\";\n    public static final String JDBC_TRINO = \"jdbc:trino://\";\n    public static final String JDBC_DAMENG = \"jdbc:dm://\";\n    public static final String JDBC_OCEANBASE = \"jdbc:oceanbase://\";\n    public static final String JDBC_SNOWFLAKE = \"jdbc:snowflake://\";\n    public static final String JDBC_VERTICA = \"jdbc:vertica://\";\n    public static final String JDBC_HANA = \"jdbc:sap://\";\n\n    /**\n     * database type\n     */\n    public static final String MYSQL = \"MYSQL\";\n    public static final String HIVE = \"HIVE\";\n\n    /**\n     * dataSource sensitive param\n     */\n    public static final String DATASOURCE_PASSWORD_REGEX =\n            \"(?<=((?i)password((\\\" : \\\")|(\\\":\\\")|(\\\\\\\\\\\":\\\\\\\\\\\")|(=')))).*?(?=((\\\")|(\\\\\\\\\\\")|(')))\";\n\n    /**\n     * datasource encryption salt\n     */\n    public static final String DATASOURCE_ENCRYPTION_SALT_DEFAULT = \"!@#$%^&*\";\n    public static final String DATASOURCE_ENCRYPTION_ENABLE = \"datasource.encryption.enable\";\n    public static final String DATASOURCE_ENCRYPTION_SALT = \"datasource.encryption.salt\";\n\n    /**\n     * datasource config\n     */\n    public static final String SPRING_DATASOURCE_MIN_IDLE = \"spring.datasource.minIdle\";\n\n    public static final String SPRING_DATASOURCE_MAX_ACTIVE = \"spring.datasource.maxActive\";\n\n    public static final String SPRING_DATASOURCE_TEST_ON_BORROW = \"spring.datasource.testOnBorrow\";\n\n    /**\n     * azure static websites\n     */\n    public static final String AZURE_SQL_DATABASE_SPN = \"https://database.windows.net/\";\n    public static final String AZURE_SQL_DATABASE_TOKEN_SCOPE = \"/.default\";\n\n}\n",
            "role": "user"
        },
        {
            "content": "//dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/TaskInstance.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.dolphinscheduler.dao.entity;\n\nimport org.apache.dolphinscheduler.common.enums.Flag;\nimport org.apache.dolphinscheduler.common.enums.Priority;\nimport org.apache.dolphinscheduler.common.enums.TaskExecuteType;\nimport org.apache.dolphinscheduler.plugin.task.api.enums.TaskExecutionStatus;\n\nimport java.io.Serializable;\nimport java.util.Date;\n\nimport lombok.Data;\n\nimport com.baomidou.mybatisplus.annotation.FieldStrategy;\nimport com.baomidou.mybatisplus.annotation.IdType;\nimport com.baomidou.mybatisplus.annotation.TableField;\nimport com.baomidou.mybatisplus.annotation.TableId;\nimport com.baomidou.mybatisplus.annotation.TableName;\n\n@Data\n@TableName(\"t_ds_task_instance\")\npublic class TaskInstance implements Serializable {\n\n    @TableId(value = \"id\", type = IdType.AUTO)\n    private Integer id;\n\n    private String name;\n\n    private String taskType;\n\n    private int workflowInstanceId;\n\n    private String workflowInstanceName;\n\n    private Long projectCode;\n\n    private long taskCode;\n\n    private int taskDefinitionVersion;\n\n    @TableField(exist = false)\n    private String processDefinitionName;\n\n    @TableField(exist = false)\n    private int taskGroupPriority;\n\n    private TaskExecutionStatus state;\n\n    private Date firstSubmitTime;\n\n    private Date submitTime;\n\n    private Date startTime;\n\n    private Date endTime;\n\n    private String host;\n\n    private String executePath;\n\n    private String logPath;\n\n    private int retryTimes;\n\n    private Flag alertFlag;\n\n    @TableField(exist = false)\n    private WorkflowInstance workflowInstance;\n\n    @TableField(exist = false)\n    private WorkflowDefinition workflowDefinition;\n\n    @TableField(exist = false)\n    private TaskDefinition taskDefine;\n\n    private int pid;\n\n    private String appLink;\n\n    private Flag flag;\n\n    private Flag isCache;\n\n    @TableField(updateStrategy = FieldStrategy.IGNORED)\n    private String cacheKey;\n\n    @TableField(exist = false)\n    private String duration;\n\n    private int maxRetryTimes;\n\n    private int retryInterval;\n\n    private Priority taskInstancePriority;\n\n    @TableField(exist = false)\n    private Priority workflowInstancePriority;\n\n    private String workerGroup;\n\n    private Long environmentCode;\n\n    private String environmentConfig;\n\n    private int executorId;\n\n    private String varPool;\n\n    private String executorName;\n\n    private int delayTime;\n\n    private String taskParams;\n\n    private int dryRun;\n\n    private int taskGroupId;\n\n    private Integer cpuQuota;\n\n    private Integer memoryMax;\n\n    private TaskExecuteType taskExecuteType;\n\n    private int testFlag;\n\n    public void init(String host, Date startTime, String executePath) {\n        this.host = host;\n        this.startTime = startTime;\n        this.executePath = executePath;\n    }\n\n}\n",
            "role": "user"
        },
        {
            "content": "//dolphinscheduler-extract/dolphinscheduler-extract-master/src/main/java/org/apache/dolphinscheduler/extract/master/dto/TaskInstanceExecuteDto.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.dolphinscheduler.extract.master.dto;\n\nimport org.apache.dolphinscheduler.common.enums.Flag;\nimport org.apache.dolphinscheduler.common.enums.Priority;\nimport org.apache.dolphinscheduler.common.enums.TaskExecuteType;\nimport org.apache.dolphinscheduler.plugin.task.api.enums.TaskExecutionStatus;\n\nimport java.util.Date;\nimport java.util.Map;\n\nimport lombok.Data;\n\n@Data\npublic class TaskInstanceExecuteDto {\n\n    private int id;\n\n    private String name;\n\n    private String taskType;\n\n    private int processInstanceId;\n\n    private long taskCode;\n\n    private int taskDefinitionVersion;\n\n    private String processInstanceName;\n\n    private int taskGroupPriority;\n\n    private TaskExecutionStatus state;\n\n    private Date firstSubmitTime;\n\n    private Date submitTime;\n\n    private Date startTime;\n\n    private Date endTime;\n\n    private String host;\n\n    private String executePath;\n\n    private String logPath;\n\n    private int retryTimes;\n\n    private Flag alertFlag;\n\n    private int pid;\n\n    private String appLink;\n\n    private Flag flag;\n\n    private String duration;\n\n    private int maxRetryTimes;\n\n    private int retryInterval;\n\n    private Priority taskInstancePriority;\n\n    private Priority processInstancePriority;\n\n    private String workerGroup;\n\n    private Long environmentCode;\n\n    private String environmentConfig;\n\n    private int executorId;\n\n    private String varPool;\n\n    private String executorName;\n\n    private Map<String, String> resources;\n\n    private int delayTime;\n\n    private String taskParams;\n\n    private int dryRun;\n\n    private int taskGroupId;\n\n    private Integer cpuQuota;\n\n    private Integer memoryMax;\n\n    private TaskExecuteType taskExecuteType;\n}\n",
            "role": "user"
        },
        {
            "content": "//dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/controller/AccessTokenController.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.dolphinscheduler.api.controller;\n\nimport static org.apache.dolphinscheduler.api.enums.Status.CREATE_ACCESS_TOKEN_ERROR;\nimport static org.apache.dolphinscheduler.api.enums.Status.DELETE_ACCESS_TOKEN_ERROR;\nimport static org.apache.dolphinscheduler.api.enums.Status.GENERATE_TOKEN_ERROR;\nimport static org.apache.dolphinscheduler.api.enums.Status.QUERY_ACCESSTOKEN_BY_USER_ERROR;\nimport static org.apache.dolphinscheduler.api.enums.Status.QUERY_ACCESSTOKEN_LIST_PAGING_ERROR;\nimport static org.apache.dolphinscheduler.api.enums.Status.UPDATE_ACCESS_TOKEN_ERROR;\n\nimport org.apache.dolphinscheduler.api.audit.OperatorLog;\nimport org.apache.dolphinscheduler.api.audit.enums.AuditType;\nimport org.apache.dolphinscheduler.api.exceptions.ApiException;\nimport org.apache.dolphinscheduler.api.service.AccessTokenService;\nimport org.apache.dolphinscheduler.api.utils.PageInfo;\nimport org.apache.dolphinscheduler.api.utils.Result;\nimport org.apache.dolphinscheduler.common.constants.Constants;\nimport org.apache.dolphinscheduler.dao.entity.AccessToken;\nimport org.apache.dolphinscheduler.dao.entity.User;\nimport org.apache.dolphinscheduler.plugin.task.api.utils.ParameterUtils;\n\nimport java.util.List;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.DeleteMapping;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.PutMapping;\nimport org.springframework.web.bind.annotation.RequestAttribute;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseStatus;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport io.swagger.v3.oas.annotations.Operation;\nimport io.swagger.v3.oas.annotations.Parameter;\nimport io.swagger.v3.oas.annotations.Parameters;\nimport io.swagger.v3.oas.annotations.media.Schema;\nimport io.swagger.v3.oas.annotations.tags.Tag;\n\n/**\n * access token controller\n */\n@Tag(name = \"ACCESS_TOKEN_TAG\")\n@RestController\n@RequestMapping(\"/access-tokens\")\npublic class AccessTokenController extends BaseController {\n\n    @Autowired\n    private AccessTokenService accessTokenService;\n\n    /**\n     * create token\n     *\n     * @param loginUser login user\n     * @param userId token for user id\n     * @param expireTime expire time for the token\n     * @param token token string (if it is absent, it will be automatically generated)\n     * @return create result state code\n     */\n    @Operation(summary = \"createToken\", description = \"CREATE_TOKEN_NOTES\")\n    @Parameters({\n            @Parameter(name = \"userId\", description = \"USER_ID\", schema = @Schema(implementation = int.class), required = true),\n            @Parameter(name = \"expireTime\", description = \"EXPIRE_TIME\", schema = @Schema(implementation = String.class), required = true, example = \"2021-12-31 00:00:00\"),\n            @Parameter(name = \"token\", description = \"TOKEN\", required = false, schema = @Schema(implementation = String.class), example = \"xxxx\")\n    })\n    @PostMapping()\n    @ResponseStatus(HttpStatus.CREATED)\n    @ApiException(CREATE_ACCESS_TOKEN_ERROR)\n    @OperatorLog(auditType = AuditType.TOKEN_CREATE)\n    public Result<AccessToken> createToken(@Parameter(hidden = true) @RequestAttribute(value = Constants.SESSION_USER) User loginUser,\n                                           @RequestParam(value = \"userId\") int userId,\n                                           @RequestParam(value = \"expireTime\") String expireTime,\n                                           @RequestParam(value = \"token\", required = false) String token) {\n\n        AccessToken accessToken = accessTokenService.createToken(loginUser, userId, expireTime, token);\n        return Result.success(accessToken);\n    }\n\n    /**\n     * generate token string\n     *\n     * @param loginUser login user\n     * @param userId token for user\n     * @param expireTime expire time\n     * @return token string\n     */\n    @Parameter(hidden = true)\n    @PostMapping(value = \"/generate\")\n    @ResponseStatus(HttpStatus.CREATED)\n    @ApiException(GENERATE_TOKEN_ERROR)\n    public Result<String> generateToken(@RequestAttribute(value = Constants.SESSION_USER) User loginUser,\n                                        @RequestParam(value = \"userId\") int userId,\n                                        @RequestParam(value = \"expireTime\") String expireTime) {\n        String token = accessTokenService.generateToken(loginUser, userId, expireTime);\n        return Result.success(token);\n    }\n\n    /**\n     * query access token list paging\n     *\n     * @param loginUser login user\n     * @param pageNo page number\n     * @param searchVal search value\n     * @param pageSize page size\n     * @return token list of page number and page size\n     */\n    @Operation(summary = \"queryAccessTokenList\", description = \"QUERY_ACCESS_TOKEN_LIST_NOTES\")\n    @Parameters({\n            @Parameter(name = \"searchVal\", description = \"SEARCH_VAL\", schema = @Schema(implementation = String.class)),\n            @Parameter(name = \"pageNo\", description = \"PAGE_NO\", required = true, schema = @Schema(implementation = int.class), example = \"1\"),\n            @Parameter(name = \"pageSize\", description = \"PAGE_SIZE\", required = true, schema = @Schema(implementation = int.class), example = \"20\")\n    })\n    @GetMapping()\n    @ResponseStatus(HttpStatus.OK)\n    @ApiException(QUERY_ACCESSTOKEN_LIST_PAGING_ERROR)\n    public Result<PageInfo<AccessToken>> queryAccessTokenList(@Parameter(hidden = true) @RequestAttribute(value = Constants.SESSION_USER) User loginUser,\n                                                              @RequestParam(\"pageNo\") Integer pageNo,\n                                                              @RequestParam(value = \"searchVal\", required = false) String searchVal,\n                                                              @RequestParam(\"pageSize\") Integer pageSize) {\n\n        checkPageParams(pageNo, pageSize);\n        searchVal = ParameterUtils.handleEscapes(searchVal);\n        PageInfo<AccessToken> accessTokenPageInfo =\n                accessTokenService.queryAccessTokenList(loginUser, searchVal, pageNo, pageSize);\n        return Result.success(accessTokenPageInfo);\n    }\n\n    /**\n     * query access token for specified user\n     *\n     * @param loginUser login user\n     * @param userId user id\n     * @return token list for specified user\n     */\n    @Operation(summary = \"queryAccessTokenByUser\", description = \"QUERY_ACCESS_TOKEN_BY_USER_NOTES\")\n    @Parameters({\n            @Parameter(name = \"userId\", description = \"USER_ID\", schema = @Schema(implementation = int.class))\n    })\n    @GetMapping(value = \"/user/{userId}\")\n    @ResponseStatus(HttpStatus.OK)\n    @ApiException(QUERY_ACCESSTOKEN_BY_USER_ERROR)\n    public Result<List<AccessToken>> queryAccessTokenByUser(@Parameter(hidden = true) @RequestAttribute(value = Constants.SESSION_USER) User loginUser,\n                                                            @PathVariable(\"userId\") Integer userId) {\n        List<AccessToken> accessTokens = accessTokenService.queryAccessTokenByUser(loginUser, userId);\n        return Result.success(accessTokens);\n    }\n\n    /**\n     * delete access token by id\n     *\n     * @param loginUser login user\n     * @param id token id\n     * @return delete result code\n     */\n    @Parameter(hidden = true)\n    @Operation(summary = \"deleteToken\", description = \"DELETE_TOKEN_NOTES\")\n    @DeleteMapping(value = \"/{id}\")\n    @ResponseStatus(HttpStatus.OK)\n    @ApiException(DELETE_ACCESS_TOKEN_ERROR)\n    @OperatorLog(auditType = AuditType.TOKEN_DELETE)\n    public Result<Boolean> delAccessTokenById(@Parameter(hidden = true) @RequestAttribute(value = Constants.SESSION_USER) User loginUser,\n                                              @PathVariable(value = \"id\") int id) {\n        accessTokenService.deleteAccessTokenById(loginUser, id);\n        return Result.success(false);\n    }\n\n    /**\n     * update token\n     *\n     * @param loginUser login user\n     * @param id token id\n     * @param userId token for user\n     * @param expireTime token expire time\n     * @param token token string (if it is absent, it will be automatically generated)\n     * @return updated access token entity\n     */\n    @Operation(summary = \"updateToken\", description = \"UPDATE_TOKEN_NOTES\")\n    @Parameters({\n            @Parameter(name = \"id\", description = \"TOKEN_ID\", required = true, schema = @Schema(implementation = int.class)),\n            @Parameter(name = \"userId\", description = \"USER_ID\", required = true, schema = @Schema(implementation = int.class)),\n            @Parameter(name = \"expireTime\", description = \"EXPIRE_TIME\", required = true, schema = @Schema(implementation = String.class), example = \"2021-12-31 00:00:00\"),\n            @Parameter(name = \"token\", description = \"TOKEN\", required = false, schema = @Schema(implementation = String.class), example = \"xxxx\")\n    })\n    @PutMapping(value = \"/{id}\")\n    @ResponseStatus(HttpStatus.OK)\n    @ApiException(UPDATE_ACCESS_TOKEN_ERROR)\n    @OperatorLog(auditType = AuditType.TOKEN_UPDATE)\n    public Result<AccessToken> updateToken(@Parameter(hidden = true) @RequestAttribute(value = Constants.SESSION_USER) User loginUser,\n                                           @PathVariable(value = \"id\") int id,\n                                           @RequestParam(value = \"userId\") int userId,\n                                           @RequestParam(value = \"expireTime\") String expireTime,\n                                           @RequestParam(value = \"token\", required = false) String token) {\n\n        AccessToken accessToken = accessTokenService.updateToken(loginUser, id, userId, expireTime, token);\n        return Result.success(accessToken);\n    }\n\n}\n",
            "role": "user"
        },
        {
            "content": "//dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/AccessTokenService.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.dolphinscheduler.api.service;\n\nimport org.apache.dolphinscheduler.api.utils.PageInfo;\nimport org.apache.dolphinscheduler.dao.entity.AccessToken;\nimport org.apache.dolphinscheduler.dao.entity.User;\n\nimport java.util.List;\n\n/**\n * access token service\n */\npublic interface AccessTokenService {\n\n    /**\n     * query access token list\n     *\n     * @param loginUser login user\n     * @param searchVal search value\n     * @param pageNo page number\n     * @param pageSize page size\n     * @return token list for page number and page size\n     */\n    PageInfo<AccessToken> queryAccessTokenList(User loginUser, String searchVal, Integer pageNo, Integer pageSize);\n\n    /**\n     * query access token for specified user\n     *\n     * @param loginUser login user\n     * @param userId user id\n     * @return token list for specified user\n     */\n    List<AccessToken> queryAccessTokenByUser(User loginUser, Integer userId);\n\n    /**\n     * create token\n     *\n     * @param userId token for user\n     * @param expireTime token expire time\n     * @param token token string (if it is absent, it will be automatically generated)\n     * @return create result code\n     */\n    AccessToken createToken(User loginUser, int userId, String expireTime, String token);\n\n    /**\n     * generate token\n     *\n     * @param userId token for user\n     * @param expireTime token expire time\n     * @return token string\n     */\n    String generateToken(User loginUser, int userId, String expireTime);\n\n    /**\n     * delete access token\n     *\n     * @param loginUser login user\n     * @param id token id\n     * @return delete result code\n     */\n    void deleteAccessTokenById(User loginUser, int id);\n\n    /**\n     * update token by id\n     *\n     * @param id token id\n     * @param userId token for user\n     * @param expireTime token expire time\n     * @param token token string (if it is absent, it will be automatically generated)\n     * @return updated access token entity\n     */\n    AccessToken updateToken(User loginUser, int id, int userId, String expireTime, String token);\n}\n",
            "role": "user"
        },
        {
            "content": "//dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/dto/EnvironmentDto.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.dolphinscheduler.api.dto;\n\nimport java.util.Date;\nimport java.util.List;\n\nimport lombok.Data;\n\n@Data\npublic class EnvironmentDto {\n\n    private Integer id;\n\n    /**\n     * environment code\n     */\n    private Long code;\n\n    /**\n     * environment name\n     */\n    private String name;\n\n    /**\n     * config content\n     */\n    private String config;\n\n    private String description;\n\n    private List<String> workerGroups;\n\n    /**\n     * operator user id\n     */\n    private Integer operator;\n\n    private Date createTime;\n\n    private Date updateTime;\n}\n",
            "role": "user"
        },
        {
            "content": "//dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/AccessToken.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.dolphinscheduler.dao.entity;\n\nimport java.util.Date;\nimport java.util.Objects;\n\nimport lombok.Data;\n\nimport com.baomidou.mybatisplus.annotation.IdType;\nimport com.baomidou.mybatisplus.annotation.TableField;\nimport com.baomidou.mybatisplus.annotation.TableId;\nimport com.baomidou.mybatisplus.annotation.TableName;\n\n@Data\n@TableName(\"t_ds_access_token\")\npublic class AccessToken {\n\n    /**\n     * primary key\n     */\n    @TableId(value = \"id\", type = IdType.AUTO)\n    private Integer id;\n    /**\n     * user_id\n     */\n    @TableField(value = \"user_id\")\n    private int userId;\n    /**\n     * token\n     */\n    @TableField(value = \"token\")\n    private String token;\n    /**\n     * expire_time\n     */\n    @TableField(value = \"expire_time\")\n    private Date expireTime;\n    /**\n     * create_time\n     */\n    @TableField(value = \"create_time\")\n    private Date createTime;\n    /**\n     * update_time\n     */\n    @TableField(value = \"update_time\")\n    private Date updateTime;\n    @TableField(exist = false)\n    private String userName;\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        AccessToken that = (AccessToken) o;\n\n        if (!Objects.equals(id, that.id)) {\n            return false;\n        }\n        if (userId != that.userId) {\n            return false;\n        }\n        if (userName != null && !userName.equals(that.userName)) {\n            return false;\n        }\n        if (token != null && !token.equals(that.token)) {\n            return false;\n        }\n        if (expireTime != null && !expireTime.equals(that.expireTime)) {\n            return false;\n        }\n        if (createTime != null && !createTime.equals(that.createTime)) {\n            return false;\n        }\n        if (updateTime != null && !updateTime.equals(that.updateTime)) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = id;\n        result = 31 * result + userId;\n        result = 31 * result + (userName != null ? userName.hashCode() : 0);\n        result = 31 * result + (token != null ? token.hashCode() : 0);\n        result = 31 * result + (expireTime != null ? expireTime.hashCode() : 0);\n        result = 31 * result + (createTime != null ? createTime.hashCode() : 0);\n        result = 31 * result + (updateTime != null ? updateTime.hashCode() : 0);\n        return result;\n    }\n}\n",
            "role": "user"
        },
        {
            "content": "//dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/controller/AuditLogController.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.dolphinscheduler.api.controller;\n\nimport static org.apache.dolphinscheduler.api.enums.Status.QUERY_AUDIT_LOG_LIST_PAGING;\n\nimport org.apache.dolphinscheduler.api.dto.AuditDto;\nimport org.apache.dolphinscheduler.api.dto.auditLog.AuditModelTypeDto;\nimport org.apache.dolphinscheduler.api.dto.auditLog.AuditOperationTypeDto;\nimport org.apache.dolphinscheduler.api.exceptions.ApiException;\nimport org.apache.dolphinscheduler.api.service.AuditService;\nimport org.apache.dolphinscheduler.api.utils.PageInfo;\nimport org.apache.dolphinscheduler.api.utils.Result;\nimport org.apache.dolphinscheduler.common.constants.Constants;\nimport org.apache.dolphinscheduler.dao.entity.User;\n\nimport java.util.List;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestAttribute;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseStatus;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport io.swagger.v3.oas.annotations.Operation;\nimport io.swagger.v3.oas.annotations.Parameter;\nimport io.swagger.v3.oas.annotations.Parameters;\nimport io.swagger.v3.oas.annotations.media.Schema;\nimport io.swagger.v3.oas.annotations.tags.Tag;\n\n@Tag(name = \"AUDIT_LOG_TAG\")\n@RestController\n@RequestMapping(\"projects/audit\")\npublic class AuditLogController extends BaseController {\n\n    @Autowired\n    AuditService auditService;\n\n    /**\n     * query audit log list paging\n     *\n     * @param loginUser         login user\n     * @param pageNo            page number\n     * @param pageSize          page size\n     * @param modelTypes        model types\n     * @param operationTypes    operation types\n     * @param userName          user name\n     * @param modelName         model name\n     * @param startDate         start time\n     * @param endDate           end time\n     * @return      audit log content\n     */\n    @Operation(summary = \"queryAuditLogListPaging\", description = \"QUERY_AUDIT_LOG\")\n    @Parameters({\n            @Parameter(name = \"startDate\", description = \"START_DATE\", schema = @Schema(implementation = String.class)),\n            @Parameter(name = \"endDate\", description = \"END_DATE\", schema = @Schema(implementation = String.class)),\n            @Parameter(name = \"objectTypes\", description = \"MODEL_TYPES\", schema = @Schema(implementation = String.class)),\n            @Parameter(name = \"operationTypes\", description = \"OPERATION_TYPES\", schema = @Schema(implementation = String.class)),\n            @Parameter(name = \"userName\", description = \"USER_NAME\", schema = @Schema(implementation = String.class)),\n            @Parameter(name = \"objectName\", description = \"MODEL_NAME\", schema = @Schema(implementation = String.class)),\n            @Parameter(name = \"pageNo\", description = \"PAGE_NO\", required = true, schema = @Schema(implementation = int.class, example = \"1\")),\n            @Parameter(name = \"pageSize\", description = \"PAGE_SIZE\", required = true, schema = @Schema(implementation = int.class, example = \"20\"))\n    })\n    @GetMapping(value = \"/audit-log-list\")\n    @ResponseStatus(HttpStatus.OK)\n    @ApiException(QUERY_AUDIT_LOG_LIST_PAGING)\n    public Result<PageInfo<AuditDto>> queryAuditLogListPaging(@Parameter(hidden = true) @RequestAttribute(value = Constants.SESSION_USER) User loginUser,\n                                                              @RequestParam(\"pageNo\") Integer pageNo,\n                                                              @RequestParam(\"pageSize\") Integer pageSize,\n                                                              @RequestParam(value = \"modelTypes\", required = false) String modelTypes,\n                                                              @RequestParam(value = \"operationTypes\", required = false) String operationTypes,\n                                                              @RequestParam(value = \"startDate\", required = false) String startDate,\n                                                              @RequestParam(value = \"endDate\", required = false) String endDate,\n                                                              @RequestParam(value = \"userName\", required = false) String userName,\n                                                              @RequestParam(value = \"modelName\", required = false) String modelName) {\n        checkPageParams(pageNo, pageSize);\n        PageInfo<AuditDto> auditDtoPageInfo = auditService.queryLogListPaging(\n                modelTypes,\n                operationTypes,\n                startDate,\n                endDate,\n                userName,\n                modelName,\n                pageNo,\n                pageSize);\n        return Result.success(auditDtoPageInfo);\n    }\n\n    /**\n     * query audit log operation type list\n     *\n     * @return object type list\n     */\n    @Operation(summary = \"queryAuditOperationTypeList\", description = \"QUERY_AUDIT_OPERATION_TYPE_LIST\")\n    @GetMapping(value = \"/audit-log-operation-type\")\n    @ResponseStatus(HttpStatus.OK)\n    @ApiException(QUERY_AUDIT_LOG_LIST_PAGING)\n    public Result<List<AuditOperationTypeDto>> queryAuditOperationTypeList() {\n        return Result.success(AuditOperationTypeDto.getOperationTypeDtoList());\n    }\n\n    /**\n     * query audit log model type list\n     *\n     * @return model type list\n     */\n    @Operation(summary = \"queryAuditModelTypeList\", description = \"QUERY_AUDIT_MODEL_TYPE_LIST\")\n    @GetMapping(value = \"/audit-log-model-type\")\n    @ResponseStatus(HttpStatus.OK)\n    @ApiException(QUERY_AUDIT_LOG_LIST_PAGING)\n    public Result<List<AuditModelTypeDto>> queryAuditModelTypeList() {\n        return Result.success(AuditModelTypeDto.getModelTypeDtoList());\n    }\n}\n",
            "role": "user"
        },
        {
            "content": "//dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/SchedulerService.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.dolphinscheduler.api.service;\n\nimport org.apache.dolphinscheduler.api.dto.schedule.ScheduleCreateRequest;\nimport org.apache.dolphinscheduler.api.dto.schedule.ScheduleFilterRequest;\nimport org.apache.dolphinscheduler.api.dto.schedule.ScheduleUpdateRequest;\nimport org.apache.dolphinscheduler.api.utils.PageInfo;\nimport org.apache.dolphinscheduler.api.utils.Result;\nimport org.apache.dolphinscheduler.common.enums.FailureStrategy;\nimport org.apache.dolphinscheduler.common.enums.Priority;\nimport org.apache.dolphinscheduler.common.enums.WarningType;\nimport org.apache.dolphinscheduler.dao.entity.Schedule;\nimport org.apache.dolphinscheduler.dao.entity.User;\n\nimport java.util.List;\nimport java.util.Map;\n\npublic interface SchedulerService {\n\n    /**\n     * save schedule\n     *\n     * @param loginUser login user\n     * @param projectCode project code\n     * @param workflowDefinitionCode workflow definition code\n     * @param schedule scheduler\n     * @param warningType warning type\n     * @param warningGroupId warning group id\n     * @param failureStrategy failure strategy\n     * @param workflowInstancePriority workflow instance priority\n     * @param workerGroup worker group\n     * @param tenantCode tenant code\n     * @param environmentCode environment code\n     * @return create result code\n     */\n    Map<String, Object> insertSchedule(User loginUser,\n                                       long projectCode,\n                                       long workflowDefinitionCode,\n                                       String schedule,\n                                       WarningType warningType,\n                                       int warningGroupId,\n                                       FailureStrategy failureStrategy,\n                                       Priority workflowInstancePriority,\n                                       String workerGroup,\n                                       String tenantCode,\n                                       Long environmentCode);\n\n    /**\n     * save schedule V2\n     *\n     * @param loginUser             login user\n     * @param scheduleCreateRequest the new schedule object will be created\n     * @return Schedule object\n     */\n    Schedule createSchedulesV2(User loginUser,\n                               ScheduleCreateRequest scheduleCreateRequest);\n\n    /**\n     * updateWorkflowInstance schedule\n     *\n     * @param loginUser login user\n     * @param projectCode project code\n     * @param id scheduler id\n     * @param scheduleExpression scheduler\n     * @param warningType warning type\n     * @param warningGroupId warning group id\n     * @param failureStrategy failure strategy\n     * @param workerGroup worker group\n     * @param tenantCode tenant code\n     * @param environmentCode environment code\n     * @param workflowInstancePriority workflow instance priority\n     * @return update result code\n     */\n    Map<String, Object> updateSchedule(User loginUser,\n                                       long projectCode,\n                                       Integer id,\n                                       String scheduleExpression,\n                                       WarningType warningType,\n                                       int warningGroupId,\n                                       FailureStrategy failureStrategy,\n                                       Priority workflowInstancePriority,\n                                       String workerGroup,\n                                       String tenantCode,\n                                       Long environmentCode);\n\n    /**\n     * update schedule object V2\n     *\n     * @param loginUser login user\n     * @param scheduleId scheduler id\n     * @param scheduleUpdateRequest the schedule object will be updated\n     * @return Schedule object\n     */\n    Schedule updateSchedulesV2(User loginUser,\n                               Integer scheduleId,\n                               ScheduleUpdateRequest scheduleUpdateRequest);\n\n    /**\n     * get schedule object\n     *\n     * @param loginUser login user\n     * @param scheduleId scheduler id\n     * @return Schedule object\n     */\n    Schedule getSchedule(User loginUser,\n                         Integer scheduleId);\n\n    /**\n     * query schedule\n     *\n     * @param loginUser login user\n     * @param projectCode project code\n     * @param workflowDefinitionCode workflow definition code\n     * @param pageNo page number\n     * @param pageSize page size\n     * @param searchVal search value\n     * @return schedule list page\n     */\n    Result querySchedule(User loginUser, long projectCode, long workflowDefinitionCode, String searchVal,\n                         Integer pageNo, Integer pageSize);\n\n    List<Schedule> queryScheduleByWorkflowDefinitionCodes(List<Long> workflowDefinitionCodes);\n\n    /**\n     * query schedule V2\n     *\n     * @param loginUser login user\n     * @param scheduleFilterRequest schedule filter request\n     * @return schedule list page\n     */\n    PageInfo<Schedule> filterSchedules(User loginUser,\n                                       ScheduleFilterRequest scheduleFilterRequest);\n\n    /**\n     * query schedule list\n     *\n     * @param loginUser   login user\n     * @param projectCode project code\n     * @return schedule list\n     */\n    Map<String, Object> queryScheduleList(User loginUser, long projectCode);\n\n    /**\n     * delete schedule by id\n     *\n     * @param loginUser login user\n     * @param scheduleId schedule id\n     */\n    void deleteSchedulesById(User loginUser, Integer scheduleId);\n\n    /**\n     * preview schedule\n     *\n     * @param loginUser login user\n     * @param schedule schedule expression\n     * @return the next five fire time\n     */\n    Map<String, Object> previewSchedule(User loginUser, String schedule);\n\n    /**\n     * update workflow definition schedule\n     *\n     * @param loginUser login user\n     * @param projectCode project code\n     * @param workflowDefinitionCode workflow definition code\n     * @param scheduleExpression scheduleExpression\n     * @param warningType warning type\n     * @param warningGroupId warning group id\n     * @param failureStrategy failure strategy\n     * @param workerGroup worker group\n     * @param tenantCode tenant code\n     * @param workflowInstancePriority workflow instance priority\n     * @return update result code\n     */\n    Map<String, Object> updateScheduleByWorkflowDefinitionCode(User loginUser,\n                                                               long projectCode,\n                                                               long workflowDefinitionCode,\n                                                               String scheduleExpression,\n                                                               WarningType warningType,\n                                                               int warningGroupId,\n                                                               FailureStrategy failureStrategy,\n                                                               Priority workflowInstancePriority,\n                                                               String workerGroup,\n                                                               String tenantCode,\n                                                               long environmentCode);\n\n    /**\n     * Online the scheduler by scheduler id, if the related workflow definition is not online will throw exception.\n     */\n    void onlineScheduler(User loginUser, Long projectCode, Integer schedulerId);\n\n    /**\n     * Do online scheduler by workflow code, this method will not do permission check.\n     */\n    void onlineSchedulerByWorkflowCode(Long workflowDefinitionCode);\n\n    /**\n     * Offline the scheduler by scheduler id, will not offline the related workflow definition.\n     */\n    void offlineScheduler(User loginUser, Long projectCode, Integer schedulerId);\n\n    /**\n     * Do offline scheduler by workflow code, this method will not do permission check.\n     */\n    void offlineSchedulerByWorkflowCode(Long workflowDefinitionCode);\n}\n",
            "role": "user"
        },
        {
            "content": "//dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/impl/SchedulerServiceImpl.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.dolphinscheduler.api.service.impl;\n\nimport static org.apache.dolphinscheduler.api.constants.ApiFuncIdentificationConstant.PROJECT;\nimport static org.apache.dolphinscheduler.api.constants.ApiFuncIdentificationConstant.WORKFLOW_ONLINE_OFFLINE;\n\nimport org.apache.dolphinscheduler.api.dto.ScheduleParam;\nimport org.apache.dolphinscheduler.api.dto.schedule.ScheduleCreateRequest;\nimport org.apache.dolphinscheduler.api.dto.schedule.ScheduleFilterRequest;\nimport org.apache.dolphinscheduler.api.dto.schedule.ScheduleUpdateRequest;\nimport org.apache.dolphinscheduler.api.enums.Status;\nimport org.apache.dolphinscheduler.api.exceptions.ServiceException;\nimport org.apache.dolphinscheduler.api.service.ExecutorService;\nimport org.apache.dolphinscheduler.api.service.ProjectService;\nimport org.apache.dolphinscheduler.api.service.SchedulerService;\nimport org.apache.dolphinscheduler.api.utils.PageInfo;\nimport org.apache.dolphinscheduler.api.utils.Result;\nimport org.apache.dolphinscheduler.api.vo.ScheduleVO;\nimport org.apache.dolphinscheduler.common.constants.Constants;\nimport org.apache.dolphinscheduler.common.enums.FailureStrategy;\nimport org.apache.dolphinscheduler.common.enums.Priority;\nimport org.apache.dolphinscheduler.common.enums.ReleaseState;\nimport org.apache.dolphinscheduler.common.enums.UserType;\nimport org.apache.dolphinscheduler.common.enums.WarningType;\nimport org.apache.dolphinscheduler.common.utils.DateUtils;\nimport org.apache.dolphinscheduler.common.utils.JSONUtils;\nimport org.apache.dolphinscheduler.dao.entity.Environment;\nimport org.apache.dolphinscheduler.dao.entity.Project;\nimport org.apache.dolphinscheduler.dao.entity.Schedule;\nimport org.apache.dolphinscheduler.dao.entity.Tenant;\nimport org.apache.dolphinscheduler.dao.entity.User;\nimport org.apache.dolphinscheduler.dao.entity.WorkflowDefinition;\nimport org.apache.dolphinscheduler.dao.mapper.EnvironmentMapper;\nimport org.apache.dolphinscheduler.dao.mapper.ProjectMapper;\nimport org.apache.dolphinscheduler.dao.mapper.ScheduleMapper;\nimport org.apache.dolphinscheduler.dao.mapper.TenantMapper;\nimport org.apache.dolphinscheduler.dao.mapper.WorkflowDefinitionMapper;\nimport org.apache.dolphinscheduler.scheduler.api.SchedulerApi;\nimport org.apache.dolphinscheduler.service.cron.CronUtils;\nimport org.apache.dolphinscheduler.service.exceptions.CronParseException;\n\nimport org.apache.commons.collections4.CollectionUtils;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.time.ZoneId;\nimport java.time.ZonedDateTime;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TimeZone;\nimport java.util.stream.Collectors;\n\nimport lombok.NonNull;\nimport lombok.extern.slf4j.Slf4j;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport com.baomidou.mybatisplus.core.metadata.IPage;\nimport com.baomidou.mybatisplus.extension.plugins.pagination.Page;\nimport com.cronutils.model.Cron;\n\n@Service\n@Slf4j\npublic class SchedulerServiceImpl extends BaseServiceImpl implements SchedulerService {\n\n    @Autowired\n    private ProjectService projectService;\n\n    @Autowired\n    private ExecutorService executorService;\n\n    @Autowired\n    private ScheduleMapper scheduleMapper;\n\n    @Autowired\n    private ProjectMapper projectMapper;\n\n    @Autowired\n    private WorkflowDefinitionMapper workflowDefinitionMapper;\n\n    @Autowired\n    private SchedulerApi schedulerApi;\n\n    @Autowired\n    private EnvironmentMapper environmentMapper;\n\n    @Autowired\n    private TenantMapper tenantMapper;\n\n    /**\n     * save schedule\n     *\n     * @param loginUser               login user\n     * @param projectCode             project name\n     * @param workflowDefinitionCode       workflow definition code\n     * @param schedule                scheduler\n     * @param warningType             warning type\n     * @param warningGroupId          warning group id\n     * @param failureStrategy         failure strategy\n     * @param workflowInstancePriority workflow instance priority\n     * @param workerGroup             worker group\n     * @param tenantCode              tenant code\n     * @param environmentCode         environment code\n     * @return create result code\n     */\n    @Override\n    @Transactional\n    public Map<String, Object> insertSchedule(User loginUser,\n                                              long projectCode,\n                                              long workflowDefinitionCode,\n                                              String schedule,\n                                              WarningType warningType,\n                                              int warningGroupId,\n                                              FailureStrategy failureStrategy,\n                                              Priority workflowInstancePriority,\n                                              String workerGroup,\n                                              String tenantCode,\n                                              Long environmentCode) {\n\n        Map<String, Object> result = new HashMap<>();\n\n        Project project = projectMapper.queryByCode(projectCode);\n\n        // check project auth\n        boolean hasProjectAndPerm = projectService.hasProjectAndPerm(loginUser, project, result, null);\n        if (!hasProjectAndPerm) {\n            return result;\n        }\n\n        // check workflow define release state\n        WorkflowDefinition workflowDefinition = workflowDefinitionMapper.queryByCode(workflowDefinitionCode);\n        executorService.checkWorkflowDefinitionValid(projectCode, workflowDefinition, workflowDefinitionCode,\n                workflowDefinition.getVersion());\n\n        Schedule scheduleExists =\n                scheduleMapper.queryByWorkflowDefinitionCode(workflowDefinitionCode);\n        if (scheduleExists != null) {\n            log.error(\"Schedule already exist, scheduleId:{}, workflowDefinitionCode:{}\", scheduleExists.getId(),\n                    workflowDefinitionCode);\n            putMsg(result, Status.SCHEDULE_ALREADY_EXISTS, workflowDefinitionCode, scheduleExists.getId());\n            return result;\n        }\n\n        Schedule scheduleObj = new Schedule();\n        Date now = new Date();\n\n        checkValidTenant(tenantCode);\n\n        scheduleObj.setTenantCode(tenantCode);\n        scheduleObj.setProjectName(project.getName());\n        scheduleObj.setWorkflowDefinitionCode(workflowDefinitionCode);\n        scheduleObj.setWorkflowDefinitionName(workflowDefinition.getName());\n\n        ScheduleParam scheduleParam = JSONUtils.parseObject(schedule, ScheduleParam.class);\n        if (DateUtils.differSec(scheduleParam.getStartTime(), scheduleParam.getEndTime()) == 0) {\n            log.warn(\"The start time must not be the same as the end or time can not be null.\");\n            putMsg(result, Status.SCHEDULE_START_TIME_END_TIME_SAME);\n            return result;\n        }\n        if (scheduleParam.getStartTime().getTime() > scheduleParam.getEndTime().getTime()) {\n            log.warn(\"The start time must smaller than end time\");\n            putMsg(result, Status.START_TIME_BIGGER_THAN_END_TIME_ERROR);\n            return result;\n        }\n\n        scheduleObj.setStartTime(scheduleParam.getStartTime());\n        scheduleObj.setEndTime(scheduleParam.getEndTime());\n        if (!CronUtils.isValidExpression(scheduleParam.getCrontab())) {\n            log.error(\"Schedule crontab verify failure, crontab:{}.\", scheduleParam.getCrontab());\n            putMsg(result, Status.REQUEST_PARAMS_NOT_VALID_ERROR, scheduleParam.getCrontab());\n            return result;\n        }\n        scheduleObj.setCrontab(scheduleParam.getCrontab());\n        scheduleObj.setTimezoneId(scheduleParam.getTimezoneId());\n        scheduleObj.setWarningType(warningType);\n        scheduleObj.setWarningGroupId(warningGroupId);\n        scheduleObj.setFailureStrategy(failureStrategy);\n        scheduleObj.setCreateTime(now);\n        scheduleObj.setUpdateTime(now);\n        scheduleObj.setUserId(loginUser.getId());\n        scheduleObj.setUserName(loginUser.getUserName());\n        scheduleObj.setReleaseState(ReleaseState.OFFLINE);\n        scheduleObj.setWorkflowInstancePriority(workflowInstancePriority);\n        scheduleObj.setWorkerGroup(workerGroup);\n        scheduleObj.setEnvironmentCode(environmentCode);\n        scheduleMapper.insert(scheduleObj);\n\n        /**\n         * updateWorkflowInstance receivers and cc by workflow definition id\n         */\n        workflowDefinition.setWarningGroupId(warningGroupId);\n        workflowDefinitionMapper.updateById(workflowDefinition);\n\n        // return scheduler object with ID\n        result.put(Constants.DATA_LIST, scheduleMapper.selectById(scheduleObj.getId()));\n        putMsg(result, Status.SUCCESS);\n        log.info(\"Schedule create complete, projectCode:{}, workflowDefinitionCode:{}, scheduleId:{}.\",\n                projectCode, workflowDefinitionCode, scheduleObj.getId());\n        result.put(\"scheduleId\", scheduleObj.getId());\n        return result;\n    }\n\n    protected void projectPermCheckByWorkflowCode(User loginUser, long workflowDefinitionCode) {\n        WorkflowDefinition workflowDefinition = workflowDefinitionMapper.queryByCode(workflowDefinitionCode);\n        if (workflowDefinition == null) {\n            throw new ServiceException(Status.WORKFLOW_DEFINITION_NOT_EXIST, workflowDefinitionCode);\n        }\n        Project project = projectMapper.queryByCode(workflowDefinition.getProjectCode());\n        // check project auth\n        this.projectService.checkProjectAndAuthThrowException(loginUser, project, null);\n    }\n\n    private void scheduleParamCheck(String scheduleParamStr) {\n        ScheduleParam scheduleParam = JSONUtils.parseObject(scheduleParamStr, ScheduleParam.class);\n        if (scheduleParam == null) {\n            throw new ServiceException(Status.PARSE_SCHEDULE_PARAM_ERROR, scheduleParamStr);\n        }\n        if (DateUtils.differSec(scheduleParam.getStartTime(), scheduleParam.getEndTime()) == 0) {\n            throw new ServiceException(Status.SCHEDULE_START_TIME_END_TIME_SAME);\n        }\n        if (scheduleParam.getStartTime().getTime() > scheduleParam.getEndTime().getTime()) {\n            throw new ServiceException(Status.START_TIME_BIGGER_THAN_END_TIME_ERROR);\n        }\n        if (!CronUtils.isValidExpression(scheduleParam.getCrontab())) {\n            throw new ServiceException(Status.SCHEDULE_CRON_CHECK_FAILED, scheduleParam.getCrontab());\n        }\n    }\n\n    /**\n     * save schedule V2, will also change workflow definition's warningGroupId if schedule's warningGroupId be set\n     *\n     * @param loginUser               login user\n     * @param scheduleCreateRequest   schedule create object\n     * @return Schedule object just be created\n     */\n    @Override\n    @Transactional\n    public Schedule createSchedulesV2(User loginUser,\n                                      ScheduleCreateRequest scheduleCreateRequest) {\n        this.projectPermCheckByWorkflowCode(loginUser, scheduleCreateRequest.getWorkflowDefinitionCode());\n\n        WorkflowDefinition workflowDefinition =\n                workflowDefinitionMapper.queryByCode(scheduleCreateRequest.getWorkflowDefinitionCode());\n\n        // check workflow define release state\n        executorService.checkWorkflowDefinitionValid(workflowDefinition.getProjectCode(), workflowDefinition,\n                workflowDefinition.getCode(), workflowDefinition.getVersion());\n\n        Schedule scheduleExists =\n                scheduleMapper.queryByWorkflowDefinitionCode(scheduleCreateRequest.getWorkflowDefinitionCode());\n        if (scheduleExists != null) {\n            throw new ServiceException(Status.SCHEDULE_ALREADY_EXISTS,\n                    scheduleCreateRequest.getWorkflowDefinitionCode(),\n                    scheduleExists.getId());\n        }\n\n        checkValidTenant(scheduleCreateRequest.getTenantCode());\n\n        Schedule schedule = scheduleCreateRequest.convert2Schedule();\n        Environment environment = environmentMapper.queryByEnvironmentCode(schedule.getEnvironmentCode());\n        if (environment == null) {\n            throw new ServiceException(Status.QUERY_ENVIRONMENT_BY_CODE_ERROR, schedule.getEnvironmentCode());\n        }\n\n        schedule.setUserId(loginUser.getId());\n        // give more detail when return schedule object\n        schedule.setUserName(loginUser.getUserName());\n        schedule.setWorkflowDefinitionName(workflowDefinition.getName());\n\n        this.scheduleParamCheck(scheduleCreateRequest.getScheduleParam());\n        int create = scheduleMapper.insert(schedule);\n        if (create <= 0) {\n            throw new ServiceException(Status.CREATE_SCHEDULE_ERROR);\n        }\n        // updateWorkflowInstance receivers and cc by workflow definition id\n        workflowDefinition.setWarningGroupId(schedule.getWarningGroupId());\n        workflowDefinitionMapper.updateById(workflowDefinition);\n        return schedule;\n    }\n\n    /**\n     * updateWorkflowInstance schedule\n     *\n     * @param loginUser               login user\n     * @param projectCode             project code\n     * @param id                      scheduler id\n     * @param scheduleExpression      scheduler\n     * @param warningType             warning type\n     * @param warningGroupId          warning group id\n     * @param failureStrategy         failure strategy\n     * @param workerGroup             worker group\n     * @param tenantCode              tenant code\n     * @param environmentCode         environment code\n     * @param workflowInstancePriority workflow instance priority\n     * @return update result code\n     */\n    @Override\n    @Transactional\n    public Map<String, Object> updateSchedule(User loginUser,\n                                              long projectCode,\n                                              Integer id,\n                                              String scheduleExpression,\n                                              WarningType warningType,\n                                              int warningGroupId,\n                                              FailureStrategy failureStrategy,\n                                              Priority workflowInstancePriority,\n                                              String workerGroup,\n                                              String tenantCode,\n                                              Long environmentCode) {\n        Map<String, Object> result = new HashMap<>();\n\n        Project project = projectMapper.queryByCode(projectCode);\n\n        // check project auth\n        boolean hasProjectAndPerm = projectService.hasProjectAndPerm(loginUser, project, result, null);\n        if (!hasProjectAndPerm) {\n            return result;\n        }\n\n        // check schedule exists\n        Schedule schedule = scheduleMapper.selectById(id);\n\n        if (schedule == null) {\n            log.error(\"Schedule does not exist, scheduleId:{}.\", id);\n            putMsg(result, Status.SCHEDULE_NOT_EXISTS, id);\n            return result;\n        }\n\n        WorkflowDefinition workflowDefinition =\n                workflowDefinitionMapper.queryByCode(schedule.getWorkflowDefinitionCode());\n        if (workflowDefinition == null || projectCode != workflowDefinition.getProjectCode()) {\n            log.error(\"workflow definition does not exist, workflowDefinitionCode:{}.\",\n                    schedule.getWorkflowDefinitionCode());\n            putMsg(result, Status.WORKFLOW_DEFINITION_NOT_EXIST, String.valueOf(schedule.getWorkflowDefinitionCode()));\n            return result;\n        }\n\n        updateSchedule(result, schedule, workflowDefinition, scheduleExpression, warningType, warningGroupId,\n                failureStrategy, workflowInstancePriority, workerGroup, tenantCode, environmentCode);\n        return result;\n    }\n\n    /**\n     * update schedule object V2\n     *\n     * @param loginUser login user\n     * @param scheduleId scheduler id\n     * @param scheduleUpdateRequest the schedule object will be updated\n     * @return Schedule object\n     */\n    @Override\n    @Transactional\n    public Schedule updateSchedulesV2(User loginUser,\n                                      Integer scheduleId,\n                                      ScheduleUpdateRequest scheduleUpdateRequest) {\n        Schedule schedule = scheduleMapper.selectById(scheduleId);\n        if (schedule == null) {\n            throw new ServiceException(Status.SCHEDULE_NOT_EXISTS, scheduleId);\n        }\n\n        Schedule scheduleUpdate;\n        try {\n            scheduleUpdate = scheduleUpdateRequest.mergeIntoSchedule(schedule);\n            // check update params\n            this.scheduleParamCheck(scheduleUpdateRequest.updateScheduleParam(scheduleUpdate));\n        } catch (InvocationTargetException | IllegalAccessException | InstantiationException\n                | NoSuchMethodException e) {\n            throw new ServiceException(Status.REQUEST_PARAMS_NOT_VALID_ERROR, scheduleUpdateRequest.toString());\n        }\n        // check update params\n        this.projectPermCheckByWorkflowCode(loginUser, scheduleUpdate.getWorkflowDefinitionCode());\n\n        if (scheduleUpdate.getEnvironmentCode() != null) {\n            Environment environment = environmentMapper.queryByEnvironmentCode(scheduleUpdate.getEnvironmentCode());\n            if (environment == null) {\n                throw new ServiceException(Status.QUERY_ENVIRONMENT_BY_CODE_ERROR, scheduleUpdate.getEnvironmentCode());\n            }\n        }\n\n        int update = scheduleMapper.updateById(scheduleUpdate);\n        if (update <= 0) {\n            throw new ServiceException(Status.UPDATE_SCHEDULE_ERROR);\n        }\n        return scheduleUpdate;\n    }\n\n    /**\n     * get schedule object\n     *\n     * @param loginUser login user\n     * @param scheduleId scheduler id\n     * @return Schedule object\n     */\n    @Override\n    @Transactional\n    public Schedule getSchedule(User loginUser,\n                                Integer scheduleId) {\n        Schedule schedule = scheduleMapper.selectById(scheduleId);\n        if (schedule == null) {\n            throw new ServiceException(Status.SCHEDULE_NOT_EXISTS, scheduleId);\n        }\n        this.projectPermCheckByWorkflowCode(loginUser, schedule.getWorkflowDefinitionCode());\n        return schedule;\n    }\n\n    /**\n     * query schedule\n     *\n     * @param loginUser         login user\n     * @param projectCode       project code\n     * @param workflowDefinitionCode workflow definition code\n     * @param pageNo            page number\n     * @param pageSize          page size\n     * @param searchVal         search value\n     * @return schedule list page\n     */\n    @Override\n    public Result querySchedule(User loginUser, long projectCode, long workflowDefinitionCode, String searchVal,\n                                Integer pageNo, Integer pageSize) {\n        Result result = new Result();\n\n        Project project = projectMapper.queryByCode(projectCode);\n\n        // check project auth\n        boolean hasProjectAndPerm = projectService.hasProjectAndPerm(loginUser, project, result, PROJECT);\n        if (!hasProjectAndPerm) {\n            return result;\n        }\n\n        if (workflowDefinitionCode != 0) {\n            WorkflowDefinition workflowDefinition = workflowDefinitionMapper.queryByCode(workflowDefinitionCode);\n            if (workflowDefinition == null || projectCode != workflowDefinition.getProjectCode()) {\n                log.error(\"workflow definition does not exist, workflowDefinitionCode:{}.\", workflowDefinitionCode);\n                putMsg(result, Status.WORKFLOW_DEFINITION_NOT_EXIST, String.valueOf(workflowDefinitionCode));\n                return result;\n            }\n        }\n\n        Page<Schedule> page = new Page<>(pageNo, pageSize);\n\n        IPage<Schedule> schedulePage =\n                scheduleMapper.queryByProjectAndWorkflowDefinitionCodePaging(page, projectCode, workflowDefinitionCode,\n                        searchVal);\n\n        List<ScheduleVO> scheduleList = new ArrayList<>();\n        for (Schedule schedule : schedulePage.getRecords()) {\n            scheduleList.add(new ScheduleVO(schedule));\n        }\n\n        PageInfo<ScheduleVO> pageInfo = new PageInfo<>(pageNo, pageSize);\n        pageInfo.setTotal((int) schedulePage.getTotal());\n        pageInfo.setTotalList(scheduleList);\n        result.setData(pageInfo);\n        putMsg(result, Status.SUCCESS);\n        return result;\n    }\n\n    public List<Schedule> queryScheduleByWorkflowDefinitionCodes(@NonNull List<Long> workflowDefinitionCodes) {\n        if (CollectionUtils.isEmpty(workflowDefinitionCodes)) {\n            return Collections.emptyList();\n        }\n        return scheduleMapper.querySchedulesByWorkflowDefinitionCodes(workflowDefinitionCodes);\n    }\n\n    /**\n     * query schedule\n     *\n     * @param loginUser login user\n     * @param scheduleFilterRequest schedule filter request\n     * @return schedule list page\n     */\n    @Override\n    @Transactional\n    public PageInfo<Schedule> filterSchedules(User loginUser,\n                                              ScheduleFilterRequest scheduleFilterRequest) {\n        if (scheduleFilterRequest.getProjectName() != null) {\n            Project project = projectMapper.queryByName(scheduleFilterRequest.getProjectName());\n            // check project auth\n            projectService.checkProjectAndAuthThrowException(loginUser, project, null);\n        }\n        Page<Schedule> page = new Page<>(scheduleFilterRequest.getPageNo(), scheduleFilterRequest.getPageSize());\n        IPage<Schedule> scheduleIPage = scheduleMapper.filterSchedules(page, scheduleFilterRequest.convert2Schedule());\n\n        PageInfo<Schedule> pageInfo =\n                new PageInfo<>(scheduleFilterRequest.getPageNo(), scheduleFilterRequest.getPageSize());\n        pageInfo.setTotal((int) scheduleIPage.getTotal());\n        pageInfo.setTotalList(scheduleIPage.getRecords());\n\n        return pageInfo;\n    }\n\n    /**\n     * query schedule list\n     *\n     * @param loginUser   login user\n     * @param projectCode project code\n     * @return schedule list\n     */\n    @Override\n    public Map<String, Object> queryScheduleList(User loginUser, long projectCode) {\n        Map<String, Object> result = new HashMap<>();\n        Project project = projectMapper.queryByCode(projectCode);\n\n        // check project auth\n        boolean hasProjectAndPerm = projectService.hasProjectAndPerm(loginUser, project, result, null);\n        if (!hasProjectAndPerm) {\n            return result;\n        }\n\n        List<Schedule> schedules = scheduleMapper.querySchedulerListByProjectName(project.getName());\n        List<ScheduleVO> scheduleList = new ArrayList<>();\n        for (Schedule schedule : schedules) {\n            scheduleList.add(new ScheduleVO(schedule));\n        }\n\n        result.put(Constants.DATA_LIST, scheduleList);\n        putMsg(result, Status.SUCCESS);\n\n        return result;\n    }\n\n    /**\n     * check valid\n     *\n     * @param result result\n     * @param bool   bool\n     * @param status status\n     * @return check result code\n     */\n    private boolean checkValid(Map<String, Object> result, boolean bool, Status status) {\n        // timeout is valid\n        if (bool) {\n            putMsg(result, status);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * delete schedule by id\n     *\n     * @param loginUser   login user\n     * @param scheduleId  schedule id\n     */\n    @Override\n    public void deleteSchedulesById(User loginUser, Integer scheduleId) {\n        Schedule schedule = scheduleMapper.selectById(scheduleId);\n        if (schedule == null) {\n            throw new ServiceException(Status.SCHEDULE_NOT_EXISTS, scheduleId);\n        }\n        // check schedule is already online\n        if (schedule.getReleaseState() == ReleaseState.ONLINE) {\n            throw new ServiceException(Status.SCHEDULE_STATE_ONLINE, scheduleId);\n        }\n        // Determine if the login user is the owner of the schedule\n        if (loginUser.getId() != schedule.getUserId() && loginUser.getUserType() != UserType.ADMIN_USER) {\n            throw new ServiceException(Status.USER_NO_OPERATION_PERM);\n        }\n\n        this.projectPermCheckByWorkflowCode(loginUser, schedule.getWorkflowDefinitionCode());\n        int delete = scheduleMapper.deleteById(scheduleId);\n        if (delete <= 0) {\n            throw new ServiceException(Status.DELETE_SCHEDULE_BY_ID_ERROR);\n        }\n    }\n\n    /**\n     * preview schedule\n     *\n     * @param loginUser login user\n     * @param schedule  schedule expression\n     * @return the next five fire time\n     */\n    @Override\n    public Map<String, Object> previewSchedule(User loginUser, String schedule) {\n        Map<String, Object> result = new HashMap<>();\n        Cron cron;\n        ScheduleParam scheduleParam = JSONUtils.parseObject(schedule, ScheduleParam.class);\n\n        assert scheduleParam != null;\n        ZoneId zoneId = TimeZone.getTimeZone(scheduleParam.getTimezoneId()).toZoneId();\n        ZonedDateTime now = ZonedDateTime.now(zoneId);\n        ZonedDateTime startTime = ZonedDateTime.ofInstant(scheduleParam.getStartTime().toInstant(), zoneId);\n        ZonedDateTime endTime = ZonedDateTime.ofInstant(scheduleParam.getEndTime().toInstant(), zoneId);\n        startTime = now.isAfter(startTime) ? now : startTime;\n\n        try {\n            cron = CronUtils.parse2Cron(scheduleParam.getCrontab());\n        } catch (CronParseException e) {\n            log.error(\"Parse cron to cron expression error, crontab:{}.\", scheduleParam.getCrontab(), e);\n            putMsg(result, Status.PARSE_TO_CRON_EXPRESSION_ERROR);\n            return result;\n        }\n        List<ZonedDateTime> selfFireDateList =\n                CronUtils.getSelfFireDateList(startTime, endTime, cron, Constants.PREVIEW_SCHEDULE_EXECUTE_COUNT);\n        List<String> previewDateList =\n                selfFireDateList.stream().map(t -> DateUtils.dateToString(t, zoneId)).collect(Collectors.toList());\n        result.put(Constants.DATA_LIST, previewDateList);\n        putMsg(result, Status.SUCCESS);\n        return result;\n    }\n\n    /**\n     * update workflow definition schedule\n     *\n     * @param loginUser               login user\n     * @param projectCode             project code\n     * @param workflowDefinitionCode   workflow definition code\n     * @param scheduleExpression      scheduleExpression\n     * @param warningType             warning type\n     * @param warningGroupId          warning group id\n     * @param failureStrategy         failure strategy\n     * @param workerGroup             worker group\n     * @param tenantCode              tenant code\n     * @param workflowInstancePriority workflow instance priority\n     * @return update result code\n     */\n    @Override\n    public Map<String, Object> updateScheduleByWorkflowDefinitionCode(User loginUser,\n                                                                      long projectCode,\n                                                                      long workflowDefinitionCode,\n                                                                      String scheduleExpression,\n                                                                      WarningType warningType,\n                                                                      int warningGroupId,\n                                                                      FailureStrategy failureStrategy,\n                                                                      Priority workflowInstancePriority,\n                                                                      String workerGroup,\n                                                                      String tenantCode,\n                                                                      long environmentCode) {\n        Project project = projectMapper.queryByCode(projectCode);\n        // check user access for project\n        Map<String, Object> result = projectService.checkProjectAndAuth(loginUser, project, projectCode, null);\n        if (result.get(Constants.STATUS) != Status.SUCCESS) {\n            return result;\n        }\n        // check schedule exists\n        Schedule schedule = scheduleMapper.queryByWorkflowDefinitionCode(workflowDefinitionCode);\n        if (schedule == null) {\n            log.error(\"Schedule of workflow definition does not exist, workflowDefinitionCode:{}.\",\n                    workflowDefinitionCode);\n            putMsg(result, Status.SCHEDULE_CRON_NOT_EXISTS, workflowDefinitionCode);\n            return result;\n        }\n\n        WorkflowDefinition workflowDefinition = workflowDefinitionMapper.queryByCode(workflowDefinitionCode);\n        if (workflowDefinition == null || projectCode != workflowDefinition.getProjectCode()) {\n            log.error(\"workflow definition does not exist, workflowDefinitionCode:{}.\", workflowDefinitionCode);\n            putMsg(result, Status.WORKFLOW_DEFINITION_NOT_EXIST, String.valueOf(workflowDefinitionCode));\n            return result;\n        }\n\n        updateSchedule(result, schedule, workflowDefinition, scheduleExpression, warningType, warningGroupId,\n                failureStrategy, workflowInstancePriority, workerGroup, tenantCode, environmentCode);\n        return result;\n    }\n\n    @Transactional\n    @Override\n    public void onlineScheduler(User loginUser, Long projectCode, Integer schedulerId) {\n        projectService.checkProjectAndAuthThrowException(loginUser, projectCode, WORKFLOW_ONLINE_OFFLINE);\n        Schedule schedule = scheduleMapper.selectById(schedulerId);\n        doOnlineScheduler(schedule);\n    }\n\n    @Transactional\n    @Override\n    public void onlineSchedulerByWorkflowCode(Long workflowDefinitionCode) {\n        Schedule schedule = scheduleMapper.queryByWorkflowDefinitionCode(workflowDefinitionCode);\n        doOnlineScheduler(schedule);\n    }\n\n    private void doOnlineScheduler(Schedule schedule) {\n        if (schedule == null) {\n            return;\n        }\n        if (ReleaseState.ONLINE.equals(schedule.getReleaseState())) {\n            log.debug(\"The schedule is already online, scheduleId:{}.\", schedule.getId());\n            return;\n        }\n        WorkflowDefinition workflowDefinition =\n                workflowDefinitionMapper.queryByCode(schedule.getWorkflowDefinitionCode());\n        if (!ReleaseState.ONLINE.equals(workflowDefinition.getReleaseState())) {\n            throw new ServiceException(Status.WORKFLOW_DEFINITION_NOT_RELEASE, workflowDefinition.getName());\n        }\n\n        schedule.setReleaseState(ReleaseState.ONLINE);\n        scheduleMapper.updateById(schedule);\n\n        Project project = projectMapper.queryByCode(workflowDefinition.getProjectCode());\n        schedulerApi.insertOrUpdateScheduleTask(project.getId(), schedule);\n    }\n\n    @Transactional\n    @Override\n    public void offlineScheduler(User loginUser, Long projectCode, Integer schedulerId) {\n        projectService.checkProjectAndAuthThrowException(loginUser, projectCode, WORKFLOW_ONLINE_OFFLINE);\n        Schedule schedule = scheduleMapper.selectById(schedulerId);\n        doOfflineScheduler(schedule);\n    }\n\n    @Transactional\n    @Override\n    public void offlineSchedulerByWorkflowCode(Long workflowDefinitionCode) {\n        Schedule schedule = scheduleMapper.queryByWorkflowDefinitionCode(workflowDefinitionCode);\n        doOfflineScheduler(schedule);\n    }\n\n    private void doOfflineScheduler(Schedule schedule) {\n        if (schedule == null) {\n            return;\n        }\n        if (ReleaseState.OFFLINE.equals(schedule.getReleaseState())) {\n            log.debug(\"The schedule is already offline, scheduleId:{}.\", schedule.getId());\n            return;\n        }\n        schedule.setReleaseState(ReleaseState.OFFLINE);\n        scheduleMapper.updateById(schedule);\n        WorkflowDefinition workflowDefinition =\n                workflowDefinitionMapper.queryByCode(schedule.getWorkflowDefinitionCode());\n        Project project = projectMapper.queryByCode(workflowDefinition.getProjectCode());\n        schedulerApi.deleteScheduleTask(project.getId(), schedule.getId());\n    }\n\n    private void updateSchedule(Map<String, Object> result, Schedule schedule, WorkflowDefinition workflowDefinition,\n                                String scheduleExpression, WarningType warningType, int warningGroupId,\n                                FailureStrategy failureStrategy, Priority workflowInstancePriority, String workerGroup,\n                                String tenantCode,\n                                long environmentCode) {\n        if (checkValid(result, schedule.getReleaseState() == ReleaseState.ONLINE,\n                Status.SCHEDULE_CRON_ONLINE_FORBID_UPDATE)) {\n            log.warn(\"Schedule can not be updated due to schedule is {}, scheduleId:{}.\",\n                    ReleaseState.ONLINE.getDescp(), schedule.getId());\n            return;\n        }\n\n        Date now = new Date();\n\n        checkValidTenant(tenantCode);\n        schedule.setTenantCode(tenantCode);\n\n        // updateWorkflowInstance param\n        if (!StringUtils.isEmpty(scheduleExpression)) {\n            ScheduleParam scheduleParam = JSONUtils.parseObject(scheduleExpression, ScheduleParam.class);\n            if (scheduleParam == null) {\n                log.warn(\"Parameter scheduleExpression is invalid, so parse cron error.\");\n                putMsg(result, Status.PARSE_TO_CRON_EXPRESSION_ERROR);\n                return;\n            }\n            if (DateUtils.differSec(scheduleParam.getStartTime(), scheduleParam.getEndTime()) == 0) {\n                log.warn(\"The start time must not be the same as the end or time can not be null.\");\n                putMsg(result, Status.SCHEDULE_START_TIME_END_TIME_SAME);\n                return;\n            }\n            if (scheduleParam.getStartTime().getTime() > scheduleParam.getEndTime().getTime()) {\n                log.warn(\"The start time must smaller than end time\");\n                putMsg(result, Status.START_TIME_BIGGER_THAN_END_TIME_ERROR);\n                return;\n            }\n\n            schedule.setStartTime(scheduleParam.getStartTime());\n            schedule.setEndTime(scheduleParam.getEndTime());\n            if (!CronUtils.isValidExpression(scheduleParam.getCrontab())) {\n                log.error(\"Schedule crontab verify failure, crontab:{}.\", scheduleParam.getCrontab());\n                putMsg(result, Status.SCHEDULE_CRON_CHECK_FAILED, scheduleParam.getCrontab());\n                return;\n            }\n            schedule.setCrontab(scheduleParam.getCrontab());\n            schedule.setTimezoneId(scheduleParam.getTimezoneId());\n        }\n\n        if (warningType != null) {\n            schedule.setWarningType(warningType);\n        }\n\n        schedule.setWarningGroupId(warningGroupId);\n\n        if (failureStrategy != null) {\n            schedule.setFailureStrategy(failureStrategy);\n        }\n\n        schedule.setWorkerGroup(workerGroup);\n        schedule.setEnvironmentCode(environmentCode);\n        schedule.setUpdateTime(now);\n        schedule.setWorkflowInstancePriority(workflowInstancePriority);\n        scheduleMapper.updateById(schedule);\n\n        workflowDefinition.setWarningGroupId(warningGroupId);\n\n        workflowDefinitionMapper.updateById(workflowDefinition);\n\n        log.info(\"Schedule update complete, projectCode:{}, workflowDefinitionCode:{}, scheduleId:{}.\",\n                workflowDefinition.getProjectCode(), workflowDefinition.getCode(), schedule.getId());\n        result.put(Constants.DATA_LIST, schedule);\n        putMsg(result, Status.SUCCESS);\n    }\n\n    /**\n     * check valid tenant\n     *\n     * @param tenantCode\n     */\n    private void checkValidTenant(String tenantCode) {\n        if (!Constants.DEFAULT.equals(tenantCode)) {\n            Tenant tenant = tenantMapper.queryByTenantCode(tenantCode);\n            if (tenant == null) {\n                throw new ServiceException(Status.TENANT_NOT_EXIST, tenantCode);\n            }\n        }\n    }\n}\n",
            "role": "user"
        },
        {
            "content": "//dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/controller/ProjectParameterController.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.dolphinscheduler.api.controller;\n\nimport static org.apache.dolphinscheduler.api.enums.Status.CREATE_PROJECT_PARAMETER_ERROR;\nimport static org.apache.dolphinscheduler.api.enums.Status.DELETE_PROJECT_PARAMETER_ERROR;\nimport static org.apache.dolphinscheduler.api.enums.Status.QUERY_PROJECT_PARAMETER_ERROR;\nimport static org.apache.dolphinscheduler.api.enums.Status.UPDATE_PROJECT_PARAMETER_ERROR;\n\nimport org.apache.dolphinscheduler.api.exceptions.ApiException;\nimport org.apache.dolphinscheduler.api.service.ProjectParameterService;\nimport org.apache.dolphinscheduler.api.utils.Result;\nimport org.apache.dolphinscheduler.common.constants.Constants;\nimport org.apache.dolphinscheduler.dao.entity.User;\nimport org.apache.dolphinscheduler.plugin.task.api.utils.ParameterUtils;\n\nimport lombok.extern.slf4j.Slf4j;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.PutMapping;\nimport org.springframework.web.bind.annotation.RequestAttribute;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseStatus;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport io.swagger.v3.oas.annotations.Operation;\nimport io.swagger.v3.oas.annotations.Parameter;\nimport io.swagger.v3.oas.annotations.Parameters;\nimport io.swagger.v3.oas.annotations.media.Schema;\nimport io.swagger.v3.oas.annotations.tags.Tag;\n\n@Tag(name = \"PROJECT_PARAMETER_TAG\")\n@RestController\n@RequestMapping(\"projects/{projectCode}/project-parameter\")\n@Slf4j\npublic class ProjectParameterController extends BaseController {\n\n    @Autowired\n    private ProjectParameterService projectParameterService;\n\n    @Operation(summary = \"createProjectParameter\", description = \"CREATE_PROJECT_PARAMETER_NOTES\")\n    @Parameters({\n            @Parameter(name = \"projectParameterName\", description = \"PROJECT_PARAMETER_NAME\", schema = @Schema(implementation = String.class)),\n            @Parameter(name = \"projectParameterValue\", description = \"PROJECT_PARAMETER_VALUE\", schema = @Schema(implementation = String.class)),\n            @Parameter(name = \"projectParameterDataType\", description = \"PROJECT_PARAMETER_DATA_TYPE\", schema = @Schema(implementation = String.class))\n    })\n    @PostMapping()\n    @ResponseStatus(HttpStatus.CREATED)\n    @ApiException(CREATE_PROJECT_PARAMETER_ERROR)\n    public Result createProjectParameter(@Parameter(hidden = true) @RequestAttribute(value = Constants.SESSION_USER) User loginUser,\n                                         @Parameter(name = \"projectCode\", description = \"PROJECT_CODE\", required = true) @PathVariable long projectCode,\n                                         @RequestParam(\"projectParameterName\") String projectParameterName,\n                                         @RequestParam(value = \"projectParameterValue\") String projectParameterValue,\n                                         @RequestParam(value = \"projectParameterDataType\", defaultValue = \"VARCHAR\") String projectParameterDataType) {\n        return projectParameterService.createProjectParameter(loginUser, projectCode, projectParameterName,\n                projectParameterValue, projectParameterDataType);\n    }\n\n    @Operation(summary = \"updateProjectParameter\", description = \"UPDATE_PROJECT_PARAMETER_NOTES\")\n    @Parameters({\n            @Parameter(name = \"code\", description = \"PROJECT_PARAMETER_CODE\", schema = @Schema(implementation = long.class, example = \"123456\")),\n            @Parameter(name = \"projectParameterName\", description = \"PROJECT_PARAMETER_NAME\", schema = @Schema(implementation = String.class)),\n            @Parameter(name = \"projectParameterValue\", description = \"PROJECT_PARAMETER_VALUE\", schema = @Schema(implementation = String.class)),\n            @Parameter(name = \"projectParameterDataType\", description = \"PROJECT_PARAMETER_DATA_TYPE\", schema = @Schema(implementation = String.class))\n    })\n    @PutMapping(value = \"/{code}\")\n    @ResponseStatus(HttpStatus.OK)\n    @ApiException(UPDATE_PROJECT_PARAMETER_ERROR)\n    public Result updateProjectParameter(@Parameter(hidden = true) @RequestAttribute(value = Constants.SESSION_USER) User loginUser,\n                                         @Parameter(name = \"projectCode\", description = \"PROJECT_CODE\", required = true) @PathVariable long projectCode,\n                                         @PathVariable(\"code\") Long code,\n                                         @RequestParam(\"projectParameterName\") String projectParameterName,\n                                         @RequestParam(value = \"projectParameterValue\") String projectParameterValue,\n                                         @RequestParam(value = \"projectParameterDataType\") String projectParameterDataType) {\n        return projectParameterService.updateProjectParameter(loginUser, projectCode, code, projectParameterName,\n                projectParameterValue, projectParameterDataType);\n    }\n\n    @Operation(summary = \"deleteProjectParametersByCode\", description = \"DELETE_PROJECT_PARAMETER_NOTES\")\n    @Parameters({\n            @Parameter(name = \"code\", description = \"PROJECT_PARAMETER_CODE\", required = true, schema = @Schema(implementation = String.class))\n    })\n    @PostMapping(value = \"/delete\")\n    @ResponseStatus(HttpStatus.OK)\n    @ApiException(DELETE_PROJECT_PARAMETER_ERROR)\n    public Result deleteProjectParametersByCode(@Parameter(hidden = true) @RequestAttribute(value = Constants.SESSION_USER) User loginUser,\n                                                @Parameter(name = \"projectCode\", description = \"PROJECT_CODE\", required = true) @PathVariable long projectCode,\n                                                @RequestParam(\"code\") long code) {\n\n        return projectParameterService.deleteProjectParametersByCode(loginUser, projectCode, code);\n    }\n\n    @Operation(summary = \"batchDeleteProjectParametersByCodes\", description = \"DELETE_PROJECT_PARAMETER_NOTES\")\n    @Parameters({\n            @Parameter(name = \"codes\", description = \"PROJECT_PARAMETER_CODE\", required = true, schema = @Schema(implementation = String.class))\n    })\n    @PostMapping(value = \"/batch-delete\")\n    @ResponseStatus(HttpStatus.OK)\n    @ApiException(DELETE_PROJECT_PARAMETER_ERROR)\n    public Result batchDeleteProjectParametersByCodes(@Parameter(hidden = true) @RequestAttribute(value = Constants.SESSION_USER) User loginUser,\n                                                      @Parameter(name = \"projectCode\", description = \"PROJECT_CODE\", required = true) @PathVariable long projectCode,\n                                                      @RequestParam(\"codes\") String codes) {\n\n        return projectParameterService.batchDeleteProjectParametersByCodes(loginUser, projectCode, codes);\n    }\n\n    @Operation(summary = \"queryProjectParameterListPaging\", description = \"QUERY_PROJECT_PARAMETER_LIST_PAGING_NOTES\")\n    @Parameters({\n            @Parameter(name = \"searchVal\", description = \"SEARCH_VAL\", required = false, schema = @Schema(implementation = String.class)),\n            @Parameter(name = \"pageNo\", description = \"PAGE_NO\", required = true, schema = @Schema(implementation = int.class, example = \"1\")),\n            @Parameter(name = \"pageSize\", description = \"PAGE_SIZE\", required = true, schema = @Schema(implementation = int.class, example = \"10\"))\n    })\n    @GetMapping()\n    @ResponseStatus(HttpStatus.OK)\n    @ApiException(QUERY_PROJECT_PARAMETER_ERROR)\n    public Result queryProjectParameterListPaging(\n                                                  @Parameter(hidden = true) @RequestAttribute(value = Constants.SESSION_USER) User loginUser,\n                                                  @Parameter(name = \"projectCode\", description = \"PROJECT_CODE\", required = true) @PathVariable long projectCode,\n                                                  @RequestParam(value = \"searchVal\", required = false) String searchVal,\n                                                  @RequestParam(value = \"projectParameterDataType\", required = false) String projectParameterDataType,\n                                                  @RequestParam(\"pageNo\") Integer pageNo,\n                                                  @RequestParam(\"pageSize\") Integer pageSize) {\n\n        checkPageParams(pageNo, pageSize);\n        searchVal = ParameterUtils.handleEscapes(searchVal);\n        return projectParameterService.queryProjectParameterListPaging(loginUser, projectCode, pageSize, pageNo,\n                searchVal, projectParameterDataType);\n    }\n\n    @Operation(summary = \"queryProjectParameterByCode\", description = \"QUERY_PROJECT_PARAMETER_NOTES\")\n    @Parameters({\n            @Parameter(name = \"code\", description = \"PROJECT_PARAMETER_CODE\", schema = @Schema(implementation = long.class, example = \"123456\"))\n    })\n    @GetMapping(value = \"/{code}\")\n    @ResponseStatus(HttpStatus.OK)\n    @ApiException(QUERY_PROJECT_PARAMETER_ERROR)\n    public Result queryProjectParameterByCode(@Parameter(hidden = true) @RequestAttribute(value = Constants.SESSION_USER) User loginUser,\n                                              @Parameter(name = \"projectCode\", description = \"PROJECT_CODE\", required = true) @PathVariable long projectCode,\n                                              @PathVariable(\"code\") long code) {\n        return projectParameterService.queryProjectParameterByCode(loginUser, projectCode, code);\n    }\n\n}\n",
            "role": "user"
        },
        {
            "content": "//dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/ProjectParameterService.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.dolphinscheduler.api.service;\n\nimport org.apache.dolphinscheduler.api.utils.Result;\nimport org.apache.dolphinscheduler.dao.entity.User;\n\npublic interface ProjectParameterService {\n\n    Result createProjectParameter(User loginUser, long projectCode, String projectParameterName,\n                                  String projectParameterValue, String projectParameterDataType);\n\n    Result updateProjectParameter(User loginUser, long projectCode, long code, String projectParameterName,\n                                  String projectParameterValue, String projectParameterDataType);\n\n    Result deleteProjectParametersByCode(User loginUser, long projectCode, long code);\n\n    Result batchDeleteProjectParametersByCodes(User loginUser, long projectCode, String codes);\n\n    Result queryProjectParameterListPaging(User loginUser, long projectCode, Integer pageSize, Integer pageNo,\n                                           String searchVal, String projectParameterDataType);\n\n    Result queryProjectParameterByCode(User loginUser, long projectCode, long code);\n}\n",
            "role": "user"
        },
        {
            "content": "//dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/impl/TenantServiceImpl.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.dolphinscheduler.api.service.impl;\n\nimport static org.apache.dolphinscheduler.api.constants.ApiFuncIdentificationConstant.TENANT_CREATE;\nimport static org.apache.dolphinscheduler.api.constants.ApiFuncIdentificationConstant.TENANT_DELETE;\nimport static org.apache.dolphinscheduler.api.constants.ApiFuncIdentificationConstant.TENANT_UPDATE;\nimport static org.apache.dolphinscheduler.common.constants.Constants.TENANT_FULL_NAME_MAX_LENGTH;\n\nimport org.apache.dolphinscheduler.api.enums.Status;\nimport org.apache.dolphinscheduler.api.exceptions.ServiceException;\nimport org.apache.dolphinscheduler.api.service.QueueService;\nimport org.apache.dolphinscheduler.api.service.TenantService;\nimport org.apache.dolphinscheduler.api.utils.PageInfo;\nimport org.apache.dolphinscheduler.api.utils.RegexUtils;\nimport org.apache.dolphinscheduler.common.constants.Constants;\nimport org.apache.dolphinscheduler.common.enums.AuthorizationType;\nimport org.apache.dolphinscheduler.dao.entity.Queue;\nimport org.apache.dolphinscheduler.dao.entity.Schedule;\nimport org.apache.dolphinscheduler.dao.entity.Tenant;\nimport org.apache.dolphinscheduler.dao.entity.User;\nimport org.apache.dolphinscheduler.dao.entity.WorkflowInstance;\nimport org.apache.dolphinscheduler.dao.mapper.ScheduleMapper;\nimport org.apache.dolphinscheduler.dao.mapper.TenantMapper;\nimport org.apache.dolphinscheduler.dao.mapper.UserMapper;\nimport org.apache.dolphinscheduler.dao.mapper.WorkflowInstanceMapper;\nimport org.apache.dolphinscheduler.plugin.storage.api.StorageOperator;\n\nimport org.apache.commons.collections4.CollectionUtils;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\n\nimport lombok.extern.slf4j.Slf4j;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport com.baomidou.mybatisplus.core.metadata.IPage;\nimport com.baomidou.mybatisplus.extension.plugins.pagination.Page;\n\n@Service\n@Slf4j\npublic class TenantServiceImpl extends BaseServiceImpl implements TenantService {\n\n    @Autowired\n    private TenantMapper tenantMapper;\n\n    @Autowired\n    private WorkflowInstanceMapper workflowInstanceMapper;\n\n    @Autowired\n    private ScheduleMapper scheduleMapper;\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Autowired\n    private QueueService queueService;\n\n    @Autowired(required = false)\n    private StorageOperator storageOperator;\n\n    /**\n     * Check the tenant new object valid or not\n     *\n     * @param tenant The tenant object want to create\n     */\n    private void createTenantValid(Tenant tenant) throws ServiceException {\n        if (StringUtils.isEmpty(tenant.getTenantCode())) {\n            throw new ServiceException(Status.REQUEST_PARAMS_NOT_VALID_ERROR, tenant.getTenantCode());\n        } else if (StringUtils.length(tenant.getTenantCode()) > TENANT_FULL_NAME_MAX_LENGTH) {\n            throw new ServiceException(Status.TENANT_FULL_NAME_TOO_LONG_ERROR);\n        } else if (!RegexUtils.isValidLinuxUserName(tenant.getTenantCode())) {\n            throw new ServiceException(Status.CHECK_OS_TENANT_CODE_ERROR);\n        } else if (checkTenantExists(tenant.getTenantCode())) {\n            throw new ServiceException(Status.OS_TENANT_CODE_EXIST, tenant.getTenantCode());\n        }\n    }\n\n    /**\n     * Check tenant update object valid or not\n     *\n     * @param existsTenant The exists queue object\n     * @param updateTenant The queue object want to update\n     */\n    private void updateTenantValid(Tenant existsTenant, Tenant updateTenant) throws ServiceException {\n        // Check the exists tenant\n        if (Objects.isNull(existsTenant)) {\n            log.error(\"Tenant does not exist.\");\n            throw new ServiceException(Status.TENANT_NOT_EXIST);\n        }\n        // Check the update tenant parameters\n        else if (StringUtils.isEmpty(updateTenant.getTenantCode())) {\n            throw new ServiceException(Status.REQUEST_PARAMS_NOT_VALID_ERROR, updateTenant.getTenantCode());\n        } else if (StringUtils.length(updateTenant.getTenantCode()) > TENANT_FULL_NAME_MAX_LENGTH) {\n            throw new ServiceException(Status.TENANT_FULL_NAME_TOO_LONG_ERROR);\n        } else if (!RegexUtils.isValidLinuxUserName(updateTenant.getTenantCode())) {\n            throw new ServiceException(Status.CHECK_OS_TENANT_CODE_ERROR);\n        } else if (!Objects.equals(existsTenant.getTenantCode(), updateTenant.getTenantCode())\n                && checkTenantExists(updateTenant.getTenantCode())) {\n            throw new ServiceException(Status.OS_TENANT_CODE_EXIST, updateTenant.getTenantCode());\n        }\n    }\n\n    /**\n     * create tenant\n     *\n     * @param loginUser login user\n     * @param tenantCode tenant code\n     * @param queueId queue id\n     * @param desc description\n     * @return create result code\n     */\n    @Override\n    @Transactional(rollbackFor = Exception.class)\n    public Tenant createTenant(User loginUser,\n                               String tenantCode,\n                               int queueId,\n                               String desc) {\n        if (!canOperatorPermissions(loginUser, null, AuthorizationType.TENANT, TENANT_CREATE)) {\n            throw new ServiceException(Status.USER_NO_OPERATION_PERM);\n        }\n        if (checkDescriptionLength(desc)) {\n            throw new ServiceException(Status.DESCRIPTION_TOO_LONG_ERROR);\n        }\n        Tenant tenant = new Tenant(tenantCode, desc, queueId);\n        createTenantValid(tenant);\n        tenantMapper.insert(tenant);\n\n        return tenant;\n    }\n\n    /**\n     * query tenant list paging\n     *\n     * @param loginUser login user\n     * @param searchVal search value\n     * @param pageNo    page number\n     * @param pageSize  page size\n     * @return tenant list page\n     */\n    @Override\n    public PageInfo<Tenant> queryTenantList(User loginUser, String searchVal, Integer pageNo, Integer pageSize) {\n\n        Set<Integer> ids = resourcePermissionCheckService.userOwnedResourceIdsAcquisition(AuthorizationType.TENANT,\n                loginUser.getId(), log);\n        if (CollectionUtils.isEmpty(ids)) {\n            return new PageInfo<>(pageNo, pageSize);\n        }\n        Page<Tenant> page = new Page<>(pageNo, pageSize);\n        IPage<Tenant> tenantPage = tenantMapper.queryTenantPaging(page, new ArrayList<>(ids), searchVal);\n        return PageInfo.of(tenantPage);\n    }\n\n    /**\n     * updateWorkflowInstance tenant\n     *\n     * @param loginUser login user\n     * @param id tenant id\n     * @param tenantCode tenant code\n     * @param queueId queue id\n     * @param desc description\n     * @return update result code\n     * @throws Exception exception\n     */\n    @Override\n    public void updateTenant(User loginUser,\n                             int id,\n                             String tenantCode,\n                             int queueId,\n                             String desc) throws Exception {\n\n        if (!canOperatorPermissions(loginUser, null, AuthorizationType.TENANT, TENANT_UPDATE)) {\n            throw new ServiceException(Status.USER_NO_OPERATION_PERM);\n        }\n        if (checkDescriptionLength(desc)) {\n            throw new ServiceException(Status.DESCRIPTION_TOO_LONG_ERROR);\n        }\n        Tenant updateTenant = new Tenant(id, tenantCode, desc, queueId);\n        Tenant existsTenant = tenantMapper.queryById(id);\n        updateTenantValid(existsTenant, updateTenant);\n\n        updateTenant.setCreateTime(existsTenant.getCreateTime());\n        int update = tenantMapper.updateById(updateTenant);\n        if (update <= 0) {\n            throw new ServiceException(Status.UPDATE_TENANT_ERROR);\n        }\n    }\n\n    /**\n     * delete tenant\n     *\n     * @param loginUser login user\n     * @param id        tenant id\n     * @return delete result code\n     * @throws Exception exception\n     */\n    @Override\n    @Transactional()\n    public void deleteTenantById(User loginUser, int id) throws Exception {\n\n        if (!canOperatorPermissions(loginUser, null, AuthorizationType.TENANT, TENANT_DELETE)) {\n            throw new ServiceException(Status.USER_NO_OPERATION_PERM);\n        }\n\n        Tenant tenant = tenantMapper.queryById(id);\n        if (Objects.isNull(tenant)) {\n            throw new ServiceException(Status.TENANT_NOT_EXIST);\n        }\n\n        List<WorkflowInstance> workflowInstances = getWorkflowInstancesByTenant(tenant);\n        if (CollectionUtils.isNotEmpty(workflowInstances)) {\n            throw new ServiceException(Status.DELETE_TENANT_BY_ID_FAIL, workflowInstances.size());\n        }\n\n        List<Schedule> schedules = scheduleMapper.queryScheduleListByTenant(tenant.getTenantCode());\n        if (CollectionUtils.isNotEmpty(schedules)) {\n            throw new ServiceException(Status.DELETE_TENANT_BY_ID_FAIL_DEFINES, schedules.size());\n        }\n\n        List<User> userList = userMapper.queryUserListByTenant(tenant.getId());\n        if (CollectionUtils.isNotEmpty(userList)) {\n            throw new ServiceException(Status.DELETE_TENANT_BY_ID_FAIL_USERS, userList.size());\n        }\n\n        int delete = tenantMapper.deleteById(id);\n        if (delete <= 0) {\n            throw new ServiceException(Status.DELETE_TENANT_BY_ID_ERROR);\n        }\n\n        workflowInstanceMapper.updateWorkflowInstanceByTenantCode(tenant.getTenantCode(), Constants.DEFAULT);\n    }\n\n    private List<WorkflowInstance> getWorkflowInstancesByTenant(Tenant tenant) {\n        return workflowInstanceMapper.queryByTenantCodeAndStatus(tenant.getTenantCode(),\n                org.apache.dolphinscheduler.service.utils.Constants.NOT_TERMINATED_STATES);\n    }\n\n    /**\n     * query tenant list\n     *\n     * @param loginUser login user\n     * @return tenant list\n     */\n    @Override\n    public List<Tenant> queryTenantList(User loginUser) {\n\n        Set<Integer> ids = resourcePermissionCheckService.userOwnedResourceIdsAcquisition(AuthorizationType.TENANT,\n                loginUser.getId(), log);\n        if (CollectionUtils.isEmpty(ids)) {\n            return Collections.emptyList();\n        }\n        return tenantMapper.selectBatchIds(ids);\n    }\n\n    /**\n     * verify tenant code\n     *\n     * @param tenantCode tenant code\n     * @return true if tenant code can use, otherwise return false\n     */\n    @Override\n    public void verifyTenantCode(String tenantCode) {\n        if (checkTenantExists(tenantCode)) {\n            throw new ServiceException(Status.OS_TENANT_CODE_EXIST, tenantCode);\n        }\n    }\n\n    /**\n     * check tenant exists\n     *\n     * @param tenantCode tenant code\n     * @return ture if the tenant code exists, otherwise return false\n     */\n    private boolean checkTenantExists(String tenantCode) {\n        Boolean existTenant = tenantMapper.existTenant(tenantCode);\n        return Boolean.TRUE.equals(existTenant);\n    }\n\n    /**\n     * query tenant by tenant code\n     *\n     * @param tenantCode tenant code\n     * @return tenant detail information\n     */\n    @Override\n    public Map<String, Object> queryByTenantCode(String tenantCode) {\n        Map<String, Object> result = new HashMap<>();\n        Tenant tenant = tenantMapper.queryByTenantCode(tenantCode);\n        if (tenant != null) {\n            result.put(Constants.DATA_LIST, tenant);\n            putMsg(result, Status.SUCCESS);\n        }\n        return result;\n    }\n\n    /**\n     * Make sure tenant with given name exists, and create the tenant if not exists\n     * ONLY for python gateway server, and should not use this in web ui function\n     *\n     * @param tenantCode tenant code\n     * @param desc The description of tenant object\n     * @param queue The value of queue which current tenant belong\n     * @param queueName The name of queue which current tenant belong\n     * @return Tenant object\n     */\n    @Override\n    public Tenant createTenantIfNotExists(String tenantCode, String desc, String queue, String queueName) {\n        if (checkTenantExists(tenantCode)) {\n            return tenantMapper.queryByTenantCode(tenantCode);\n        }\n        Queue queueObj = queueService.createQueueIfNotExists(queue, queueName);\n        Tenant tenant = new Tenant(tenantCode, desc, queueObj.getId());\n        createTenantValid(tenant);\n        tenantMapper.insert(tenant);\n        return tenant;\n    }\n}\n",
            "role": "user"
        },
        {
            "content": "//dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/impl/UsersServiceImpl.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.dolphinscheduler.api.service.impl;\n\nimport static org.apache.dolphinscheduler.api.constants.ApiFuncIdentificationConstant.USER_MANAGER;\n\nimport org.apache.dolphinscheduler.api.enums.Status;\nimport org.apache.dolphinscheduler.api.exceptions.ServiceException;\nimport org.apache.dolphinscheduler.api.service.MetricsCleanUpService;\nimport org.apache.dolphinscheduler.api.service.SessionService;\nimport org.apache.dolphinscheduler.api.service.UsersService;\nimport org.apache.dolphinscheduler.api.utils.CheckUtils;\nimport org.apache.dolphinscheduler.api.utils.PageInfo;\nimport org.apache.dolphinscheduler.api.utils.Result;\nimport org.apache.dolphinscheduler.common.constants.Constants;\nimport org.apache.dolphinscheduler.common.enums.AuthorizationType;\nimport org.apache.dolphinscheduler.common.enums.Flag;\nimport org.apache.dolphinscheduler.common.enums.UserType;\nimport org.apache.dolphinscheduler.common.utils.EncryptionUtils;\nimport org.apache.dolphinscheduler.dao.entity.AlertGroup;\nimport org.apache.dolphinscheduler.dao.entity.DatasourceUser;\nimport org.apache.dolphinscheduler.dao.entity.K8sNamespaceUser;\nimport org.apache.dolphinscheduler.dao.entity.Project;\nimport org.apache.dolphinscheduler.dao.entity.ProjectUser;\nimport org.apache.dolphinscheduler.dao.entity.Tenant;\nimport org.apache.dolphinscheduler.dao.entity.User;\nimport org.apache.dolphinscheduler.dao.mapper.AccessTokenMapper;\nimport org.apache.dolphinscheduler.dao.mapper.AlertGroupMapper;\nimport org.apache.dolphinscheduler.dao.mapper.DataSourceUserMapper;\nimport org.apache.dolphinscheduler.dao.mapper.K8sNamespaceUserMapper;\nimport org.apache.dolphinscheduler.dao.mapper.ProjectMapper;\nimport org.apache.dolphinscheduler.dao.mapper.ProjectUserMapper;\nimport org.apache.dolphinscheduler.dao.mapper.TenantMapper;\nimport org.apache.dolphinscheduler.dao.mapper.UserMapper;\nimport org.apache.dolphinscheduler.plugin.storage.api.StorageOperator;\n\nimport org.apache.commons.collections4.CollectionUtils;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.io.IOException;\nimport java.text.MessageFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.TimeZone;\nimport java.util.stream.Collectors;\n\nimport lombok.extern.slf4j.Slf4j;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport com.baomidou.mybatisplus.core.metadata.IPage;\nimport com.baomidou.mybatisplus.extension.plugins.pagination.Page;\n\n/**\n * users service impl\n */\n@Service\n@Slf4j\npublic class UsersServiceImpl extends BaseServiceImpl implements UsersService {\n\n    @Autowired\n    private AccessTokenMapper accessTokenMapper;\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Autowired\n    private TenantMapper tenantMapper;\n\n    @Autowired\n    private ProjectUserMapper projectUserMapper;\n\n    @Autowired\n    private DataSourceUserMapper datasourceUserMapper;\n\n    @Autowired\n    private AlertGroupMapper alertGroupMapper;\n\n    @Autowired\n    private ProjectMapper projectMapper;\n\n    @Autowired(required = false)\n    private StorageOperator storageOperator;\n\n    @Autowired\n    private K8sNamespaceUserMapper k8sNamespaceUserMapper;\n\n    @Autowired\n    private MetricsCleanUpService metricsCleanUpService;\n\n    @Autowired\n    private SessionService sessionService;\n\n    /**\n     * create user, only system admin have permission\n     *\n     * @param loginUser    login user\n     * @param userName     user name\n     * @param userPassword user password\n     * @param email        email\n     * @param tenantId     tenant id\n     * @param phone        phone\n     * @param queue        queue\n     * @return create result code\n     * @throws Exception exception\n     */\n    @Override\n    @Transactional(rollbackFor = Exception.class)\n    public Map<String, Object> createUser(User loginUser,\n                                          String userName,\n                                          String userPassword,\n                                          String email,\n                                          int tenantId,\n                                          String phone,\n                                          String queue,\n                                          int state) throws Exception {\n        Map<String, Object> result = new HashMap<>();\n\n        // check all user params\n        String msg = this.checkUserParams(userName, userPassword, email, phone);\n        if (resourcePermissionCheckService.functionDisabled()) {\n            putMsg(result, Status.FUNCTION_DISABLED, msg);\n            return result;\n        }\n\n        if (!isAdmin(loginUser)) {\n            putMsg(result, Status.USER_NO_OPERATION_PERM);\n            return result;\n        }\n\n        if (!StringUtils.isEmpty(msg)) {\n            putMsg(result, Status.REQUEST_PARAMS_NOT_VALID_ERROR, msg);\n            return result;\n        }\n\n        if (!checkTenantExists(tenantId)) {\n            log.warn(\"Tenant does not exist, tenantId:{}.\", tenantId);\n            putMsg(result, Status.TENANT_NOT_EXIST);\n            return result;\n        }\n\n        User user = createUser(userName, userPassword, email, tenantId, phone, queue, state);\n\n        log.info(\"User is created and id is {}.\", user.getId());\n        result.put(Constants.DATA_LIST, user);\n        putMsg(result, Status.SUCCESS);\n        return result;\n    }\n\n    @Override\n    @Transactional\n    public User createUser(String userName,\n                           String userPassword,\n                           String email,\n                           int tenantId,\n                           String phone,\n                           String queue,\n                           int state) {\n        User user = new User();\n        Date now = new Date();\n\n        user.setUserName(userName);\n        user.setUserPassword(EncryptionUtils.getMd5(userPassword));\n        user.setEmail(email);\n        user.setTenantId(tenantId);\n        user.setPhone(phone);\n        user.setState(state);\n        // create general users, administrator users are currently built-in\n        user.setUserType(UserType.GENERAL_USER);\n        user.setCreateTime(now);\n        user.setUpdateTime(now);\n        if (StringUtils.isEmpty(queue)) {\n            queue = \"\";\n        }\n        user.setQueue(queue);\n\n        // save user\n        userMapper.insert(user);\n        return user;\n    }\n\n    /***\n     * create User for ldapCasdoor SSO and OAuth2.0 login\n     */\n    @Override\n    @Transactional\n    public User createUser(UserType userType, String userId, String email) {\n        User user = new User();\n        Date now = new Date();\n\n        user.setUserName(userId);\n        user.setEmail(email);\n        // create general users, administrator users are currently built-in\n        user.setUserType(userType);\n        user.setCreateTime(now);\n        user.setUpdateTime(now);\n        user.setTenantId(-1);\n        user.setQueue(\"\");\n        user.setState(Flag.YES.getCode());\n\n        // save user\n        userMapper.insert(user);\n        return user;\n    }\n\n    /**\n     * get user by user name\n     *\n     * @param userName user name\n     * @return exist user or null\n     */\n    @Override\n    public User getUserByUserName(String userName) {\n        return userMapper.queryByUserNameAccurately(userName);\n    }\n\n    /**\n     * query user by id\n     *\n     * @param id id\n     * @return user info\n     */\n    @Override\n    public User queryUser(int id) {\n        return userMapper.selectById(id);\n    }\n\n    @Override\n    public List<User> queryUser(List<Integer> ids) {\n        if (CollectionUtils.isEmpty(ids)) {\n            return new ArrayList<>();\n        }\n        return userMapper.selectByIds(ids);\n    }\n\n    /**\n     * query user\n     *\n     * @param name name\n     * @return user info\n     */\n    @Override\n    public User queryUser(String name) {\n        return userMapper.queryByUserNameAccurately(name);\n    }\n\n    /**\n     * query user\n     *\n     * @param name     name\n     * @param password password\n     * @return user info\n     */\n    @Override\n    public User queryUser(String name, String password) {\n        String md5 = EncryptionUtils.getMd5(password);\n        return userMapper.queryUserByNamePassword(name, md5);\n    }\n\n    /**\n     * get user id by user name\n     *\n     * @param name user name\n     * @return if name empty 0, user not exists -1, user exist user id\n     */\n    @Override\n    public int getUserIdByName(String name) {\n        // executor name query\n        int executorId = 0;\n        if (StringUtils.isNotEmpty(name)) {\n            User executor = queryUser(name);\n            if (null != executor) {\n                executorId = executor.getId();\n            } else {\n                executorId = -1;\n            }\n        }\n\n        return executorId;\n    }\n\n    /**\n     * query user list\n     *\n     * @param loginUser login user\n     * @param pageNo    page number\n     * @param searchVal search value\n     * @param pageSize  page size\n     * @return user list page\n     */\n    @Override\n    public Result<Object> queryUserList(User loginUser, String searchVal, Integer pageNo, Integer pageSize) {\n        Result<Object> result = new Result<>();\n        if (resourcePermissionCheckService.functionDisabled()) {\n            putMsg(result, Status.FUNCTION_DISABLED);\n            return result;\n        }\n        if (!isAdmin(loginUser)) {\n            log.warn(\"User does not have permission for this feature, userId:{}, userName:{}.\", loginUser.getId(),\n                    loginUser.getUserName());\n            putMsg(result, Status.USER_NO_OPERATION_PERM);\n            return result;\n        }\n\n        Page<User> page = new Page<>(pageNo, pageSize);\n\n        IPage<User> scheduleList = userMapper.queryUserPaging(page, searchVal);\n\n        PageInfo<User> pageInfo = new PageInfo<>(pageNo, pageSize);\n        pageInfo.setTotal((int) scheduleList.getTotal());\n        pageInfo.setTotalList(scheduleList.getRecords());\n        result.setData(pageInfo);\n        putMsg(result, Status.SUCCESS);\n\n        return result;\n    }\n\n    @Override\n    @Transactional\n    public User updateUser(User loginUser,\n                           Integer userId,\n                           String userName,\n                           String userPassword,\n                           String email,\n                           Integer tenantId,\n                           String phone,\n                           String queue,\n                           int state,\n                           String timeZone) {\n        if (resourcePermissionCheckService.functionDisabled()) {\n            throw new ServiceException(Status.FUNCTION_DISABLED);\n        }\n        if (!canOperator(loginUser, userId)) {\n            throw new ServiceException(Status.USER_NO_OPERATION_PERM);\n        }\n        User user = userMapper.selectById(userId);\n        if (user == null) {\n            throw new ServiceException(Status.USER_NOT_EXIST, userId);\n        }\n\n        // non-admin should not modify tenantId and queue\n        if (!isAdmin(loginUser)) {\n            if (tenantId != null && user.getTenantId() != tenantId) {\n                throw new ServiceException(Status.USER_NO_OPERATION_PERM);\n            }\n            if (StringUtils.isNotEmpty(queue) && !StringUtils.equals(queue, user.getQueue())) {\n                throw new ServiceException(Status.USER_NO_OPERATION_PERM);\n            }\n        }\n\n        if (StringUtils.isNotEmpty(userName)) {\n\n            if (!CheckUtils.checkUserName(userName)) {\n                throw new ServiceException(Status.REQUEST_PARAMS_NOT_VALID_ERROR, userName);\n            }\n\n            // todo: use the db unique index\n            User tempUser = userMapper.queryByUserNameAccurately(userName);\n            if (tempUser != null && !userId.equals(tempUser.getId())) {\n                throw new ServiceException(Status.USER_NAME_EXIST);\n            }\n            user.setUserName(userName);\n        }\n\n        if (StringUtils.isNotEmpty(userPassword)) {\n            if (!CheckUtils.checkPasswordLength(userPassword)) {\n                throw new ServiceException(Status.USER_PASSWORD_LENGTH_ERROR);\n            }\n            user.setUserPassword(EncryptionUtils.getMd5(userPassword));\n            sessionService.expireSession(user.getId());\n        }\n\n        if (StringUtils.isNotEmpty(email)) {\n            if (!CheckUtils.checkEmail(email)) {\n                throw new ServiceException(Status.REQUEST_PARAMS_NOT_VALID_ERROR, email);\n            }\n            user.setEmail(email);\n        }\n\n        if (StringUtils.isNotEmpty(phone) && !CheckUtils.checkPhone(phone)) {\n            throw new ServiceException(Status.REQUEST_PARAMS_NOT_VALID_ERROR, phone);\n        }\n\n        if (state == 0 && user.getState() != state && Objects.equals(loginUser.getId(), user.getId())) {\n            throw new ServiceException(Status.NOT_ALLOW_TO_DISABLE_OWN_ACCOUNT);\n        }\n\n        if (StringUtils.isNotEmpty(timeZone)) {\n            if (!CheckUtils.checkTimeZone(timeZone)) {\n                throw new ServiceException(Status.TIME_ZONE_ILLEGAL, timeZone);\n            }\n            user.setTimeZone(timeZone);\n        }\n\n        user.setPhone(phone);\n        user.setQueue(queue);\n        user.setState(state);\n        user.setUpdateTime(new Date());\n        user.setTenantId(tenantId);\n        // updateWorkflowInstance user\n        if (userMapper.updateById(user) <= 0) {\n            throw new ServiceException(Status.UPDATE_USER_ERROR);\n        }\n        return user;\n    }\n\n    /**\n     * delete user\n     *\n     * @param loginUser login user\n     * @param id        user id\n     * @return delete result code\n     * @throws Exception exception when operate hdfs\n     */\n    @Override\n    @Transactional\n    public Map<String, Object> deleteUserById(User loginUser, int id) throws IOException {\n        Map<String, Object> result = new HashMap<>();\n        if (resourcePermissionCheckService.functionDisabled()) {\n            putMsg(result, Status.FUNCTION_DISABLED);\n            return result;\n        }\n        // only admin can operate\n        if (!isAdmin(loginUser)) {\n            log.warn(\"User does not have permission for this feature, userId:{}, userName:{}.\", loginUser.getId(),\n                    loginUser.getUserName());\n            putMsg(result, Status.USER_NO_OPERATION_PERM, id);\n            return result;\n        }\n        // check exist\n        User tempUser = userMapper.selectById(id);\n        if (tempUser == null) {\n            log.error(\"User does not exist, userId:{}.\", id);\n            putMsg(result, Status.USER_NOT_EXIST, id);\n            return result;\n        }\n        // check if is a project owner\n        List<Project> projects = projectMapper.queryProjectCreatedByUser(id);\n        if (CollectionUtils.isNotEmpty(projects)) {\n            String projectNames = projects.stream().map(Project::getName).collect(Collectors.joining(\",\"));\n            putMsg(result, Status.TRANSFORM_PROJECT_OWNERSHIP, projectNames);\n            log.warn(\"Please transfer the project ownership before deleting the user, userId:{}, projects:{}.\", id,\n                    projectNames);\n            return result;\n        }\n        // delete user\n        userMapper.queryTenantCodeByUserId(id);\n\n        accessTokenMapper.deleteAccessTokenByUserId(id);\n        sessionService.expireSession(id);\n\n        if (userMapper.deleteById(id) > 0) {\n            metricsCleanUpService.cleanUpApiResponseTimeMetricsByUserId(id);\n            log.info(\"User is deleted and id is :{}.\", id);\n            putMsg(result, Status.SUCCESS);\n            return result;\n        } else {\n            log.error(\"User delete error, userId:{}.\", id);\n            putMsg(result, Status.DELETE_USER_BY_ID_ERROR);\n            return result;\n        }\n    }\n\n    /**\n     * revoke the project permission for specified user by id\n     *\n     * @param loginUser  Login user\n     * @param userId     User id\n     * @param projectIds project id array\n     * @return\n     */\n    @Override\n    @Transactional(rollbackFor = RuntimeException.class)\n    public Map<String, Object> revokeProjectById(User loginUser, int userId, String projectIds) {\n        Map<String, Object> result = new HashMap<>();\n        result.put(Constants.STATUS, false);\n\n        if (resourcePermissionCheckService.functionDisabled()) {\n            putMsg(result, Status.FUNCTION_DISABLED);\n            return result;\n        }\n        // 1. only admin can operate\n        if (this.check(result, !this.isAdmin(loginUser), Status.USER_NO_OPERATION_PERM)) {\n            return result;\n        }\n\n        // 2. check if user is existed\n        User user = this.userMapper.selectById(userId);\n        if (user == null) {\n            this.putMsg(result, Status.USER_NOT_EXIST, userId);\n            return result;\n        }\n\n        Arrays.stream(projectIds.split(\",\")).distinct().forEach(projectId -> {\n            // 3. check if project is existed\n            Project project = this.projectMapper.queryDetailById(Integer.parseInt(projectId));\n            if (project == null) {\n                this.putMsg(result, Status.PROJECT_NOT_FOUND, Integer.parseInt(projectId));\n            } else {\n                // 4. delete the relationship between project and user\n                this.projectUserMapper.deleteProjectRelation(project.getId(), user.getId());\n            }\n        });\n\n        this.putMsg(result, Status.SUCCESS);\n        return result;\n    }\n\n    /**\n     * grant project with read permission\n     *\n     * @param loginUser  login user\n     * @param userId     user id\n     * @param projectIds project id array\n     * @return grant result code\n     */\n    @Override\n    @Transactional(rollbackFor = RuntimeException.class)\n    public Map<String, Object> grantProjectWithReadPerm(User loginUser, int userId, String projectIds) {\n        Map<String, Object> result = new HashMap<>();\n        result.put(Constants.STATUS, false);\n\n        if (resourcePermissionCheckService.functionDisabled()) {\n            putMsg(result, Status.FUNCTION_DISABLED);\n            return result;\n        }\n\n        if (!isAdmin(loginUser)) {\n            putMsg(result, Status.NO_CURRENT_OPERATING_PERMISSION);\n            return result;\n        }\n\n        // check exist\n        User tempUser = userMapper.selectById(userId);\n        if (tempUser == null) {\n            putMsg(result, Status.USER_NOT_EXIST, userId);\n            return result;\n        }\n\n        if (check(result, StringUtils.isEmpty(projectIds), Status.SUCCESS)) {\n            return result;\n        }\n        Arrays.stream(projectIds.split(Constants.COMMA)).distinct().forEach(projectId -> {\n            ProjectUser projectUserOld = projectUserMapper.queryProjectRelation(Integer.parseInt(projectId), userId);\n            if (projectUserOld != null) {\n                projectUserMapper.deleteProjectRelation(Integer.parseInt(projectId), userId);\n            }\n            Date now = new Date();\n            ProjectUser projectUser = new ProjectUser();\n            projectUser.setUserId(userId);\n            projectUser.setProjectId(Integer.parseInt(projectId));\n            projectUser.setPerm(Constants.READ_PERMISSION);\n            projectUser.setCreateTime(now);\n            projectUser.setUpdateTime(now);\n            projectUserMapper.insert(projectUser);\n        });\n        putMsg(result, Status.SUCCESS);\n\n        return result;\n    }\n\n    /**\n     * grant project\n     *\n     * @param loginUser  login user\n     * @param userId     user id\n     * @param projectIds project id array\n     * @return grant result code\n     */\n    @Override\n    @Transactional\n    public Map<String, Object> grantProject(User loginUser, int userId, String projectIds) {\n        Map<String, Object> result = new HashMap<>();\n        result.put(Constants.STATUS, false);\n\n        if (resourcePermissionCheckService.functionDisabled()) {\n            putMsg(result, Status.FUNCTION_DISABLED);\n            return result;\n        }\n\n        // check exist\n        User tempUser = userMapper.selectById(userId);\n        if (tempUser == null) {\n            log.error(\"User does not exist, userId:{}.\", userId);\n            putMsg(result, Status.USER_NOT_EXIST, userId);\n            return result;\n        }\n\n        if (!isAdmin(loginUser)) {\n            putMsg(result, Status.NO_CURRENT_OPERATING_PERMISSION);\n            return result;\n        }\n\n        if (check(result, StringUtils.isEmpty(projectIds), Status.SUCCESS)) {\n            log.warn(\"Parameter projectIds is empty.\");\n            return result;\n        }\n        Arrays.stream(projectIds.split(\",\")).distinct().forEach(projectId -> {\n            ProjectUser projectUserOld = projectUserMapper.queryProjectRelation(Integer.parseInt(projectId), userId);\n            if (projectUserOld != null) {\n                projectUserMapper.deleteProjectRelation(Integer.parseInt(projectId), userId);\n            }\n            Date now = new Date();\n            ProjectUser projectUser = new ProjectUser();\n            projectUser.setUserId(userId);\n            projectUser.setProjectId(Integer.parseInt(projectId));\n            projectUser.setPerm(Constants.AUTHORIZE_WRITABLE_PERM);\n            projectUser.setCreateTime(now);\n            projectUser.setUpdateTime(now);\n            projectUserMapper.insert(projectUser);\n        });\n        putMsg(result, Status.SUCCESS);\n\n        return result;\n    }\n\n    /**\n     * grant project by code\n     *\n     * @param loginUser   login user\n     * @param userId      user id\n     * @param projectCode project code\n     * @return grant result code\n     */\n    @Override\n    public Map<String, Object> grantProjectByCode(final User loginUser, final int userId, final long projectCode) {\n        Map<String, Object> result = new HashMap<>();\n        result.put(Constants.STATUS, false);\n\n        if (resourcePermissionCheckService.functionDisabled()) {\n            putMsg(result, Status.FUNCTION_DISABLED);\n            return result;\n        }\n\n        // 1. check if user is existed\n        User tempUser = this.userMapper.selectById(userId);\n        if (tempUser == null) {\n            log.error(\"User does not exist, userId:{}.\", userId);\n            this.putMsg(result, Status.USER_NOT_EXIST, userId);\n            return result;\n        }\n\n        // 2. check if project is existed\n        Project project = this.projectMapper.queryByCode(projectCode);\n        if (project == null) {\n            log.error(\"Project does not exist, projectCode:{}.\", projectCode);\n            this.putMsg(result, Status.PROJECT_NOT_FOUND, projectCode);\n            return result;\n        }\n\n        // 3. only project owner can operate\n        if (!this.canOperator(loginUser, project.getUserId())) {\n            log.warn(\"User does not have permission for project, userId:{}, userName:{}, projectCode:{}.\",\n                    loginUser.getId(), loginUser.getUserName(), projectCode);\n            this.putMsg(result, Status.USER_NO_OPERATION_PERM);\n            return result;\n        }\n\n        // 4. maintain the relationship between project and user if not exists\n        ProjectUser projectUser = projectUserMapper.queryProjectRelation(project.getId(), userId);\n        if (projectUser == null) {\n            Date today = new Date();\n            projectUser = new ProjectUser();\n            projectUser.setUserId(userId);\n            projectUser.setProjectId(project.getId());\n            projectUser.setPerm(Constants.AUTHORIZE_WRITABLE_PERM);\n            projectUser.setCreateTime(today);\n            projectUser.setUpdateTime(today);\n            this.projectUserMapper.insert(projectUser);\n        }\n        log.info(\"User is granted permission for projects, userId:{}, projectCode:{}.\", userId, projectCode);\n        this.putMsg(result, Status.SUCCESS);\n        return result;\n    }\n\n    /**\n     * revoke the project permission for specified user.\n     *\n     * @param loginUser   Login user\n     * @param userId      User id\n     * @param projectCode Project Code\n     * @return\n     */\n    @Override\n    public Map<String, Object> revokeProject(User loginUser, int userId, long projectCode) {\n        Map<String, Object> result = new HashMap<>();\n        result.put(Constants.STATUS, false);\n\n        if (resourcePermissionCheckService.functionDisabled()) {\n            putMsg(result, Status.FUNCTION_DISABLED);\n            return result;\n        }\n        // 1. only admin can operate\n        if (this.check(result, !this.isAdmin(loginUser), Status.USER_NO_OPERATION_PERM)) {\n            log.warn(\"Only admin can revoke the project permission.\");\n            return result;\n        }\n\n        // 2. check if user is existed\n        User user = this.userMapper.selectById(userId);\n        if (user == null) {\n            log.error(\"User does not exist, userId:{}.\", userId);\n            this.putMsg(result, Status.USER_NOT_EXIST, userId);\n            return result;\n        }\n\n        // 3. check if project is existed\n        Project project = this.projectMapper.queryByCode(projectCode);\n        if (project == null) {\n            log.error(\"Project does not exist, projectCode:{}.\", projectCode);\n            this.putMsg(result, Status.PROJECT_NOT_FOUND, projectCode);\n            return result;\n        }\n\n        // 4. delete th relationship between project and user\n        this.projectUserMapper.deleteProjectRelation(project.getId(), user.getId());\n        log.info(\"User is revoked permission for projects, userId:{}, projectCode:{}.\", userId, projectCode);\n        this.putMsg(result, Status.SUCCESS);\n        return result;\n    }\n\n    /**\n     * grant namespace\n     *\n     * @param loginUser    login user\n     * @param userId       user id\n     * @param namespaceIds namespace id array\n     * @return grant result code\n     */\n    @Override\n    @Transactional\n    public Map<String, Object> grantNamespaces(User loginUser, int userId, String namespaceIds) {\n        Map<String, Object> result = new HashMap<>();\n        result.put(Constants.STATUS, false);\n        if (resourcePermissionCheckService.functionDisabled()) {\n            putMsg(result, Status.FUNCTION_DISABLED);\n            return result;\n        }\n        // only admin can operate\n        if (this.check(result, !this.isAdmin(loginUser), Status.USER_NO_OPERATION_PERM)) {\n            log.warn(\"Only admin can grant namespaces.\");\n            return result;\n        }\n\n        // check exist\n        User tempUser = userMapper.selectById(userId);\n        if (tempUser == null) {\n            log.error(\"User does not exist, userId:{}.\", userId);\n            putMsg(result, Status.USER_NOT_EXIST, userId);\n            return result;\n        }\n\n        k8sNamespaceUserMapper.deleteNamespaceRelation(0, userId);\n        if (StringUtils.isNotEmpty(namespaceIds)) {\n            String[] namespaceIdArr = namespaceIds.split(\",\");\n            for (String namespaceId : namespaceIdArr) {\n                Date now = new Date();\n                K8sNamespaceUser namespaceUser = new K8sNamespaceUser();\n                namespaceUser.setUserId(userId);\n                namespaceUser.setNamespaceId(Integer.parseInt(namespaceId));\n                namespaceUser.setPerm(7);\n                namespaceUser.setCreateTime(now);\n                namespaceUser.setUpdateTime(now);\n                k8sNamespaceUserMapper.insert(namespaceUser);\n            }\n        }\n\n        log.info(\"User is granted permission for namespace, userId:{}.\", tempUser.getId());\n\n        putMsg(result, Status.SUCCESS);\n\n        return result;\n    }\n\n    /**\n     * grant datasource\n     *\n     * @param loginUser     login user\n     * @param userId        user id\n     * @param datasourceIds data source id array\n     * @return grant result code\n     */\n    @Override\n    @Transactional\n    public Map<String, Object> grantDataSource(User loginUser, int userId, String datasourceIds) {\n        Map<String, Object> result = new HashMap<>();\n        result.put(Constants.STATUS, false);\n\n        if (resourcePermissionCheckService.functionDisabled()) {\n            putMsg(result, Status.FUNCTION_DISABLED);\n            return result;\n        }\n        // only admin can operate\n        if (this.check(result, !this.isAdmin(loginUser), Status.USER_NO_OPERATION_PERM)) {\n            log.warn(\"Only admin can grant datasource.\");\n            return result;\n        }\n        User user = userMapper.selectById(userId);\n        if (user == null) {\n            putMsg(result, Status.USER_NOT_EXIST, userId);\n            return result;\n        }\n\n        datasourceUserMapper.deleteByUserId(userId);\n\n        if (check(result, StringUtils.isEmpty(datasourceIds), Status.SUCCESS)) {\n            return result;\n        }\n\n        String[] datasourceIdArr = datasourceIds.split(\",\");\n\n        for (String datasourceId : datasourceIdArr) {\n            Date now = new Date();\n\n            DatasourceUser datasourceUser = new DatasourceUser();\n            datasourceUser.setUserId(userId);\n            datasourceUser.setDatasourceId(Integer.parseInt(datasourceId));\n            datasourceUser.setPerm(Constants.AUTHORIZE_WRITABLE_PERM);\n            datasourceUser.setCreateTime(now);\n            datasourceUser.setUpdateTime(now);\n            datasourceUserMapper.insert(datasourceUser);\n        }\n\n        putMsg(result, Status.SUCCESS);\n\n        return result;\n    }\n\n    /**\n     * query user info\n     *\n     * @param loginUser login user\n     * @return user info\n     */\n    @Override\n    public Map<String, Object> getUserInfo(User loginUser) {\n\n        Map<String, Object> result = new HashMap<>();\n\n        if (resourcePermissionCheckService.functionDisabled()) {\n            putMsg(result, Status.FUNCTION_DISABLED);\n            return result;\n        }\n        User user = null;\n        if (loginUser.getUserType() == UserType.ADMIN_USER) {\n            user = loginUser;\n        } else {\n            user = userMapper.queryDetailsById(loginUser.getId());\n\n            List<AlertGroup> alertGroups = alertGroupMapper.queryByUserId(loginUser.getId());\n\n            StringBuilder sb = new StringBuilder();\n\n            if (alertGroups != null && !alertGroups.isEmpty()) {\n                for (int i = 0; i < alertGroups.size() - 1; i++) {\n                    sb.append(alertGroups.get(i).getGroupName()).append(\",\");\n                }\n                sb.append(alertGroups.get(alertGroups.size() - 1));\n                user.setAlertGroup(sb.toString());\n            }\n        }\n\n        Tenant tenant = tenantMapper.selectById(user.getTenantId());\n        if (tenant != null) {\n            user.setTenantCode(tenant.getTenantCode());\n        }\n\n        // add system default timezone if not user timezone\n        if (StringUtils.isEmpty(user.getTimeZone())) {\n            user.setTimeZone(TimeZone.getDefault().toZoneId().getId());\n        }\n\n        // remove password\n        user.setUserPassword(null);\n\n        result.put(Constants.DATA_LIST, user);\n\n        putMsg(result, Status.SUCCESS);\n        return result;\n    }\n\n    /**\n     * query user list\n     *\n     * @param loginUser login user\n     * @return user list\n     */\n    @Override\n    public Map<String, Object> queryAllGeneralUsers(User loginUser) {\n        Map<String, Object> result = new HashMap<>();\n        if (resourcePermissionCheckService.functionDisabled()) {\n            putMsg(result, Status.FUNCTION_DISABLED);\n            return result;\n        }\n        // only admin can operate\n        if (check(result, !isAdmin(loginUser), Status.USER_NO_OPERATION_PERM)) {\n            log.warn(\"Only admin can query all general users.\");\n            return result;\n        }\n\n        List<User> userList = userMapper.queryAllGeneralUser();\n        result.put(Constants.DATA_LIST, userList);\n        putMsg(result, Status.SUCCESS);\n\n        return result;\n    }\n\n    /**\n     * query user list\n     *\n     * @param loginUser login user\n     * @return user list\n     */\n    @Override\n    public Map<String, Object> queryUserList(User loginUser) {\n        Map<String, Object> result = new HashMap<>();\n        // only admin can operate\n        if (!canOperatorPermissions(loginUser, null, AuthorizationType.ACCESS_TOKEN, USER_MANAGER)) {\n            putMsg(result, Status.USER_NO_OPERATION_PERM);\n            return result;\n        }\n        List<User> userList = userMapper.queryEnabledUsers();\n        result.put(Constants.DATA_LIST, userList);\n        putMsg(result, Status.SUCCESS);\n\n        return result;\n    }\n\n    /**\n     * verify user name exists\n     *\n     * @param userName user name\n     * @return true if user name not exists, otherwise return false\n     */\n    @Override\n    public Result<Object> verifyUserName(String userName) {\n\n        Result<Object> result = new Result<>();\n        User user = userMapper.queryByUserNameAccurately(userName);\n        if (user != null) {\n            putMsg(result, Status.USER_NAME_EXIST);\n        } else {\n            putMsg(result, Status.SUCCESS);\n        }\n\n        return result;\n    }\n\n    /**\n     * unauthorized user\n     *\n     * @param loginUser    login user\n     * @param alertgroupId alert group id\n     * @return unauthorize result code\n     */\n    @Override\n    public Map<String, Object> unauthorizedUser(User loginUser, Integer alertgroupId) {\n\n        Map<String, Object> result = new HashMap<>();\n        if (resourcePermissionCheckService.functionDisabled()) {\n            putMsg(result, Status.FUNCTION_DISABLED);\n            return result;\n        }\n        // only admin can operate\n        if (check(result, !isAdmin(loginUser), Status.USER_NO_OPERATION_PERM)) {\n            log.warn(\"Only admin can deauthorize user.\");\n            return result;\n        }\n\n        List<User> userList = userMapper.selectList(null);\n        List<User> resultUsers = new ArrayList<>();\n        Set<User> userSet = null;\n        if (userList != null && !userList.isEmpty()) {\n            userSet = new HashSet<>(userList);\n\n            List<User> authedUserList = userMapper.queryUserListByAlertGroupId(alertgroupId);\n\n            Set<User> authedUserSet = null;\n            if (authedUserList != null && !authedUserList.isEmpty()) {\n                authedUserSet = new HashSet<>(authedUserList);\n                userSet.removeAll(authedUserSet);\n            }\n            resultUsers = new ArrayList<>(userSet);\n        }\n        result.put(Constants.DATA_LIST, resultUsers);\n        putMsg(result, Status.SUCCESS);\n\n        return result;\n    }\n\n    /**\n     * authorized user\n     *\n     * @param loginUser    login user\n     * @param alertGroupId alert group id\n     * @return authorized result code\n     */\n    @Override\n    public Map<String, Object> authorizedUser(User loginUser, Integer alertGroupId) {\n        Map<String, Object> result = new HashMap<>();\n        if (resourcePermissionCheckService.functionDisabled()) {\n            putMsg(result, Status.FUNCTION_DISABLED);\n            return result;\n        }\n        // only admin can operate\n        if (check(result, !isAdmin(loginUser), Status.USER_NO_OPERATION_PERM)) {\n            log.warn(\"Only admin can authorize user.\");\n            return result;\n        }\n        List<User> userList = userMapper.queryUserListByAlertGroupId(alertGroupId);\n        result.put(Constants.DATA_LIST, userList);\n        putMsg(result, Status.SUCCESS);\n\n        return result;\n    }\n\n    /**\n     * @param tenantId tenant id\n     * @return true if tenant exists, otherwise return false\n     */\n    private boolean checkTenantExists(int tenantId) {\n        return tenantMapper.queryById(tenantId) != null;\n    }\n\n    /**\n     * @return if check failed return the field, otherwise return null\n     */\n    private String checkUserParams(String userName, String password, String email, String phone) {\n\n        String msg = null;\n        if (!CheckUtils.checkUserName(userName)) {\n            log.warn(\"Parameter userName check failed.\");\n            msg = userName;\n        } else if (!CheckUtils.checkPassword(password)) {\n            log.warn(\"Parameter password check failed.\");\n            msg = password;\n        } else if (!CheckUtils.checkEmail(email)) {\n            log.warn(\"Parameter email check failed.\");\n            msg = email;\n        } else if (!CheckUtils.checkPhone(phone)) {\n            log.warn(\"Parameter phone check failed.\");\n            msg = phone;\n        }\n\n        return msg;\n    }\n\n    /**\n     * registry user, default state is 0, default tenant_id is 1, no phone, no queue\n     *\n     * @param userName       user name\n     * @param userPassword   user password\n     * @param repeatPassword repeat password\n     * @param email          email\n     * @return registry result code\n     * @throws Exception exception\n     */\n    @Override\n    @Transactional\n    public Map<String, Object> registerUser(String userName, String userPassword, String repeatPassword, String email) {\n        Map<String, Object> result = new HashMap<>();\n\n        // check user params\n        String msg = this.checkUserParams(userName, userPassword, email, \"\");\n        if (resourcePermissionCheckService.functionDisabled()) {\n            putMsg(result, Status.FUNCTION_DISABLED);\n            return result;\n        }\n        if (!StringUtils.isEmpty(msg)) {\n            putMsg(result, Status.REQUEST_PARAMS_NOT_VALID_ERROR, msg);\n            return result;\n        }\n\n        if (!userPassword.equals(repeatPassword)) {\n            putMsg(result, Status.REQUEST_PARAMS_NOT_VALID_ERROR, \"two passwords are not same\");\n            return result;\n        }\n        User user = createUser(userName, userPassword, email, -1, \"\", \"\", Flag.NO.ordinal());\n        putMsg(result, Status.SUCCESS);\n        result.put(Constants.DATA_LIST, user);\n        return result;\n    }\n\n    /**\n     * activate user, only system admin have permission, change user state code 0 to 1\n     *\n     * @param loginUser login user\n     * @param userName  user name\n     * @return create result code\n     */\n    @Override\n    public Map<String, Object> activateUser(User loginUser, String userName) {\n        Map<String, Object> result = new HashMap<>();\n        result.put(Constants.STATUS, false);\n        if (resourcePermissionCheckService.functionDisabled()) {\n            putMsg(result, Status.FUNCTION_DISABLED);\n            return result;\n        }\n        if (!isAdmin(loginUser)) {\n            putMsg(result, Status.USER_NO_OPERATION_PERM);\n            return result;\n        }\n\n        if (!CheckUtils.checkUserName(userName)) {\n            putMsg(result, Status.REQUEST_PARAMS_NOT_VALID_ERROR, userName);\n            return result;\n        }\n\n        User user = userMapper.queryByUserNameAccurately(userName);\n\n        if (user == null) {\n            putMsg(result, Status.USER_NOT_EXIST, userName);\n            return result;\n        }\n\n        if (user.getState() != Flag.NO.ordinal()) {\n            putMsg(result, Status.REQUEST_PARAMS_NOT_VALID_ERROR, userName);\n            return result;\n        }\n\n        user.setState(Flag.YES.ordinal());\n        Date now = new Date();\n        user.setUpdateTime(now);\n        userMapper.updateById(user);\n\n        User responseUser = userMapper.queryByUserNameAccurately(userName);\n        putMsg(result, Status.SUCCESS);\n        result.put(Constants.DATA_LIST, responseUser);\n        return result;\n    }\n\n    /**\n     * activate user, only system admin have permission, change users state code 0 to 1\n     *\n     * @param loginUser login user\n     * @param userNames user name\n     * @return create result code\n     */\n    @Override\n    public Map<String, Object> batchActivateUser(User loginUser, List<String> userNames) {\n        Map<String, Object> result = new HashMap<>();\n\n        if (resourcePermissionCheckService.functionDisabled()) {\n            putMsg(result, Status.FUNCTION_DISABLED);\n            return result;\n        }\n        if (!isAdmin(loginUser)) {\n            putMsg(result, Status.USER_NO_OPERATION_PERM);\n            return result;\n        }\n\n        int totalSuccess = 0;\n        List<String> successUserNames = new ArrayList<>();\n        Map<String, Object> successRes = new HashMap<>();\n        int totalFailed = 0;\n        List<Map<String, String>> failedInfo = new ArrayList<>();\n        Map<String, Object> failedRes = new HashMap<>();\n        for (String userName : userNames) {\n            Map<String, Object> tmpResult = activateUser(loginUser, userName);\n            if (tmpResult.get(Constants.STATUS) != Status.SUCCESS) {\n                totalFailed++;\n                Map<String, String> failedBody = new HashMap<>();\n                failedBody.put(\"userName\", userName);\n                Status status = (Status) tmpResult.get(Constants.STATUS);\n                String errorMessage = MessageFormat.format(status.getMsg(), userName);\n                failedBody.put(\"msg\", errorMessage);\n                failedInfo.add(failedBody);\n            } else {\n                totalSuccess++;\n                successUserNames.add(userName);\n            }\n        }\n        successRes.put(\"sum\", totalSuccess);\n        successRes.put(\"userName\", successUserNames);\n        failedRes.put(\"sum\", totalFailed);\n        failedRes.put(\"info\", failedInfo);\n        Map<String, Object> res = new HashMap<>();\n        res.put(\"success\", successRes);\n        res.put(\"failed\", failedRes);\n        putMsg(result, Status.SUCCESS);\n        result.put(Constants.DATA_LIST, res);\n        return result;\n    }\n\n    /**\n     * Make sure user with given name exists, and create the user if not exists\n     * <p>\n     * ONLY for python gateway server, and should not use this in web ui function\n     *\n     * @param userName     user name\n     * @param userPassword user password\n     * @param email        user email\n     * @param phone        user phone\n     * @param tenantCode   tenant code\n     * @param queue        queue\n     * @param state        state\n     * @return create result code\n     */\n    @Override\n    @Transactional\n    public User createUserIfNotExists(String userName,\n                                      String userPassword,\n                                      String email,\n                                      String phone,\n                                      String tenantCode,\n                                      String queue,\n                                      int state) {\n        User user = userMapper.queryByUserNameAccurately(userName);\n        if (Objects.isNull(user)) {\n            Tenant tenant = tenantMapper.queryByTenantCode(tenantCode);\n            user = createUser(userName, userPassword, email, tenant.getId(), phone, queue, state);\n            return user;\n        }\n\n        updateUser(user, user.getId(), userName, userPassword, email, user.getTenantId(), phone, queue, state, null);\n        user = userMapper.queryDetailsById(user.getId());\n        return user;\n    }\n}\n",
            "role": "user"
        }
    ],
    "model": "gpt-4-1106-preview",
    "response_format": {
        "type": "json_object"
    },
    "temperature": 0.9
}