{
    "key":"//common/src/main/java/org/apache/rocketmq/common/BrokerConfig.java\npublic class BrokerConfig extends BrokerIdentity {\n\n    private String brokerConfigPath = null;\n\n    private String rocketmqHome = System.getProperty(MixAll.ROCKETMQ_HOME_PROPERTY, System.getenv(MixAll.ROCKETMQ_HOME_ENV));\n    @ImportantField\n    private String namesrvAddr = System.getProperty(MixAll.NAMESRV_ADDR_PROPERTY, System.getenv(MixAll.NAMESRV_ADDR_ENV));\n\n    /**\n     * Listen port for single broker\n     */\n    @ImportantField\n    private int listenPort = 6888;\n\n    @ImportantField\n    private String brokerIP1 = NetworkUtil.getLocalAddress();\n    private String brokerIP2 = NetworkUtil.getLocalAddress();\n\n    @ImportantField\n    private boolean recoverConcurrently = false;\n\n    private int brokerPermission = PermName.PERM_READ | PermName.PERM_WRITE;\n    private int defaultTopicQueueNums = 8;\n    @ImportantField\n    private boolean autoCreateTopicEnable = true;\n\n    private boolean clusterTopicEnable = true;\n\n    private boolean brokerTopicEnable = true;\n    @ImportantField\n    private boolean autoCreateSubscriptionGroup = true;\n    private String messageStorePlugIn = \"\";\n\n    private static final int PROCESSOR_NUMBER = Runtime.getRuntime().availableProcessors();\n    @ImportantField\n    private String msgTraceTopicName = TopicValidator.RMQ_SYS_TRACE_TOPIC;\n    @ImportantField\n    private boolean traceTopicEnable = false;\n    /**\n     * thread numbers for send message thread pool.\n     */\n    private int sendMessageThreadPoolNums = Math.min(PROCESSOR_NUMBER, 4);\n    private int putMessageFutureThreadPoolNums = Math.min(PROCESSOR_NUMBER, 4);\n    private int pullMessageThreadPoolNums = 16 + PROCESSOR_NUMBER * 2;\n    private int litePullMessageThreadPoolNums = 16 + PROCESSOR_NUMBER * 2;\n    private int ackMessageThreadPoolNums = 3;\n    private int processReplyMessageThreadPoolNums = 16 + PROCESSOR_NUMBER * 2;\n    private int queryMessageThreadPoolNums = 8 + PROCESSOR_NUMBER;\n\n    private int adminBrokerThreadPoolNums = 16;\n    private int clientManageThreadPoolNums = 32;\n    private int consumerManageThreadPoolNums = 32;\n    private int loadBalanceProcessorThreadPoolNums = 32;\n    private int heartbeatThreadPoolNums = Math.min(32, PROCESSOR_NUMBER);\n    private int recoverThreadPoolNums = 32;\n\n    /**\n     * Thread numbers for EndTransactionProcessor\n     */\n    private int endTransactionThreadPoolNums = Math.max(8 + PROCESSOR_NUMBER * 2,\n            sendMessageThreadPoolNums * 4);\n\n    private int flushConsumerOffsetInterval = 1000 * 5;\n\n    private int flushConsumerOffsetHistoryInterval = 1000 * 60;\n\n    @ImportantField\n    private boolean rejectTransactionMessage = false;\n\n    @ImportantField\n    private boolean fetchNameSrvAddrByDnsLookup = false;\n\n    @ImportantField\n    private boolean fetchNamesrvAddrByAddressServer = false;\n\n    private int sendThreadPoolQueueCapacity = 10000;\n    private int putThreadPoolQueueCapacity = 10000;\n    private int pullThreadPoolQueueCapacity = 100000;\n    private int litePullThreadPoolQueueCapacity = 100000;\n    private int ackThreadPoolQueueCapacity = 100000;\n    private int replyThreadPoolQueueCapacity = 10000;\n    private int queryThreadPoolQueueCapacity = 20000;\n    private int clientManagerThreadPoolQueueCapacity = 1000000;\n    private int consumerManagerThreadPoolQueueCapacity = 1000000;\n    private int heartbeatThreadPoolQueueCapacity = 50000;\n    private int endTransactionPoolQueueCapacity = 100000;\n    private int adminBrokerThreadPoolQueueCapacity = 10000;\n    private int loadBalanceThreadPoolQueueCapacity = 100000;\n\n    private boolean longPollingEnable = true;\n\n    private long shortPollingTimeMills = 1000;\n\n    private boolean notifyConsumerIdsChangedEnable = true;\n\n    private boolean highSpeedMode = false;\n\n    private int commercialBaseCount = 1;\n\n    private int commercialSizePerMsg = 4 * 1024;\n\n    private boolean accountStatsEnable = true;\n    private boolean accountStatsPrintZeroValues = true;\n\n    private boolean transferMsgByHeap = true;\n\n    private String regionId = MixAll.DEFAULT_TRACE_REGION_ID;\n    private int registerBrokerTimeoutMills = 24000;\n\n    private int sendHeartbeatTimeoutMillis = 1000;\n\n    private boolean slaveReadEnable = false;\n\n    private boolean disableConsumeIfConsumerReadSlowly = false;\n    private long consumerFallbehindThreshold = 1024L * 1024 * 1024 * 16;\n\n    private boolean brokerFastFailureEnable = true;\n    private long waitTimeMillsInSendQueue = 200;\n    private long waitTimeMillsInPullQueue = 5 * 1000;\n    private long waitTimeMillsInLitePullQueue = 5 * 1000;\n    private long waitTimeMillsInHeartbeatQueue = 31 * 1000;\n    private long waitTimeMillsInTransactionQueue = 3 * 1000;\n    private long waitTimeMillsInAckQueue = 3000;\n\n    private long startAcceptSendRequestTimeStamp = 0L;\n\n    private boolean traceOn = true;\n\n    // Switch of filter bit map calculation.\n    // If switch on:\n    // 1. Calculate filter bit map when construct queue.\n    // 2. Filter bit map will be saved to consume queue extend file if allowed.\n    private boolean enableCalcFilterBitMap = false;\n\n    //Reject the pull consumer instance to pull messages from broker.\n    private boolean rejectPullConsumerEnable = false;\n\n    // Expect num of consumers will use filter.\n    private int expectConsumerNumUseFilter = 32;\n\n    // Error rate of bloom filter, 1~100.\n    private int maxErrorRateOfBloomFilter = 20;\n\n    //how long to clean filter data after dead.Default: 24h\n    private long filterDataCleanTimeSpan = 24 * 3600 * 1000;\n\n    // whether do filter when retry.\n    private boolean filterSupportRetry = false;\n    private boolean enablePropertyFilter = false;\n\n    private boolean compressedRegister = false;\n\n    private boolean forceRegister = true;\n\n    /**\n     * This configurable item defines interval of topics registration of broker to name server. Allowing values are\n     * between 10,000 and 60,000 milliseconds.\n     */\n    private int registerNameServerPeriod = 1000 * 30;\n\n    /**\n     * the interval to send heartbeat to name server for liveness detection.\n     */\n    private int brokerHeartbeatInterval = 1000;\n\n    /**\n     * How long the broker will be considered as inactive by nameserver since last heartbeat. Effective only if\n     * enableSlaveActingMaster is true\n     */\n    private long brokerNotActiveTimeoutMillis = 10 * 1000;\n\n    private boolean enableNetWorkFlowControl = false;\n\n    private boolean enableBroadcastOffsetStore = true;\n\n    private long broadcastOffsetExpireSecond = 2 * 60;\n\n    private long broadcastOffsetExpireMaxSecond = 5 * 60;\n\n    private int popPollingSize = 1024;\n    private int popPollingMapSize = 100000;\n    // 20w cost 200M heap memory.\n    private long maxPopPollingSize = 100000;\n    private int reviveQueueNum = 8;\n    private long reviveInterval = 1000;\n    private long reviveMaxSlow = 3;\n    private long reviveScanTime = 10000;\n    private boolean enableSkipLongAwaitingAck = false;\n    private long reviveAckWaitMs = TimeUnit.MINUTES.toMillis(3);\n    private boolean enablePopLog = false;\n    private boolean enablePopBufferMerge = false;\n    private int popCkStayBufferTime = 10 * 1000;\n    private int popCkStayBufferTimeOut = 3 * 1000;\n    private int popCkMaxBufferSize = 200000;\n    private int popCkOffsetMaxQueueSize = 20000;\n    private boolean enablePopBatchAck = false;\n    private boolean enableNotifyAfterPopOrderLockRelease = true;\n    private boolean initPopOffsetByCheckMsgInMem = true;\n    // read message from pop retry topic v1, for the compatibility, will be removed in the future version\n    private boolean retrieveMessageFromPopRetryTopicV1 = true;\n    private boolean enableRetryTopicV2 = false;\n\n    private boolean realTimeNotifyConsumerChange = true;\n\n    private boolean litePullMessageEnable = true;\n\n    // The period to sync broker member group from namesrv, default value is 1 second\n    private int syncBrokerMemberGroupPeriod = 1000;\n\n    /**\n     * the interval of pulling topic information from the named server\n     */\n    private long loadBalancePollNameServerInterval = 1000 * 30;\n\n    /**\n     * the interval of cleaning\n     */\n    private int cleanOfflineBrokerInterval = 1000 * 30;\n\n    private boolean serverLoadBalancerEnable = true;\n\n    private MessageRequestMode defaultMessageRequestMode = MessageRequestMode.PULL;\n\n    private int defaultPopShareQueueNum = -1;\n\n    /**\n     * The minimum time of the transactional message  to be checked firstly, one message only exceed this time interval\n     * that can be checked.\n     */\n    @ImportantField\n    private long transactionTimeOut = 6 * 1000;\n\n    /**\n     * The maximum number of times the message was checked, if exceed this value, this message will be discarded.\n     */\n    @ImportantField\n    private int transactionCheckMax = 15;\n\n    /**\n     * Transaction message check interval.\n     */\n    @ImportantField\n    private long transactionCheckInterval = 30 * 1000;\n\n    private long transactionMetricFlushInterval = 3 * 1000;\n\n    /**\n     * transaction batch op message\n     */\n    private int transactionOpMsgMaxSize = 4096;\n\n    private int transactionOpBatchInterval = 3000;\n\n    /**\n     * Acl feature switch\n     */\n    @ImportantField\n    private boolean aclEnable = false;\n\n    private boolean storeReplyMessageEnable = true;\n\n    private boolean enableDetailStat = true;\n\n    private boolean autoDeleteUnusedStats = false;\n\n    /**\n     * Whether to distinguish log paths when multiple brokers are deployed on the same machine\n     */\n    private boolean isolateLogEnable = false;\n\n    private long forwardTimeout = 3 * 1000;\n\n    /**\n     * Slave will act master when failover. For example, if master down, timer or transaction message which is expire in slave will\n     * put to master (master of the same process in broker container mode or other masters in cluster when enableFailoverRemotingActing is true)\n     * when enableSlaveActingMaster is true\n     */\n    private boolean enableSlaveActingMaster = false;\n\n    private boolean enableRemoteEscape = false;\n\n    private boolean skipPreOnline = false;\n\n    private boolean asyncSendEnable = true;\n\n    private boolean useServerSideResetOffset = true;\n\n    private long consumerOffsetUpdateVersionStep = 500;\n\n    private long delayOffsetUpdateVersionStep = 200;\n\n    /**\n     * Whether to lock quorum replicas.\n     *\n     * True: need to lock quorum replicas succeed. False: only need to lock one replica succeed.\n     */\n    private boolean lockInStrictMode = false;\n\n    private boolean compatibleWithOldNameSrv = true;\n\n    /**\n     * Is startup controller mode, which support auto switch broker's role.\n     */\n    private boolean enableControllerMode = false;\n\n    private String controllerAddr = \"\";\n\n    private boolean fetchControllerAddrByDnsLookup = false;\n\n    private long syncBrokerMetadataPeriod = 5 * 1000;\n\n    private long checkSyncStateSetPeriod = 5 * 1000;\n\n    private long syncControllerMetadataPeriod = 10 * 1000;\n\n    private long controllerHeartBeatTimeoutMills = 10 * 1000;\n\n    private boolean validateSystemTopicWhenUpdateTopic = true;\n\n    /**\n     * It is an important basis for the controller to choose the broker master.\n     * The lower the value of brokerElectionPriority, the higher the priority of the broker being selected as the master.\n     * You can set a lower priority for the broker with better machine conditions.\n     */\n    private int brokerElectionPriority = Integer.MAX_VALUE;\n\n    private boolean useStaticSubscription = false;\n\n    private MetricsExporterType metricsExporterType = MetricsExporterType.DISABLE;\n\n    private int metricsOtelCardinalityLimit = 50 * 1000;\n    private String metricsGrpcExporterTarget = \"\";\n    private String metricsGrpcExporterHeader = \"\";\n    private long metricGrpcExporterTimeOutInMills = 3 * 1000;\n    private long metricGrpcExporterIntervalInMills = 60 * 1000;\n    private long metricLoggingExporterIntervalInMills = 10 * 1000;\n\n    private int metricsPromExporterPort = 5557;\n    private String metricsPromExporterHost = \"\";\n\n    // Label pairs in CSV. Each label follows pattern of Key:Value. eg: instance_id:xxx,uid:xxx\n    private String metricsLabel = \"\";\n\n    private boolean metricsInDelta = false;\n\n    private long channelExpiredTimeout = 1000 * 120;\n    private long subscriptionExpiredTimeout = 1000 * 60 * 10;\n\n    // remoting\n    private boolean enableRemotingLocalProxyGrpc = true;\n    private int localProxyConnectTimeoutMs = 3000;\n    private String remotingAccessAddr = \"\";\n    private int remotingListenPort = 8080;\n\n    // related to proxy's send strategy in cluster mode.\n    private boolean sendLatencyEnable = false;\n    private boolean startDetectorEnable = false;\n    private int detectTimeout = 200;\n    private int detectInterval = 2 * 1000;\n\n    private int remotingHeartbeatThreadPoolNums = 2 * PROCESSOR_NUMBER;\n    private int remotingTopicRouteThreadPoolNums = 2 * PROCESSOR_NUMBER;\n    private int remotingSendMessageThreadPoolNums = 4 * PROCESSOR_NUMBER;\n    private int remotingPullMessageThreadPoolNums = 4 * PROCESSOR_NUMBER;\n    private int remotingUpdateOffsetThreadPoolNums = 4 * PROCESSOR_NUMBER;\n    private int remotingDefaultThreadPoolNums = 4 * PROCESSOR_NUMBER;\n\n    private int remotingHeartbeatThreadPoolQueueCapacity = 50000;\n    private int remotingTopicRouteThreadPoolQueueCapacity = 50000;\n    private int remotingSendThreadPoolQueueCapacity = 10000;\n    private int remotingPullThreadPoolQueueCapacity = 50000;\n    private int remotingUpdateOffsetThreadPoolQueueCapacity = 10000;\n    private int remotingDefaultThreadPoolQueueCapacity = 50000;\n\n    private long remotingWaitTimeMillsInSendQueue = 3 * 1000;\n    private long remotingWaitTimeMillsInPullQueue = 5 * 1000;\n    private long remotingWaitTimeMillsInHeartbeatQueue = 31 * 1000;\n    private long remotingWaitTimeMillsInUpdateOffsetQueue = 3 * 1000;\n    private long remotingWaitTimeMillsInTopicRouteQueue = 3 * 1000;\n    private long remotingWaitTimeMillsInDefaultQueue = 3 * 1000;\n\n    private boolean enableBatchAck = false;\n\n    /**\n     * Config in this black list will be not allowed to update by command.\n     * Try to update this config black list by restart process.\n     * Try to update configures in black list by restart process.\n     */\n    private String configBlackList = \"configBlackList;brokerConfigPath\";\n\n    public String getConfigBlackList() {\n        return configBlackList;\n    }\n\n    public void setConfigBlackList(String configBlackList) {\n        this.configBlackList = configBlackList;\n    }\n\n    public long getMaxPopPollingSize() {\n        return maxPopPollingSize;\n    }\n\n    public void setMaxPopPollingSize(long maxPopPollingSize) {\n        this.maxPopPollingSize = maxPopPollingSize;\n    }\n\n    public int getReviveQueueNum() {\n        return reviveQueueNum;\n    }\n\n    public void setReviveQueueNum(int reviveQueueNum) {\n        this.reviveQueueNum = reviveQueueNum;\n    }\n\n    public long getReviveInterval() {\n        return reviveInterval;\n    }\n\n    public void setReviveInterval(long reviveInterval) {\n        this.reviveInterval = reviveInterval;\n    }\n\n    public int getPopCkStayBufferTime() {\n        return popCkStayBufferTime;\n    }\n\n    public void setPopCkStayBufferTime(int popCkStayBufferTime) {\n        this.popCkStayBufferTime = popCkStayBufferTime;\n    }\n\n    public int getPopCkStayBufferTimeOut() {\n        return popCkStayBufferTimeOut;\n    }\n\n    public void setPopCkStayBufferTimeOut(int popCkStayBufferTimeOut) {\n
{
    "key":"//broker/src/main/java/org/apache/rocketmq/broker/metrics/ConsumerLagCalculator.java\npublic class ConsumerLagCalculator {\n    private final BrokerConfig brokerConfig;\n    private final TopicConfigManager topicConfigManager;\n    private final ConsumerManager consumerManager;\n    private final ConsumerOffsetManager offsetManager;\n    private final ConsumerFilterManager consumerFilterManager;\n    private final SubscriptionGroupManager subscriptionGroupManager;\n    private final MessageStore messageStore;\n    private final PopBufferMergeService popBufferMergeService;\n    private final PopInflightMessageCounter popInflightMessageCounter;\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(LoggerName.BROKER_LOGGER_NAME);\n\n    public ConsumerLagCalculator(BrokerController brokerController) {\n        this.brokerConfig = brokerController.getBrokerConfig();\n        this.topicConfigManager = brokerController.getTopicConfigManager();\n        this.consumerManager = brokerController.getConsumerManager();\n        this.offsetManager = brokerController.getConsumerOffsetManager();\n        this.consumerFilterManager = brokerController.getConsumerFilterManager();\n        this.subscriptionGroupManager = brokerController.getSubscriptionGroupManager();\n        this.messageStore = brokerController.getMessageStore();\n        this.popBufferMergeService = brokerController.getPopMessageProcessor().getPopBufferMergeService();\n        this.popInflightMessageCounter = brokerController.getPopInflightMessageCounter();\n    }\n\n    private static class ProcessGroupInfo {\n        public String group;\n        public String topic;\n        public boolean isPop;\n        public String retryTopic;\n\n        public ProcessGroupInfo(String group, String topic, boolean isPop,\n            String retryTopic) {\n            this.group = group;\n            this.topic = topic;\n            this.isPop = isPop;\n            this.retryTopic = retryTopic;\n        }\n    }\n\n    public static class BaseCalculateResult {\n        public String group;\n        public String topic;\n        public boolean isRetry;\n\n        public BaseCalculateResult(String group, String topic, boolean isRetry) {\n            this.group = group;\n            this.topic = topic;\n            this.isRetry = isRetry;\n        }\n    }\n\n    public static class CalculateLagResult extends BaseCalculateResult {\n        public long lag;\n        public long earliestUnconsumedTimestamp;\n\n        public CalculateLagResult(String group, String topic, boolean isRetry) {\n            super(group, topic, isRetry);\n        }\n    }\n\n    public static class CalculateInflightResult extends BaseCalculateResult {\n        public long inFlight;\n        public long earliestUnPulledTimestamp;\n\n        public CalculateInflightResult(String group, String topic, boolean isRetry) {\n            super(group, topic, isRetry);\n        }\n    }\n\n    public static class CalculateAvailableResult extends BaseCalculateResult {\n        public long available;\n\n        public CalculateAvailableResult(String group, String topic, boolean isRetry) {\n            super(group, topic, isRetry);\n        }\n    }\n\n    private void processAllGroup(Consumer<ProcessGroupInfo> consumer) {\n        for (Map.Entry<String, SubscriptionGroupConfig> subscriptionEntry :\n            subscriptionGroupManager.getSubscriptionGroupTable().entrySet()) {\n\n            String group = subscriptionEntry.getKey();\n            ConsumerGroupInfo consumerGroupInfo = consumerManager.getConsumerGroupInfo(group, true);\n            boolean isPop = false;\n            if (consumerGroupInfo != null) {\n                isPop = consumerGroupInfo.getConsumeType() == ConsumeType.CONSUME_POP;\n            }\n            Set<String> topics;\n            if (brokerConfig.isUseStaticSubscription()) {\n                SubscriptionGroupConfig subscriptionGroupConfig = subscriptionEntry.getValue();\n                if (subscriptionGroupConfig.getSubscriptionDataSet() == null ||\n                    subscriptionGroupConfig.getSubscriptionDataSet().isEmpty()) {\n                    continue;\n                }\n                topics = subscriptionGroupConfig.getSubscriptionDataSet()\n                    .stream()\n                    .map(SimpleSubscriptionData::getTopic)\n                    .collect(Collectors.toSet());\n            } else {\n                if (consumerGroupInfo == null) {\n                    continue;\n                }\n                topics = consumerGroupInfo.getSubscribeTopics();\n            }\n\n            if (null == topics || topics.isEmpty()) {\n                continue;\n            }\n            for (String topic : topics) {\n                // skip retry topic\n                if (topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {\n                    continue;\n                }\n\n                TopicConfig topicConfig = topicConfigManager.selectTopicConfig(topic);\n                if (topicConfig == null) {\n                    continue;\n                }\n\n                // skip no perm topic\n                int topicPerm = topicConfig.getPerm() & brokerConfig.getBrokerPermission();\n                if (!PermName.isReadable(topicPerm) && !PermName.isWriteable(topicPerm)) {\n                    continue;\n                }\n\n                if (isPop) {\n                    String retryTopic = KeyBuilder.buildPopRetryTopic(topic, group, brokerConfig.isEnableRetryTopicV2());\n                    TopicConfig retryTopicConfig = topicConfigManager.selectTopicConfig(retryTopic);\n                    if (retryTopicConfig != null) {\n                        int retryTopicPerm = retryTopicConfig.getPerm() & brokerConfig.getBrokerPermission();\n                        if (PermName.isReadable(retryTopicPerm) || PermName.isWriteable(retryTopicPerm)) {\n                            consumer.accept(new ProcessGroupInfo(group, topic, true, retryTopic));\n                            continue;\n                        }\n                    }\n                    if (brokerConfig.isEnableRetryTopicV2() && brokerConfig.isRetrieveMessageFromPopRetryTopicV1()) {\n                        String retryTopicV1 = KeyBuilder.buildPopRetryTopicV1(topic, group);\n                        TopicConfig retryTopicConfigV1 = topicConfigManager.selectTopicConfig(retryTopicV1);\n                        if (retryTopicConfigV1 != null) {\n                            int retryTopicPerm = retryTopicConfigV1.getPerm() & brokerConfig.getBrokerPermission();\n                            if (PermName.isReadable(retryTopicPerm) || PermName.isWriteable(retryTopicPerm)) {\n                                consumer.accept(new ProcessGroupInfo(group, topic, true, retryTopicV1));\n                                continue;\n                            }\n                        }\n                    }\n                    consumer.accept(new ProcessGroupInfo(group, topic, true, null));\n                } else {\n                    consumer.accept(new ProcessGroupInfo(group, topic, false, null));\n                }\n            }\n        }\n    }\n\n    public void calculateLag(Consumer<CalculateLagResult> lagRecorder) {\n        processAllGroup(info -> {\n            if (info.group == null || info.topic == null) {\n                return;\n            }\n\n            CalculateLagResult result = new CalculateLagResult(info.group, info.topic, false);\n\n            Pair<Long, Long> lag = getConsumerLagStats(info.group, info.topic, info.isPop);\n            if (lag != null) {\n                result.lag = lag.getObject1();\n                result.earliestUnconsumedTimestamp = lag.getObject2();\n            }\n            lagRecorder.accept(result);\n\n            if (info.isPop) {\n                Pair<Long, Long> retryLag = getConsumerLagStats(info.group, info.retryTopic, true);\n\n                result = new CalculateLagResult(info.group, info.topic, true);\n                if (retryLag != null) {\n                    result.lag = retryLag.getObject1();\n                    result.earliestUnconsumedTimestamp = retryLag.getObject2();\n                }\n                lagRecorder.accept(result);\n            }\n        });\n    }\n\n    public void calculateInflight(Consumer<CalculateInflightResult> inflightRecorder) {\n        processAllGroup(info -> {\n            CalculateInflightResult result = new CalculateInflightResult(info.group, info.topic, false);\n            Pair<Long, Long> inFlight = getInFlightMsgStats(info.group, info.topic, info.isPop);\n            if (inFlight != null) {\n                result.inFlight = inFlight.getObject1();\n                result.earliestUnPulledTimestamp = inFlight.getObject2();\n            }\n            inflightRecorder.accept(result);\n\n            if (info.isPop) {\n                Pair<Long, Long> retryInFlight = getInFlightMsgStats(info.group, info.retryTopic, true);\n\n                result = new CalculateInflightResult(info.group, info.topic, true);\n                if (retryInFlight != null) {\n                    result.inFlight = retryInFlight.getObject1();\n                    result.earliestUnPulledTimestamp = retryInFlight.getObject2();\n                }\n                inflightRecorder.accept(result);\n            }\n        });\n    }\n\n    public void calculateAvailable(Consumer<CalculateAvailableResult> availableRecorder) {\n        processAllGroup(info -> {\n            CalculateAvailableResult result = new CalculateAvailableResult(info.group, info.topic, false);\n\n            result.available = getAvailableMsgCount(info.group, info.topic, info.isPop);\n            availableRecorder.accept(result);\n\n            if (info.isPop) {\n                long retryAvailable = getAvailableMsgCount(info.group, info.retryTopic, true);\n\n                result = new CalculateAvailableResult(info.group, info.topic, true);\n                result.available = retryAvailable;\n                availableRecorder.accept(result);\n            }\n        });\n    }\n\n    public Pair<Long, Long> getConsumerLagStats(String group, String topic, boolean isPop) {\n        long total = 0L;\n        long earliestUnconsumedTimestamp = Long.MAX_VALUE;\n\n        if (group == null || topic == null) {\n            return new Pair<>(total, earliestUnconsumedTimestamp);\n        }\n\n        TopicConfig topicConfig = topicConfigManager.selectTopicConfig(topic);\n        if (topicConfig != null) {\n            for (int queueId = 0; queueId < topicConfig.getWriteQueueNums(); queueId++) {\n                Pair<Long, Long> pair = getConsumerLagStats(group, topic, queueId, isPop);\n                total += pair.getObject1();\n                earliestUnconsumedTimestamp = Math.min(earliestUnconsumedTimestamp, pair.getObject2());\n            }\n        } else {\n            LOGGER.warn(\"failed to get config of topic {}\", topic);\n        }\n\n        if (earliestUnconsumedTimestamp < 0 || earliestUnconsumedTimestamp == Long.MAX_VALUE) {\n            earliestUnconsumedTimestamp = 0L;\n        }\n\n        return new Pair<>(total, earliestUnconsumedTimestamp);\n    }\n\n    public Pair<Long, Long> getConsumerLagStats(String group, String topic, int queueId, boolean isPop) {\n        long brokerOffset = messageStore.getMaxOffsetInQueue(topic, queueId);\n        if (brokerOffset < 0) {\n            brokerOffset = 0;\n        }\n\n        if (isPop) {\n            long pullOffset = popBufferMergeService.getLatestOffset(topic, group, queueId);\n            if (pullOffset < 0) {\n                pullOffset = offsetManager.queryOffset(group, topic, queueId);\n            }\n            if (pullOffset < 0) {\n                pullOffset = brokerOffset;\n            }\n            long inFlightNum = popInflightMessageCounter.getGroupPopInFlightMessageNum(topic, group, queueId);\n            long lag = calculateMessageCount(group, topic, queueId, pullOffset, brokerOffset) + inFlightNum;\n            long consumerOffset = pullOffset - inFlightNum;\n            long consumerStoreTimeStamp = getStoreTimeStamp(topic, queueId, consumerOffset);\n            return new Pair<>(lag, consumerStoreTimeStamp);\n        }\n\n        long consumerOffset = offsetManager.queryOffset(group, topic, queueId);\n        if (consumerOffset < 0) {\n            consumerOffset = brokerOffset;\n        }\n\n        long lag = calculateMessageCount(group, topic, queueId, consumerOffset, brokerOffset);\n        long consumerStoreTimeStamp = getStoreTimeStamp(topic, queueId, consumerOffset);\n        return new Pair<>(lag, consumerStoreTimeStamp);\n    }\n\n    public Pair<Long, Long> getInFlightMsgStats(String group, String topic, boolean isPop) {\n        long total = 0L;\n        long earliestUnPulledTimestamp = Long.MAX_VALUE;\n\n        if (group == null || topic == null) {\n            return new Pair<>(total, earliestUnPulledTimestamp);\n        }\n\n        TopicConfig topicConfig = topicConfigManager.selectTopicConfig(topic);\n        if (topicConfig != null) {\n            for (int queueId = 0; queueId < topicConfig.getWriteQueueNums(); queueId++) {\n                Pair<Long, Long> pair = getInFlightMsgStats(group, topic, queueId, isPop);\n                total += pair.getObject1();\n                earliestUnPulledTimestamp = Math.min(earliestUnPulledTimestamp, pair.getObject2());\n            }\n        } else {\n            LOGGER.warn(\"failed to get config of topic {}\", topic);\n        }\n\n        if (earliestUnPulledTimestamp < 0 || earliestUnPulledTimestamp == Long.MAX_VALUE) {\n            earliestUnPulledTimestamp = 0L;\n        }\n\n        return new Pair<>(total, earliestUnPulledTimestamp);\n    }\n\n    public Pair<Long, Long> getInFlightMsgStats(String group, String topic, int queueId, boolean isPop) {\n        if (isPop) {\n            long inflight = popInflightMessageCounter.getGroupPopInFlightMessageNum(topic, group, queueId);\n            long pullOffset = popBufferMergeService.getLatestOffset(topic, group, queueId);\n            if (pullOffset < 0) {\n                pullOffset = offsetManager.queryOffset(group, topic, queueId);\n            }\n            if (pullOffset < 0) {\n                pullOffset = messageStore.getMaxOffsetInQueue(topic, queueId);\n            }\n            long pullStoreTimeStamp = getStoreTimeStamp(topic, queueId, pullOffset);\n            return new Pair<>(inflight, pullStoreTimeStamp);\n        }\n\n        long pullOffset = offsetManager.queryPullOffset(group, topic, queueId);\n        if (pullOffset < 0) {\n            pullOffset = 0;\n        }\n\n        long commitOffset = offsetManager.queryOffset(group, topic, queueId);\n        if (commitOffset < 0) {\n            commitOffset = pullOffset;\n        }\n\n        long inflight = calculateMessageCount(group, topic, queueId, commitOffset, pullOffset);\n        long pullStoreTimeStamp = getStoreTimeStamp(topic, queueId, pullOffset);\n        return new Pair<>(inflight, pullStoreTimeStamp);\n    }\n\n    public long getAvailableMsgCount(String group, String topic, boolean isPop) {\n        long total = 0L;\n\n        if (group == null || topic == null) {\n            return total;\n        }\n\n        TopicConfig topicConfig = topicConfigManager.selectTopicConfig(topic);\n        if (topicConfig != null) {\n            for (int queueId = 0; queueId < topicConfig.getWriteQueueNums(); queueId++) {\n                total += getAvailableMsgCount(group, topic, queueId, isPop);\n            }\n        } else {\n            LOGGER.warn(\"failed to get config of topic {}\", topic);\n        }\n\n        return total;\n    }\n\n    public long getAvailableMsgCount(String group, String topic, int queueId, boolean isPop) {\n        long brokerOffset = messageStore.getMaxOffsetInQueue(topic, queueId);\n        if (brokerOffset < 0) {\n            brokerOffset = 0;\n        }\n\n        long pullOffset;\n        if (isPop) {\n            pullOffset = popBufferMergeService.getLatestOffset(topic, group, queueId);\n            if (pullOffset < 0) {\n                pullOffset = offsetManager.queryOffset(group, topic, queueId);\n            }\n            if (pullOffset < 0) {\n                pullOffset = brokerOffset;\n            }\n        } else {\n            pullOffset = offsetManager.queryPullOffset(group, topic, queueId);\n        }\n        if (pullOffset < 0) {\n            pullOffset = brokerOffset;\n        }\n\n        return calculateMessageCount(group, topic, queueId, pullOffset, brokerOffset);\n    }\n\n    public long getStoreTimeStamp(String topic, int queueId, long offset) {\n        long storeTimeStamp = Long.MAX_VALUE;\n        if (offset >= 0) {\n            storeTimeStamp = messageStore.getMessageStoreTimeStamp(topic, queueId, offset);\n            storeTimeStamp = storeTimeStamp > 0 ? storeTimeStamp : Long.MAX_VALUE;\n        }\n        return storeTimeStamp;\n    }\n\n    public long calculateMessageCount(String group, String topic, int queueId, long from, long to) {\n        long count = to - from;\n\n        if (brokerConfig.isEstimateAccumulation() && to > from) {\n            SubscriptionData subscriptionData = null;\n            if (brokerConfig.isUseStaticSubscription()) {\n                SubscriptionGroupConfig subscriptionGroupConfig = subscriptionGroupManager.findSubscriptionGroupConfig(group);\n                if (subscriptionGroupConfig != null) {\n                    for (SimpleSubscriptionData simpleSubscriptionData : subscriptionGroupConfig.getSubscriptionDataSet()) {\n                        if (topic.equals(simpleSubscriptionData.getTopic())) {\n                            try {\n                                subscriptionData = FilterAPI.buildSubscriptionData(simpleSubscriptionData.getTopic(),\n                                    simpleSubscriptionData.getExpression(), simpleSubscriptionData.getExpressionType());\n                            } catch (Exception e) {\n                                LOGGER.error(\"Try to build subscription for group:{}, topic:{} exception.\", group, topic, e);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } else {\n                ConsumerGroupInfo consumerGroupInfo = consumerManager.getConsumerGroupInfo(group, true);\n                if (consumerGroupInfo != null) {\n                    subscriptionData = consumerGroupInfo.findSubscriptionData(topic);\n                }\n            }\n\n            if (null != subscriptionData) {\n                if (ExpressionType.TAG.equalsIgnoreCase(subscriptionData.getExpressionType())\n                    && !SubscriptionData.SUB_ALL.equals(subscriptionData.getSubString())) {\n                    count = messageStore.estimateMessageCount(topic, queueId, from, to,\n                        new DefaultMessageFilter(subscriptionData));\n                } else if (ExpressionType.SQL92.equalsIgnoreCase(sub
{
    "key":"//broker/src/main/java/org/apache/rocketmq/broker/out/BrokerOuterAPI.java\npublic class BrokerOuterAPI {\n    private static final Logger LOGGER = LoggerFactory.getLogger(LoggerName.BROKER_LOGGER_NAME);\n    private final RemotingClient remotingClient;\n    private final TopAddressing topAddressing = new DefaultTopAddressing(MixAll.getWSAddr());\n    private final ExecutorService brokerOuterExecutor = ThreadUtils.newThreadPoolExecutor(4, 10, 1, TimeUnit.MINUTES,\n            new ArrayBlockingQueue<>(32), new ThreadFactoryImpl(\"brokerOutApi_thread_\", true));\n    private final ClientMetadata clientMetadata;\n    private final RpcClient rpcClient;\n    private String nameSrvAddr = null;\n\n    public BrokerOuterAPI(final NettyClientConfig nettyClientConfig, AuthConfig authConfig) {\n        this(nettyClientConfig, authConfig, new DynamicalExtFieldRPCHook(), new ClientMetadata());\n    }\n\n    private BrokerOuterAPI(final NettyClientConfig nettyClientConfig, AuthConfig authConfig, RPCHook rpcHook, ClientMetadata clientMetadata) {\n        this.remotingClient = new NettyRemotingClient(nettyClientConfig);\n        this.clientMetadata = clientMetadata;\n        this.remotingClient.registerRPCHook(rpcHook);\n        this.remotingClient.registerRPCHook(newAclRPCHook(authConfig));\n        this.rpcClient = new RpcClientImpl(this.clientMetadata, this.remotingClient);\n    }\n\n    private RPCHook newAclRPCHook(AuthConfig config) {\n        if (config == null || StringUtils.isBlank(config.getInnerClientAuthenticationCredentials())) {\n            return null;\n        }\n        SessionCredentials sessionCredentials =\n            JSON.parseObject(config.getInnerClientAuthenticationCredentials(), SessionCredentials.class);\n        if (StringUtils.isBlank(sessionCredentials.getAccessKey()) || StringUtils.isBlank(sessionCredentials.getSecretKey())) {\n            return null;\n        }\n        return new AclClientRPCHook(sessionCredentials);\n    }\n\n    public void start() {\n        this.remotingClient.start();\n    }\n\n    public void shutdown() {\n        this.remotingClient.shutdown();\n        this.brokerOuterExecutor.shutdown();\n    }\n\n    public List<String> getNameServerAddressList() {\n        return this.remotingClient.getNameServerAddressList();\n    }\n\n    public String fetchNameServerAddr() {\n        try {\n            String addrs = this.topAddressing.fetchNSAddr();\n            if (!UtilAll.isBlank(addrs)) {\n                if (!addrs.equals(this.nameSrvAddr)) {\n                    LOGGER.info(\"name server address changed, old: {} new: {}\", this.nameSrvAddr, addrs);\n                    this.updateNameServerAddressList(addrs);\n                    this.nameSrvAddr = addrs;\n                    return nameSrvAddr;\n                }\n            }\n        } catch (Exception e) {\n            LOGGER.error(\"fetchNameServerAddr Exception\", e);\n        }\n        return nameSrvAddr;\n    }\n\n    public List<String> dnsLookupAddressByDomain(String domain) {\n        List<String> addressList = new ArrayList<>();\n        try {\n            java.security.Security.setProperty(\"networkaddress.cache.ttl\", \"10\");\n            int index = domain.indexOf(\":\");\n            String portStr = domain.substring(index);\n            String domainStr = domain.substring(0, index);\n            InetAddress[] addresses = InetAddress.getAllByName(domainStr);\n            for (InetAddress address : addresses) {\n                addressList.add(address.getHostAddress() + portStr);\n            }\n            LOGGER.info(\"dns lookup address by domain success, domain={}, result={}\", domain, addressList);\n        } catch (Exception e) {\n            LOGGER.error(\"dns lookup address by domain error, domain={}\", domain, e);\n        }\n        return addressList;\n    }\n\n    public boolean checkAddressReachable(String address) {\n        return this.remotingClient.isAddressReachable(address);\n    }\n\n    public void updateNameServerAddressList(final String addrs) {\n        String[] addrArray = addrs.split(\";\");\n        List<String> lst = new ArrayList<String>(Arrays.asList(addrArray));\n        this.remotingClient.updateNameServerAddressList(lst);\n    }\n\n    public void updateNameServerAddressListByDnsLookup(final String domain) {\n        List<String> lst = this.dnsLookupAddressByDomain(domain);\n        this.remotingClient.updateNameServerAddressList(lst);\n    }\n\n    public BrokerMemberGroup syncBrokerMemberGroup(String clusterName, String brokerName)\n        throws InterruptedException, RemotingTimeoutException, RemotingSendRequestException, RemotingConnectException {\n        return syncBrokerMemberGroup(clusterName, brokerName, false);\n    }\n\n    public BrokerMemberGroup syncBrokerMemberGroup(String clusterName, String brokerName,\n        boolean isCompatibleWithOldNameSrv)\n        throws InterruptedException, RemotingTimeoutException, RemotingSendRequestException, RemotingConnectException {\n        if (isCompatibleWithOldNameSrv) {\n            return getBrokerMemberGroupCompatible(clusterName, brokerName);\n        } else {\n            return getBrokerMemberGroup(clusterName, brokerName);\n        }\n    }\n\n    public BrokerMemberGroup getBrokerMemberGroup(String clusterName, String brokerName)\n        throws InterruptedException, RemotingTimeoutException, RemotingSendRequestException, RemotingConnectException {\n        BrokerMemberGroup brokerMemberGroup = new BrokerMemberGroup(clusterName, brokerName);\n\n        GetBrokerMemberGroupRequestHeader requestHeader = new GetBrokerMemberGroupRequestHeader();\n        requestHeader.setClusterName(clusterName);\n        requestHeader.setBrokerName(brokerName);\n\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.GET_BROKER_MEMBER_GROUP, requestHeader);\n\n        RemotingCommand response = null;\n        response = this.remotingClient.invokeSync(null, request, 3000);\n        assert response != null;\n\n        switch (response.getCode()) {\n            case ResponseCode.SUCCESS: {\n                byte[] body = response.getBody();\n                if (body != null) {\n                    GetBrokerMemberGroupResponseBody brokerMemberGroupResponseBody =\n                        GetBrokerMemberGroupResponseBody.decode(body, GetBrokerMemberGroupResponseBody.class);\n\n                    return brokerMemberGroupResponseBody.getBrokerMemberGroup();\n                }\n            }\n            default:\n                break;\n        }\n\n        return brokerMemberGroup;\n    }\n\n    public BrokerMemberGroup getBrokerMemberGroupCompatible(String clusterName, String brokerName)\n        throws InterruptedException, RemotingTimeoutException, RemotingSendRequestException, RemotingConnectException {\n        BrokerMemberGroup brokerMemberGroup = new BrokerMemberGroup(clusterName, brokerName);\n\n        GetRouteInfoRequestHeader requestHeader = new GetRouteInfoRequestHeader();\n        requestHeader.setTopic(TopicValidator.SYNC_BROKER_MEMBER_GROUP_PREFIX + brokerName);\n\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.GET_ROUTEINFO_BY_TOPIC, requestHeader);\n\n        RemotingCommand response;\n        response = this.remotingClient.invokeSync(null, request, 3000);\n        assert response != null;\n\n        switch (response.getCode()) {\n            case ResponseCode.SUCCESS: {\n                byte[] body = response.getBody();\n                if (body != null) {\n                    TopicRouteData topicRouteData = TopicRouteData.decode(body, TopicRouteData.class);\n                    for (BrokerData brokerData : topicRouteData.getBrokerDatas()) {\n                        if (brokerData != null\n                            && brokerData.getBrokerName().equals(brokerName)\n                            && brokerData.getCluster().equals(clusterName)) {\n                            brokerMemberGroup.getBrokerAddrs().putAll(brokerData.getBrokerAddrs());\n                            break;\n                        }\n                    }\n                    return brokerMemberGroup;\n                }\n            }\n            default:\n                break;\n        }\n\n        return brokerMemberGroup;\n    }\n\n    public void sendHeartbeatViaDataVersion(\n        final String clusterName,\n        final String brokerAddr,\n        final String brokerName,\n        final Long brokerId,\n        final int timeoutMillis,\n        final DataVersion dataVersion,\n        final boolean isInBrokerContainer) {\n        List<String> nameServerAddressList = this.remotingClient.getAvailableNameSrvList();\n        if (nameServerAddressList != null && nameServerAddressList.size() > 0) {\n            final QueryDataVersionRequestHeader requestHeader = new QueryDataVersionRequestHeader();\n            requestHeader.setBrokerAddr(brokerAddr);\n            requestHeader.setBrokerName(brokerName);\n            requestHeader.setBrokerId(brokerId);\n            requestHeader.setClusterName(clusterName);\n\n            for (final String namesrvAddr : nameServerAddressList) {\n                brokerOuterExecutor.execute(new AbstractBrokerRunnable(new BrokerIdentity(clusterName, brokerName, brokerId, isInBrokerContainer)) {\n\n                    @Override\n                    public void run0() {\n                        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.QUERY_DATA_VERSION, requestHeader);\n                        request.setBody(dataVersion.encode());\n\n                        try {\n                            BrokerOuterAPI.this.remotingClient.invokeOneway(namesrvAddr, request, timeoutMillis);\n                        } catch (Exception e) {\n                            LOGGER.error(\"sendHeartbeat Exception \" + namesrvAddr, e);\n                        }\n                    }\n                });\n            }\n        }\n    }\n\n    public void sendHeartbeat(final String clusterName,\n        final String brokerAddr,\n        final String brokerName,\n        final Long brokerId,\n        final int timeoutMills,\n        final boolean isInBrokerContainer) {\n        List<String> nameServerAddressList = this.remotingClient.getAvailableNameSrvList();\n\n        final BrokerHeartbeatRequestHeader requestHeader = new BrokerHeartbeatRequestHeader();\n        requestHeader.setClusterName(clusterName);\n        requestHeader.setBrokerAddr(brokerAddr);\n        requestHeader.setBrokerName(brokerName);\n\n        if (nameServerAddressList != null && nameServerAddressList.size() > 0) {\n            for (final String namesrvAddr : nameServerAddressList) {\n                brokerOuterExecutor.execute(new AbstractBrokerRunnable(new BrokerIdentity(clusterName, brokerName, brokerId, isInBrokerContainer)) {\n                    @Override\n                    public void run0() {\n                        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.BROKER_HEARTBEAT, requestHeader);\n\n                        try {\n                            BrokerOuterAPI.this.remotingClient.invokeOneway(namesrvAddr, request, timeoutMills);\n                        } catch (Exception e) {\n                            LOGGER.error(\"sendHeartbeat Exception \" + namesrvAddr, e);\n                        }\n                    }\n                });\n            }\n        }\n    }\n\n    public BrokerSyncInfo retrieveBrokerHaInfo(String masterBrokerAddr)\n        throws InterruptedException, RemotingTimeoutException, RemotingSendRequestException, RemotingConnectException,\n        MQBrokerException, RemotingCommandException {\n        ExchangeHAInfoRequestHeader requestHeader = new ExchangeHAInfoRequestHeader();\n        requestHeader.setMasterHaAddress(null);\n\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.EXCHANGE_BROKER_HA_INFO, requestHeader);\n\n        RemotingCommand response = this.remotingClient.invokeSync(masterBrokerAddr, request, 3000);\n        assert response != null;\n        switch (response.getCode()) {\n            case ResponseCode.SUCCESS: {\n                ExchangeHAInfoResponseHeader responseHeader = (ExchangeHAInfoResponseHeader) response.decodeCommandCustomHeader(ExchangeHAInfoResponseHeader.class);\n                return new BrokerSyncInfo(responseHeader.getMasterHaAddress(), responseHeader.getMasterFlushOffset(), responseHeader.getMasterAddress());\n            }\n            default:\n                break;\n        }\n\n        throw new MQBrokerException(response.getCode(), response.getRemark());\n    }\n\n    public void sendBrokerHaInfo(String brokerAddr, String masterHaAddr, long brokerInitMaxOffset, String masterAddr)\n        throws InterruptedException, RemotingTimeoutException, RemotingSendRequestException, RemotingConnectException, MQBrokerException {\n        ExchangeHAInfoRequestHeader requestHeader = new ExchangeHAInfoRequestHeader();\n        requestHeader.setMasterHaAddress(masterHaAddr);\n        requestHeader.setMasterFlushOffset(brokerInitMaxOffset);\n        requestHeader.setMasterAddress(masterAddr);\n\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.EXCHANGE_BROKER_HA_INFO, requestHeader);\n\n        RemotingCommand response = this.remotingClient.invokeSync(brokerAddr, request, 3000);\n\n        assert response != null;\n        switch (response.getCode()) {\n            case ResponseCode.SUCCESS: {\n                return;\n            }\n            default:\n                break;\n        }\n\n        throw new MQBrokerException(response.getCode(), response.getRemark());\n    }\n\n    public List<RegisterBrokerResult> registerBrokerAll(\n        final String clusterName,\n        final String brokerAddr,\n        final String brokerName,\n        final long brokerId,\n        final String haServerAddr,\n        final TopicConfigSerializeWrapper topicConfigWrapper,\n        final List<String> filterServerList,\n        final boolean oneway,\n        final int timeoutMills,\n        final boolean enableActingMaster,\n        final boolean compressed,\n        final BrokerIdentity brokerIdentity) {\n        return registerBrokerAll(clusterName,\n            brokerAddr,\n            brokerName,\n            brokerId,\n            haServerAddr,\n            topicConfigWrapper,\n            filterServerList,\n            oneway, timeoutMills,\n            enableActingMaster,\n            compressed,\n            null,\n            brokerIdentity);\n    }\n\n    /**\n     * Considering compression brings much CPU overhead to name server, stream API will not support compression and\n     * compression feature is deprecated.\n     *\n     * @param clusterName\n     * @param brokerAddr\n     * @param brokerName\n     * @param brokerId\n     * @param haServerAddr\n     * @param topicConfigWrapper\n     * @param filterServerList\n     * @param oneway\n     * @param timeoutMills\n     * @param compressed         default false\n     * @return\n     */\n    public List<RegisterBrokerResult> registerBrokerAll(\n        final String clusterName,\n        final String brokerAddr,\n        final String brokerName,\n        final long brokerId,\n        final String haServerAddr,\n        final TopicConfigSerializeWrapper topicConfigWrapper,\n        final List<String> filterServerList,\n        final boolean oneway,\n        final int timeoutMills,\n        final boolean enableActingMaster,\n        final boolean compressed,\n        final Long heartbeatTimeoutMillis,\n        final BrokerIdentity brokerIdentity) {\n\n        final List<RegisterBrokerResult> registerBrokerResultList = new CopyOnWriteArrayList<>();\n        List<String> nameServerAddressList = this.remotingClient.getAvailableNameSrvList();\n        if (nameServerAddressList != null && nameServerAddressList.size() > 0) {\n\n            final RegisterBrokerRequestHeader requestHeader = new RegisterBrokerRequestHeader();\n            requestHeader.setBrokerAddr(brokerAddr);\n            requestHeader.setBrokerId(brokerId);\n            requestHeader.setBrokerName(brokerName);\n            requestHeader.setClusterName(clusterName);\n            requestHeader.setHaServerAddr(haServerAddr);\n            requestHeader.setEnableActingMaster(enableActingMaster);\n            requestHeader.setCompressed(false);\n            if (heartbeatTimeoutMillis != null) {\n                requestHeader.setHeartbeatTimeoutMillis(heartbeatTimeoutMillis);\n            }\n\n            RegisterBrokerBody requestBody = new RegisterBrokerBody();\n            requestBody.setTopicConfigSerializeWrapper(TopicConfigAndMappingSerializeWrapper.from(topicConfigWrapper));\n            requestBody.setFilterServerList(filterServerList);\n            final byte[] body = requestBody.encode(compressed);\n            final int bodyCrc32 = UtilAll.crc32(body);\n            requestHeader.setBodyCrc32(bodyCrc32);\n            final CountDownLatch countDownLatch = new CountDownLatch(nameServerAddressList.size());\n            for (final String namesrvAddr : nameServerAddressList) {\n                brokerOuterExecutor.execute(new AbstractBrokerRunnable(brokerIdentity) {\n                    @Override\n                    public void run0() {\n                        try {\n                            RegisterBrokerResult result = registerBroker(namesrvAddr, oneway, timeoutMills, requestHeader, body);\n                            if (result != null) {\n                                registerBrokerResultList.add(result);\n                            }\n\n                            LOGGER.info(\"Registering current broker to name server completed. TargetHost={}\", namesrvAddr);\n                        } catch (Exception e) {\n                            LOGGER.error(\"Failed to register current broker to name server. TargetHost={}\", namesrvAddr, e);\n                        } finally {\n                            countDownLatch.countDown();\n                        }\n                    }\n                });\n            }\n\n            try {\n                if (!countDownLatch.await(timeoutMills, TimeUnit.MILLISECONDS)) {\n                    LOGGER.warn(\"Registration to one or more name servers does NOT complete within deadline. Timeout threshold: {}ms\", timeoutMills);\n                }\n            } catch (InterruptedException ignore) {\n            }\n        }\n\n        return registerBrokerResultList;\n    }\n\n    private RegisterBrokerResult registerBroker(\n        final String namesrvAddr,\n        final boolean oneway,\n        final int timeoutMills,\n        final RegisterBrokerRequestHeader requestHeader,\n        final byte[] body\n    ) throws RemotingCommandException, MQBrokerException, RemotingConnectException, RemotingSendRequestException, RemotingTimeoutException,\n        InterruptedException {\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.REGISTER_BROKER, requestHeader);\n        request.setBody(body);\n\n        if (oneway) {\n            try {\n                this.remotingClient.invokeOneway(namesrvAddr, request, timeoutMills);\n            } catch (RemotingTooMuchRequestException e) {\n                // Ignore\n            }\n            return null;\n        }\n\n        RemotingCommand response = this.remotingClient.invokeSync(namesrvAddr, request, timeoutMills);\n        assert response != null;\n        switch (response.getCode()) {\n            case ResponseCode.SUCCESS: {\n                RegisterBrokerResponseHeader responseHeader =\n                    (RegisterBrokerResponseHeader) response.decodeCommandCustomHeader(RegisterBrokerResponseHeader.class);\n                Register
{
    "key":"//broker/src/main/java/org/apache/rocketmq/broker/failover/EscapeBridge.java\npublic class EscapeBridge {\n    protected static final Logger LOG = LoggerFactory.getLogger(LoggerName.BROKER_LOGGER_NAME);\n    private static final long SEND_TIMEOUT = 3000L;\n    private static final long DEFAULT_PULL_TIMEOUT_MILLIS = 1000 * 10L;\n    private final String innerProducerGroupName;\n    private final String innerConsumerGroupName;\n\n    private final BrokerController brokerController;\n\n    private ExecutorService defaultAsyncSenderExecutor;\n\n    public EscapeBridge(BrokerController brokerController) {\n        this.brokerController = brokerController;\n        this.innerProducerGroupName = \"InnerProducerGroup_\" + brokerController.getBrokerConfig().getBrokerName() + \"_\" + brokerController.getBrokerConfig().getBrokerId();\n        this.innerConsumerGroupName = \"InnerConsumerGroup_\" + brokerController.getBrokerConfig().getBrokerName() + \"_\" + brokerController.getBrokerConfig().getBrokerId();\n    }\n\n    public void start() throws Exception {\n        if (brokerController.getBrokerConfig().isEnableSlaveActingMaster() && brokerController.getBrokerConfig().isEnableRemoteEscape()) {\n            final BlockingQueue<Runnable> asyncSenderThreadPoolQueue = new LinkedBlockingQueue<>(50000);\n            this.defaultAsyncSenderExecutor = ThreadUtils.newThreadPoolExecutor(\n                Runtime.getRuntime().availableProcessors(),\n                Runtime.getRuntime().availableProcessors(),\n                1000 * 60,\n                TimeUnit.MILLISECONDS,\n                asyncSenderThreadPoolQueue,\n                new ThreadFactoryImpl(\"AsyncEscapeBridgeExecutor_\", this.brokerController.getBrokerIdentity())\n            );\n            LOG.info(\"init executor for escaping messages asynchronously success.\");\n        }\n    }\n\n    public void shutdown() {\n        if (null != this.defaultAsyncSenderExecutor) {\n            this.defaultAsyncSenderExecutor.shutdown();\n        }\n    }\n\n    public PutMessageResult putMessage(MessageExtBrokerInner messageExt) {\n        BrokerController masterBroker = this.brokerController.peekMasterBroker();\n        if (masterBroker != null) {\n            return masterBroker.getMessageStore().putMessage(messageExt);\n        } else if (this.brokerController.getBrokerConfig().isEnableSlaveActingMaster()\n            && this.brokerController.getBrokerConfig().isEnableRemoteEscape()) {\n\n            try {\n                messageExt.setWaitStoreMsgOK(false);\n                final SendResult sendResult = putMessageToRemoteBroker(messageExt);\n                return transformSendResult2PutResult(sendResult);\n            } catch (Exception e) {\n                LOG.error(\"sendMessageInFailover to remote failed\", e);\n                return new PutMessageResult(PutMessageStatus.PUT_TO_REMOTE_BROKER_FAIL, null, true);\n            }\n        } else {\n            LOG.warn(\"Put message failed, enableSlaveActingMaster={}, enableRemoteEscape={}.\",\n                this.brokerController.getBrokerConfig().isEnableSlaveActingMaster(), this.brokerController.getBrokerConfig().isEnableRemoteEscape());\n            return new PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, null);\n        }\n    }\n\n    private SendResult putMessageToRemoteBroker(MessageExtBrokerInner messageExt) {\n        final boolean isTransHalfMessage = TransactionalMessageUtil.buildHalfTopic().equals(messageExt.getTopic());\n        MessageExtBrokerInner messageToPut = messageExt;\n        if (isTransHalfMessage) {\n            messageToPut = TransactionalMessageUtil.buildTransactionalMessageFromHalfMessage(messageExt);\n        }\n        final TopicPublishInfo topicPublishInfo = this.brokerController.getTopicRouteInfoManager().tryToFindTopicPublishInfo(messageToPut.getTopic());\n        if (null == topicPublishInfo || !topicPublishInfo.ok()) {\n            LOG.warn(\"putMessageToRemoteBroker: no route info of topic {} when escaping message, msgId={}\",\n                messageToPut.getTopic(), messageToPut.getMsgId());\n            return null;\n        }\n\n        final MessageQueue mqSelected = topicPublishInfo.selectOneMessageQueue(this.brokerController.getBrokerConfig().getBrokerName());\n\n        messageToPut.setQueueId(mqSelected.getQueueId());\n\n        final String brokerNameToSend = mqSelected.getBrokerName();\n        final String brokerAddrToSend = this.brokerController.getTopicRouteInfoManager().findBrokerAddressInPublish(brokerNameToSend);\n\n        final long beginTimestamp = System.currentTimeMillis();\n        try {\n            final SendResult sendResult = this.brokerController.getBrokerOuterAPI().sendMessageToSpecificBroker(\n                brokerAddrToSend, brokerNameToSend,\n                messageToPut, this.getProducerGroup(messageToPut), SEND_TIMEOUT);\n            if (null != sendResult && SendStatus.SEND_OK.equals(sendResult.getSendStatus())) {\n                return sendResult;\n            } else {\n                LOG.error(\"Escaping failed! cost {}ms, Topic: {}, MsgId: {}, Broker: {}\",\n                    System.currentTimeMillis() - beginTimestamp, messageExt.getTopic(),\n                    messageExt.getMsgId(), brokerNameToSend);\n            }\n        } catch (RemotingException | MQBrokerException e) {\n            LOG.error(String.format(\"putMessageToRemoteBroker exception, MsgId: %s, RT: %sms, Broker: %s\",\n                messageToPut.getMsgId(), System.currentTimeMillis() - beginTimestamp, mqSelected), e);\n        } catch (InterruptedException e) {\n            LOG.error(String.format(\"putMessageToRemoteBroker interrupted, MsgId: %s, RT: %sms, Broker: %s\",\n                messageToPut.getMsgId(), System.currentTimeMillis() - beginTimestamp, mqSelected), e);\n            Thread.currentThread().interrupt();\n        }\n\n        return null;\n    }\n\n    public CompletableFuture<PutMessageResult> asyncPutMessage(MessageExtBrokerInner messageExt) {\n        BrokerController masterBroker = this.brokerController.peekMasterBroker();\n        if (masterBroker != null) {\n            return masterBroker.getMessageStore().asyncPutMessage(messageExt);\n        } else if (this.brokerController.getBrokerConfig().isEnableSlaveActingMaster()\n            && this.brokerController.getBrokerConfig().isEnableRemoteEscape()) {\n            try {\n                messageExt.setWaitStoreMsgOK(false);\n\n                final TopicPublishInfo topicPublishInfo = this.brokerController.getTopicRouteInfoManager().tryToFindTopicPublishInfo(messageExt.getTopic());\n                final String producerGroup = getProducerGroup(messageExt);\n\n                final MessageQueue mqSelected = topicPublishInfo.selectOneMessageQueue();\n                messageExt.setQueueId(mqSelected.getQueueId());\n\n                final String brokerNameToSend = mqSelected.getBrokerName();\n                final String brokerAddrToSend = this.brokerController.getTopicRouteInfoManager().findBrokerAddressInPublish(brokerNameToSend);\n                final CompletableFuture<SendResult> future = this.brokerController.getBrokerOuterAPI().sendMessageToSpecificBrokerAsync(brokerAddrToSend,\n                    brokerNameToSend, messageExt,\n                    producerGroup, SEND_TIMEOUT);\n\n                return future.exceptionally(throwable -> null)\n                    .thenApplyAsync(sendResult -> transformSendResult2PutResult(sendResult), this.defaultAsyncSenderExecutor)\n                    .exceptionally(throwable -> transformSendResult2PutResult(null));\n\n            } catch (Exception e) {\n                LOG.error(\"sendMessageInFailover to remote failed\", e);\n                return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.PUT_TO_REMOTE_BROKER_FAIL, null, true));\n            }\n        } else {\n            LOG.warn(\"Put message failed, enableSlaveActingMaster={}, enableRemoteEscape={}.\",\n                this.brokerController.getBrokerConfig().isEnableSlaveActingMaster(), this.brokerController.getBrokerConfig().isEnableRemoteEscape());\n            return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, null));\n        }\n    }\n\n\n    private String getProducerGroup(MessageExtBrokerInner messageExt) {\n        if (null == messageExt) {\n            return this.innerProducerGroupName;\n        }\n        String producerGroup = messageExt.getProperty(MessageConst.PROPERTY_PRODUCER_GROUP);\n        if (StringUtils.isEmpty(producerGroup)) {\n            producerGroup = this.innerProducerGroupName;\n        }\n        return producerGroup;\n    }\n\n\n    public PutMessageResult putMessageToSpecificQueue(MessageExtBrokerInner messageExt) {\n        BrokerController masterBroker = this.brokerController.peekMasterBroker();\n        if (masterBroker != null) {\n            return masterBroker.getMessageStore().putMessage(messageExt);\n        } else if (this.brokerController.getBrokerConfig().isEnableSlaveActingMaster()\n            && this.brokerController.getBrokerConfig().isEnableRemoteEscape()) {\n            try {\n                messageExt.setWaitStoreMsgOK(false);\n\n                final TopicPublishInfo topicPublishInfo = this.brokerController.getTopicRouteInfoManager().tryToFindTopicPublishInfo(messageExt.getTopic());\n                List<MessageQueue> mqs = topicPublishInfo.getMessageQueueList();\n\n                if (null == mqs || mqs.isEmpty()) {\n                    return new PutMessageResult(PutMessageStatus.PUT_TO_REMOTE_BROKER_FAIL, null, true);\n                }\n\n                String id = messageExt.getTopic() + messageExt.getStoreHost();\n                final int index = Math.floorMod(id.hashCode(), mqs.size());\n\n                MessageQueue mq = mqs.get(index);\n                messageExt.setQueueId(mq.getQueueId());\n\n                String brokerNameToSend = mq.getBrokerName();\n                String brokerAddrToSend = this.brokerController.getTopicRouteInfoManager().findBrokerAddressInPublish(brokerNameToSend);\n                final SendResult sendResult = this.brokerController.getBrokerOuterAPI().sendMessageToSpecificBroker(\n                    brokerAddrToSend, brokerNameToSend,\n                    messageExt, this.getProducerGroup(messageExt), SEND_TIMEOUT);\n\n                return transformSendResult2PutResult(sendResult);\n            } catch (Exception e) {\n                LOG.error(\"sendMessageInFailover to remote failed\", e);\n                return new PutMessageResult(PutMessageStatus.PUT_TO_REMOTE_BROKER_FAIL, null, true);\n            }\n        } else {\n            LOG.warn(\"Put message to specific queue failed, enableSlaveActingMaster={}, enableRemoteEscape={}.\",\n                this.brokerController.getBrokerConfig().isEnableSlaveActingMaster(), this.brokerController.getBrokerConfig().isEnableRemoteEscape());\n            return new PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, null);\n        }\n    }\n\n    private PutMessageResult transformSendResult2PutResult(SendResult sendResult) {\n        if (sendResult == null) {\n            return new PutMessageResult(PutMessageStatus.PUT_TO_REMOTE_BROKER_FAIL, null, true);\n        }\n        switch (sendResult.getSendStatus()) {\n            case SEND_OK:\n                return new PutMessageResult(PutMessageStatus.PUT_OK, null, true);\n            case SLAVE_NOT_AVAILABLE:\n                return new PutMessageResult(PutMessageStatus.SLAVE_NOT_AVAILABLE, null, true);\n            case FLUSH_DISK_TIMEOUT:\n                return new PutMessageResult(PutMessageStatus.FLUSH_DISK_TIMEOUT, null, true);\n            case FLUSH_SLAVE_TIMEOUT:\n                return new PutMessageResult(PutMessageStatus.FLUSH_SLAVE_TIMEOUT, null, true);\n            default:\n                return new PutMessageResult(PutMessageStatus.PUT_TO_REMOTE_BROKER_FAIL, null, true);\n        }\n    }\n\n    public Pair<GetMessageStatus, MessageExt> getMessage(String topic, long offset, int queueId, String brokerName, boolean deCompressBody) {\n        return getMessageAsync(topic, offset, queueId, brokerName, deCompressBody).join();\n    }\n\n    public CompletableFuture<Pair<GetMessageStatus, MessageExt>> getMessageAsync(String topic, long offset, int queueId, String brokerName, boolean deCompressBody) {\n        MessageStore messageStore = brokerController.getMessageStoreByBrokerName(brokerName);\n        if (messageStore != null) {\n            return messageStore.getMessageAsync(innerConsumerGroupName, topic, queueId, offset, 1, null)\n                .thenApply(result -> {\n                    if (result == null) {\n                        LOG.warn(\"getMessageResult is null , innerConsumerGroupName {}, topic {}, offset {}, queueId {}\", innerConsumerGroupName, topic, offset, queueId);\n                        return new Pair<>(GetMessageStatus.MESSAGE_WAS_REMOVING, null);\n                    }\n                    List<MessageExt> list = decodeMsgList(result, deCompressBody);\n                    if (list == null || list.isEmpty()) {\n                        LOG.warn(\"Can not get msg , topic {}, offset {}, queueId {}, result is {}\", topic, offset, queueId, result);\n                        return new Pair<>(result.getStatus(), null);\n                    }\n                    return new Pair<>(result.getStatus(), list.get(0));\n                });\n        } else {\n            return getMessageFromRemoteAsync(topic, offset, queueId, brokerName)\n                .thenApply(msg -> {\n                    if (msg == null) {\n                        return new Pair<>(GetMessageStatus.MESSAGE_WAS_REMOVING, null);\n                    }\n                    return new Pair<>(GetMessageStatus.FOUND, msg);\n                });\n        }\n    }\n\n    protected List<MessageExt> decodeMsgList(GetMessageResult getMessageResult, boolean deCompressBody) {\n        List<MessageExt> foundList = new ArrayList<>();\n        try {\n            List<ByteBuffer> messageBufferList = getMessageResult.getMessageBufferList();\n            if (messageBufferList != null) {\n                for (int i = 0; i < messageBufferList.size(); i++) {\n                    ByteBuffer bb = messageBufferList.get(i);\n                    if (bb == null) {\n                        LOG.error(\"bb is null {}\", getMessageResult);\n                        continue;\n                    }\n                    MessageExt msgExt = MessageDecoder.decode(bb, true, deCompressBody);\n                    if (msgExt == null) {\n                        LOG.error(\"decode msgExt is null {}\", getMessageResult);\n                        continue;\n                    }\n                    // use CQ offset, not offset in Message\n                    msgExt.setQueueOffset(getMessageResult.getMessageQueueOffset().get(i));\n                    foundList.add(msgExt);\n                }\n            }\n        } finally {\n            getMessageResult.release();\n        }\n\n        return foundList;\n    }\n\n    protected MessageExt getMessageFromRemote(String topic, long offset, int queueId, String brokerName) {\n        return getMessageFromRemoteAsync(topic, offset, queueId, brokerName).join();\n    }\n\n    protected CompletableFuture<MessageExt> getMessageFromRemoteAsync(String topic, long offset, int queueId, String brokerName) {\n        try {\n            String brokerAddr = this.brokerController.getTopicRouteInfoManager().findBrokerAddressInSubscribe(brokerName, MixAll.MASTER_ID, false);\n            if (null == brokerAddr) {\n                this.brokerController.getTopicRouteInfoManager().updateTopicRouteInfoFromNameServer(topic, true, false);\n                brokerAddr = this.brokerController.getTopicRouteInfoManager().findBrokerAddressInSubscribe(brokerName, MixAll.MASTER_ID, false);\n\n                if (null == brokerAddr) {\n                    LOG.warn(\"can't find broker address for topic {}\", topic);\n                    return CompletableFuture.completedFuture(null);\n                }\n            }\n\n            return this.brokerController.getBrokerOuterAPI().pullMessageFromSpecificBrokerAsync(brokerName,\n                brokerAddr, this.innerConsumerGroupName, topic, queueId, offset, 1, DEFAULT_PULL_TIMEOUT_MILLIS)\n                .thenApply(pullResult -> {\n                    if (pullResult.getPullStatus().equals(PullStatus.FOUND) && !pullResult.getMsgFoundList().isEmpty()) {\n                        return pullResult.getMsgFoundList().get(0);\n                    }\n                    return null;\n                });\n        } catch (Exception e) {\n            LOG.error(\"Get message from remote failed.\", e);\n        }\n\n        return CompletableFuture.completedFuture(null);\n    }\n}\n",
    "reason":"domain",
    "justification":"The variables 'brokerConfig', 'topicConfigManager', 'consumerManager', 'offsetManager', 'consumerFilterManager', 'subscriptionGroupManager', 'messageStore', 'popBufferMergeService', and 'popInflightMessageCounter' are all related to the domain of managing broker configurations, consumer groups, topic configurations, message storage, and message consumption in a message queue system. Extracting these variables into a separate class would encapsulate the domain logic related to broker operations and improve modularity.",
    "suggestedName":"BrokerManagementContext"
}