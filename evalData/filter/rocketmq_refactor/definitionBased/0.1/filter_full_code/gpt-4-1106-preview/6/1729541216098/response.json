{
    "key":"public class BrokerConfig extends BrokerIdentity {\n\n    private String brokerConfigPath = null;\n\n    private String rocketmqHome = System.getProperty(MixAll.ROCKETMQ_HOME_PROPERTY, System.getenv(MixAll.ROCKETMQ_HOME_ENV));\n    @ImportantField\n    private String namesrvAddr = System.getProperty(MixAll.NAMESRV_ADDR_PROPERTY, System.getenv(MixAll.NAMESRV_ADDR_ENV));\n\n    /**\n     * Listen port for single broker\n     */\n    @ImportantField\n    private int listenPort = 6888;\n\n    @ImportantField\n    private String brokerIP1 = NetworkUtil.getLocalAddress();\n    private String brokerIP2 = NetworkUtil.getLocalAddress();\n\n    @ImportantField\n    private boolean recoverConcurrently = false;\n\n    private int brokerPermission = PermName.PERM_READ | PermName.PERM_WRITE;\n    private int defaultTopicQueueNums = 8;\n    @ImportantField\n    private boolean autoCreateTopicEnable = true;\n\n    private boolean clusterTopicEnable = true;\n\n    private boolean brokerTopicEnable = true;\n    @ImportantField\n    private boolean autoCreateSubscriptionGroup = true;\n    private String messageStorePlugIn = \"\";\n\n    private static final int PROCESSOR_NUMBER = Runtime.getRuntime().availableProcessors();\n    @ImportantField\n    private String msgTraceTopicName = TopicValidator.RMQ_SYS_TRACE_TOPIC;\n    @ImportantField\n    private boolean traceTopicEnable = false;\n    /**\n     * thread numbers for send message thread pool.\n     */\n    private int sendMessageThreadPoolNums = Math.min(PROCESSOR_NUMBER, 4);\n    private int putMessageFutureThreadPoolNums = Math.min(PROCESSOR_NUMBER, 4);\n    private int pullMessageThreadPoolNums = 16 + PROCESSOR_NUMBER * 2;\n    private int litePullMessageThreadPoolNums = 16 + PROCESSOR_NUMBER * 2;\n    private int ackMessageThreadPoolNums = 3;\n    private int processReplyMessageThreadPoolNums = 16 + PROCESSOR_NUMBER * 2;\n    private int queryMessageThreadPoolNums = 8 + PROCESSOR_NUMBER;\n\n    private int adminBrokerThreadPoolNums = 16;\n    private int clientManageThreadPoolNums = 32;\n    private int consumerManageThreadPoolNums = 32;\n    private int loadBalanceProcessorThreadPoolNums = 32;\n    private int heartbeatThreadPoolNums = Math.min(32, PROCESSOR_NUMBER);\n    private int recoverThreadPoolNums = 32;\n\n    /**\n     * Thread numbers for EndTransactionProcessor\n     */\n    private int endTransactionThreadPoolNums = Math.max(8 + PROCESSOR_NUMBER * 2,\n            sendMessageThreadPoolNums * 4);\n\n    private int flushConsumerOffsetInterval = 1000 * 5;\n\n    private int flushConsumerOffsetHistoryInterval = 1000 * 60;\n\n    @ImportantField\n    private boolean rejectTransactionMessage = false;\n\n    @ImportantField\n    private boolean fetchNameSrvAddrByDnsLookup = false;\n\n    @ImportantField\n    private boolean fetchNamesrvAddrByAddressServer = false;\n\n    private int sendThreadPoolQueueCapacity = 10000;\n    private int putThreadPoolQueueCapacity = 10000;\n    private int pullThreadPoolQueueCapacity = 100000;\n    private int litePullThreadPoolQueueCapacity = 100000;\n    private int ackThreadPoolQueueCapacity = 100000;\n    private int replyThreadPoolQueueCapacity = 10000;\n    private int queryThreadPoolQueueCapacity = 20000;\n    private int clientManagerThreadPoolQueueCapacity = 1000000;\n    private int consumerManagerThreadPoolQueueCapacity = 1000000;\n    private int heartbeatThreadPoolQueueCapacity = 50000;\n    private int endTransactionPoolQueueCapacity = 100000;\n    private int adminBrokerThreadPoolQueueCapacity = 10000;\n    private int loadBalanceThreadPoolQueueCapacity = 100000;\n\n    private boolean longPollingEnable = true;\n\n    private long shortPollingTimeMills = 1000;\n\n    private boolean notifyConsumerIdsChangedEnable = true;\n\n    private boolean highSpeedMode = false;\n\n    private int commercialBaseCount = 1;\n\n    private int commercialSizePerMsg = 4 * 1024;\n\n    private boolean accountStatsEnable = true;\n    private boolean accountStatsPrintZeroValues = true;\n\n    private boolean transferMsgByHeap = true;\n\n    private String regionId = MixAll.DEFAULT_TRACE_REGION_ID;\n    private int registerBrokerTimeoutMills = 24000;\n\n    private int sendHeartbeatTimeoutMillis = 1000;\n\n    private boolean slaveReadEnable = false;\n\n    private boolean disableConsumeIfConsumerReadSlowly = false;\n    private long consumerFallbehindThreshold = 1024L * 1024 * 1024 * 16;\n\n    private boolean brokerFastFailureEnable = true;\n    private long waitTimeMillsInSendQueue = 200;\n    private long waitTimeMillsInPullQueue = 5 * 1000;\n    private long waitTimeMillsInLitePullQueue = 5 * 1000;\n    private long waitTimeMillsInHeartbeatQueue = 31 * 1000;\n    private long waitTimeMillsInTransactionQueue = 3 * 1000;\n    private long waitTimeMillsInAckQueue = 3000;\n\n    private long startAcceptSendRequestTimeStamp = 0L;\n\n    private boolean traceOn = true;\n\n    // Switch of filter bit map calculation.\n    // If switch on:\n    // 1. Calculate filter bit map when construct queue.\n    // 2. Filter bit map will be saved to consume queue extend file if allowed.\n    private boolean enableCalcFilterBitMap = false;\n\n    //Reject the pull consumer instance to pull messages from broker.\n    private boolean rejectPullConsumerEnable = false;\n\n    // Expect num of consumers will use filter.\n    private int expectConsumerNumUseFilter = 32;\n\n    // Error rate of bloom filter, 1~100.\n    private int maxErrorRateOfBloomFilter = 20;\n\n    //how long to clean filter data after dead.Default: 24h\n    private long filterDataCleanTimeSpan = 24 * 3600 * 1000;\n\n    // whether do filter when retry.\n    private boolean filterSupportRetry = false;\n    private boolean enablePropertyFilter = false;\n\n    private boolean compressedRegister = false;\n\n    private boolean forceRegister = true;\n\n    /**\n     * This configurable item defines interval of topics registration of broker to name server. Allowing values are\n     * between 10,000 and 60,000 milliseconds.\n     */\n    private int registerNameServerPeriod = 1000 * 30;\n\n    /**\n     * the interval to send heartbeat to name server for liveness detection.\n     */\n    private int brokerHeartbeatInterval = 1000;\n\n    /**\n     * How long the broker will be considered as inactive by nameserver since last heartbeat. Effective only if\n     * enableSlaveActingMaster is true\n     */\n    private long brokerNotActiveTimeoutMillis = 10 * 1000;\n\n    private boolean enableNetWorkFlowControl = false;\n\n    private boolean enableBroadcastOffsetStore = true;\n\n    private long broadcastOffsetExpireSecond = 2 * 60;\n\n    private long broadcastOffsetExpireMaxSecond = 5 * 60;\n\n    private int popPollingSize = 1024;\n    private int popPollingMapSize = 100000;\n    // 20w cost 200M heap memory.\n    private long maxPopPollingSize = 100000;\n    private int reviveQueueNum = 8;\n    private long reviveInterval = 1000;\n    private long reviveMaxSlow = 3;\n    private long reviveScanTime = 10000;\n    private boolean enableSkipLongAwaitingAck = false;\n    private long reviveAckWaitMs = TimeUnit.MINUTES.toMillis(3);\n    private boolean enablePopLog = false;\n    private boolean enablePopBufferMerge = false;\n    private int popCkStayBufferTime = 10 * 1000;\n    private int popCkStayBufferTimeOut = 3 * 1000;\n    private int popCkMaxBufferSize = 200000;\n    private int popCkOffsetMaxQueueSize = 20000;\n    private boolean enablePopBatchAck = false;\n    private boolean enableNotifyAfterPopOrderLockRelease = true;\n    private boolean initPopOffsetByCheckMsgInMem = true;\n    // read message from pop retry topic v1, for the compatibility, will be removed in the future version\n    private boolean retrieveMessageFromPopRetryTopicV1 = true;\n    private boolean enableRetryTopicV2 = false;\n\n    private boolean realTimeNotifyConsumerChange = true;\n\n    private boolean litePullMessageEnable = true;\n\n    // The period to sync broker member group from namesrv, default value is 1 second\n    private int syncBrokerMemberGroupPeriod = 1000;\n\n    /**\n     * the interval of pulling topic information from the named server\n     */\n    private long loadBalancePollNameServerInterval = 1000 * 30;\n\n    /**\n     * the interval of cleaning\n     */\n    private int cleanOfflineBrokerInterval = 1000 * 30;\n\n    private boolean serverLoadBalancerEnable = true;\n\n    private MessageRequestMode defaultMessageRequestMode = MessageRequestMode.PULL;\n\n    private int defaultPopShareQueueNum = -1;\n\n    /**\n     * The minimum time of the transactional message  to be checked firstly, one message only exceed this time interval\n     * that can be checked.\n     */\n    @ImportantField\n    private long transactionTimeOut = 6 * 1000;\n\n    /**\n     * The maximum number of times the message was checked, if exceed this value, this message will be discarded.\n     */\n    @ImportantField\n    private int transactionCheckMax = 15;\n\n    /**\n     * Transaction message check interval.\n     */\n    @ImportantField\n    private long transactionCheckInterval = 30 * 1000;\n\n    private long transactionMetricFlushInterval = 3 * 1000;\n\n    /**\n     * transaction batch op message\n     */\n    private int transactionOpMsgMaxSize = 4096;\n\n    private int transactionOpBatchInterval = 3000;\n\n    /**\n     * Acl feature switch\n     */\n    @ImportantField\n    private boolean aclEnable = false;\n\n    private boolean storeReplyMessageEnable = true;\n\n    private boolean enableDetailStat = true;\n\n    private boolean autoDeleteUnusedStats = false;\n\n    /**\n     * Whether to distinguish log paths when multiple brokers are deployed on the same machine\n     */\n    private boolean isolateLogEnable = false;\n\n    private long forwardTimeout = 3 * 1000;\n\n    /**\n     * Slave will act master when failover. For example, if master down, timer or transaction message which is expire in slave will\n     * put to master (master of the same process in broker container mode or other masters in cluster when enableFailoverRemotingActing is true)\n     * when enableSlaveActingMaster is true\n     */\n    private boolean enableSlaveActingMaster = false;\n\n    private boolean enableRemoteEscape = false;\n\n    private boolean skipPreOnline = false;\n\n    private boolean asyncSendEnable = true;\n\n    private boolean useServerSideResetOffset = true;\n\n    private long consumerOffsetUpdateVersionStep = 500;\n\n    private long delayOffsetUpdateVersionStep = 200;\n\n    /**\n     * Whether to lock quorum replicas.\n     *\n     * True: need to lock quorum replicas succeed. False: only need to lock one replica succeed.\n     */\n    private boolean lockInStrictMode = false;\n\n    private boolean compatibleWithOldNameSrv = true;\n\n    /**\n     * Is startup controller mode, which support auto switch broker's role.\n     */\n    private boolean enableControllerMode = false;\n\n    private String controllerAddr = \"\";\n\n    private boolean fetchControllerAddrByDnsLookup = false;\n\n    private long syncBrokerMetadataPeriod = 5 * 1000;\n\n    private long checkSyncStateSetPeriod = 5 * 1000;\n\n    private long syncControllerMetadataPeriod = 10 * 1000;\n\n    private long controllerHeartBeatTimeoutMills = 10 * 1000;\n\n    private boolean validateSystemTopicWhenUpdateTopic = true;\n\n    /**\n     * It is an important basis for the controller to choose the broker master.\n     * The lower the value of brokerElectionPriority, the higher the priority of the broker being selected as the master.\n     * You can set a lower priority for the broker with better machine conditions.\n     */\n    private int brokerElectionPriority = Integer.MAX_VALUE;\n\n    private boolean useStaticSubscription = false;\n\n    private MetricsExporterType metricsExporterType = MetricsExporterType.DISABLE;\n\n    private int metricsOtelCardinalityLimit = 50 * 1000;\n    private String metricsGrpcExporterTarget = \"\";\n    private String metricsGrpcExporterHeader = \"\";\n    private long metricGrpcExporterTimeOutInMills = 3 * 1000;\n    private long metricGrpcExporterIntervalInMills = 60 * 1000;\n    private long metricLoggingExporterIntervalInMills = 10 * 1000;\n\n    private int metricsPromExporterPort = 5557;\n    private String metricsPromExporterHost = \"\";\n\n    // Label pairs in CSV. Each label follows pattern of Key:Value. eg: instance_id:xxx,uid:xxx\n    private String metricsLabel = \"\";\n\n    private boolean metricsInDelta = false;\n\n    private long channelExpiredTimeout = 1000 * 120;\n    private long subscriptionExpiredTimeout = 1000 * 60 * 10;\n\n    // remoting\n    private boolean enableRemotingLocalProxyGrpc = true;\n    private int localProxyConnectTimeoutMs = 3000;\n    private String remotingAccessAddr = \"\";\n    private int remotingListenPort = 8080;\n\n    // related to proxy's send strategy in cluster mode.\n    private boolean sendLatencyEnable = false;\n    private boolean startDetectorEnable = false;\n    private int detectTimeout = 200;\n    private int detectInterval = 2 * 1000;\n\n    private int remotingHeartbeatThreadPoolNums = 2 * PROCESSOR_NUMBER;\n    private int remotingTopicRouteThreadPoolNums = 2 * PROCESSOR_NUMBER;\n    private int remotingSendMessageThreadPoolNums = 4 * PROCESSOR_NUMBER;\n    private int remotingPullMessageThreadPoolNums = 4 * PROCESSOR_NUMBER;\n    private int remotingUpdateOffsetThreadPoolNums = 4 * PROCESSOR_NUMBER;\n    private int remotingDefaultThreadPoolNums = 4 * PROCESSOR_NUMBER;\n\n    private int remotingHeartbeatThreadPoolQueueCapacity = 50000;\n    private int remotingTopicRouteThreadPoolQueueCapacity = 50000;\n    private int remotingSendThreadPoolQueueCapacity = 10000;\n    private int remotingPullThreadPoolQueueCapacity = 50000;\n    private int remotingUpdateOffsetThreadPoolQueueCapacity = 10000;\n    private int remotingDefaultThreadPoolQueueCapacity = 50000;\n\n    private long remotingWaitTimeMillsInSendQueue = 3 * 1000;\n    private long remotingWaitTimeMillsInPullQueue = 5 * 1000;\n    private long remotingWaitTimeMillsInHeartbeatQueue = 31 * 1000;\n    private long remotingWaitTimeMillsInUpdateOffsetQueue = 3 * 1000;\n    private long remotingWaitTimeMillsInTopicRouteQueue = 3 * 1000;\n    private long remotingWaitTimeMillsInDefaultQueue = 3 * 1000;\n\n    private boolean enableBatchAck = false;\n\n}",
    "reason":"size",
    "justification":"The data clump is chosen because it contains a large number of parameters/fields, which can be a sign of poor class design and can lead to more complex code when trying to understand or change it.",
    "suggestedName":"BrokerConfiguration"
}