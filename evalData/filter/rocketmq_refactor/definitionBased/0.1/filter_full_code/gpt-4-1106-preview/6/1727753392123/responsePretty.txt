"{
    "key":"//common/src/main/java/org/apache/rocketmq/common/BrokerConfig.java\npackage org.apache.rocketmq.common;\n\npublic class BrokerConfig extends BrokerIdentity {\n\n    private String brokerConfigPath = null;\n\n    private String rocketmqHome = System.getProperty(MixAll.ROCKETMQ_HOME_PROPERTY, System.getenv(MixAll.ROCKETMQ_HOME_ENV));\n    @ImportantField\n    private String namesrvAddr = System.getProperty(MixAll.NAMESRV_ADDR_PROPERTY, System.getenv(MixAll.NAMESRV_ADDR_ENV));\n\n    /**\n     * Listen port for single broker\n     */\n    @ImportantField\n    private int listenPort = 6888;\n\n    @ImportantField\n    private String brokerIP1 = NetworkUtil.getLocalAddress();\n    private String brokerIP2 = NetworkUtil.getLocalAddress();\n\n    @ImportantField\n    private boolean recoverConcurrently = false;\n\n    private int brokerPermission = PermName.PERM_READ | PermName.PERM_WRITE;\n    private int defaultTopicQueueNums = 8;\n    @ImportantField\n    private boolean autoCreateTopicEnable = true;\n\n    private boolean clusterTopicEnable = true;\n\n    private boolean brokerTopicEnable = true;\n    @ImportantField\n    private boolean autoCreateSubscriptionGroup = true;\n    private String messageStorePlugIn = \"\";\n\n    private static final int PROCESSOR_NUMBER = Runtime.getRuntime().availableProcessors();\n    @ImportantField\n    private String msgTraceTopicName = TopicValidator.RMQ_SYS_TRACE_TOPIC;\n    @ImportantField\n    private boolean traceTopicEnable = false;\n    /**\n     * thread numbers for send message thread pool.\n     */\n    private int sendMessageThreadPoolNums = Math.min(PROCESSOR_NUMBER, 4);\n    private int putMessageFutureThreadPoolNums = Math.min(PROCESSOR_NUMBER, 4);\n    private int pullMessageThreadPoolNums = 16 + PROCESSOR_NUMBER * 2;\n    private int litePullMessageThreadPoolNums = 16 + PROCESSOR_NUMBER * 2;\n    private int ackMessageThreadPoolNums = 3;\n    private int processReplyMessageThreadPoolNums = 16 + PROCESSOR_NUMBER * 2;\n    private int queryMessageThreadPoolNums = 8 + PROCESSOR_NUMBER;\n\n    private int adminBrokerThreadPoolNums = 16;\n    private int clientManageThreadPoolNums = 32;\n    private int consumerManageThreadPoolNums = 32;\n    private int loadBalanceProcessorThreadPoolNums = 32;\n    private int heartbeatThreadPoolNums = Math.min(32, PROCESSOR_NUMBER);\n    private int recoverThreadPoolNums = 32;\n\n    /**\n     * Thread numbers for EndTransactionProcessor\n     */\n    private int endTransactionThreadPoolNums = Math.max(8 + PROCESSOR_NUMBER * 2,\n            sendMessageThreadPoolNums * 4);\n\n    private int flushConsumerOffsetInterval = 1000 * 5;\n\n    private int flushConsumerOffsetHistoryInterval = 1000 * 60;\n\n    @ImportantField\n    private boolean rejectTransactionMessage = false;\n\n    @ImportantField\n    private boolean fetchNameSrvAddrByDnsLookup = false;\n\n    @ImportantField\n    private boolean fetchNamesrvAddrByAddressServer = false;\n\n    private int sendThreadPoolQueueCapacity = 10000;\n    private int putThreadPoolQueueCapacity = 10000;\n    private int pullThreadPoolQueueCapacity = 100000;\n    private int litePullThreadPoolQueueCapacity = 100000;\n    private int ackThreadPoolQueueCapacity = 100000;\n    private int replyThreadPoolQueueCapacity = 10000;\n    private int queryThreadPoolQueueCapacity = 20000;\n    private int clientManagerThreadPoolQueueCapacity = 1000000;\n    private int consumerManagerThreadPoolQueueCapacity = 1000000;\n    private int heartbeatThreadPoolQueueCapacity = 50000;\n    private int endTransactionPoolQueueCapacity = 100000;\n    private int adminBrokerThreadPoolQueueCapacity = 10000;\n    private int loadBalanceThreadPoolQueueCapacity = 100000;\n\n    private boolean longPollingEnable = true;\n\n    private long shortPollingTimeMills = 1000;\n\n    private boolean notifyConsumerIdsChangedEnable = true;\n\n    private boolean highSpeedMode = false;\n\n    private int commercialBaseCount = 1;\n\n    private int commercialSizePerMsg = 4 * 1024;\n\n    private boolean accountStatsEnable = true;\n    private boolean accountStatsPrintZeroValues = true;\n\n    private boolean transferMsgByHeap = true;\n\n    private String regionId = MixAll.DEFAULT_TRACE_REGION_ID;\n    private int registerBrokerTimeoutMills = 24000;\n\n    private int sendHeartbeatTimeoutMillis = 1000;\n\n    private boolean slaveReadEnable = false;\n\n    private boolean disableConsumeIfConsumerReadSlowly = false;\n    private long consumerFallbehindThreshold = 1024L * 1024 * 1024 * 16;\n\n    private boolean brokerFastFailureEnable = true;\n    private long waitTimeMillsInSendQueue = 200;\n    private long waitTimeMillsInPullQueue = 5 * 1000;\n    private long waitTimeMillsInLitePullQueue = 5 * 1000;\n    private long waitTimeMillsInHeartbeatQueue = 31 * 1000;\n    private long waitTimeMillsInTransactionQueue = 3 * 1000;\n    private long waitTimeMillsInAckQueue = 3000;\n\n    private long startAcceptSendRequestTimeStamp = 0L;\n\n    private boolean traceOn = true;\n\n    // Switch of filter bit map calculation.\n    // If switch on:\n    // 1. Calculate filter bit map when construct queue.\n    // 2. Filter bit map will be saved to consume queue extend file if allowed.\n    private boolean enableCalcFilterBitMap = false;\n\n    //Reject the pull consumer instance to pull messages from broker.\n    private boolean rejectPullConsumerEnable = false;\n\n    // Expect num of consumers will use filter.\n    private int expectConsumerNumUseFilter = 32;\n\n    // Error rate of bloom filter, 1~100.\n    private int maxErrorRateOfBloomFilter = 20;\n\n    //how long to clean filter data after dead.Default: 24h\n    private long filterDataCleanTimeSpan = 24 * 3600 * 1000;\n\n    // whether do filter when retry.\n    private boolean filterSupportRetry = false;\n    private boolean enablePropertyFilter = false;\n\n    private boolean compressedRegister = false;\n\n    private boolean forceRegister = true;\n\n    /**\n     * This configurable item defines interval of topics registration of broker to name server. Allowing values are\n     * between 10,000 and 60,000 milliseconds.\n     */\n    private int registerNameServerPeriod = 1000 * 30;\n\n    /**\n     * the interval to send heartbeat to name server for liveness detection.\n     */\n    private int brokerHeartbeatInterval = 1000;\n\n    /**\n     * How long the broker will be considered as inactive by nameserver since last heartbeat. Effective only if\n     * enableSlaveActingMaster is true\n     */\n    private long brokerNotActiveTimeoutMillis = 10 * 1000;\n\n    private boolean enableNetWorkFlowControl = false;\n\n    private boolean enableBroadcastOffsetStore = true;\n\n    private long broadcastOffsetExpireSecond = 2 * 60;\n\n    private long broadcastOffsetExpireMaxSecond = 5 * 60;\n\n    private int popPollingSize = 1024;\n    private int popPollingMapSize = 100000;\n    // 20w cost 200M heap memory.\n    private long maxPopPollingSize = 100000;\n    private int reviveQueueNum = 8;\n    private long reviveInterval = 1000;\n    private long reviveMaxSlow = 3;\n    private long reviveScanTime = 10000;\n    private boolean enableSkipLongAwaitingAck = false;\n    private long reviveAckWaitMs = TimeUnit.MINUTES.toMillis(3);\n    private boolean enablePopLog = false;\n    private boolean enablePopBufferMerge = false;\n    private int popCkStayBufferTime = 10 * 1000;\n    private int popCkStayBufferTimeOut = 3 * 1000;\n    private int popCkMaxBufferSize = 200000;\n    private int popCkOffsetMaxQueueSize = 20000;\n    private boolean enablePopBatchAck = false;\n    private boolean enableNotifyAfterPopOrderLockRelease = true;\n    private boolean initPopOffsetByCheckMsgInMem = true;\n    // read message from pop retry topic v1, for the compatibility, will be removed in the future version\n    private boolean retrieveMessageFromPopRetryTopicV1 = true;\n    private boolean enableRetryTopicV2 = false;\n\n    private boolean realTimeNotifyConsumerChange = true;\n\n    private boolean litePullMessageEnable = true;\n\n    // The period to sync broker member group from namesrv, default value is 1 second\n    private int syncBrokerMemberGroupPeriod = 1000;\n\n    /**\n     * the interval of pulling topic information from the named server\n     */\n    private long loadBalancePollNameServerInterval = 1000 * 30;\n\n    /**\n     * the interval of cleaning\n     */\n    private int cleanOfflineBrokerInterval = 1000 * 30;\n\n    private boolean serverLoadBalancerEnable = true;\n\n    private MessageRequestMode defaultMessageRequestMode = MessageRequestMode.PULL;\n\n    private int defaultPopShareQueueNum = -1;\n\n    /**\n     * The minimum time of the transactional message  to be checked firstly, one message only exceed this time interval\n     * that can be checked.\n     */\n    @ImportantField\n    private long transactionTimeOut = 6 * 1000;\n\n    /**\n     * The maximum number of times the message was checked, if exceed this value, this message will be discarded.\n     */\n    @ImportantField\n    private int transactionCheckMax = 15;\n\n    /**\n     * Transaction message check interval.\n     */\n    @ImportantField\n    private long transactionCheckInterval = 30 * 1000;\n\n    private long transactionMetricFlushInterval = 3 * 1000;\n\n    /**\n     * transaction batch op message\n     */\n    private int transactionOpMsgMaxSize = 4096;\n\n    private int transactionOpBatchInterval = 3000;\n\n    /**\n     * Acl feature switch\n     */\n    @ImportantField\n    private boolean aclEnable = false;\n\n    private boolean storeReplyMessageEnable = true;\n\n    private boolean enableDetailStat = true;\n\n    private boolean autoDeleteUnusedStats = false;\n\n    /**\n     * Whether to distinguish log paths when multiple brokers are deployed on the same machine\n     */\n    private boolean isolateLogEnable = false;\n\n    private long forwardTimeout = 3 * 1000;\n\n    /**\n     * Slave will act master when failover. For example, if master down, timer or transaction message which is expire in slave will\n     * put to master (master of the same process in broker container mode or other masters in cluster when enableFailoverRemotingActing is true)\n     * when enableSlaveActingMaster is true\n     */\n    private boolean enableSlaveActingMaster = false;\n\n    private boolean enableRemoteEscape = false;\n\n    private boolean skipPreOnline = false;\n\n    private boolean asyncSendEnable = true;\n\n    private boolean useServerSideResetOffset = true;\n\n    private long consumerOffsetUpdateVersionStep = 500;\n\n    private long delayOffsetUpdateVersionStep = 200;\n\n    /**\n     * Whether to lock quorum replicas.\n     *\n     * True: need to lock quorum replicas succeed. False: only need to lock one replica succeed.\n     */\n    private boolean lockInStrictMode = false;\n\n    private boolean compatibleWithOldNameSrv = true;\n\n    /**\n     * Is startup controller mode, which support auto switch broker's role.\n     */\n    private boolean enableControllerMode = false;\n\n    private String controllerAddr = \"\";\n\n    private boolean fetchControllerAddrByDnsLookup = false;\n\n    private long syncBrokerMetadataPeriod = 5 * 1000;\n\n    private long checkSyncStateSetPeriod = 5 * 1000;\n\n    private long syncControllerMetadataPeriod = 10 * 1000;\n\n    private long controllerHeartBeatTimeoutMills = 10 * 1000;\n\n    private boolean validateSystemTopicWhenUpdateTopic = true;\n\n    /**\n     * It is an important basis for the controller to choose the broker master.\n     * The lower the value of brokerElectionPriority, the higher the priority of the broker being selected as the master.\n     * You can set a lower priority for the broker with better machine conditions.\n     */\n    private int brokerElectionPriority = Integer.MAX_VALUE;\n\n    private boolean useStaticSubscription = false;\n\n    private MetricsExporterType metricsExporterType = MetricsExporterType.DISABLE;\n\n    private int metricsOtelCardinalityLimit = 50 * 1000;\n    private String metricsGrpcExporterTarget = \"\";\n    private String metricsGrpcExporterHeader = \"\";\n    private long metricGrpcExporterTimeOutInMills = 3 * 1000;\n    private long metricGrpcExporterIntervalInMills = 60 * 1000;\n    private long metricLoggingExporterIntervalInMills = 10 * 1000;\n\n    private int metricsPromExporterPort = 5557;\n    private String metricsPromExporterHost = \"\";\n\n    // Label pairs in CSV. Each label follows pattern of Key:Value. eg: instance_id:xxx,uid:xxx\n    private String metricsLabel = \"\";\n\n    private boolean metricsInDelta = false;\n\n    private long channelExpiredTimeout = 1000 * 120;\n    private long subscriptionExpiredTimeout = 1000 * 60 * 10;\n\n    /**\n     * Estimate accumulation or not when subscription filter type is tag and is not SUB_ALL.\n     */\n    private boolean estimateAccumulation = true;\n\n    private boolean coldCtrStrategyEnable = false;\n    private boolean usePIDColdCtrStrategy = true;\n    private long cgColdReadThreshold = 3 * 1024 * 1024;\n    private long globalColdReadThreshold = 100 * 1024 * 1024;\n    \n    /**\n     * The interval to fetch namesrv addr, default value is 10 second\n     */\n    private long fetchNamesrvAddrInterval = 10 * 1000;\n\n    /**\n     * Pop response returns the actual retry topic rather than tampering with the original topic\n     */\n    private boolean popResponseReturnActualRetryTopic = false;\n\n    /**\n     * If both the deleteTopicWithBrokerRegistration flag in the NameServer configuration and this flag are set to true,\n     * it guarantees the ultimate consistency of data between the broker and the nameserver during topic deletion.\n     */\n    private boolean enableSingleTopicRegister = false;\n\n    private boolean enableMixedMessageType = false;\n\n    /**\n     * This flag and deleteTopicWithBrokerRegistration flag in the NameServer cannot be set to true at the same time,\n     * otherwise there will be a loss of routing\n     */\n    private boolean enableSplitRegistration = false;\n\n    private long popInflightMessageThreshold = 10000;\n    private boolean enablePopMessageThreshold = false;\n\n    private int splitRegistrationSize = 800;\n\n    /**\n     * Config in this black list will be not allowed to update by command.\n     * Try to update this config black list by restart process.\n     * Try to update configures in black list by restart process.\n     */\n    private String configBlackList = \"configBlackList;brokerConfigPath\";\n\n    public String getConfigBlackList() {\n        return configBlackList;\n    }\n\n    public void setConfigBlackList(String configBlackList) {\n        this.configBlackList = configBlackList;\n    }\n\n    public long getMaxPopPollingSize() {\n        return maxPopPollingSize;\n    }\n\n    public void setMaxPopPollingSize(long maxPopPollingSize) {\n        this.maxPopPollingSize = maxPopPollingSize;\n    }\n\n    public int getReviveQueueNum() {\n        return reviveQueueNum;\n    }\n\n    public void setReviveQueueNum(int reviveQueueNum) {\n        this.reviveQueueNum = reviveQueueNum;\n    }\n\n    public long getReviveInterval() {\n        return reviveInterval;\n    }\n\n    public void setReviveInterval(long reviveInterval) {\n        this.reviveInterval = reviveInterval;\n    }\n\n    public int getPopCkStayBufferTime() {\n        return popCkStayBufferTime;\n    }\n\n    public void setPopCkStayBufferTime(int popCkStayBufferTime) {\n        this.popCkStayBufferTime = popCkStayBufferTime;\n    }\n\n    public int getPopCkStayBufferTimeOut() {\n        return popCkStayBufferTimeOut;\n    }\n\n    public void setPopCkStayBufferTimeOut(int popCkStayBufferTimeOut) {\n        this.popCkStayBufferTimeOut = popCkStayBufferTimeOut;\n    }\n\n    public int getPopPollingMapSize() {\n        return popPollingMapSize;\n    }\n\n    public void setPopPollingMapSize(int popPollingMapSize) {\n        this.popPollingMapSize = popPollingMapSize;\n    }\n\n    public long getReviveScanTime() {\n       
{
    "key":"//broker/src/main/java/org/apache/rocketmq/broker/metrics/ConsumerLagCalculator.java\npackage org.apache.rocketmq.broker.metrics;\n\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.function.Consumer;\nimport java.util.stream.Collectors;\nimport org.apache.rocketmq.broker.BrokerController;\nimport org.apache.rocketmq.broker.client.ConsumerGroupInfo;\nimport org.apache.rocketmq.broker.client.ConsumerManager;\nimport org.apache.rocketmq.broker.filter.ConsumerFilterData;\nimport org.apache.rocketmq.broker.filter.ConsumerFilterManager;\nimport org.apache.rocketmq.broker.offset.ConsumerOffsetManager;\nimport org.apache.rocketmq.broker.processor.PopBufferMergeService;\nimport org.apache.rocketmq.broker.processor.PopInflightMessageCounter;\nimport org.apache.rocketmq.broker.subscriptionscript.SubscriptionGroupManager;\nimport org.apache.rocketmq.broker.topic.TopicConfigManager;\nimport org.apache.rocketmq.common.BrokerConfig;\nimport org.apache.rocketmq.common.KeyBuilder;\nimport org.apache.rocketmq.common.MixAll;\nimport org.apache.rocketmq.common.Pair;\nimport org.apache.rocketmq.common.constant.LoggerName;\nimport org.apache.rocketmq.common.constant.PermName;\nimport org.apache.rocketmq.common.filter.ExpressionType;\nimport org.apache.rocketmq.common.message.MessageStore;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\nimport org.apache.rocketmq.remoting.protocol.BrokerSyncInfo;\nimport org.apache.rocketmq.remoting.protocol.DataVersion;\nimport org.apache.rocketmq.remoting.protocol.RemotingSerializable;\nimport org.apache.rocketmq.remoting.protocol.RequestCode;\nimport org.apache.rocketmq.remoting.protocol.ResponseCode;\nimport org.apache.rocketmq.remoting.protocol.body.BrokerMemberGroup;\nimport org.apache.rocketmq.remoting.protocol.body.ClusterInfo;\nimport org.apache.rocketmq.remoting.protocol.body.ConsumerOffsetSerializeWrapper;\nimport org.apache.rocketmq.remoting.protocol.body.ElectMasterResponseBody;\nimport org.apache.rocketmq.remoting.protocol.body.GetBrokerMemberGroupResponseBody;\nimport org.apache.rocketmq.remoting.protocol.body.GetMaxOffsetRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.body.GetMaxOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.GetMinOffsetRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.body.GetMinOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.KVTable;\nimport org.apache.rocketmq.remoting.protocol.body.LockBatchRequestBody;\nimport org.apache.rocketmq.remoting.protocol.body.LockBatchResponseBody;\nimport org.apache.rocketmq.remoting.protocol.body.MessageRequestModeSerializeWrapper;\nimport org.apache.rocketmq.remoting.protocol.body.RegisterBrokerBody;\nimport org.apache.rocketmq.remoting.protocol.body.SubscriptionGroupWrapper;\nimport org.apache.rocketmq.remoting.protocol.body.TopicConfigAndMappingSerializeWrapper;\nimport org.apache.rocketmq.remoting.protocol.body.TopicConfigSerializeWrapper;\nimport org.apache.rocketmq.remoting.protocol.header.ExchangeHAInfoRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.ExchangeHAInfoResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.GetBrokerMemberGroupRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.GetMaxOffsetRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.GetMaxOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.GetMinOffsetRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.GetMinOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.LockBatchMqRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.PullMessageRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.PullMessageResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.SendMessageRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.SendMessageRequestHeaderV2;\nimport org.apache.rocketmq.remoting.protocol.header.SendMessageResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.UnlockBatchMqRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.controller.AlterSyncStateSetRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.controller.ElectMasterRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.controller.ElectMasterResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.controller.GetMetaDataResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.controller.GetReplicaInfoRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.controller.GetReplicaInfoResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.controller.register.ApplyBrokerIdRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.controller.register.ApplyBrokerIdResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.controller.register.GetNextBrokerIdRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.controller.register.GetNextBrokerIdResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.controller.register.RegisterBrokerToControllerRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.controller.register.RegisterBrokerToControllerResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.namesrv.BrokerHeartbeatRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.namesrv.GetRouteInfoRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.namesrv.QueryDataVersionRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.namesrv.QueryDataVersionResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.namesrv.RegisterBrokerRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.namesrv.RegisterBrokerResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.namesrv.RegisterTopicRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.namesrv.UnRegisterBrokerRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.heartbeat.SubscriptionData;\nimport org.apache.rocketmq.remoting.protocol.namesrv.RegisterBrokerResult;\nimport org.apache.rocketmq.remoting.protocol.route.BrokerData;\nimport org.apache.rocketmq.remoting.protocol.route.QueueData;\nimport org.apache.rocketmq.remoting.protocol.route.TopicRouteData;\nimport org.apache.rocketmq.remoting.rpc.ClientMetadata;\nimport org.apache.rocketmq.remoting.rpc.RpcClient;\nimport org.apache.rocketmq.remoting.rpc.RpcClientImpl;\nimport org.apache.rocketmq.remoting.rpc.RpcHook;\nimport org.apache.rocketmq.store.DefaultMessageFilter;\nimport org.apache.rocketmq.store.MessageStore;\nimport org.apache.rocketmq.store.PutMessageResult;\nimport org.apache.rocketmq.store.PutMessageStatus;\n\npublic class ConsumerLagCalculator {\n    private final BrokerConfig brokerConfig;\n    private final TopicConfigManager topicConfigManager;\n    private final ConsumerManager consumerManager;\n    private final ConsumerOffsetManager offsetManager;\n    private final ConsumerFilterManager consumerFilterManager;\n    private final SubscriptionGroupManager subscriptionGroupManager;\n    private final MessageStore messageStore;\n    private final PopBufferMergeService popBufferMergeService;\n    private final PopInflightMessageCounter popInflightMessageCounter;\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(LoggerName.BROKER_LOGGER_NAME);\n\n    public ConsumerLagCalculator(BrokerController brokerController) {\n        this.brokerConfig = brokerController.getBrokerConfig();\n        this.topicConfigManager = brokerController.getTopicConfigManager();\n        this.consumerManager = brokerController.getConsumerManager();\n        this.offsetManager = brokerController.getConsumerOffsetManager();\n        this.consumerFilterManager = brokerController.getConsumerFilterManager();\n        this.subscriptionGroupManager = brokerController.getSubscriptionGroupManager();\n        this.messageStore = brokerController.getMessageStore();\n        this.popBufferMergeService = brokerController.getPopMessageProcessor().getPopBufferMergeService();\n        this.popInflightMessageCounter = brokerController.getPopInflightMessageCounter();\n    }\n\n    private static class ProcessGroupInfo {\n        public String group;\n        public String topic;\n        public boolean isPop;\n        public String retryTopic;\n\n        public ProcessGroupInfo(String group, String topic, boolean isPop,\n            String retryTopic) {\n            this.group = group;\n            this.topic = topic;\n            this.isPop = isPop;\n            this.retryTopic = retryTopic;\n        }\n    }\n\n    public static class BaseCalculateResult {\n        public String group;\n        public String topic;\n        public boolean isRetry;\n\n        public BaseCalculateResult(String group, String topic, boolean isRetry) {\n            this.group = group;\n            this.topic = topic;\n            this.isRetry = isRetry;\n        }\n    }\n\n    public static class CalculateLagResult extends BaseCalculateResult {\n        public long lag;\n        public long earliestUnconsumedTimestamp;\n\n        public CalculateLagResult(String group, String topic, boolean isRetry) {\n            super(group, topic, isRetry);\n        }\n    }\n\n    public static class CalculateInflightResult extends BaseCalculateResult {\n        public long inFlight;\n        public long earliestUnPulledTimestamp;\n\n        public CalculateInflightResult(String group, String topic, boolean isRetry) {\n            super(group, topic, isRetry);\n        }\n    }\n\n    public static class CalculateAvailableResult extends BaseCalculateResult {\n        public long available;\n\n        public CalculateAvailableResult(String group, String topic, boolean isRetry) {\n            super(group, topic, isRetry);\n        }\n    }\n\n    private void processAllGroup(Consumer<ProcessGroupInfo> consumer) {\n        for (Map.Entry<String, SubscriptionGroupConfig> subscriptionEntry :\n            subscriptionGroupManager.getSubscriptionGroupTable().entrySet()) {\n\n            String group = subscriptionEntry.getKey();\n            ConsumerGroupInfo consumerGroupInfo = consumerManager.getConsumerGroupInfo(group, true);\n            boolean isPop = false;\n            if (consumerGroupInfo != null) {\n                isPop = consumerGroupInfo.getConsumeType() == ConsumeType.CONSUME_POP;\n            }\n            Set<String> topics;\n            if (brokerConfig.isUseStaticSubscription()) {\n                SubscriptionGroupConfig subscriptionGroupConfig = subscriptionEntry.getValue();\n                if (subscriptionGroupConfig.getSubscriptionDataSet() == null ||\n                    subscriptionGroupConfig.getSubscriptionDataSet().isEmpty()) {\n                    continue;\n                }\n                topics = subscriptionGroupConfig.getSubscriptionDataSet()\n                    .stream()\n                    .map(SimpleSubscriptionData::getTopic)\n                    .collect(Collectors.toSet());\n            } else {\n                if (consumerGroupInfo == null) {\n                    continue;\n                }\n                topics = consumerGroupInfo.getSubscribeTopics();\n            }\n\n            if (null == topics || topics.isEmpty()) {\n                continue;\n            }\n            for (String topic : topics) {\n                // skip retry topic\n                if (topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {\n                    continue;\n                }\n\n                TopicConfig topicConfig = topicConfigManager.selectTopicConfig(topic);\n                if (topicConfig == null) {\n                    continue;\n                }\n\n                // skip no perm topic\n                int topicPerm = topicConfig.getPerm() & brokerConfig.getBrokerPermission();\n                if (!PermName.isReadable(topicPerm) && !PermName.isWriteable(topicPerm)) {\n                    continue;\n                }\n\n                if (isPop) {\n                    String retryTopic = KeyBuilder.buildPopRetryTopic(topic, group, brokerConfig.isEnableRetryTopicV2());\n                    TopicConfig retryTopicConfig = topicConfigManager.selectTopicConfig(retryTopic);\n                    if (retryTopicConfig != null) {\n                        int retryTopicPerm = retryTopicConfig.getPerm() & brokerConfig.getBrokerPermission();\n                        if (PermName.isReadable(retryTopicPerm) || PermName.isWriteable(retryTopicPerm)) {\n                            consumer.accept(new ProcessGroupInfo(group, topic, true, retryTopic));\n                            continue;\n                        }\n                    }\n                    if (brokerConfig.isEnableRetryTopicV2() && brokerConfig.isRetrieveMessageFromPopRetryTopicV1()) {\n                        String retryTopicV1 = KeyBuilder.buildPopRetryTopicV1(topic, group);\n                        TopicConfig retryTopicConfigV1 = topicConfigManager.selectTopicConfig(retryTopicV1);\n                        if (retryTopicConfigV1 != null) {\n                            int retryTopicPerm = retryTopicConfigV1.getPerm() & brokerConfig.getBrokerPermission();\n                            if (PermName.isReadable(retryTopicPerm) || PermName.isWriteable(retryTopicPerm)) {\n                                consumer.accept(new ProcessGroupInfo(group, topic, true, retryTopicV1));\n                                continue;\n                            }\n                        }\n                    }\n                    consumer.accept(new ProcessGroupInfo(group, topic, true, null));\n                } else {\n                    consumer.accept(new ProcessGroupInfo(group, topic, false, null));\n                }\n            }\n        }\n    }\n\n    public void calculateLag(Consumer<CalculateLagResult> lagRecorder) {\n        processAllGroup(info -> {\n            if (info.group == null || info.topic == null) {\n                return;\n            }\n\n            CalculateLagResult result = new CalculateLagResult(info.group, info.topic, false);\n\n            Pair<Long, Long> lag = getConsumerLagStats(info.group, info.topic, info.isPop);\n            if (lag != null) {\n                result.lag = lag.getObject1();\n                result.earliestUnconsumedTimestamp = lag.getObject2();\n            }\n            lagRecorder.accept(result);\n\n            if (info.isPop) {\n                Pair<Long, Long> retryLag = getConsumerLagStats(info.group, info.retryTopic, true);\n\n                result = new CalculateLagResult(info.group, info.topic, true);\n                if (retryLag != null) {\n                    result.lag = retryLag.getObject1();\n                    result.earliestUnconsumedTimestamp = retryLag.getObject2();\n                }\n                lagRecorder.accept(result);\n            }\n        });\n    }\n\n    public void calculateInflight(Consumer<CalculateInflightResult> inflightRecorder) {\n        processAllGroup(info -> {\n            CalculateInflightResult result = new CalculateInflightResult(info.group, info.topic, false);\n            Pair<Long, Long> inFlight = getInFlightMsgStats(info.group, info.topic, info.isPop);\n            if (inFlight != null) {\n                result.inFlight = inFlight.getObject1();\n                result.earliestUnPulledTimestamp = inFlight.getObject2();\n            }\n            inflightRecorder.accept(result);\n\n            if (info.isPop) {\n                Pair<Long, Long> retryInFlight = getInFlightMsgStats(info.group, info.retryTopic, true);\n\n                result = new CalculateInflightResult(info.group, info.topic, true);\n                if (retryInFlight != null) {\n                    result.inFlight = retryInFlight.getObject1();\n                    result.earliestUnPulledTimestamp = retryInFlight.getObject2();\n                }\n                inflightRecorder.accept(result);\n            }\n        });\n    }\n\n    public void calculateAvailable(Consumer<CalculateAvailableResult> availableRecorder) {\n        processAllGroup(info -> {\n            CalculateAvailableResult result = new CalculateAvailableResult(info.group, info.topic, false);\n\n            result.available = getAvailableMsgCount(info.group, info.topic, info.isPop);\n            availableRecorder.accept(result);\n\n            if (info.isPop) {\n                long retryAvailable = getAvailableMsgCount(info.group, info.retryTopic, true);\n\n                result = new CalculateAvailableResult(info.group, info.topic, true);\n                result.available = retryAvailable;\n                availableRecorder.accept(result);\n            }\n        });\n    }\n\n    public Pair<Long, Long> getConsumerLagStats(String group, String topic, boolean isPop) {\n        long total = 0L;\n        long earliestUnconsumedTimestamp = Long.MAX_VALUE;\n\n        if (group == null || topic == null) {\n            return new Pair<>(total, earliestUnconsumedTimestamp);\n        }\n\n        TopicConfig topicConfig = topicConfigManager.selectTopicConfig(topic);\n        if (topicConfig != null) {\n            for (int queueId = 0; queueId < topicConfig.getWriteQueueNums(); queueId++) {\n                Pair<Long, Long> pair = getConsumerLagStats(group, topic, queueId, isPop);\n                total += pair.getObject1();\n                earliestUnconsumedTimestamp = Math.min(earliestUnconsumedTimestamp, pair.getObject2());\n            }\n        } else {\n            LOGGER.warn(\"failed to get config of topic {}\", topic);\n        }\n\n        if (earliestUnconsumedTimestamp < 0 || earliestUnconsumedTimestamp == Long.MAX_VALUE) {\n            earliestUnconsumedTimestamp = 0L;\n        }\n\n        return new Pair<>(total, earliestUnconsumedTimestamp);\n    }\n\n    public Pair<Long, Long> getConsumerLagStats(String group, String topic, int queueId, boolean isPop) {\n        long brokerOffset = messageStore.getMaxOffsetInQueue(topic, queueId);\n        if (brokerOffset < 0) {\n            brokerOffset = 0;\n        }\n\n        if (isPop) {\n            long pullOffset = popBufferMergeService.getLatestOffset(topic, group, queueId);\n            if (pullOffset < 0) {\n                pullOffset = offsetManager.queryOffset(group, topic, queueId);\n            }\n            if (pullOffset < 0) {\n                pullOffset = brokerOffset;\n            }\n            long inFlightNum = popInflightMessageCounter.getGroupPopInFlightMessageNum(topic, group, queueId);\n            long lag = calculateMessageCount(group, topic, queueId, pullOffset, brokerOffset) + inFlightNum;\n            long consumerOffset = pullOffset - inFlightNum;\n            long consumerStoreTimeStamp = getStoreTimeStamp(topic, queueId, consumerOffset);\n            return new Pair<>(lag, consumerStoreTimeStamp);\n        }\n\n        long consumerOffset = offsetManager.queryOffset(group, topic, queueId);\n        if (consumerOffset < 0) {\n            consumerOffset = brokerOffset;\n        }\n\n        long lag = calculateMessageCount(group, topic, queueId, consumerOffset, brokerOffset);\n        long consumer
{
    "key":"//broker/src/main/java/org/apache/rocketmq/broker/out/BrokerOuterAPI.java\npackage org.apache.rocketmq.broker.out;\n\nimport com.alibaba.fastjson2.JSON;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.TimeUnit;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.rocketmq.acl.common.AclClientRPCHook;\nimport org.apache.rocketmq.acl.common.SessionCredentials;\nimport org.apache.rocketmq.auth.config.AuthConfig;\nimport org.apache.rocketmq.client.consumer.PullResult;\nimport org.apache.rocketmq.client.consumer.PullStatus;\nimport org.apache.rocketmq.client.exception.MQBrokerException;\nimport org.apache.rocketmq.client.impl.consumer.PullResultExt;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.client.producer.SendStatus;\nimport org.apache.rocketmq.common.AbstractBrokerRunnable;\nimport org.apache.rocketmq.common.BrokerIdentity;\nimport org.apache.rocketmq.common.LockCallback;\nimport org.apache.rocketmq.common.MixAll;\nimport org.apache.rocketmq.common.Pair;\nimport org.apache.rocketmq.common.ThreadFactoryImpl;\nimport org.apache.rocketmq.common.UnlockCallback;\nimport org.apache.rocketmq.common.UtilAll;\nimport org.apache.rocketmq.common.constant.LoggerName;\nimport org.apache.rocketmq.common.constant.PermName;\nimport org.apache.rocketmq.common.filter.ExpressionType;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageAccessor;\nimport org.apache.rocketmq.common.message.MessageBatch;\nimport org.apache.rocketmq.common.message.MessageClientIDSetter;\nimport org.apache.rocketmq.common.message.MessageConst;\nimport org.apache.rocketmq.common.message.MessageDecoder;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.common.message.MessageQueue;\nimport org.apache.rocketmq.common.namesrv.DefaultTopAddressing;\nimport org.apache.rocketmq.common.namesrv.TopAddressing;\nimport org.apache.rocketmq.common.sysflag.PullSysFlag;\nimport org.apache.rocketmq.common.topic.TopicValidator;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\nimport org.apache.rocketmq.remoting.InvokeCallback;\nimport org.apache.rocketmq.remoting.RPCHook;\nimport org.apache.rocketmq.remoting.RemotingClient;\nimport org.apache.rocketmq.remoting.RemotingCommand;\nimport org.apache.rocketmq.remoting.exception.RemotingCommandException;\nimport org.apache.rocketmq.remoting.exception.RemotingConnectException;\nimport org.apache.rocketmq.remoting.exception.RemotingException;\nimport org.apache.rocketmq.remoting.exception.RemotingSendRequestException;\nimport org.apache.rocketmq.remoting.exception.RemotingTimeoutException;\nimport org.apache.rocketmq.remoting.exception.RemotingTooMuchRequestException;\nimport org.apache.rocketmq.remoting.netty.NettyClientConfig;\nimport org.apache.rocketmq.remoting.netty.NettyRemotingClient;\nimport org.apache.rocketmq.remoting.netty.ResponseFuture;\nimport org.apache.rocketmq.remoting.protocol.BrokerSyncInfo;\nimport org.apache.rocketmq.remoting.protocol.DataVersion;\nimport org.apache.rocketmq.remoting.protocol.RemotingCommand;\nimport org.apache.rocketmq.remoting.protocol.RemotingSerializable;\nimport org.apache.rocketmq.remoting.protocol.RequestCode;\nimport org.apache.rocketmq.remoting.protocol.ResponseCode;\nimport org.apache.rocketmq.remoting.protocol.body.BrokerMemberGroup;\nimport org.apache.rocketmq.remoting.protocol.body.ClusterInfo;\nimport org.apache.rocketmq.remoting.protocol.body.ConsumerOffsetSerializeWrapper;\nimport org.apache.rocketmq.remoting.protocol.body.ElectMasterResponseBody;\nimport org.apache.rocketmq.remoting.protocol.body.GetBrokerMemberGroupResponseBody;\nimport org.apache.rocketmq.remoting.protocol.body.GetMaxOffsetRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.body.GetMaxOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.GetMinOffsetRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.body.GetMinOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.KVTable;\nimport org.apache.rocketmq.remoting.protocol.body.LockBatchRequestBody;\nimport org.apache.rocketmq.remoting.protocol.body.LockBatchResponseBody;\nimport org.apache.rocketmq.remoting.protocol.body.MessageRequestModeSerializeWrapper;\nimport org.apache.rocketmq.remoting.protocol.body.RegisterBrokerBody;\nimport org.apache.rocketmq.remoting.protocol.body.SubscriptionGroupWrapper;\nimport org.apache.rocketmq.remoting.protocol.body.TopicConfigAndMappingSerializeWrapper;\nimport org.apache.rocketmq.remoting.protocol.body.TopicConfigSerializeWrapper;\nimport org.apache.rocketmq.remoting.protocol.header.ExchangeHAInfoRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.ExchangeHAInfoResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.GetBrokerMemberGroupRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.GetMaxOffsetRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.GetMaxOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.GetMinOffsetRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.GetMinOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.LockBatchMqRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.PullMessageRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.PullMessageResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.SendMessageRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.SendMessageRequestHeaderV2;\nimport org.apache.rocketmq.remoting.protocol.header.SendMessageResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.UnlockBatchMqRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.controller.AlterSyncStateSetRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.controller.ElectMasterRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.controller.ElectMasterResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.controller.GetMetaDataResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.controller.GetReplicaInfoRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.controller.GetReplicaInfoResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.controller.register.ApplyBrokerIdRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.controller.register.ApplyBrokerIdResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.controller.register.GetNextBrokerIdRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.controller.register.GetNextBrokerIdResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.controller.register.RegisterBrokerToControllerRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.controller.register.RegisterBrokerToControllerResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.namesrv.BrokerHeartbeatRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.namesrv.GetRouteInfoRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.namesrv.QueryDataVersionRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.namesrv.QueryDataVersionResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.namesrv.RegisterBrokerRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.namesrv.RegisterBrokerResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.namesrv.RegisterTopicRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.namesrv.UnRegisterBrokerRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.heartbeat.SubscriptionData;\nimport org.apache.rocketmq.remoting.protocol.namesrv.RegisterBrokerResult;\nimport org.apache.rocketmq.remoting.protocol.route.BrokerData;\nimport org.apache.rocketmq.remoting.protocol.route.QueueData;\nimport org.apache.rocketmq.remoting.protocol.route.TopicRouteData;\nimport org.apache.rocketmq.remoting.rpc.ClientMetadata;\nimport org.apache.rocketmq.remoting.rpc.RpcClient;\nimport org.apache.rocketmq.remoting.rpc.RpcClientImpl;\nimport org.apache.rocketmq.remoting.rpc.RpcHook;\nimport org.apache.rocketmq.store.DefaultMessageFilter;\nimport org.apache.rocketmq.store.MessageStore;\nimport org.apache.rocketmq.store.PutMessageResult;\nimport org.apache.rocketmq.store.PutMessageStatus;\n\npublic class BrokerOuterAPI {\n    private static final Logger LOGGER = LoggerFactory.getLogger(LoggerName.BROKER_LOGGER_NAME);\n    private final RemotingClient remotingClient;\n    private final TopAddressing topAddressing = new DefaultTopAddressing(MixAll.getWSAddr());\n    private final ExecutorService brokerOuterExecutor = ThreadUtils.newThreadPoolExecutor(4, 10, 1, TimeUnit.MINUTES,\n            new ArrayBlockingQueue<>(32), new ThreadFactoryImpl(\"brokerOutApi_thread_\", true));\n    private final ClientMetadata clientMetadata;\n    private final RpcClient rpcClient;\n    private String nameSrvAddr = null;\n\n    public BrokerOuterAPI(final NettyClientConfig nettyClientConfig, AuthConfig authConfig) {\n        this(nettyClientConfig, authConfig, new DynamicalExtFieldRPCHook(), new ClientMetadata());\n    }\n\n    private BrokerOuterAPI(final NettyClientConfig nettyClientConfig, AuthConfig authConfig, RPCHook rpcHook, ClientMetadata clientMetadata) {\n        this.remotingClient = new NettyRemotingClient(nettyClientConfig);\n        this.clientMetadata = clientMetadata;\n        this.remotingClient.registerRPCHook(rpcHook);\n        this.remotingClient.registerRPCHook(newAclRPCHook(authConfig));\n        this.rpcClient = new RpcClientImpl(this.clientMetadata, this.remotingClient);\n    }\n\n    private RPCHook newAclRPCHook(AuthConfig config) {\n        if (config == null || StringUtils.isBlank(config.getInnerClientAuthenticationCredentials())) {\n            return null;\n        }\n        SessionCredentials sessionCredentials =\n            JSON.parseObject(config.getInnerClientAuthenticationCredentials(), SessionCredentials.class);\n        if (StringUtils.isBlank(sessionCredentials.getAccessKey()) || StringUtils.isBlank(sessionCredentials.getSecretKey())) {\n            return null;\n        }\n        return new AclClientRPCHook(sessionCredentials);\n    }\n\n    public void start() {\n        this.remotingClient.start();\n    }\n\n    public void shutdown() {\n        this.remotingClient.shutdown();\n        this.brokerOuterExecutor.shutdown();\n    }\n\n    public List<String> getNameServerAddressList() {\n        return this.remotingClient.getNameServerAddressList();\n    }\n\n    public String fetchNameServerAddr() {\n        try {\n            String addrs = this.topAddressing.fetchNSAddr();\n            if (!UtilAll.isBlank(addrs)) {\n                if (!addrs.equals(this.nameSrvAddr)) {\n                    LOGGER.info(\"name server address changed, old: {} new: {}\", this.nameSrvAddr, addrs);\n                    this.updateNameServerAddressList(addrs);\n                    this.nameSrvAddr = addrs;\n                    return nameSrvAddr;\n                }\n            }\n        } catch (Exception e) {\n            LOGGER.error(\"fetchNameServerAddr Exception\", e);\n        }\n        return nameSrvAddr;\n    }\n\n    public List<String> dnsLookupAddressByDomain(String domain) {\n        List<String> addressList = new ArrayList<>();\n        try {\n            java.security.Security.setProperty(\"networkaddress.cache.ttl\", \"10\");\n            int index = domain.indexOf(\":\");\n            String portStr = domain.substring(index);\n            String domainStr = domain.substring(0, index);\n            InetAddress[] addresses = InetAddress.getAllByName(domainStr);\n            for (InetAddress address : addresses) {\n                addressList.add(address.getHostAddress() + portStr);\n            }\n            LOGGER.info(\"dns lookup address by domain success, domain={}, result={}\", domain, addressList);\n        } catch (Exception e) {\n            LOGGER.error(\"dns lookup address by domain error, domain={}\", domain, e);\n        }\n        return addressList;\n    }\n\n    public boolean checkAddressReachable(String address) {\n        return this.remotingClient.isAddressReachable(address);\n    }\n\n    public void updateNameServerAddressList(final String addrs) {\n        String[] addrArray = addrs.split(\";\");\n        List<String> lst = new ArrayList<String>(Arrays.asList(addrArray));\n        this.remotingClient.updateNameServerAddressList(lst);\n    }\n\n    public void updateNameServerAddressListByDnsLookup(final String domain) {\n        List<String> lst = this.dnsLookupAddressByDomain(domain);\n        this.remotingClient.updateNameServerAddressList(lst);\n    }\n\n    public BrokerMemberGroup syncBrokerMemberGroup(String clusterName, String brokerName)\n        throws InterruptedException, RemotingTimeoutException, RemotingSendRequestException, RemotingConnectException {\n        return syncBrokerMemberGroup(clusterName, brokerName, false);\n    }\n\n    public BrokerMemberGroup syncBrokerMemberGroup(String clusterName, String brokerName,\n        boolean isCompatibleWithOldNameSrv)\n        throws InterruptedException, RemotingTimeoutException, RemotingSendRequestException, RemotingConnectException {\n        if (isCompatibleWithOldNameSrv) {\n            return getBrokerMemberGroupCompatible(clusterName, brokerName);\n        } else {\n            return getBrokerMemberGroup(clusterName, brokerName);\n        }\n    }\n\n    public BrokerMemberGroup getBrokerMemberGroup(String clusterName, String brokerName)\n        throws InterruptedException, RemotingTimeoutException, RemotingSendRequestException, RemotingConnectException {\n        BrokerMemberGroup brokerMemberGroup = new BrokerMemberGroup(clusterName, brokerName);\n\n        GetBrokerMemberGroupRequestHeader requestHeader = new GetBrokerMemberGroupRequestHeader();\n        requestHeader.setClusterName(clusterName);\n        requestHeader.setBrokerName(brokerName);\n\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.GET_BROKER_MEMBER_GROUP, requestHeader);\n\n        RemotingCommand response = null;\n        response = this.remotingClient.invokeSync(null, request, 3000);\n        assert response != null;\n\n        switch (response.getCode()) {\n            case ResponseCode.SUCCESS: {\n                byte[] body = response.getBody();\n                if (body != null) {\n                    GetBrokerMemberGroupResponseBody brokerMemberGroupResponseBody =\n                        GetBrokerMemberGroupResponseBody.decode(body, GetBrokerMemberGroupResponseBody.class);\n\n                    return brokerMemberGroupResponseBody.getBrokerMemberGroup();\n                }\n            }\n            default:\n                break;\n        }\n\n        return brokerMemberGroup;\n    }\n\n    public BrokerMemberGroup getBrokerMemberGroupCompatible(String clusterName, String brokerName)\n        throws InterruptedException, RemotingTimeoutException, RemotingSendRequestException, RemotingConnectException {\n        BrokerMemberGroup brokerMemberGroup = new BrokerMemberGroup(clusterName, brokerName);\n\n        GetRouteInfoRequestHeader requestHeader = new GetRouteInfoRequestHeader();\n        requestHeader.setTopic(TopicValidator.SYNC_BROKER_MEMBER_GROUP_PREFIX + brokerName);\n\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.GET_ROUTEINFO_BY_TOPIC, requestHeader);\n\n        RemotingCommand response;\n        response = this.remotingClient.invokeSync(null, request, 3000);\n        assert response != null;\n\n        switch (response.getCode()) {\n            case ResponseCode.SUCCESS: {\n                byte[] body = response.getBody();\n                if (body != null) {\n                    TopicRouteData topicRouteData = TopicRouteData.decode(body, TopicRouteData.class);\n                    for (BrokerData brokerData : topicRouteData.getBrokerDatas()) {\n                        if (brokerData != null\n                            && brokerData.getBrokerName().equals(brokerName)\n                            && brokerData.getCluster().equals(clusterName)) {\n                            brokerMemberGroup.getBrokerAddrs().putAll(brokerData.getBrokerAddrs());\n                            break;\n                        }\n                    }\n                    return brokerMemberGroup;\n                }\n            }\n            default:\n                break;\n        }\n\n        return brokerMemberGroup;\n    }\n\n    public void sendHeartbeatViaDataVersion(\n        final String clusterName,\n        final String brokerAddr,\n        final String brokerName,\n        final Long brokerId,\n        final int timeoutMillis,\n        final DataVersion dataVersion,\n        final boolean isInBrokerContainer) {\n        List<String> nameServerAddressList = this.remotingClient.getAvailableNameSrvList();\n        if (nameServerAddressList != null && nameServerAddressList.size() > 0) {\n            final QueryDataVersionRequestHeader requestHeader = new QueryDataVersionRequestHeader();\n            requestHeader.setBrokerAddr(brokerAddr);\n            requestHeader.setBrokerName(brokerName);\n            requestHeader.setBrokerId(brokerId);\n            requestHeader.setClusterName(clusterName);\n\n            for (final String namesrvAddr : nameServerAddressList) {\n                brokerOuterExecutor.execute(new AbstractBrokerRunnable(new BrokerIdentity(clusterName, brokerName, brokerId, isInBrokerContainer)) {\n\n                    @Override\n                    public void run0() {\n                        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.QUERY_DATA_VERSION, requestHeader);\n                        request.setBody(dataVersion.encode());\n\n                        try {\n                            BrokerOuterAPI.this.remotingClient.invokeOneway(namesrvAddr, request, timeoutMillis);\n                        } catch (Exception e) {\n                            LOGGER.error(\"sendHeartbeat Exception \" + namesrvAddr, e);\n                        }\n                    }\n                });\n            }\n        }\n    }\n\n    public void sendHeartbeat(final String clusterName,\n        final String brokerAddr,\n        final String brokerName,\n        final Long brokerId,\n        final int timeoutMills,\n        final boolean isInBrokerContainer) {\n        List<String> nameServerAddressList = this.remotingClient.getAvailableNameSrvList();\n\n        final BrokerHeartbeatRequestHeader requestHeader = new BrokerHeartbeatRequestHeader();\
{
    "key":"//example/src/main/java/org/apache/rocketmq/example/broadcast/PushConsumer.java\npackage org.apache.rocketmq.example.broadcast;\n\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.remoting.protocol.heartbeat.MessageModel;\n\npublic class PushConsumer {\n\n    public static final String CONSUMER_GROUP = \"please_rename_unique_group_name_1\";\n    public static final String DEFAULT_NAMESRVADDR = \"127.0.0.1:9876\";\n    public static final String TOPIC = \"TopicTest\";\n\n    public static final String SUB_EXPRESSION = \"TagA || TagC || TagD\";\n\n    public static void main(String[] args) throws InterruptedException, MQClientException {\n\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);\n\n        // Uncomment the following line while debugging, namesrvAddr should be set to your local address\n//        consumer.setNamesrvAddr(DEFAULT_NAMESRVADDR);\n\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n\n        consumer.setMessageModel(MessageModel.BROADCASTING);\n\n        consumer.subscribe(TOPIC, SUB_EXPRESSION);\n\n        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> {\n            System.out.printf(\"%s Receive New Messages: %s %n\", Thread.currentThread().getName(), msgs);\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        });\n\n        consumer.start();\n        System.out.printf(\"Broadcast Consumer Started.%n\");\n    }\n}\n",
    "reason":"domain",
    "justification":"The code provided is related to the domain of broadcasting messages using RocketMQ, which involves setting up a `DefaultMQPushConsumer` with a specific consumer group, nameserver address, topic, and subscription expression. The consumer is configured to consume messages from the beginning of the message queue and to use a broadcasting message model, meaning that messages are delivered to all consumer instances under the same consumer group. The message listener implemented simply prints out the received messages and acknowledges successful consumption. This is a typical use case in the domain of message broadcasting with RocketMQ, making it a relevant choice for refactoring to improve maintainability and potentially add new features or optimizations."
}"