{
    "messages": [
        {
            "content": "\nI will provide you Java files that contain data clumps.\nChoose one data clump that you think is most important and should be refactored.\n\nA data clump exists if\n1) two methods (in the same or in different classes) have at least 3 common parameters\n    and one of those methods does not override the other,\n\nor  \n2) At least three fields in a class are common with the parameters of a method (in the same or in a different class),\n\nor\n3) Two different classes have at least three common fields\n\n\nReturn the key of that data clump.\nJustify your response. \nUse the following  output format in JSON:\n\nThe \"reason\" attribute should be equal to as follows:\n        \"size\" -> if you choose the data clump because of its large number of parameters/fields\n        \"occurrence\" -> if you choose the data clump because it occurs very often and leads to much duplication\n        \"affected_files\" -> if you choose this data clump because many files are affected by this data clump\n        \"domain\" -> if you choose this data clump because the variables share a common domain so that extracting a class is a good idea\n        \"other\" -> if none of the options above fits\n\n### JSON\n{\n    \"key\":\"<a portion of the source code, as submitted, that shows where the data clump is located\",,\n    \"reason\":\"<as explained above>,\n    \"justification\":\"<Your justification which explains the 'reason' in more details>\",\n    \"suggestedName\":\"<A suitable name for an extracted class if the data clumps variables were to be extracted>\"\n\n}\n\n### END JSON\n",
            "role": "user"
        },
        {
            "content": "//common/src/main/java/org/apache/rocketmq/common/stats/Stats.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.rocketmq.common.stats;\n\npublic class Stats {\n\n    public static final String QUEUE_PUT_NUMS = \"QUEUE_PUT_NUMS\";\n    public static final String QUEUE_PUT_SIZE = \"QUEUE_PUT_SIZE\";\n    public static final String QUEUE_GET_NUMS = \"QUEUE_GET_NUMS\";\n    public static final String QUEUE_GET_SIZE = \"QUEUE_GET_SIZE\";\n    public static final String TOPIC_PUT_NUMS = \"TOPIC_PUT_NUMS\";\n    public static final String TOPIC_PUT_SIZE = \"TOPIC_PUT_SIZE\";\n    public static final String GROUP_GET_NUMS = \"GROUP_GET_NUMS\";\n    public static final String GROUP_GET_SIZE = \"GROUP_GET_SIZE\";\n    public static final String SNDBCK_PUT_NUMS = \"SNDBCK_PUT_NUMS\";\n    public static final String BROKER_PUT_NUMS = \"BROKER_PUT_NUMS\";\n    public static final String BROKER_GET_NUMS = \"BROKER_GET_NUMS\";\n    public static final String GROUP_GET_FROM_DISK_NUMS = \"GROUP_GET_FROM_DISK_NUMS\";\n    public static final String GROUP_GET_FROM_DISK_SIZE = \"GROUP_GET_FROM_DISK_SIZE\";\n    public static final String BROKER_GET_FROM_DISK_NUMS = \"BROKER_GET_FROM_DISK_NUMS\";\n    public static final String BROKER_GET_FROM_DISK_SIZE = \"BROKER_GET_FROM_DISK_SIZE\";\n    public static final String COMMERCIAL_SEND_TIMES = \"COMMERCIAL_SEND_TIMES\";\n    public static final String COMMERCIAL_SNDBCK_TIMES = \"COMMERCIAL_SNDBCK_TIMES\";\n    public static final String COMMERCIAL_RCV_TIMES = \"COMMERCIAL_RCV_TIMES\";\n    public static final String COMMERCIAL_RCV_EPOLLS = \"COMMERCIAL_RCV_EPOLLS\";\n    public static final String COMMERCIAL_SEND_SIZE = \"COMMERCIAL_SEND_SIZE\";\n    public static final String COMMERCIAL_RCV_SIZE = \"COMMERCIAL_RCV_SIZE\";\n    public static final String COMMERCIAL_PERM_FAILURES = \"COMMERCIAL_PERM_FAILURES\";\n\n    public static final String GROUP_GET_FALL_SIZE = \"GROUP_GET_FALL_SIZE\";\n    public static final String GROUP_GET_FALL_TIME = \"GROUP_GET_FALL_TIME\";\n    public static final String GROUP_GET_LATENCY = \"GROUP_GET_LATENCY\";\n}\n",
            "role": "user"
        },
        {
            "content": "//store/src/main/java/org/apache/rocketmq/store/stats/BrokerStatsManager.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.rocketmq.store.stats;\n\nimport java.util.HashMap;\nimport java.util.concurrent.ScheduledExecutorService;\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.apache.rocketmq.common.BrokerConfig;\nimport org.apache.rocketmq.common.ThreadFactoryImpl;\nimport org.apache.rocketmq.common.UtilAll;\nimport org.apache.rocketmq.common.constant.LoggerName;\nimport org.apache.rocketmq.common.statistics.StatisticsItem;\nimport org.apache.rocketmq.common.statistics.StatisticsItemFormatter;\nimport org.apache.rocketmq.common.statistics.StatisticsItemPrinter;\nimport org.apache.rocketmq.common.statistics.StatisticsItemScheduledIncrementPrinter;\nimport org.apache.rocketmq.common.statistics.StatisticsItemScheduledPrinter;\nimport org.apache.rocketmq.common.statistics.StatisticsItemStateGetter;\nimport org.apache.rocketmq.common.statistics.StatisticsKindMeta;\nimport org.apache.rocketmq.common.statistics.StatisticsManager;\nimport org.apache.rocketmq.common.stats.MomentStatsItemSet;\nimport org.apache.rocketmq.common.stats.Stats;\nimport org.apache.rocketmq.common.stats.StatsItem;\nimport org.apache.rocketmq.common.stats.StatsItemSet;\nimport org.apache.rocketmq.common.topic.TopicValidator;\nimport org.apache.rocketmq.common.utils.ThreadUtils;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\n\npublic class BrokerStatsManager {\n\n    @Deprecated public static final String QUEUE_PUT_NUMS = Stats.QUEUE_PUT_NUMS;\n    @Deprecated public static final String QUEUE_PUT_SIZE = Stats.QUEUE_PUT_SIZE;\n    @Deprecated public static final String QUEUE_GET_NUMS = Stats.QUEUE_GET_NUMS;\n    @Deprecated public static final String QUEUE_GET_SIZE = Stats.QUEUE_GET_SIZE;\n    @Deprecated public static final String TOPIC_PUT_NUMS = Stats.TOPIC_PUT_NUMS;\n    @Deprecated public static final String TOPIC_PUT_SIZE = Stats.TOPIC_PUT_SIZE;\n\n    @Deprecated public static final String GROUP_GET_NUMS = Stats.GROUP_GET_NUMS;\n    @Deprecated public static final String GROUP_GET_SIZE = Stats.GROUP_GET_SIZE;\n\n    @Deprecated public static final String SNDBCK_PUT_NUMS = Stats.SNDBCK_PUT_NUMS;\n    @Deprecated public static final String BROKER_PUT_NUMS = Stats.BROKER_PUT_NUMS;\n    @Deprecated public static final String BROKER_GET_NUMS = Stats.BROKER_GET_NUMS;\n    @Deprecated public static final String GROUP_GET_FROM_DISK_NUMS = Stats.GROUP_GET_FROM_DISK_NUMS;\n    @Deprecated public static final String GROUP_GET_FROM_DISK_SIZE = Stats.GROUP_GET_FROM_DISK_SIZE;\n    @Deprecated public static final String BROKER_GET_FROM_DISK_NUMS = Stats.BROKER_GET_FROM_DISK_NUMS;\n    @Deprecated public static final String BROKER_GET_FROM_DISK_SIZE = Stats.BROKER_GET_FROM_DISK_SIZE;\n    // For commercial\n    @Deprecated public static final String COMMERCIAL_SEND_TIMES = Stats.COMMERCIAL_SEND_TIMES;\n    @Deprecated public static final String COMMERCIAL_SNDBCK_TIMES = Stats.COMMERCIAL_SNDBCK_TIMES;\n    @Deprecated public static final String COMMERCIAL_RCV_TIMES = Stats.COMMERCIAL_RCV_TIMES;\n    @Deprecated public static final String COMMERCIAL_RCV_EPOLLS = Stats.COMMERCIAL_RCV_EPOLLS;\n    @Deprecated public static final String COMMERCIAL_SEND_SIZE = Stats.COMMERCIAL_SEND_SIZE;\n    @Deprecated public static final String COMMERCIAL_RCV_SIZE = Stats.COMMERCIAL_RCV_SIZE;\n    @Deprecated public static final String COMMERCIAL_PERM_FAILURES = Stats.COMMERCIAL_PERM_FAILURES;\n\n    // Send message latency\n    public static final String TOPIC_PUT_LATENCY = \"TOPIC_PUT_LATENCY\";\n    public static final String GROUP_ACK_NUMS = \"GROUP_ACK_NUMS\";\n    public static final String GROUP_CK_NUMS = \"GROUP_CK_NUMS\";\n    public static final String DLQ_PUT_NUMS = \"DLQ_PUT_NUMS\";\n    public static final String BROKER_ACK_NUMS = \"BROKER_ACK_NUMS\";\n    public static final String BROKER_CK_NUMS = \"BROKER_CK_NUMS\";\n    public static final String BROKER_GET_NUMS_WITHOUT_SYSTEM_TOPIC = \"BROKER_GET_NUMS_WITHOUT_SYSTEM_TOPIC\";\n    public static final String BROKER_PUT_NUMS_WITHOUT_SYSTEM_TOPIC = \"BROKER_PUT_NUMS_WITHOUT_SYSTEM_TOPIC\";\n    public static final String SNDBCK2DLQ_TIMES = \"SNDBCK2DLQ_TIMES\";\n\n    public static final String COMMERCIAL_OWNER = \"Owner\";\n\n    public static final String ACCOUNT_OWNER_PARENT = \"OWNER_PARENT\";\n    public static final String ACCOUNT_OWNER_SELF = \"OWNER_SELF\";\n\n    public static final long ACCOUNT_STAT_INVERTAL = 60 * 1000;\n    public static final String ACCOUNT_AUTH_TYPE = \"AUTH_TYPE\";\n\n    public static final String ACCOUNT_SEND = \"SEND\";\n    public static final String ACCOUNT_RCV = \"RCV\";\n    public static final String ACCOUNT_SEND_BACK = \"SEND_BACK\";\n    public static final String ACCOUNT_SEND_BACK_TO_DLQ = \"SEND_BACK_TO_DLQ\";\n    public static final String ACCOUNT_AUTH_FAILED = \"AUTH_FAILED\";\n    public static final String ACCOUNT_SEND_REJ = \"SEND_REJ\";\n    public static final String ACCOUNT_REV_REJ = \"RCV_REJ\";\n\n    public static final String MSG_NUM = \"MSG_NUM\";\n    public static final String MSG_SIZE = \"MSG_SIZE\";\n    public static final String SUCCESS_MSG_NUM = \"SUCCESS_MSG_NUM\";\n    public static final String FAILURE_MSG_NUM = \"FAILURE_MSG_NUM\";\n    public static final String COMMERCIAL_MSG_NUM = \"COMMERCIAL_MSG_NUM\";\n    public static final String SUCCESS_REQ_NUM = \"SUCCESS_REQ_NUM\";\n    public static final String FAILURE_REQ_NUM = \"FAILURE_REQ_NUM\";\n    public static final String SUCCESS_MSG_SIZE = \"SUCCESS_MSG_SIZE\";\n    public static final String FAILURE_MSG_SIZE = \"FAILURE_MSG_SIZE\";\n    public static final String RT = \"RT\";\n    public static final String INNER_RT = \"INNER_RT\";\n\n    @Deprecated public static final String GROUP_GET_FALL_SIZE = Stats.GROUP_GET_FALL_SIZE;\n    @Deprecated public static final String GROUP_GET_FALL_TIME = Stats.GROUP_GET_FALL_TIME;\n    // Pull Message Latency\n    @Deprecated public static final String GROUP_GET_LATENCY = Stats.GROUP_GET_LATENCY;\n\n    // Consumer Register Time\n    public static final String CONSUMER_REGISTER_TIME = \"CONSUMER_REGISTER_TIME\";\n    // Producer Register Time\n    public static final String PRODUCER_REGISTER_TIME = \"PRODUCER_REGISTER_TIME\";\n    public static final String CHANNEL_ACTIVITY = \"CHANNEL_ACTIVITY\";\n    public static final String CHANNEL_ACTIVITY_CONNECT = \"CONNECT\";\n    public static final String CHANNEL_ACTIVITY_IDLE = \"IDLE\";\n    public static final String CHANNEL_ACTIVITY_EXCEPTION = \"EXCEPTION\";\n    public static final String CHANNEL_ACTIVITY_CLOSE = \"CLOSE\";\n\n    /**\n     * read disk follow stats\n     */\n    private static final Logger log = LoggerFactory.getLogger(LoggerName.ROCKETMQ_STATS_LOGGER_NAME);\n    private static final Logger COMMERCIAL_LOG = LoggerFactory.getLogger(\n        LoggerName.COMMERCIAL_LOGGER_NAME);\n    private static final Logger ACCOUNT_LOG = LoggerFactory.getLogger(LoggerName.ACCOUNT_LOGGER_NAME);\n    private static final Logger DLQ_STAT_LOG = LoggerFactory.getLogger(\n        LoggerName.DLQ_STATS_LOGGER_NAME);\n    private ScheduledExecutorService scheduledExecutorService;\n    private ScheduledExecutorService commercialExecutor;\n    private ScheduledExecutorService accountExecutor;\n\n    private final HashMap<String, StatsItemSet> statsTable = new HashMap<>();\n    private final String clusterName;\n    private final boolean enableQueueStat;\n    private MomentStatsItemSet momentStatsItemSetFallSize;\n    private MomentStatsItemSet momentStatsItemSetFallTime;\n\n    private final StatisticsManager accountStatManager = new StatisticsManager();\n    private StateGetter producerStateGetter;\n    private StateGetter consumerStateGetter;\n\n    private BrokerConfig brokerConfig;\n\n    public BrokerStatsManager(BrokerConfig brokerConfig) {\n        this.brokerConfig = brokerConfig;\n        this.enableQueueStat = brokerConfig.isEnableDetailStat();\n        initScheduleService();\n        this.clusterName = brokerConfig.getBrokerClusterName();\n        init();\n    }\n\n    public BrokerStatsManager(String clusterName, boolean enableQueueStat) {\n        this.clusterName = clusterName;\n        this.enableQueueStat = enableQueueStat;\n        initScheduleService();\n        init();\n    }\n\n    public void init() {\n        momentStatsItemSetFallSize = new MomentStatsItemSet(GROUP_GET_FALL_SIZE,\n            scheduledExecutorService, log);\n\n        momentStatsItemSetFallTime = new MomentStatsItemSet(GROUP_GET_FALL_TIME,\n            scheduledExecutorService, log);\n\n        if (enableQueueStat) {\n            this.statsTable.put(Stats.QUEUE_PUT_NUMS, new StatsItemSet(Stats.QUEUE_PUT_NUMS, this.scheduledExecutorService, log));\n            this.statsTable.put(Stats.QUEUE_PUT_SIZE, new StatsItemSet(Stats.QUEUE_PUT_SIZE, this.scheduledExecutorService, log));\n            this.statsTable.put(Stats.QUEUE_GET_NUMS, new StatsItemSet(Stats.QUEUE_GET_NUMS, this.scheduledExecutorService, log));\n            this.statsTable.put(Stats.QUEUE_GET_SIZE, new StatsItemSet(Stats.QUEUE_GET_SIZE, this.scheduledExecutorService, log));\n        }\n        this.statsTable.put(Stats.TOPIC_PUT_NUMS, new StatsItemSet(Stats.TOPIC_PUT_NUMS, this.scheduledExecutorService, log));\n        this.statsTable.put(Stats.TOPIC_PUT_SIZE, new StatsItemSet(Stats.TOPIC_PUT_SIZE, this.scheduledExecutorService, log));\n        this.statsTable.put(Stats.GROUP_GET_NUMS, new StatsItemSet(Stats.GROUP_GET_NUMS, this.scheduledExecutorService, log));\n        this.statsTable.put(Stats.GROUP_GET_SIZE, new StatsItemSet(Stats.GROUP_GET_SIZE, this.scheduledExecutorService, log));\n        this.statsTable.put(GROUP_ACK_NUMS, new StatsItemSet(GROUP_ACK_NUMS, this.scheduledExecutorService, log));\n        this.statsTable.put(GROUP_CK_NUMS, new StatsItemSet(GROUP_CK_NUMS, this.scheduledExecutorService, log));\n        this.statsTable.put(Stats.GROUP_GET_LATENCY, new StatsItemSet(Stats.GROUP_GET_LATENCY, this.scheduledExecutorService, log));\n        this.statsTable.put(TOPIC_PUT_LATENCY, new StatsItemSet(TOPIC_PUT_LATENCY, this.scheduledExecutorService, log));\n        this.statsTable.put(Stats.SNDBCK_PUT_NUMS, new StatsItemSet(Stats.SNDBCK_PUT_NUMS, this.scheduledExecutorService, log));\n        this.statsTable.put(DLQ_PUT_NUMS, new StatsItemSet(DLQ_PUT_NUMS, this.scheduledExecutorService, log));\n        this.statsTable.put(Stats.BROKER_PUT_NUMS, new StatsItemSet(Stats.BROKER_PUT_NUMS, this.scheduledExecutorService, log));\n        this.statsTable.put(Stats.BROKER_GET_NUMS, new StatsItemSet(Stats.BROKER_GET_NUMS, this.scheduledExecutorService, log));\n        this.statsTable.put(BROKER_ACK_NUMS, new StatsItemSet(BROKER_ACK_NUMS, this.scheduledExecutorService, log));\n        this.statsTable.put(BROKER_CK_NUMS, new StatsItemSet(BROKER_CK_NUMS, this.scheduledExecutorService, log));\n        this.statsTable.put(BROKER_GET_NUMS_WITHOUT_SYSTEM_TOPIC,\n            new StatsItemSet(BROKER_GET_NUMS_WITHOUT_SYSTEM_TOPIC, this.scheduledExecutorService, log));\n        this.statsTable.put(BROKER_PUT_NUMS_WITHOUT_SYSTEM_TOPIC,\n            new StatsItemSet(BROKER_PUT_NUMS_WITHOUT_SYSTEM_TOPIC, this.scheduledExecutorService, log));\n        this.statsTable.put(Stats.GROUP_GET_FROM_DISK_NUMS,\n            new StatsItemSet(Stats.GROUP_GET_FROM_DISK_NUMS, this.scheduledExecutorService, log));\n        this.statsTable.put(Stats.GROUP_GET_FROM_DISK_SIZE,\n            new StatsItemSet(Stats.GROUP_GET_FROM_DISK_SIZE, this.scheduledExecutorService, log));\n        this.statsTable.put(Stats.BROKER_GET_FROM_DISK_NUMS,\n            new StatsItemSet(Stats.BROKER_GET_FROM_DISK_NUMS, this.scheduledExecutorService, log));\n        this.statsTable.put(Stats.BROKER_GET_FROM_DISK_SIZE,\n            new StatsItemSet(Stats.BROKER_GET_FROM_DISK_SIZE, this.scheduledExecutorService, log));\n\n        this.statsTable.put(SNDBCK2DLQ_TIMES,\n            new StatsItemSet(SNDBCK2DLQ_TIMES, this.scheduledExecutorService, DLQ_STAT_LOG));\n\n        this.statsTable.put(Stats.COMMERCIAL_SEND_TIMES,\n            new StatsItemSet(Stats.COMMERCIAL_SEND_TIMES, this.commercialExecutor, COMMERCIAL_LOG));\n        this.statsTable.put(Stats.COMMERCIAL_RCV_TIMES,\n            new StatsItemSet(Stats.COMMERCIAL_RCV_TIMES, this.commercialExecutor, COMMERCIAL_LOG));\n        this.statsTable.put(Stats.COMMERCIAL_SEND_SIZE,\n            new StatsItemSet(Stats.COMMERCIAL_SEND_SIZE, this.commercialExecutor, COMMERCIAL_LOG));\n        this.statsTable.put(Stats.COMMERCIAL_RCV_SIZE,\n            new StatsItemSet(Stats.COMMERCIAL_RCV_SIZE, this.commercialExecutor, COMMERCIAL_LOG));\n        this.statsTable.put(Stats.COMMERCIAL_RCV_EPOLLS,\n            new StatsItemSet(Stats.COMMERCIAL_RCV_EPOLLS, this.commercialExecutor, COMMERCIAL_LOG));\n        this.statsTable.put(Stats.COMMERCIAL_SNDBCK_TIMES,\n            new StatsItemSet(Stats.COMMERCIAL_SNDBCK_TIMES, this.commercialExecutor, COMMERCIAL_LOG));\n        this.statsTable.put(Stats.COMMERCIAL_PERM_FAILURES,\n            new StatsItemSet(Stats.COMMERCIAL_PERM_FAILURES, this.commercialExecutor, COMMERCIAL_LOG));\n\n        this.statsTable.put(CONSUMER_REGISTER_TIME,\n            new StatsItemSet(CONSUMER_REGISTER_TIME, this.scheduledExecutorService, log));\n        this.statsTable.put(PRODUCER_REGISTER_TIME,\n            new StatsItemSet(PRODUCER_REGISTER_TIME, this.scheduledExecutorService, log));\n\n        this.statsTable.put(CHANNEL_ACTIVITY, new StatsItemSet(CHANNEL_ACTIVITY, this.scheduledExecutorService, log));\n\n        StatisticsItemFormatter formatter = new StatisticsItemFormatter();\n        accountStatManager.setBriefMeta(new Pair[] {\n            Pair.of(RT, new long[][] {{50, 50}, {100, 10}, {1000, 10}}),\n            Pair.of(INNER_RT, new long[][] {{10, 10}, {100, 10}, {1000, 10}})});\n        String[] itemNames = new String[] {\n            MSG_NUM, SUCCESS_MSG_NUM, FAILURE_MSG_NUM, COMMERCIAL_MSG_NUM,\n            SUCCESS_REQ_NUM, FAILURE_REQ_NUM,\n            MSG_SIZE, SUCCESS_MSG_SIZE, FAILURE_MSG_SIZE,\n            RT, INNER_RT};\n        this.accountStatManager.addStatisticsKindMeta(createStatisticsKindMeta(\n            ACCOUNT_SEND, itemNames, this.accountExecutor, formatter, ACCOUNT_LOG, ACCOUNT_STAT_INVERTAL));\n        this.accountStatManager.addStatisticsKindMeta(createStatisticsKindMeta(\n            ACCOUNT_RCV, itemNames, this.accountExecutor, formatter, ACCOUNT_LOG, ACCOUNT_STAT_INVERTAL));\n        this.accountStatManager.addStatisticsKindMeta(createStatisticsKindMeta(\n            ACCOUNT_SEND_BACK, itemNames, this.accountExecutor, formatter, ACCOUNT_LOG, ACCOUNT_STAT_INVERTAL));\n        this.accountStatManager.addStatisticsKindMeta(createStatisticsKindMeta(\n            ACCOUNT_SEND_BACK_TO_DLQ, itemNames, this.accountExecutor, formatter, ACCOUNT_LOG, ACCOUNT_STAT_INVERTAL));\n        this.accountStatManager.addStatisticsKindMeta(createStatisticsKindMeta(\n            ACCOUNT_SEND_REJ, itemNames, this.accountExecutor, formatter, ACCOUNT_LOG, ACCOUNT_STAT_INVERTAL));\n        this.accountStatManager.addStatisticsKindMeta(createStatisticsKindMeta(\n            ACCOUNT_REV_REJ, itemNames, this.accountExecutor, formatter, ACCOUNT_LOG, ACCOUNT_STAT_INVERTAL));\n        this.accountStatManager.setStatisticsItemStateGetter(new StatisticsItemStateGetter() {\n            @Override\n            public boolean online(StatisticsItem item) {\n                String[] strArr = null;\n                try {\n                    strArr = splitAccountStatKey(item.getStatObject());\n                } catch (Exception e) {\n                    log.warn(\"parse account stat key failed, key: {}\", item.getStatObject());\n                    return false;\n                }\n\n                // TODO ugly\n                if (strArr == null || strArr.length < 4) {\n                    return false;\n                }\n\n                String instanceId = strArr[1];\n                String topic = strArr[2];\n                String group = strArr[3];\n\n                String kind = item.getStatKind();\n                if (ACCOUNT_SEND.equals(kind) || ACCOUNT_SEND_REJ.equals(kind)) {\n                    return producerStateGetter.online(instanceId, group, topic);\n                } else if (ACCOUNT_RCV.equals(kind) || ACCOUNT_SEND_BACK.equals(kind) || ACCOUNT_SEND_BACK_TO_DLQ.equals(kind) || ACCOUNT_REV_REJ.equals(kind)) {\n                    return consumerStateGetter.online(instanceId, group, topic);\n                }\n                return false;\n            }\n        });\n    }\n\n    private void initScheduleService() {\n        this.scheduledExecutorService =\n            ThreadUtils.newSingleThreadScheduledExecutor(new ThreadFactoryImpl(\"BrokerStatsThread\", true, brokerConfig));\n        this.commercialExecutor =\n            ThreadUtils.newSingleThreadScheduledExecutor(new ThreadFactoryImpl(\"CommercialStatsThread\", true, brokerConfig));\n        this.accountExecutor =\n            ThreadUtils.newSingleThreadScheduledExecutor(new ThreadFactoryImpl(\"AccountStatsThread\", true, brokerConfig));\n    }\n\n    public MomentStatsItemSet getMomentStatsItemSetFallSize() {\n        return momentStatsItemSetFallSize;\n    }\n\n    public MomentStatsItemSet getMomentStatsItemSetFallTime() {\n        return momentStatsItemSetFallTime;\n    }\n\n    public StateGetter getProducerStateGetter() {\n        return producerStateGetter;\n    }\n\n    public void setProducerStateGetter(StateGetter producerStateGetter) {\n        this.producerStateGetter = producerStateGetter;\n    }\n\n    public StateGetter getConsumerStateGetter() {\n        return consumerStateGetter;\n    }\n\n    public void setConsumerStateGetter(StateGetter consumerStateGetter) {\n        this.consumerStateGetter = consumerStateGetter;\n    }\n\n    public void start() {\n    }\n\n    public void shutdown() {\n        this.scheduledExecutorService.shutdown();\n        this.commercialExecutor.shutdown();\n    }\n\n    public StatsItem getStatsItem(final String statsName, final String statsKey) {\n        try {\n            return this.statsTable.get(statsName).getStatsItem(statsKey);\n        } catch (Exception e) {\n        }\n\n        return null;\n    }\n\n    public void onTopicDeleted(final String topic) {\n        this.statsTable.get(Stats.TOPIC_PUT_NUMS).delValue(topic);\n        this.statsTable.get(Stats.TOPIC_PUT_SIZE).delValue(topic);\n        if (enableQueueStat) {\n            this.statsTable.get(Stats.QUEUE_PUT_NUMS).delValueByPrefixKey(topic, \"@\");\n            this.statsTable.get(Stats.QUEUE_PUT_SIZE).delValueByPrefixKey(topic, \"@\");\n        }\n        this.statsTable.get(Stats.GROUP_GET_NUMS).delValueByPrefixKey(topic, \"@\");\n        this.statsTable.get(Stats.GROUP_GET_SIZE).delValueByPrefixKey(topic, \"@\");\n        this.statsTable.get(Stats.QUEUE_GET_NUMS).delValueByPrefixKey(topic, \"@\");\n        this.statsTable.get(Stats.QUEUE_GET_SIZE).delValueByPrefixKey(topic, \"@\");\n        this.statsTable.get(Stats.SNDBCK_PUT_NUMS).delValueByPrefixKey(topic, \"@\");\n        this.statsTable.get(Stats.GROUP_GET_LATENCY).delValueByInfixKey(topic, \"@\");\n        this.momentStatsItemSetFallSize.delValueByInfixKey(topic, \"@\");\n        this.momentStatsItemSetFallTime.delValueByInfixKey(topic, \"@\");\n    }\n\n    public void onGroupDeleted(final String group) {\n        this.statsTable.get(Stats.GROUP_GET_NUMS).delValueBySuffixKey(group, \"@\");\n        this.statsTable.get(Stats.GROUP_GET_SIZE).delValueBySuffixKey(group, \"@\");\n        if (enableQueueStat) {\n            this.statsTable.get(Stats.QUEUE_GET_NUMS).delValueBySuffixKey(group, \"@\");\n            this.statsTable.get(Stats.QUEUE_GET_SIZE).delValueBySuffixKey(group, \"@\");\n        }\n        this.statsTable.get(Stats.SNDBCK_PUT_NUMS).delValueBySuffixKey(group, \"@\");\n        this.statsTable.get(Stats.GROUP_GET_LATENCY).delValueBySuffixKey(group, \"@\");\n        this.momentStatsItemSetFallSize.delValueBySuffixKey(group, \"@\");\n        this.momentStatsItemSetFallTime.delValueBySuffixKey(group, \"@\");\n    }\n\n    public void incQueuePutNums(final String topic, final Integer queueId) {\n        if (enableQueueStat) {\n            this.statsTable.get(Stats.QUEUE_PUT_NUMS).addValue(buildStatsKey(topic, queueId), 1, 1);\n        }\n    }\n\n    public void incQueuePutNums(final String topic, final Integer queueId, int num, int times) {\n        if (enableQueueStat) {\n            this.statsTable.get(Stats.QUEUE_PUT_NUMS).addValue(buildStatsKey(topic, queueId), num, times);\n        }\n    }\n\n    public void incQueuePutSize(final String topic, final Integer queueId, final int size) {\n        if (enableQueueStat) {\n            this.statsTable.get(Stats.QUEUE_PUT_SIZE).addValue(buildStatsKey(topic, queueId), size, 1);\n        }\n    }\n\n    public void incQueueGetNums(final String group, final String topic, final Integer queueId, final int incValue) {\n        if (enableQueueStat) {\n            final String statsKey = buildStatsKey(topic, queueId, group);\n            this.statsTable.get(Stats.QUEUE_GET_NUMS).addValue(statsKey, incValue, 1);\n        }\n    }\n\n    public void incQueueGetSize(final String group, final String topic, final Integer queueId, final int incValue) {\n        if (enableQueueStat) {\n            final String statsKey = buildStatsKey(topic, queueId, group);\n            this.statsTable.get(Stats.QUEUE_GET_SIZE).addValue(statsKey, incValue, 1);\n        }\n    }\n\n    public void incConsumerRegisterTime(final int incValue) {\n        this.statsTable.get(CONSUMER_REGISTER_TIME).addValue(this.clusterName, incValue, 1);\n    }\n\n    public void incProducerRegisterTime(final int incValue) {\n        this.statsTable.get(PRODUCER_REGISTER_TIME).addValue(this.clusterName, incValue, 1);\n    }\n\n    public void incChannelConnectNum() {\n        this.statsTable.get(CHANNEL_ACTIVITY).addValue(CHANNEL_ACTIVITY_CONNECT, 1, 1);\n    }\n\n    public void incChannelCloseNum() {\n        this.statsTable.get(CHANNEL_ACTIVITY).addValue(CHANNEL_ACTIVITY_CLOSE, 1, 1);\n    }\n\n    public void incChannelExceptionNum() {\n        this.statsTable.get(CHANNEL_ACTIVITY).addValue(CHANNEL_ACTIVITY_EXCEPTION, 1, 1);\n    }\n\n    public void incChannelIdleNum() {\n        this.statsTable.get(CHANNEL_ACTIVITY).addValue(CHANNEL_ACTIVITY_IDLE, 1, 1);\n    }\n\n    public void incTopicPutNums(final String topic) {\n        this.statsTable.get(Stats.TOPIC_PUT_NUMS).addValue(topic, 1, 1);\n    }\n\n    public void incTopicPutNums(final String topic, int num, int times) {\n        this.statsTable.get(Stats.TOPIC_PUT_NUMS).addValue(topic, num, times);\n    }\n\n    public void incTopicPutSize(final String topic, final int size) {\n        this.statsTable.get(Stats.TOPIC_PUT_SIZE).addValue(topic, size, 1);\n    }\n\n    public void incGroupGetNums(final String group, final String topic, final int incValue) {\n        final String statsKey = buildStatsKey(topic, group);\n        this.statsTable.get(Stats.GROUP_GET_NUMS).addValue(statsKey, incValue, 1);\n    }\n\n    public void incGroupCkNums(final String group, final String topic, final int incValue) {\n        final String statsKey = buildStatsKey(topic, group);\n        this.statsTable.get(GROUP_CK_NUMS).addValue(statsKey, incValue, 1);\n    }\n\n    public void incGroupAckNums(final String group, final String topic, final int incValue) {\n        final String statsKey = buildStatsKey(topic, group);\n        this.statsTable.get(GROUP_ACK_NUMS).addValue(statsKey, incValue, 1);\n    }\n\n    public String buildStatsKey(String topic, String group) {\n        StringBuilder strBuilder;\n        if (topic != null && group != null) {\n            strBuilder = new StringBuilder(topic.length() + group.length() + 1);\n        } else {\n            strBuilder = new StringBuilder();\n        }\n        strBuilder.append(topic).append(\"@\").append(group);\n        return strBuilder.toString();\n    }\n\n    public String buildStatsKey(String topic, int queueId) {\n        StringBuilder strBuilder;\n        if (topic != null) {\n            strBuilder = new StringBuilder(topic.length() + 5);\n        } else {\n            strBuilder = new StringBuilder();\n        }\n        strBuilder.append(topic).append(\"@\").append(queueId);\n        return strBuilder.toString();\n    }\n\n    public String buildStatsKey(String topic, int queueId, String group) {\n        StringBuilder strBuilder;\n        if (topic != null && group != null) {\n            strBuilder = new StringBuilder(topic.length() + group.length() + 6);\n        } else {\n            strBuilder = new StringBuilder();\n        }\n        strBuilder.append(topic).append(\"@\").append(queueId).append(\"@\").append(group);\n        return strBuilder.toString();\n    }\n\n    public String buildStatsKey(int queueId, String topic, String group) {\n        StringBuilder strBuilder;\n        if (topic != null && group != null) {\n            strBuilder = new StringBuilder(topic.length() + group.length() + 6);\n        } else {\n            strBuilder = new StringBuilder();\n        }\n        strBuilder.append(queueId).append(\"@\").append(topic).append(\"@\").append(group);\n        return strBuilder.toString();\n    }\n\n    public void incGroupGetSize(final String group, final String topic, final int incValue) {\n        final String statsKey = buildStatsKey(topic, group);\n        this.statsTable.get(Stats.GROUP_GET_SIZE).addValue(statsKey, incValue, 1);\n    }\n\n    public void incGroupGetLatency(final String group, final String topic, final int queueId, final int incValue) {\n        String statsKey;\n        if (enableQueueStat) {\n            statsKey = buildStatsKey(queueId, topic, group);\n        } else {\n            statsKey = buildStatsKey(topic, group);\n        }\n        this.statsTable.get(Stats.GROUP_GET_LATENCY).addRTValue(statsKey, incValue, 1);\n    }\n\n    public void incTopicPutLatency(final String topic, final int queueId, final int incValue) {\n        StringBuilder statsKey;\n        if (topic != null) {\n            statsKey = new StringBuilder(topic.length() + 6);\n        } else {\n            statsKey = new StringBuilder(6);\n        }\n        statsKey.append(queueId).append(\"@\").append(topic);\n        this.statsTable.get(TOPIC_PUT_LATENCY).addValue(statsKey.toString(), incValue, 1);\n    }\n\n    public void incBrokerPutNums() {\n        this.statsTable.get(Stats.BROKER_PUT_NUMS).getAndCreateStatsItem(this.clusterName).getValue().add(1);\n    }\n\n    public void incBrokerPutNums(final String topic, final int incValue) {\n        this.statsTable.get(Stats.BROKER_PUT_NUMS).getAndCreateStatsItem(this.clusterName).getValue().add(incValue);\n        incBrokerPutNumsWithoutSystemTopic(topic, incValue);\n    }\n\n    public void incBrokerGetNums(final String topic, final int incValue) {\n        this.statsTable.get(Stats.BROKER_GET_NUMS).getAndCreateStatsItem(this.clusterName).getValue().add(incValue);\n        this.incBrokerGetNumsWithoutSystemTopic(topic, incValue);\n    }\n\n    public void incBrokerAckNums(final int incValue) {\n        this.statsTable.get(BROKER_ACK_NUMS).getAndCreateStatsItem(this.clusterName).getValue().add(incValue);\n    }\n\n    public void incBrokerCkNums(final int incValue) {\n        this.statsTable.get(BROKER_CK_NUMS).getAndCreateStatsItem(this.clusterName).getValue().add(incValue);\n    }\n\n    public void incBrokerGetNumsWithoutSystemTopic(final String topic, final int incValue) {\n        if (TopicValidator.isSystemTopic(topic)) {\n            return;\n        }\n        this.statsTable.get(BROKER_GET_NUMS_WITHOUT_SYSTEM_TOPIC).getAndCreateStatsItem(this.clusterName).getValue().add(incValue);\n    }\n\n    public void incBrokerPutNumsWithoutSystemTopic(final String topic, final int incValue) {\n        if (TopicValidator.isSystemTopic(topic)) {\n            return;\n        }\n        this.statsTable.get(BROKER_PUT_NUMS_WITHOUT_SYSTEM_TOPIC).getAndCreateStatsItem(this.clusterName).getValue().add(incValue);\n    }\n\n    public long getBrokerGetNumsWithoutSystemTopic() {\n        final StatsItemSet statsItemSet = this.statsTable.get(BROKER_GET_NUMS_WITHOUT_SYSTEM_TOPIC);\n        if (statsItemSet == null) {\n            return 0;\n        }\n        final StatsItem statsItem = statsItemSet.getStatsItem(this.clusterName);\n        if (statsItem == null) {\n            return 0;\n        }\n        return statsItem.getValue().longValue();\n    }\n\n    public long getBrokerPutNumsWithoutSystemTopic() {\n        final StatsItemSet statsItemSet = this.statsTable.get(BROKER_PUT_NUMS_WITHOUT_SYSTEM_TOPIC);\n        if (statsItemSet == null) {\n            return 0;\n        }\n        final StatsItem statsItem = statsItemSet.getStatsItem(this.clusterName);\n        if (statsItem == null) {\n            return 0;\n        }\n        return statsItem.getValue().longValue();\n    }\n\n    public void incSendBackNums(final String group, final String topic) {\n        final String statsKey = buildStatsKey(topic, group);\n        this.statsTable.get(Stats.SNDBCK_PUT_NUMS).addValue(statsKey, 1, 1);\n    }\n\n    public double tpsGroupGetNums(final String group, final String topic) {\n        final String statsKey = buildStatsKey(topic, group);\n        return this.statsTable.get(Stats.GROUP_GET_NUMS).getStatsDataInMinute(statsKey).getTps();\n    }\n\n    public void recordDiskFallBehindTime(final String group, final String topic, final int queueId,\n        final long fallBehind) {\n        final String statsKey = buildStatsKey(queueId, topic, group);\n        this.momentStatsItemSetFallTime.getAndCreateStatsItem(statsKey).getValue().set(fallBehind);\n    }\n\n    public void recordDiskFallBehindSize(final String group, final String topic, final int queueId,\n        final long fallBehind) {\n        final String statsKey = buildStatsKey(queueId, topic, group);\n        this.momentStatsItemSetFallSize.getAndCreateStatsItem(statsKey).getValue().set(fallBehind);\n    }\n\n    public void incDLQStatValue(final String key, final String owner, final String group,\n        final String topic, final String type, final int incValue) {\n        final String statsKey = buildCommercialStatsKey(owner, topic, group, type);\n        this.statsTable.get(key).addValue(statsKey, incValue, 1);\n    }\n\n    public void incCommercialValue(final String key, final String owner, final String group,\n        final String topic, final String type, final int incValue) {\n        final String statsKey = buildCommercialStatsKey(owner, topic, group, type);\n        this.statsTable.get(key).addValue(statsKey, incValue, 1);\n    }\n\n    public void incAccountValue(final String key, final String accountOwnerParent, final String accountOwnerSelf,\n        final String instanceId, final String group, final String topic,\n        final String msgType, final int incValue) {\n        final String statsKey = buildAccountStatsKey(accountOwnerParent, accountOwnerSelf, instanceId, topic, group,\n            msgType);\n        this.statsTable.get(key).addValue(statsKey, incValue, 1);\n    }\n\n    public void incAccountValue(final String key, final String accountOwnerParent, final String accountOwnerSelf,\n        final String instanceId, final String group, final String topic,\n        final String msgType, final String flowlimitThreshold, final int incValue) {\n        final String statsKey = buildAccountStatsKey(accountOwnerParent, accountOwnerSelf, instanceId, topic, group,\n            msgType, flowlimitThreshold);\n        this.statsTable.get(key).addValue(statsKey, incValue, 1);\n    }\n\n    public void incAccountValue(final String statType, final String owner, final String instanceId, final String topic,\n        final String group, final String msgType,\n        final long... incValues) {\n        final String key = buildAccountStatKey(owner, instanceId, topic, group, msgType);\n        this.accountStatManager.inc(statType, key, incValues);\n    }\n\n    public void incAccountValue(final String statType, final String owner, final String instanceId, final String topic,\n        final String group, final String msgType, final String flowlimitThreshold,\n        final long... incValues) {\n        final String key = buildAccountStatKey(owner, instanceId, topic, group, msgType, flowlimitThreshold);\n        this.accountStatManager.inc(statType, key, incValues);\n    }\n\n    public String buildCommercialStatsKey(String owner, String topic, String group, String type) {\n        StringBuilder strBuilder = new StringBuilder();\n        strBuilder.append(owner);\n        strBuilder.append(\"@\");\n        strBuilder.append(topic);\n        strBuilder.append(\"@\");\n        strBuilder.append(group);\n        strBuilder.append(\"@\");\n        strBuilder.append(type);\n        return strBuilder.toString();\n    }\n\n    public String buildAccountStatsKey(String accountOwnerParent, String accountOwnerSelf, String instanceId,\n        String topic, String group, String msgType) {\n        StringBuffer strBuilder = new StringBuffer();\n        strBuilder.append(accountOwnerParent);\n        strBuilder.append(\"@\");\n        strBuilder.append(accountOwnerSelf);\n        strBuilder.append(\"@\");\n        strBuilder.append(instanceId);\n        strBuilder.append(\"@\");\n        strBuilder.append(topic);\n        strBuilder.append(\"@\");\n        strBuilder.append(group);\n        strBuilder.append(\"@\");\n        strBuilder.append(msgType);\n        return strBuilder.toString();\n    }\n\n    public String buildAccountStatsKey(String accountOwnerParent, String accountOwnerSelf, String instanceId,\n        String topic, String group, String msgType, String flowlimitThreshold) {\n        StringBuffer strBuilder = new StringBuffer();\n        strBuilder.append(accountOwnerParent);\n        strBuilder.append(\"@\");\n        strBuilder.append(accountOwnerSelf);\n        strBuilder.append(\"@\");\n        strBuilder.append(instanceId);\n        strBuilder.append(\"@\");\n        strBuilder.append(topic);\n        strBuilder.append(\"@\");\n        strBuilder.append(group);\n        strBuilder.append(\"@\");\n        strBuilder.append(msgType);\n        strBuilder.append(\"@\");\n        strBuilder.append(flowlimitThreshold);\n        return strBuilder.toString();\n    }\n\n    public String buildAccountStatKey(final String owner, final String instanceId,\n        final String topic, final String group,\n        final String msgType) {\n        final String sep = \"|\";\n        StringBuffer strBuilder = new StringBuffer();\n        strBuilder.append(owner).append(sep);\n        strBuilder.append(instanceId).append(sep);\n        strBuilder.append(topic).append(sep);\n        strBuilder.append(group).append(sep);\n        strBuilder.append(msgType);\n        return strBuilder.toString();\n    }\n\n    public String buildAccountStatKey(final String owner, final String instanceId,\n        final String topic, final String group,\n        final String msgType, String flowlimitThreshold) {\n        final String sep = \"|\";\n        StringBuffer strBuilder = new StringBuffer();\n        strBuilder.append(owner).append(sep);\n        strBuilder.append(instanceId).append(sep);\n        strBuilder.append(topic).append(sep);\n        strBuilder.append(group).append(sep);\n        strBuilder.append(msgType).append(sep);\n        strBuilder.append(flowlimitThreshold);\n        return strBuilder.toString();\n    }\n\n    public String[] splitAccountStatKey(final String accountStatKey) {\n        final String sep = \"\\\\|\";\n        return accountStatKey.split(sep);\n    }\n\n    private StatisticsKindMeta createStatisticsKindMeta(String name,\n        String[] itemNames,\n        ScheduledExecutorService executorService,\n        StatisticsItemFormatter formatter,\n        Logger log,\n        long interval) {\n        final BrokerConfig brokerConfig = this.brokerConfig;\n        StatisticsItemPrinter printer = new StatisticsItemPrinter(formatter, log);\n        StatisticsKindMeta kindMeta = new StatisticsKindMeta();\n        kindMeta.setName(name);\n        kindMeta.setItemNames(itemNames);\n        kindMeta.setScheduledPrinter(\n            new StatisticsItemScheduledIncrementPrinter(\n                \"Stat In One Minute: \",\n                printer,\n                executorService,\n                new StatisticsItemScheduledPrinter.InitialDelay() {\n                    @Override\n                    public long get() {\n                        return Math.abs(UtilAll.computeNextMinutesTimeMillis() - System.currentTimeMillis());\n                    }\n                },\n                interval,\n                new String[] {MSG_NUM},\n                new StatisticsItemScheduledIncrementPrinter.Valve() {\n                    @Override\n                    public boolean enabled() {\n                        return brokerConfig != null ? brokerConfig.isAccountStatsEnable() : true;\n                    }\n\n                    @Override\n                    public boolean printZeroLine() {\n                        return brokerConfig != null ? brokerConfig.isAccountStatsPrintZeroValues() : true;\n                    }\n                }\n            )\n        );\n        return kindMeta;\n    }\n\n    public interface StateGetter {\n        boolean online(String instanceId, String group, String topic);\n    }\n\n    public enum StatsType {\n        SEND_SUCCESS,\n        SEND_FAILURE,\n\n        RCV_SUCCESS,\n        RCV_EPOLLS,\n        SEND_BACK,\n        SEND_BACK_TO_DLQ,\n\n        SEND_ORDER,\n        SEND_TIMER,\n        SEND_TRANSACTION,\n\n        PERM_FAILURE\n    }\n}\n",
            "role": "user"
        },
        {
            "content": "//client/src/main/java/org/apache/rocketmq/client/impl/consumer/DefaultLitePullConsumerImpl.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.rocketmq.client.impl.consumer;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.rocketmq.client.Validators;\nimport org.apache.rocketmq.client.consumer.DefaultLitePullConsumer;\nimport org.apache.rocketmq.client.consumer.MessageQueueListener;\nimport org.apache.rocketmq.client.consumer.MessageSelector;\nimport org.apache.rocketmq.client.consumer.PullResult;\nimport org.apache.rocketmq.client.consumer.TopicMessageQueueChangeListener;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.store.LocalFileOffsetStore;\nimport org.apache.rocketmq.client.consumer.store.OffsetStore;\nimport org.apache.rocketmq.client.consumer.store.ReadOffsetType;\nimport org.apache.rocketmq.client.consumer.store.RemoteBrokerOffsetStore;\nimport org.apache.rocketmq.client.exception.MQBrokerException;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.hook.ConsumeMessageContext;\nimport org.apache.rocketmq.client.hook.ConsumeMessageHook;\nimport org.apache.rocketmq.client.hook.FilterMessageHook;\nimport org.apache.rocketmq.client.impl.CommunicationMode;\nimport org.apache.rocketmq.client.impl.MQClientManager;\nimport org.apache.rocketmq.client.impl.factory.MQClientInstance;\nimport org.apache.rocketmq.common.MixAll;\nimport org.apache.rocketmq.common.ServiceState;\nimport org.apache.rocketmq.common.ThreadFactoryImpl;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.filter.ExpressionType;\nimport org.apache.rocketmq.common.help.FAQUrl;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.common.message.MessageQueue;\nimport org.apache.rocketmq.common.sysflag.PullSysFlag;\nimport org.apache.rocketmq.remoting.RPCHook;\nimport org.apache.rocketmq.remoting.exception.RemotingException;\nimport org.apache.rocketmq.remoting.protocol.NamespaceUtil;\nimport org.apache.rocketmq.remoting.protocol.ResponseCode;\nimport org.apache.rocketmq.remoting.protocol.body.ConsumerRunningInfo;\nimport org.apache.rocketmq.remoting.protocol.body.ProcessQueueInfo;\nimport org.apache.rocketmq.remoting.protocol.filter.FilterAPI;\nimport org.apache.rocketmq.remoting.protocol.heartbeat.ConsumeType;\nimport org.apache.rocketmq.remoting.protocol.heartbeat.MessageModel;\nimport org.apache.rocketmq.remoting.protocol.heartbeat.SubscriptionData;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\n\npublic class DefaultLitePullConsumerImpl implements MQConsumerInner {\n\n    private static final Logger log = LoggerFactory.getLogger(DefaultLitePullConsumerImpl.class);\n\n    private final long consumerStartTimestamp = System.currentTimeMillis();\n\n    private final RPCHook rpcHook;\n\n    private final ArrayList<FilterMessageHook> filterMessageHookList = new ArrayList<>();\n\n    private volatile ServiceState serviceState = ServiceState.CREATE_JUST;\n\n    protected MQClientInstance mQClientFactory;\n\n    private PullAPIWrapper pullAPIWrapper;\n\n    private OffsetStore offsetStore;\n\n    private RebalanceImpl rebalanceImpl = new RebalanceLitePullImpl(this);\n\n    private enum SubscriptionType {\n        NONE, SUBSCRIBE, ASSIGN\n    }\n\n    private static final String NOT_RUNNING_EXCEPTION_MESSAGE = \"The consumer not running, please start it first.\";\n\n    private static final String SUBSCRIPTION_CONFLICT_EXCEPTION_MESSAGE = \"Subscribe and assign are mutually exclusive.\";\n    /**\n     * the type of subscription\n     */\n    private SubscriptionType subscriptionType = SubscriptionType.NONE;\n    /**\n     * Delay some time when exception occur\n     */\n    private long pullTimeDelayMillsWhenException = 1000;\n    /**\n     * Flow control interval when message cache is full\n     */\n    private static final long PULL_TIME_DELAY_MILLS_WHEN_CACHE_FLOW_CONTROL = 50;\n    /**\n     * Flow control interval when broker return flow control\n     */\n    private static final long PULL_TIME_DELAY_MILLS_WHEN_BROKER_FLOW_CONTROL = 20;\n    /**\n     * Delay some time when suspend pull service\n     */\n    private static final long PULL_TIME_DELAY_MILLS_WHEN_PAUSE = 1000;\n\n    private static final long PULL_TIME_DELAY_MILLS_ON_EXCEPTION = 3 * 1000;\n\n    private ConcurrentHashMap<String/* topic */, String/* subExpression */> topicToSubExpression = new ConcurrentHashMap<>();\n\n    private DefaultLitePullConsumer defaultLitePullConsumer;\n\n    private final ConcurrentMap<MessageQueue, PullTaskImpl> taskTable =\n        new ConcurrentHashMap<>();\n\n    private AssignedMessageQueue assignedMessageQueue = new AssignedMessageQueue();\n\n    private final BlockingQueue<ConsumeRequest> consumeRequestCache = new LinkedBlockingQueue<>();\n\n    private ScheduledThreadPoolExecutor scheduledThreadPoolExecutor;\n\n    private final ScheduledExecutorService scheduledExecutorService;\n\n    private Map<String, TopicMessageQueueChangeListener> topicMessageQueueChangeListenerMap = new HashMap<>();\n\n    private Map<String, Set<MessageQueue>> messageQueuesForTopic = new HashMap<>();\n\n    private long consumeRequestFlowControlTimes = 0L;\n\n    private long queueFlowControlTimes = 0L;\n\n    private long queueMaxSpanFlowControlTimes = 0L;\n\n    private long nextAutoCommitDeadline = -1L;\n\n    private final MessageQueueLock messageQueueLock = new MessageQueueLock();\n\n    private final ArrayList<ConsumeMessageHook> consumeMessageHookList = new ArrayList<>();\n\n    // only for test purpose, will be modified by reflection in unit test.\n    @SuppressWarnings(\"FieldMayBeFinal\")\n    private static boolean doNotUpdateTopicSubscribeInfoWhenSubscriptionChanged = false;\n\n    public DefaultLitePullConsumerImpl(final DefaultLitePullConsumer defaultLitePullConsumer, final RPCHook rpcHook) {\n        this.defaultLitePullConsumer = defaultLitePullConsumer;\n        this.rpcHook = rpcHook;\n        this.scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(\n            this.defaultLitePullConsumer.getPullThreadNums(),\n            new ThreadFactoryImpl(\"PullMsgThread-\" + this.defaultLitePullConsumer.getConsumerGroup())\n        );\n        this.scheduledExecutorService = Executors.newSingleThreadScheduledExecutor(new ThreadFactoryImpl(\"MonitorMessageQueueChangeThread\"));\n        this.pullTimeDelayMillsWhenException = defaultLitePullConsumer.getPullTimeDelayMillsWhenException();\n    }\n\n    public void registerConsumeMessageHook(final ConsumeMessageHook hook) {\n        this.consumeMessageHookList.add(hook);\n        log.info(\"register consumeMessageHook Hook, {}\", hook.hookName());\n    }\n\n    public void executeHookBefore(final ConsumeMessageContext context) {\n        if (!this.consumeMessageHookList.isEmpty()) {\n            for (ConsumeMessageHook hook : this.consumeMessageHookList) {\n                try {\n                    hook.consumeMessageBefore(context);\n                } catch (Throwable e) {\n                    log.error(\"consumeMessageHook {} executeHookBefore exception\", hook.hookName(), e);\n                }\n            }\n        }\n    }\n\n    public void executeHookAfter(final ConsumeMessageContext context) {\n        if (!this.consumeMessageHookList.isEmpty()) {\n            for (ConsumeMessageHook hook : this.consumeMessageHookList) {\n                try {\n                    hook.consumeMessageAfter(context);\n                } catch (Throwable e) {\n                    log.error(\"consumeMessageHook {} executeHookAfter exception\", hook.hookName(), e);\n                }\n            }\n        }\n    }\n\n    private void checkServiceState() {\n        if (this.serviceState != ServiceState.RUNNING) {\n            throw new IllegalStateException(NOT_RUNNING_EXCEPTION_MESSAGE);\n        }\n    }\n\n    public void updateNameServerAddr(String newAddresses) {\n        this.mQClientFactory.getMQClientAPIImpl().updateNameServerAddressList(newAddresses);\n    }\n\n    private synchronized void setSubscriptionType(SubscriptionType type) {\n        if (this.subscriptionType == SubscriptionType.NONE) {\n            this.subscriptionType = type;\n        } else if (this.subscriptionType != type) {\n            throw new IllegalStateException(SUBSCRIPTION_CONFLICT_EXCEPTION_MESSAGE);\n        }\n    }\n\n    private void updateAssignedMessageQueue(String topic, Set<MessageQueue> assignedMessageQueue) {\n        this.assignedMessageQueue.updateAssignedMessageQueue(topic, assignedMessageQueue);\n    }\n\n    private void updatePullTask(String topic, Set<MessageQueue> mqNewSet) {\n        Iterator<Map.Entry<MessageQueue, PullTaskImpl>> it = this.taskTable.entrySet().iterator();\n        while (it.hasNext()) {\n            Map.Entry<MessageQueue, PullTaskImpl> next = it.next();\n            if (next.getKey().getTopic().equals(topic)) {\n                if (!mqNewSet.contains(next.getKey())) {\n                    next.getValue().setCancelled(true);\n                    it.remove();\n                }\n            }\n        }\n        startPullTask(mqNewSet);\n    }\n\n    class MessageQueueListenerImpl implements MessageQueueListener {\n        @Override\n        public void messageQueueChanged(String topic, Set<MessageQueue> mqAll, Set<MessageQueue> mqDivided) {\n            updateAssignQueueAndStartPullTask(topic, mqAll, mqDivided);\n        }\n    }\n\n    public void updateAssignQueueAndStartPullTask(String topic, Set<MessageQueue> mqAll, Set<MessageQueue> mqDivided) {\n        MessageModel messageModel = defaultLitePullConsumer.getMessageModel();\n        switch (messageModel) {\n            case BROADCASTING:\n                updateAssignedMessageQueue(topic, mqAll);\n                updatePullTask(topic, mqAll);\n                break;\n            case CLUSTERING:\n                updateAssignedMessageQueue(topic, mqDivided);\n                updatePullTask(topic, mqDivided);\n                break;\n            default:\n                break;\n        }\n    }\n\n    public synchronized void shutdown() {\n        switch (this.serviceState) {\n            case CREATE_JUST:\n                break;\n            case RUNNING:\n                persistConsumerOffset();\n                this.mQClientFactory.unregisterConsumer(this.defaultLitePullConsumer.getConsumerGroup());\n                scheduledThreadPoolExecutor.shutdown();\n                scheduledExecutorService.shutdown();\n                this.mQClientFactory.shutdown();\n                this.serviceState = ServiceState.SHUTDOWN_ALREADY;\n                log.info(\"the consumer [{}] shutdown OK\", this.defaultLitePullConsumer.getConsumerGroup());\n                break;\n            default:\n                break;\n        }\n    }\n\n    public synchronized boolean isRunning() {\n        return this.serviceState == ServiceState.RUNNING;\n    }\n\n    public synchronized void start() throws MQClientException {\n        switch (this.serviceState) {\n            case CREATE_JUST:\n                this.serviceState = ServiceState.START_FAILED;\n\n                this.checkConfig();\n\n                if (this.defaultLitePullConsumer.getMessageModel() == MessageModel.CLUSTERING) {\n                    this.defaultLitePullConsumer.changeInstanceNameToPID();\n                }\n\n                initMQClientFactory();\n\n                initRebalanceImpl();\n\n                initPullAPIWrapper();\n\n                initOffsetStore();\n\n                mQClientFactory.start();\n\n                startScheduleTask();\n\n                this.serviceState = ServiceState.RUNNING;\n\n                log.info(\"the consumer [{}] start OK\", this.defaultLitePullConsumer.getConsumerGroup());\n\n                operateAfterRunning();\n\n                break;\n            case RUNNING:\n            case START_FAILED:\n            case SHUTDOWN_ALREADY:\n                throw new MQClientException(\"The PullConsumer service state not OK, maybe started once, \"\n                    + this.serviceState\n                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),\n                    null);\n            default:\n                break;\n        }\n    }\n\n    private void initMQClientFactory() throws MQClientException {\n        this.mQClientFactory = MQClientManager.getInstance().getOrCreateMQClientInstance(this.defaultLitePullConsumer, this.rpcHook);\n        boolean registerOK = mQClientFactory.registerConsumer(this.defaultLitePullConsumer.getConsumerGroup(), this);\n        if (!registerOK) {\n            this.serviceState = ServiceState.CREATE_JUST;\n\n            throw new MQClientException(\"The consumer group[\" + this.defaultLitePullConsumer.getConsumerGroup()\n                + \"] has been created before, specify another name please.\" + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),\n                null);\n        }\n    }\n\n    private void initRebalanceImpl() {\n        this.rebalanceImpl.setConsumerGroup(this.defaultLitePullConsumer.getConsumerGroup());\n        this.rebalanceImpl.setMessageModel(this.defaultLitePullConsumer.getMessageModel());\n        this.rebalanceImpl.setAllocateMessageQueueStrategy(this.defaultLitePullConsumer.getAllocateMessageQueueStrategy());\n        this.rebalanceImpl.setmQClientFactory(this.mQClientFactory);\n    }\n\n    private void initPullAPIWrapper() {\n        this.pullAPIWrapper = new PullAPIWrapper(\n            mQClientFactory,\n            this.defaultLitePullConsumer.getConsumerGroup(), isUnitMode());\n        this.pullAPIWrapper.registerFilterMessageHook(filterMessageHookList);\n    }\n\n    private void initOffsetStore() throws MQClientException {\n        if (this.defaultLitePullConsumer.getOffsetStore() != null) {\n            this.offsetStore = this.defaultLitePullConsumer.getOffsetStore();\n        } else {\n            switch (this.defaultLitePullConsumer.getMessageModel()) {\n                case BROADCASTING:\n                    this.offsetStore = new LocalFileOffsetStore(this.mQClientFactory, this.defaultLitePullConsumer.getConsumerGroup());\n                    break;\n                case CLUSTERING:\n                    this.offsetStore = new RemoteBrokerOffsetStore(this.mQClientFactory, this.defaultLitePullConsumer.getConsumerGroup());\n                    break;\n                default:\n                    break;\n            }\n            this.defaultLitePullConsumer.setOffsetStore(this.offsetStore);\n        }\n        this.offsetStore.load();\n    }\n\n    private void startScheduleTask() {\n        scheduledExecutorService.scheduleAtFixedRate(\n            new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        fetchTopicMessageQueuesAndCompare();\n                    } catch (Exception e) {\n                        log.error(\"ScheduledTask fetchMessageQueuesAndCompare exception\", e);\n                    }\n                }\n            }, 1000 * 10, this.getDefaultLitePullConsumer().getTopicMetadataCheckIntervalMillis(), TimeUnit.MILLISECONDS);\n    }\n\n    private void operateAfterRunning() throws MQClientException {\n        // If subscribe function invoke before start function, then update topic subscribe info after initialization.\n        if (subscriptionType == SubscriptionType.SUBSCRIBE) {\n            updateTopicSubscribeInfoWhenSubscriptionChanged();\n        }\n        // If assign function invoke before start function, then update pull task after initialization.\n        if (subscriptionType == SubscriptionType.ASSIGN) {\n            updateAssignPullTask(assignedMessageQueue.getAssignedMessageQueues());\n        }\n\n        for (String topic : topicMessageQueueChangeListenerMap.keySet()) {\n            Set<MessageQueue> messageQueues = fetchMessageQueues(topic);\n            messageQueuesForTopic.put(topic, messageQueues);\n        }\n        this.mQClientFactory.checkClientInBroker();\n    }\n\n    private void checkConfig() throws MQClientException {\n        // Check consumerGroup\n        Validators.checkGroup(this.defaultLitePullConsumer.getConsumerGroup());\n\n        // Check consumerGroup name is not equal default consumer group name.\n        if (this.defaultLitePullConsumer.getConsumerGroup().equals(MixAll.DEFAULT_CONSUMER_GROUP)) {\n            throw new MQClientException(\n                \"consumerGroup can not equal \"\n                    + MixAll.DEFAULT_CONSUMER_GROUP\n                    + \", please specify another one.\"\n                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),\n                null);\n        }\n\n        // Check messageModel is not null.\n        if (null == this.defaultLitePullConsumer.getMessageModel()) {\n            throw new MQClientException(\n                \"messageModel is null\"\n                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),\n                null);\n        }\n\n        // Check allocateMessageQueueStrategy is not null\n        if (null == this.defaultLitePullConsumer.getAllocateMessageQueueStrategy()) {\n            throw new MQClientException(\n                \"allocateMessageQueueStrategy is null\"\n                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),\n                null);\n        }\n\n        if (this.defaultLitePullConsumer.getConsumerTimeoutMillisWhenSuspend() < this.defaultLitePullConsumer.getBrokerSuspendMaxTimeMillis()) {\n            throw new MQClientException(\n                \"Long polling mode, the consumer consumerTimeoutMillisWhenSuspend must greater than brokerSuspendMaxTimeMillis\"\n                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),\n                null);\n        }\n    }\n\n    public PullAPIWrapper getPullAPIWrapper() {\n        return pullAPIWrapper;\n    }\n\n    private void startPullTask(Collection<MessageQueue> mqSet) {\n        for (MessageQueue messageQueue : mqSet) {\n            if (!this.taskTable.containsKey(messageQueue)) {\n                PullTaskImpl pullTask = new PullTaskImpl(messageQueue);\n                this.taskTable.put(messageQueue, pullTask);\n                this.scheduledThreadPoolExecutor.schedule(pullTask, 0, TimeUnit.MILLISECONDS);\n            }\n        }\n    }\n\n    private void updateAssignPullTask(Collection<MessageQueue> mqNewSet) {\n        Iterator<Map.Entry<MessageQueue, PullTaskImpl>> it = this.taskTable.entrySet().iterator();\n        while (it.hasNext()) {\n            Map.Entry<MessageQueue, PullTaskImpl> next = it.next();\n            if (!mqNewSet.contains(next.getKey())) {\n                next.getValue().setCancelled(true);\n                it.remove();\n            }\n        }\n\n        startPullTask(mqNewSet);\n    }\n\n    private void updateTopicSubscribeInfoWhenSubscriptionChanged() {\n        if (doNotUpdateTopicSubscribeInfoWhenSubscriptionChanged) {\n            return;\n        }\n        Map<String, SubscriptionData> subTable = rebalanceImpl.getSubscriptionInner();\n        if (subTable != null) {\n            for (final Map.Entry<String, SubscriptionData> entry : subTable.entrySet()) {\n                final String topic = entry.getKey();\n                this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);\n            }\n        }\n    }\n\n    /**\n     * subscribe data by customizing messageQueueListener\n     *\n     * @param topic\n     * @param subExpression\n     * @param messageQueueListener\n     * @throws MQClientException\n     */\n    public synchronized void subscribe(String topic, String subExpression,\n        MessageQueueListener messageQueueListener) throws MQClientException {\n        try {\n            if (StringUtils.isEmpty(topic)) {\n                throw new IllegalArgumentException(\"Topic can not be null or empty.\");\n            }\n            setSubscriptionType(SubscriptionType.SUBSCRIBE);\n            SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(topic, subExpression);\n            this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);\n            this.defaultLitePullConsumer.setMessageQueueListener(new MessageQueueListener() {\n                @Override\n                public void messageQueueChanged(String topic, Set<MessageQueue> mqAll, Set<MessageQueue> mqDivided) {\n                    // First, update the assign queue\n                    updateAssignQueueAndStartPullTask(topic, mqAll, mqDivided);\n                    // run custom listener\n                    messageQueueListener.messageQueueChanged(topic, mqAll, mqDivided);\n                }\n            });\n            assignedMessageQueue.setRebalanceImpl(this.rebalanceImpl);\n            if (serviceState == ServiceState.RUNNING) {\n                this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();\n                updateTopicSubscribeInfoWhenSubscriptionChanged();\n            }\n        } catch (Exception e) {\n            throw new MQClientException(\"subscribe exception\", e);\n        }\n    }\n\n    public synchronized void subscribe(String topic, String subExpression) throws MQClientException {\n        try {\n            if (topic == null || \"\".equals(topic)) {\n                throw new IllegalArgumentException(\"Topic can not be null or empty.\");\n            }\n            setSubscriptionType(SubscriptionType.SUBSCRIBE);\n            SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(topic, subExpression);\n            this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);\n            this.defaultLitePullConsumer.setMessageQueueListener(new MessageQueueListenerImpl());\n            assignedMessageQueue.setRebalanceImpl(this.rebalanceImpl);\n            if (serviceState == ServiceState.RUNNING) {\n                this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();\n                updateTopicSubscribeInfoWhenSubscriptionChanged();\n            }\n        } catch (Exception e) {\n            throw new MQClientException(\"subscribe exception\", e);\n        }\n    }\n\n    public synchronized void subscribe(String topic, MessageSelector messageSelector) throws MQClientException {\n        try {\n            if (topic == null || \"\".equals(topic)) {\n                throw new IllegalArgumentException(\"Topic can not be null or empty.\");\n            }\n            setSubscriptionType(SubscriptionType.SUBSCRIBE);\n            if (messageSelector == null) {\n                subscribe(topic, SubscriptionData.SUB_ALL);\n                return;\n            }\n            SubscriptionData subscriptionData = FilterAPI.build(topic,\n                messageSelector.getExpression(), messageSelector.getExpressionType());\n            this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);\n            this.defaultLitePullConsumer.setMessageQueueListener(new MessageQueueListenerImpl());\n            assignedMessageQueue.setRebalanceImpl(this.rebalanceImpl);\n            if (serviceState == ServiceState.RUNNING) {\n                this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();\n                updateTopicSubscribeInfoWhenSubscriptionChanged();\n            }\n        } catch (Exception e) {\n            throw new MQClientException(\"subscribe exception\", e);\n        }\n    }\n\n    public synchronized void unsubscribe(final String topic) {\n        this.rebalanceImpl.getSubscriptionInner().remove(topic);\n        removePullTaskCallback(topic);\n        assignedMessageQueue.removeAssignedMessageQueue(topic);\n    }\n\n    public synchronized void assign(Collection<MessageQueue> messageQueues) {\n        if (messageQueues == null || messageQueues.isEmpty()) {\n            throw new IllegalArgumentException(\"Message queues can not be null or empty.\");\n        }\n        setSubscriptionType(SubscriptionType.ASSIGN);\n        assignedMessageQueue.updateAssignedMessageQueue(messageQueues);\n        if (serviceState == ServiceState.RUNNING) {\n            updateAssignPullTask(messageQueues);\n        }\n    }\n\n    public synchronized void setSubExpressionForAssign(final String topic, final String subExpression) {\n        if (StringUtils.isBlank(subExpression)) {\n            throw new IllegalArgumentException(\"subExpression can not be null or empty.\");\n        }\n        if (serviceState != ServiceState.CREATE_JUST) {\n            throw new IllegalStateException(\"setAssignTag only can be called before start.\");\n        }\n        setSubscriptionType(SubscriptionType.ASSIGN);\n        topicToSubExpression.put(topic, subExpression);\n    }\n\n    private void maybeAutoCommit() {\n        long now = System.currentTimeMillis();\n        if (now >= nextAutoCommitDeadline) {\n            commitAll();\n            nextAutoCommitDeadline = now + defaultLitePullConsumer.getAutoCommitIntervalMillis();\n        }\n    }\n\n    public synchronized List<MessageExt> poll(long timeout) {\n        try {\n            checkServiceState();\n            if (timeout < 0) {\n                throw new IllegalArgumentException(\"Timeout must not be negative\");\n            }\n\n            if (defaultLitePullConsumer.isAutoCommit()) {\n                maybeAutoCommit();\n            }\n            long endTime = System.currentTimeMillis() + timeout;\n\n            ConsumeRequest consumeRequest = consumeRequestCache.poll(endTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n\n            if (endTime - System.currentTimeMillis() > 0) {\n                while (consumeRequest != null && consumeRequest.getProcessQueue().isDropped()) {\n                    consumeRequest = consumeRequestCache.poll(endTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n                    if (endTime - System.currentTimeMillis() <= 0) {\n                        break;\n                    }\n                }\n            }\n\n            if (consumeRequest != null && !consumeRequest.getProcessQueue().isDropped()) {\n                List<MessageExt> messages = consumeRequest.getMessageExts();\n                long offset = consumeRequest.getProcessQueue().removeMessage(messages);\n                assignedMessageQueue.updateConsumeOffset(consumeRequest.getMessageQueue(), offset);\n                //If namespace not null , reset Topic without namespace.\n                this.resetTopic(messages);\n                if (!this.consumeMessageHookList.isEmpty()) {\n                    ConsumeMessageContext consumeMessageContext = new ConsumeMessageContext();\n                    consumeMessageContext.setNamespace(defaultLitePullConsumer.getNamespace());\n                    consumeMessageContext.setConsumerGroup(this.groupName());\n                    consumeMessageContext.setMq(consumeRequest.getMessageQueue());\n                    consumeMessageContext.setMsgList(messages);\n                    consumeMessageContext.setSuccess(false);\n                    this.executeHookBefore(consumeMessageContext);\n                    consumeMessageContext.setStatus(ConsumeConcurrentlyStatus.CONSUME_SUCCESS.toString());\n                    consumeMessageContext.setSuccess(true);\n                    consumeMessageContext.setAccessChannel(defaultLitePullConsumer.getAccessChannel());\n                    this.executeHookAfter(consumeMessageContext);\n                }\n                consumeRequest.getProcessQueue().setLastConsumeTimestamp(System.currentTimeMillis());\n                return messages;\n            }\n        } catch (InterruptedException ignore) {\n\n        }\n\n        return Collections.emptyList();\n    }\n\n    public void pause(Collection<MessageQueue> messageQueues) {\n        assignedMessageQueue.pause(messageQueues);\n    }\n\n    public void resume(Collection<MessageQueue> messageQueues) {\n        assignedMessageQueue.resume(messageQueues);\n    }\n\n    public synchronized void seek(MessageQueue messageQueue, long offset) throws MQClientException {\n        if (!assignedMessageQueue.getAssignedMessageQueues().contains(messageQueue)) {\n            if (subscriptionType == SubscriptionType.SUBSCRIBE) {\n                throw new MQClientException(\"The message queue is not in assigned list, may be rebalancing, message queue: \" + messageQueue, null);\n            } else {\n                throw new MQClientException(\"The message queue is not in assigned list, message queue: \" + messageQueue, null);\n            }\n        }\n        long minOffset = minOffset(messageQueue);\n        long maxOffset = maxOffset(messageQueue);\n        if (offset < minOffset || offset > maxOffset) {\n            throw new MQClientException(\"Seek offset illegal, seek offset = \" + offset + \", min offset = \" + minOffset + \", max offset = \" + maxOffset, null);\n        }\n        final Object objLock = messageQueueLock.fetchLockObject(messageQueue);\n        synchronized (objLock) {\n            clearMessageQueueInCache(messageQueue);\n\n            PullTaskImpl oldPullTaskImpl = this.taskTable.get(messageQueue);\n            if (oldPullTaskImpl != null) {\n                oldPullTaskImpl.tryInterrupt();\n                this.taskTable.remove(messageQueue);\n            }\n            assignedMessageQueue.setSeekOffset(messageQueue, offset);\n            if (!this.taskTable.containsKey(messageQueue)) {\n                PullTaskImpl pullTask = new PullTaskImpl(messageQueue);\n                this.taskTable.put(messageQueue, pullTask);\n                this.scheduledThreadPoolExecutor.schedule(pullTask, 0, TimeUnit.MILLISECONDS);\n            }\n        }\n    }\n\n    public void seekToBegin(MessageQueue messageQueue) throws MQClientException {\n        long begin = minOffset(messageQueue);\n        this.seek(messageQueue, begin);\n    }\n\n    public void seekToEnd(MessageQueue messageQueue) throws MQClientException {\n        long end = maxOffset(messageQueue);\n        this.seek(messageQueue, end);\n    }\n\n    private long maxOffset(MessageQueue messageQueue) throws MQClientException {\n        checkServiceState();\n        return this.mQClientFactory.getMQAdminImpl().maxOffset(messageQueue);\n    }\n\n    private long minOffset(MessageQueue messageQueue) throws MQClientException {\n        checkServiceState();\n        return this.mQClientFactory.getMQAdminImpl().minOffset(messageQueue);\n    }\n\n    private void removePullTaskCallback(final String topic) {\n        removePullTask(topic);\n    }\n\n    private void removePullTask(final String topic) {\n        Iterator<Map.Entry<MessageQueue, PullTaskImpl>> it = this.taskTable.entrySet().iterator();\n        while (it.hasNext()) {\n            Map.Entry<MessageQueue, PullTaskImpl> next = it.next();\n            if (next.getKey().getTopic().equals(topic)) {\n                next.getValue().setCancelled(true);\n                it.remove();\n            }\n        }\n    }\n\n    public synchronized void commitAll() {\n        for (MessageQueue messageQueue : assignedMessageQueue.getAssignedMessageQueues()) {\n            try {\n                commit(messageQueue);\n            } catch (Exception e) {\n                log.error(\"An error occurred when update consume offset Automatically.\");\n            }\n        }\n    }\n\n    /**\n     * Specify offset commit\n     *\n     * @param messageQueues\n     * @param persist\n     */\n    public synchronized void commit(final Map<MessageQueue, Long> messageQueues, boolean persist) {\n        if (messageQueues == null || messageQueues.size() == 0) {\n            log.warn(\"MessageQueues is empty, Ignore this commit \");\n            return;\n        }\n        for (Map.Entry<MessageQueue, Long> messageQueueEntry : messageQueues.entrySet()) {\n            MessageQueue messageQueue = messageQueueEntry.getKey();\n            long offset = messageQueueEntry.getValue();\n            if (offset != -1) {\n                ProcessQueue processQueue = assignedMessageQueue.getProcessQueue(messageQueue);\n                if (processQueue != null && !processQueue.isDropped()) {\n                    updateConsumeOffset(messageQueue, offset);\n                }\n            } else {\n                log.error(\"consumerOffset is -1 in messageQueue [\" + messageQueue + \"].\");\n            }\n        }\n\n        if (persist) {\n            this.offsetStore.persistAll(messageQueues.keySet());\n        }\n    }\n\n    /**\n     * Get the queue assigned in subscribe mode\n     *\n     * @return\n     */\n    public synchronized Set<MessageQueue> assignment() {\n        return assignedMessageQueue.getAssignedMessageQueues();\n    }\n\n    public synchronized void commit(final Set<MessageQueue> messageQueues, boolean persist) {\n        if (messageQueues == null || messageQueues.size() == 0) {\n            return;\n        }\n\n        for (MessageQueue messageQueue : messageQueues) {\n            commit(messageQueue);\n        }\n\n        if (persist) {\n            this.offsetStore.persistAll(messageQueues);\n        }\n    }\n\n    private synchronized void commit(MessageQueue messageQueue) {\n        long consumerOffset = assignedMessageQueue.getConsumerOffset(messageQueue);\n\n        if (consumerOffset != -1) {\n            ProcessQueue processQueue = assignedMessageQueue.getProcessQueue(messageQueue);\n            if (processQueue != null && !processQueue.isDropped()) {\n                updateConsumeOffset(messageQueue, consumerOffset);\n            }\n        } else {\n            log.error(\"consumerOffset is -1 in messageQueue [\" + messageQueue + \"].\");\n        }\n    }\n\n    private void updatePullOffset(MessageQueue messageQueue, long nextPullOffset, ProcessQueue processQueue) {\n        if (assignedMessageQueue.getSeekOffset(messageQueue) == -1) {\n            assignedMessageQueue.updatePullOffset(messageQueue, nextPullOffset, processQueue);\n        }\n    }\n\n    private void submitConsumeRequest(ConsumeRequest consumeRequest) {\n        try {\n            consumeRequestCache.put(consumeRequest);\n        } catch (InterruptedException e) {\n            log.error(\"Submit consumeRequest error\", e);\n        }\n    }\n\n    private long fetchConsumeOffset(MessageQueue messageQueue) throws MQClientException {\n        checkServiceState();\n        long offset = this.rebalanceImpl.computePullFromWhereWithException(messageQueue);\n        return offset;\n    }\n\n    public long committed(MessageQueue messageQueue) throws MQClientException {\n        checkServiceState();\n        long offset = this.offsetStore.readOffset(messageQueue, ReadOffsetType.MEMORY_FIRST_THEN_STORE);\n        if (offset == -2) {\n            throw new MQClientException(\"Fetch consume offset from broker exception\", null);\n        }\n        return offset;\n    }\n\n    private void clearMessageQueueInCache(MessageQueue messageQueue) {\n        ProcessQueue processQueue = assignedMessageQueue.getProcessQueue(messageQueue);\n        if (processQueue != null) {\n            processQueue.clear();\n        }\n        Iterator<ConsumeRequest> iter = consumeRequestCache.iterator();\n        while (iter.hasNext()) {\n            if (iter.next().getMessageQueue().equals(messageQueue)) {\n                iter.remove();\n            }\n        }\n    }\n\n    private long nextPullOffset(MessageQueue messageQueue) throws MQClientException {\n        long offset = -1;\n        long seekOffset = assignedMessageQueue.getSeekOffset(messageQueue);\n        if (seekOffset != -1) {\n            offset = seekOffset;\n            assignedMessageQueue.updateConsumeOffset(messageQueue, offset);\n            assignedMessageQueue.setSeekOffset(messageQueue, -1);\n        } else {\n            offset = assignedMessageQueue.getPullOffset(messageQueue);\n            if (offset == -1) {\n                offset = fetchConsumeOffset(messageQueue);\n            }\n        }\n        return offset;\n    }\n\n    public long searchOffset(MessageQueue mq, long timestamp) throws MQClientException {\n        checkServiceState();\n        return this.mQClientFactory.getMQAdminImpl().searchOffset(mq, timestamp);\n    }\n\n    public class PullTaskImpl implements Runnable {\n        private final MessageQueue messageQueue;\n        private volatile boolean cancelled = false;\n        private Thread currentThread;\n\n        public PullTaskImpl(final MessageQueue messageQueue) {\n            this.messageQueue = messageQueue;\n        }\n\n        public void tryInterrupt() {\n            setCancelled(true);\n            if (currentThread == null) {\n                return;\n            }\n            if (!currentThread.isInterrupted()) {\n                currentThread.interrupt();\n            }\n        }\n\n        @Override\n        public void run() {\n\n            if (!this.isCancelled()) {\n\n                this.currentThread = Thread.currentThread();\n\n                if (assignedMessageQueue.isPaused(messageQueue)) {\n                    scheduledThreadPoolExecutor.schedule(this, PULL_TIME_DELAY_MILLS_WHEN_PAUSE, TimeUnit.MILLISECONDS);\n                    log.debug(\"Message Queue: {} has been paused!\", messageQueue);\n                    return;\n                }\n\n                ProcessQueue processQueue = assignedMessageQueue.getProcessQueue(messageQueue);\n\n                if (null == processQueue || processQueue.isDropped()) {\n                    log.info(\"The message queue not be able to poll, because it's dropped. group={}, messageQueue={}\", defaultLitePullConsumer.getConsumerGroup(), this.messageQueue);\n                    return;\n                }\n\n                processQueue.setLastPullTimestamp(System.currentTimeMillis());\n\n                if ((long) consumeRequestCache.size() * defaultLitePullConsumer.getPullBatchSize() > defaultLitePullConsumer.getPullThresholdForAll()) {\n                    scheduledThreadPoolExecutor.schedule(this, PULL_TIME_DELAY_MILLS_WHEN_CACHE_FLOW_CONTROL, TimeUnit.MILLISECONDS);\n                    if ((consumeRequestFlowControlTimes++ % 1000) == 0) {\n                        log.warn(\"The consume request count exceeds threshold {}, so do flow control, consume request count={}, flowControlTimes={}\",\n                                (int)Math.ceil((double)defaultLitePullConsumer.getPullThresholdForAll() / defaultLitePullConsumer.getPullBatchSize()),\n                                consumeRequestCache.size(), consumeRequestFlowControlTimes);\n                    }\n                    return;\n                }\n\n                long cachedMessageCount = processQueue.getMsgCount().get();\n                long cachedMessageSizeInMiB = processQueue.getMsgSize().get() / (1024 * 1024);\n\n                if (cachedMessageCount > defaultLitePullConsumer.getPullThresholdForQueue()) {\n                    scheduledThreadPoolExecutor.schedule(this, PULL_TIME_DELAY_MILLS_WHEN_CACHE_FLOW_CONTROL, TimeUnit.MILLISECONDS);\n                    if ((queueFlowControlTimes++ % 1000) == 0) {\n                        log.warn(\n                            \"The cached message count exceeds the threshold {}, so do flow control, minOffset={}, maxOffset={}, count={}, size={} MiB, flowControlTimes={}\",\n                            defaultLitePullConsumer.getPullThresholdForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, queueFlowControlTimes);\n                    }\n                    return;\n                }\n\n                if (cachedMessageSizeInMiB > defaultLitePullConsumer.getPullThresholdSizeForQueue()) {\n                    scheduledThreadPoolExecutor.schedule(this, PULL_TIME_DELAY_MILLS_WHEN_CACHE_FLOW_CONTROL, TimeUnit.MILLISECONDS);\n                    if ((queueFlowControlTimes++ % 1000) == 0) {\n                        log.warn(\n                            \"The cached message size exceeds the threshold {} MiB, so do flow control, minOffset={}, maxOffset={}, count={}, size={} MiB, flowControlTimes={}\",\n                            defaultLitePullConsumer.getPullThresholdSizeForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, queueFlowControlTimes);\n                    }\n                    return;\n                }\n\n                if (processQueue.getMaxSpan() > defaultLitePullConsumer.getConsumeMaxSpan()) {\n                    scheduledThreadPoolExecutor.schedule(this, PULL_TIME_DELAY_MILLS_WHEN_CACHE_FLOW_CONTROL, TimeUnit.MILLISECONDS);\n                    if ((queueMaxSpanFlowControlTimes++ % 1000) == 0) {\n                        log.warn(\n                            \"The queue's messages, span too long, so do flow control, minOffset={}, maxOffset={}, maxSpan={}, flowControlTimes={}\",\n                            processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), processQueue.getMaxSpan(), queueMaxSpanFlowControlTimes);\n                    }\n                    return;\n                }\n\n                long offset = 0L;\n                try {\n                    offset = nextPullOffset(messageQueue);\n                } catch (Exception e) {\n                    log.error(\"Failed to get next pull offset\", e);\n                    scheduledThreadPoolExecutor.schedule(this, PULL_TIME_DELAY_MILLS_ON_EXCEPTION, TimeUnit.MILLISECONDS);\n                    return;\n                }\n\n                if (this.isCancelled() || processQueue.isDropped()) {\n                    return;\n                }\n                long pullDelayTimeMills = 0;\n                try {\n                    SubscriptionData subscriptionData;\n                    String topic = this.messageQueue.getTopic();\n                    if (subscriptionType == SubscriptionType.SUBSCRIBE) {\n                        subscriptionData = rebalanceImpl.getSubscriptionInner().get(topic);\n                    } else {\n                        String subExpression4Assign = topicToSubExpression.get(topic);\n                        subExpression4Assign = subExpression4Assign == null ? SubscriptionData.SUB_ALL : subExpression4Assign;\n                        subscriptionData = FilterAPI.buildSubscriptionData(topic, subExpression4Assign);\n                    }\n\n                    PullResult pullResult = pull(messageQueue, subscriptionData, offset, defaultLitePullConsumer.getPullBatchSize());\n                    if (this.isCancelled() || processQueue.isDropped()) {\n                        return;\n                    }\n                    switch (pullResult.getPullStatus()) {\n                        case FOUND:\n                            final Object objLock = messageQueueLock.fetchLockObject(messageQueue);\n                            synchronized (objLock) {\n                                if (pullResult.getMsgFoundList() != null && !pullResult.getMsgFoundList().isEmpty() && assignedMessageQueue.getSeekOffset(messageQueue) == -1) {\n                                    processQueue.putMessage(pullResult.getMsgFoundList());\n                                    submitConsumeRequest(new ConsumeRequest(pullResult.getMsgFoundList(), messageQueue, processQueue));\n                                }\n                            }\n                            break;\n                        case OFFSET_ILLEGAL:\n                            log.warn(\"The pull request offset illegal, {}\", pullResult.toString());\n                            break;\n                        default:\n                            break;\n                    }\n                    updatePullOffset(messageQueue, pullResult.getNextBeginOffset(), processQueue);\n                } catch (InterruptedException interruptedException) {\n                    log.warn(\"Polling thread was interrupted.\", interruptedException);\n                } catch (Throwable e) {\n                    if (e instanceof MQBrokerException && ((MQBrokerException) e).getResponseCode() == ResponseCode.FLOW_CONTROL) {\n                        pullDelayTimeMills = PULL_TIME_DELAY_MILLS_WHEN_BROKER_FLOW_CONTROL;\n                    } else {\n                        pullDelayTimeMills = pullTimeDelayMillsWhenException;\n                    }\n                    log.error(\"An error occurred in pull message process.\", e);\n                }\n\n                if (!this.isCancelled()) {\n                    scheduledThreadPoolExecutor.schedule(this, pullDelayTimeMills, TimeUnit.MILLISECONDS);\n                } else {\n                    log.warn(\"The Pull Task is cancelled after doPullTask, {}\", messageQueue);\n                }\n            }\n        }\n\n        public boolean isCancelled() {\n            return cancelled;\n        }\n\n        public void setCancelled(boolean cancelled) {\n            this.cancelled = cancelled;\n        }\n\n        public MessageQueue getMessageQueue() {\n            return messageQueue;\n        }\n    }\n\n    private PullResult pull(MessageQueue mq, SubscriptionData subscriptionData, long offset, int maxNums)\n        throws MQClientException, RemotingException, MQBrokerException, InterruptedException {\n        return pull(mq, subscriptionData, offset, maxNums, this.defaultLitePullConsumer.getConsumerPullTimeoutMillis());\n    }\n\n    private PullResult pull(MessageQueue mq, SubscriptionData subscriptionData, long offset, int maxNums, long timeout)\n        throws MQClientException, RemotingException, MQBrokerException, InterruptedException {\n        return this.pullSyncImpl(mq, subscriptionData, offset, maxNums, true, timeout);\n    }\n\n    private PullResult pullSyncImpl(MessageQueue mq, SubscriptionData subscriptionData, long offset, int maxNums,\n        boolean block,\n        long timeout)\n        throws MQClientException, RemotingException, MQBrokerException, InterruptedException {\n\n        if (null == mq) {\n            throw new MQClientException(\"mq is null\", null);\n        }\n\n        if (offset < 0) {\n            throw new MQClientException(\"offset < 0\", null);\n        }\n\n        if (maxNums <= 0) {\n            throw new MQClientException(\"maxNums <= 0\", null);\n        }\n\n        int sysFlag = PullSysFlag.buildSysFlag(false, block, true, false, true);\n\n        long timeoutMillis = block ? this.defaultLitePullConsumer.getConsumerTimeoutMillisWhenSuspend() : timeout;\n\n        boolean isTagType = ExpressionType.isTagType(subscriptionData.getExpressionType());\n        PullResult pullResult = this.pullAPIWrapper.pullKernelImpl(\n            mq,\n            subscriptionData.getSubString(),\n            subscriptionData.getExpressionType(),\n            isTagType ? 0L : subscriptionData.getSubVersion(),\n            offset,\n            maxNums,\n            sysFlag,\n            0,\n            this.defaultLitePullConsumer.getBrokerSuspendMaxTimeMillis(),\n            timeoutMillis,\n            CommunicationMode.SYNC,\n            null\n        );\n        this.pullAPIWrapper.processPullResult(mq, pullResult, subscriptionData);\n        return pullResult;\n    }\n\n    private void resetTopic(List<MessageExt> msgList) {\n        if (null == msgList || msgList.size() == 0) {\n            return;\n        }\n\n        //If namespace not null , reset Topic without namespace.\n        for (MessageExt messageExt : msgList) {\n            if (null != this.defaultLitePullConsumer.getNamespace()) {\n                messageExt.setTopic(NamespaceUtil.withoutNamespace(messageExt.getTopic(), this.defaultLitePullConsumer.getNamespace()));\n            }\n        }\n\n    }\n\n    public void updateConsumeOffset(MessageQueue mq, long offset) {\n        checkServiceState();\n        this.offsetStore.updateOffset(mq, offset, false);\n    }\n\n    @Override\n    public String groupName() {\n        return this.defaultLitePullConsumer.getConsumerGroup();\n    }\n\n    @Override\n    public MessageModel messageModel() {\n        return this.defaultLitePullConsumer.getMessageModel();\n    }\n\n    @Override\n    public ConsumeType consumeType() {\n        return ConsumeType.CONSUME_ACTIVELY;\n    }\n\n    @Override\n    public ConsumeFromWhere consumeFromWhere() {\n        return ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET;\n    }\n\n    @Override\n    public Set<SubscriptionData> subscriptions() {\n        Set<SubscriptionData> subSet = new HashSet<>();\n\n        subSet.addAll(this.rebalanceImpl.getSubscriptionInner().values());\n\n        return subSet;\n    }\n\n    @Override\n    public void doRebalance() {\n        if (this.rebalanceImpl != null) {\n            this.rebalanceImpl.doRebalance(false);\n        }\n    }\n\n    @Override\n    public boolean tryRebalance() {\n        if (this.rebalanceImpl != null) {\n            return this.rebalanceImpl.doRebalance(false);\n        }\n        return false;\n    }\n\n    @Override\n    public void persistConsumerOffset() {\n        try {\n            checkServiceState();\n            Set<MessageQueue> mqs = new HashSet<>();\n            if (this.subscriptionType == SubscriptionType.SUBSCRIBE) {\n                Set<MessageQueue> allocateMq = this.rebalanceImpl.getProcessQueueTable().keySet();\n                mqs.addAll(allocateMq);\n            } else if (this.subscriptionType == SubscriptionType.ASSIGN) {\n                Set<MessageQueue> assignedMessageQueue = this.assignedMessageQueue.getAssignedMessageQueues();\n                mqs.addAll(assignedMessageQueue);\n            }\n            this.offsetStore.persistAll(mqs);\n        } catch (Exception e) {\n            log.error(\"Persist consumer offset error for group: {} \", this.defaultLitePullConsumer.getConsumerGroup(), e);\n        }\n    }\n\n    @Override\n    public void updateTopicSubscribeInfo(String topic, Set<MessageQueue> info) {\n        Map<String, SubscriptionData> subTable = this.rebalanceImpl.getSubscriptionInner();\n        if (subTable != null) {\n            if (subTable.containsKey(topic)) {\n                this.rebalanceImpl.getTopicSubscribeInfoTable().put(topic, info);\n            }\n        }\n    }\n\n    @Override\n    public boolean isSubscribeTopicNeedUpdate(String topic) {\n        Map<String, SubscriptionData> subTable = this.rebalanceImpl.getSubscriptionInner();\n        if (subTable != null) {\n            if (subTable.containsKey(topic)) {\n                return !this.rebalanceImpl.topicSubscribeInfoTable.containsKey(topic);\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public boolean isUnitMode() {\n        return this.defaultLitePullConsumer.isUnitMode();\n    }\n\n    @Override\n    public ConsumerRunningInfo consumerRunningInfo() {\n        ConsumerRunningInfo info = new ConsumerRunningInfo();\n\n        Properties prop = MixAll.object2Properties(this.defaultLitePullConsumer);\n        prop.put(ConsumerRunningInfo.PROP_CONSUMER_START_TIMESTAMP, String.valueOf(this.consumerStartTimestamp));\n        info.setProperties(prop);\n\n        info.getSubscriptionSet().addAll(this.subscriptions());\n\n        for (MessageQueue mq : this.assignedMessageQueue.getAssignedMessageQueues()) {\n            ProcessQueue pq = this.assignedMessageQueue.getProcessQueue(mq);\n            ProcessQueueInfo pqInfo = new ProcessQueueInfo();\n            pqInfo.setCommitOffset(this.offsetStore.readOffset(mq, ReadOffsetType.MEMORY_FIRST_THEN_STORE));\n            pq.fillProcessQueueInfo(pqInfo);\n            info.getMqTable().put(mq, pqInfo);\n        }\n\n        return info;\n    }\n\n    private void updateConsumeOffsetToBroker(MessageQueue mq, long offset, boolean isOneway) throws RemotingException,\n        MQBrokerException, InterruptedException, MQClientException {\n        this.offsetStore.updateConsumeOffsetToBroker(mq, offset, isOneway);\n    }\n\n    public OffsetStore getOffsetStore() {\n        return offsetStore;\n    }\n\n    public DefaultLitePullConsumer getDefaultLitePullConsumer() {\n        return defaultLitePullConsumer;\n    }\n\n    public Set<MessageQueue> fetchMessageQueues(String topic) throws MQClientException {\n        checkServiceState();\n        Set<MessageQueue> result = this.mQClientFactory.getMQAdminImpl().fetchSubscribeMessageQueues(topic);\n        return parseMessageQueues(result);\n    }\n\n    private synchronized void fetchTopicMessageQueuesAndCompare() throws MQClientException {\n        for (Map.Entry<String, TopicMessageQueueChangeListener> entry : topicMessageQueueChangeListenerMap.entrySet()) {\n            String topic = entry.getKey();\n            TopicMessageQueueChangeListener topicMessageQueueChangeListener = entry.getValue();\n            Set<MessageQueue> oldMessageQueues = messageQueuesForTopic.get(topic);\n            Set<MessageQueue> newMessageQueues = fetchMessageQueues(topic);\n            boolean isChanged = !isSetEqual(newMessageQueues, oldMessageQueues);\n            if (isChanged) {\n                messageQueuesForTopic.put(topic, newMessageQueues);\n                if (topicMessageQueueChangeListener != null) {\n                    topicMessageQueueChangeListener.onChanged(topic, newMessageQueues);\n                }\n            }\n        }\n    }\n\n    private boolean isSetEqual(Set<MessageQueue> set1, Set<MessageQueue> set2) {\n        if (set1 == null && set2 == null) {\n            return true;\n        }\n\n        if (set1 == null || set2 == null || set1.size() != set2.size()) {\n            return false;\n        }\n\n        for (MessageQueue messageQueue : set2) {\n            if (!set1.contains(messageQueue)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public AssignedMessageQueue getAssignedMessageQueue() {\n        return assignedMessageQueue;\n    }\n\n    public synchronized void registerTopicMessageQueueChangeListener(String topic,\n        TopicMessageQueueChangeListener listener) throws MQClientException {\n        if (topic == null || listener == null) {\n            throw new MQClientException(\"Topic or listener is null\", null);\n        }\n        if (topicMessageQueueChangeListenerMap.containsKey(topic)) {\n            log.warn(\"Topic {} had been registered, new listener will overwrite the old one\", topic);\n        }\n        topicMessageQueueChangeListenerMap.put(topic, listener);\n        if (this.serviceState == ServiceState.RUNNING) {\n            Set<MessageQueue> messageQueues = fetchMessageQueues(topic);\n            messageQueuesForTopic.put(topic, messageQueues);\n        }\n    }\n\n    private Set<MessageQueue> parseMessageQueues(Set<MessageQueue> queueSet) {\n        Set<MessageQueue> resultQueues = new HashSet<>();\n        for (MessageQueue messageQueue : queueSet) {\n            String userTopic = NamespaceUtil.withoutNamespace(messageQueue.getTopic(),\n                this.defaultLitePullConsumer.getNamespace());\n            resultQueues.add(new MessageQueue(userTopic, messageQueue.getBrokerName(), messageQueue.getQueueId()));\n        }\n        return resultQueues;\n    }\n\n    public class ConsumeRequest {\n        private final List<MessageExt> messageExts;\n        private final MessageQueue messageQueue;\n        private final ProcessQueue processQueue;\n\n        public ConsumeRequest(final List<MessageExt> messageExts, final MessageQueue messageQueue,\n            final ProcessQueue processQueue) {\n            this.messageExts = messageExts;\n            this.messageQueue = messageQueue;\n            this.processQueue = processQueue;\n        }\n\n        public List<MessageExt> getMessageExts() {\n            return messageExts;\n        }\n\n        public MessageQueue getMessageQueue() {\n            return messageQueue;\n        }\n\n        public ProcessQueue getProcessQueue() {\n            return processQueue;\n        }\n\n    }\n\n    public void setPullTimeDelayMillsWhenException(long pullTimeDelayMillsWhenException) {\n        this.pullTimeDelayMillsWhenException = pullTimeDelayMillsWhenException;\n    }\n}\n",
            "role": "user"
        },
        {
            "content": "//client/src/main/java/org/apache/rocketmq/client/impl/consumer/DefaultMQPushConsumerImpl.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.rocketmq.client.impl.consumer;\n\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentMap;\nimport org.apache.commons.collections.CollectionUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.rocketmq.client.QueryResult;\nimport org.apache.rocketmq.client.Validators;\nimport org.apache.rocketmq.client.consumer.AckCallback;\nimport org.apache.rocketmq.client.consumer.AckResult;\nimport org.apache.rocketmq.client.consumer.AckStatus;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.MessageQueueListener;\nimport org.apache.rocketmq.client.consumer.MessageSelector;\nimport org.apache.rocketmq.client.consumer.PopCallback;\nimport org.apache.rocketmq.client.consumer.PopResult;\nimport org.apache.rocketmq.client.consumer.PopStatus;\nimport org.apache.rocketmq.client.consumer.PullCallback;\nimport org.apache.rocketmq.client.consumer.PullResult;\nimport org.apache.rocketmq.client.consumer.listener.MessageListener;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerOrderly;\nimport org.apache.rocketmq.client.consumer.store.LocalFileOffsetStore;\nimport org.apache.rocketmq.client.consumer.store.OffsetStore;\nimport org.apache.rocketmq.client.consumer.store.ReadOffsetType;\nimport org.apache.rocketmq.client.consumer.store.RemoteBrokerOffsetStore;\nimport org.apache.rocketmq.client.exception.MQBrokerException;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.hook.ConsumeMessageContext;\nimport org.apache.rocketmq.client.hook.ConsumeMessageHook;\nimport org.apache.rocketmq.client.hook.FilterMessageContext;\nimport org.apache.rocketmq.client.hook.FilterMessageHook;\nimport org.apache.rocketmq.client.impl.CommunicationMode;\nimport org.apache.rocketmq.client.impl.FindBrokerResult;\nimport org.apache.rocketmq.client.impl.MQClientManager;\nimport org.apache.rocketmq.client.impl.factory.MQClientInstance;\nimport org.apache.rocketmq.client.stat.ConsumerStatsManager;\nimport org.apache.rocketmq.common.KeyBuilder;\nimport org.apache.rocketmq.common.MixAll;\nimport org.apache.rocketmq.common.ServiceState;\nimport org.apache.rocketmq.common.UtilAll;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.help.FAQUrl;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageAccessor;\nimport org.apache.rocketmq.common.message.MessageConst;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.common.message.MessageQueue;\nimport org.apache.rocketmq.common.sysflag.PullSysFlag;\nimport org.apache.rocketmq.remoting.RPCHook;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\nimport org.apache.rocketmq.remoting.exception.RemotingException;\nimport org.apache.rocketmq.remoting.protocol.NamespaceUtil;\nimport org.apache.rocketmq.remoting.protocol.ResponseCode;\nimport org.apache.rocketmq.remoting.protocol.body.ConsumeStatus;\nimport org.apache.rocketmq.remoting.protocol.body.ConsumerRunningInfo;\nimport org.apache.rocketmq.remoting.protocol.body.PopProcessQueueInfo;\nimport org.apache.rocketmq.remoting.protocol.body.ProcessQueueInfo;\nimport org.apache.rocketmq.remoting.protocol.body.QueueTimeSpan;\nimport org.apache.rocketmq.remoting.protocol.filter.FilterAPI;\nimport org.apache.rocketmq.remoting.protocol.header.AckMessageRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.ChangeInvisibleTimeRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.ExtraInfoUtil;\nimport org.apache.rocketmq.remoting.protocol.heartbeat.ConsumeType;\nimport org.apache.rocketmq.remoting.protocol.heartbeat.MessageModel;\nimport org.apache.rocketmq.remoting.protocol.heartbeat.SubscriptionData;\nimport org.apache.rocketmq.remoting.protocol.route.BrokerData;\nimport org.apache.rocketmq.remoting.protocol.route.TopicRouteData;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\n\npublic class DefaultMQPushConsumerImpl implements MQConsumerInner {\n    /**\n     * Delay some time when exception occur\n     */\n    private long pullTimeDelayMillsWhenException = 3000;\n    /**\n     * Flow control interval when message cache is full\n     */\n    private static final long PULL_TIME_DELAY_MILLS_WHEN_CACHE_FLOW_CONTROL = 50;\n    /**\n     * Flow control interval when broker return flow control\n     */\n    private static final long PULL_TIME_DELAY_MILLS_WHEN_BROKER_FLOW_CONTROL = 20;\n    /**\n     * Delay some time when suspend pull service\n     */\n    private static final long PULL_TIME_DELAY_MILLS_WHEN_SUSPEND = 1000;\n    private static final long BROKER_SUSPEND_MAX_TIME_MILLIS = 1000 * 15;\n    private static final long CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND = 1000 * 30;\n    private static final Logger log = LoggerFactory.getLogger(DefaultMQPushConsumerImpl.class);\n    private final DefaultMQPushConsumer defaultMQPushConsumer;\n    private final RebalanceImpl rebalanceImpl = new RebalancePushImpl(this);\n    private final ArrayList<FilterMessageHook> filterMessageHookList = new ArrayList<>();\n    private final long consumerStartTimestamp = System.currentTimeMillis();\n    private final ArrayList<ConsumeMessageHook> consumeMessageHookList = new ArrayList<>();\n    private final RPCHook rpcHook;\n    private volatile ServiceState serviceState = ServiceState.CREATE_JUST;\n    private MQClientInstance mQClientFactory;\n    private PullAPIWrapper pullAPIWrapper;\n    private volatile boolean pause = false;\n    private boolean consumeOrderly = false;\n    private MessageListener messageListenerInner;\n    private OffsetStore offsetStore;\n    private ConsumeMessageService consumeMessageService;\n    private ConsumeMessageService consumeMessagePopService;\n    private long queueFlowControlTimes = 0;\n    private long queueMaxSpanFlowControlTimes = 0;\n\n    //10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h\n    private final int[] popDelayLevel = new int[] {10, 30, 60, 120, 180, 240, 300, 360, 420, 480, 540, 600, 1200, 1800, 3600, 7200};\n\n    private static final int MAX_POP_INVISIBLE_TIME = 300000;\n    private static final int MIN_POP_INVISIBLE_TIME = 5000;\n    private static final int ASYNC_TIMEOUT = 3000;\n\n    // only for test purpose, will be modified by reflection in unit test.\n    @SuppressWarnings(\"FieldMayBeFinal\")\n    private static boolean doNotUpdateTopicSubscribeInfoWhenSubscriptionChanged = false;\n\n    public DefaultMQPushConsumerImpl(DefaultMQPushConsumer defaultMQPushConsumer, RPCHook rpcHook) {\n        this.defaultMQPushConsumer = defaultMQPushConsumer;\n        this.rpcHook = rpcHook;\n        this.pullTimeDelayMillsWhenException = defaultMQPushConsumer.getPullTimeDelayMillsWhenException();\n    }\n\n    public void registerFilterMessageHook(final FilterMessageHook hook) {\n        this.filterMessageHookList.add(hook);\n        log.info(\"register FilterMessageHook Hook, {}\", hook.hookName());\n    }\n\n    public boolean hasHook() {\n        return !this.consumeMessageHookList.isEmpty();\n    }\n\n    public void registerConsumeMessageHook(final ConsumeMessageHook hook) {\n        this.consumeMessageHookList.add(hook);\n        log.info(\"register consumeMessageHook Hook, {}\", hook.hookName());\n    }\n\n    public void executeHookBefore(final ConsumeMessageContext context) {\n        if (!this.consumeMessageHookList.isEmpty()) {\n            for (ConsumeMessageHook hook : this.consumeMessageHookList) {\n                try {\n                    hook.consumeMessageBefore(context);\n                } catch (Throwable e) {\n                    log.warn(\"consumeMessageHook {} executeHookBefore exception\", hook.hookName(), e);\n                }\n            }\n        }\n    }\n\n    public void executeHookAfter(final ConsumeMessageContext context) {\n        if (!this.consumeMessageHookList.isEmpty()) {\n            for (ConsumeMessageHook hook : this.consumeMessageHookList) {\n                try {\n                    hook.consumeMessageAfter(context);\n                } catch (Throwable e) {\n                    log.warn(\"consumeMessageHook {} executeHookAfter exception\", hook.hookName(), e);\n                }\n            }\n        }\n    }\n\n    public void createTopic(String key, String newTopic, int queueNum) throws MQClientException {\n        createTopic(key, newTopic, queueNum, 0);\n    }\n\n    public void createTopic(String key, String newTopic, int queueNum, int topicSysFlag) throws MQClientException {\n        this.mQClientFactory.getMQAdminImpl().createTopic(key, newTopic, queueNum, topicSysFlag, null);\n    }\n\n    public Set<MessageQueue> fetchSubscribeMessageQueues(String topic) throws MQClientException {\n        Set<MessageQueue> result = this.rebalanceImpl.getTopicSubscribeInfoTable().get(topic);\n        if (null == result) {\n            this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);\n            result = this.rebalanceImpl.getTopicSubscribeInfoTable().get(topic);\n        }\n\n        if (null == result) {\n            throw new MQClientException(\"The topic[\" + topic + \"] not exist\", null);\n        }\n\n        return parseSubscribeMessageQueues(result);\n    }\n\n    public Set<MessageQueue> parseSubscribeMessageQueues(Set<MessageQueue> messageQueueList) {\n        Set<MessageQueue> resultQueues = new HashSet<>();\n        for (MessageQueue queue : messageQueueList) {\n            String userTopic = NamespaceUtil.withoutNamespace(queue.getTopic(), this.defaultMQPushConsumer.getNamespace());\n            resultQueues.add(new MessageQueue(userTopic, queue.getBrokerName(), queue.getQueueId()));\n        }\n\n        return resultQueues;\n    }\n\n    public DefaultMQPushConsumer getDefaultMQPushConsumer() {\n        return defaultMQPushConsumer;\n    }\n\n    public long earliestMsgStoreTime(MessageQueue mq) throws MQClientException {\n        return this.mQClientFactory.getMQAdminImpl().earliestMsgStoreTime(mq);\n    }\n\n    public long maxOffset(MessageQueue mq) throws MQClientException {\n        return this.mQClientFactory.getMQAdminImpl().maxOffset(mq);\n    }\n\n    public long minOffset(MessageQueue mq) throws MQClientException {\n        return this.mQClientFactory.getMQAdminImpl().minOffset(mq);\n    }\n\n    public OffsetStore getOffsetStore() {\n        return offsetStore;\n    }\n\n    public void setOffsetStore(OffsetStore offsetStore) {\n        this.offsetStore = offsetStore;\n    }\n\n    public void pullMessage(final PullRequest pullRequest) {\n        final ProcessQueue processQueue = pullRequest.getProcessQueue();\n        if (processQueue.isDropped()) {\n            log.info(\"the pull request[{}] is dropped.\", pullRequest.toString());\n            return;\n        }\n\n        pullRequest.getProcessQueue().setLastPullTimestamp(System.currentTimeMillis());\n\n        try {\n            this.makeSureStateOK();\n        } catch (MQClientException e) {\n            log.warn(\"pullMessage exception, consumer state not ok\", e);\n            this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);\n            return;\n        }\n\n        if (this.isPause()) {\n            log.warn(\"consumer was paused, execute pull request later. instanceName={}, group={}\", this.defaultMQPushConsumer.getInstanceName(), this.defaultMQPushConsumer.getConsumerGroup());\n            this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_SUSPEND);\n            return;\n        }\n\n        long cachedMessageCount = processQueue.getMsgCount().get();\n        long cachedMessageSizeInMiB = processQueue.getMsgSize().get() / (1024 * 1024);\n\n        if (cachedMessageCount > this.defaultMQPushConsumer.getPullThresholdForQueue()) {\n            this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_CACHE_FLOW_CONTROL);\n            if ((queueFlowControlTimes++ % 1000) == 0) {\n                log.warn(\n                    \"the cached message count exceeds the threshold {}, so do flow control, minOffset={}, maxOffset={}, count={}, size={} MiB, pullRequest={}, flowControlTimes={}\",\n                    this.defaultMQPushConsumer.getPullThresholdForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes);\n            }\n            return;\n        }\n\n        if (cachedMessageSizeInMiB > this.defaultMQPushConsumer.getPullThresholdSizeForQueue()) {\n            this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_CACHE_FLOW_CONTROL);\n            if ((queueFlowControlTimes++ % 1000) == 0) {\n                log.warn(\n                    \"the cached message size exceeds the threshold {} MiB, so do flow control, minOffset={}, maxOffset={}, count={}, size={} MiB, pullRequest={}, flowControlTimes={}\",\n                    this.defaultMQPushConsumer.getPullThresholdSizeForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes);\n            }\n            return;\n        }\n\n        if (!this.consumeOrderly) {\n            if (processQueue.getMaxSpan() > this.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan()) {\n                this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_CACHE_FLOW_CONTROL);\n                if ((queueMaxSpanFlowControlTimes++ % 1000) == 0) {\n                    log.warn(\n                        \"the queue's messages, span too long, so do flow control, minOffset={}, maxOffset={}, maxSpan={}, pullRequest={}, flowControlTimes={}\",\n                        processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), processQueue.getMaxSpan(),\n                        pullRequest, queueMaxSpanFlowControlTimes);\n                }\n                return;\n            }\n        } else {\n            if (processQueue.isLocked()) {\n                if (!pullRequest.isPreviouslyLocked()) {\n                    long offset = -1L;\n                    try {\n                        offset = this.rebalanceImpl.computePullFromWhereWithException(pullRequest.getMessageQueue());\n                        if (offset < 0) {\n                            throw new MQClientException(ResponseCode.SYSTEM_ERROR, \"Unexpected offset \" + offset);\n                        }\n                    } catch (Exception e) {\n                        this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);\n                        log.error(\"Failed to compute pull offset, pullResult: {}\", pullRequest, e);\n                        return;\n                    }\n                    boolean brokerBusy = offset < pullRequest.getNextOffset();\n                    log.info(\"the first time to pull message, so fix offset from broker. pullRequest: {} NewOffset: {} brokerBusy: {}\",\n                        pullRequest, offset, brokerBusy);\n                    if (brokerBusy) {\n                        log.info(\"[NOTIFYME]the first time to pull message, but pull request offset larger than broker consume offset. pullRequest: {} NewOffset: {}\",\n                            pullRequest, offset);\n                    }\n\n                    pullRequest.setPreviouslyLocked(true);\n                    pullRequest.setNextOffset(offset);\n                }\n            } else {\n                this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);\n                log.info(\"pull message later because not locked in broker, {}\", pullRequest);\n                return;\n            }\n        }\n\n        final MessageQueue messageQueue = pullRequest.getMessageQueue();\n        final SubscriptionData subscriptionData = this.rebalanceImpl.getSubscriptionInner().get(messageQueue.getTopic());\n        if (null == subscriptionData) {\n            this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);\n            log.warn(\"find the consumer's subscription failed, {}\", pullRequest);\n            return;\n        }\n\n        final long beginTimestamp = System.currentTimeMillis();\n\n        PullCallback pullCallback = new PullCallback() {\n            @Override\n            public void onSuccess(PullResult pullResult) {\n                if (pullResult != null) {\n                    pullResult = DefaultMQPushConsumerImpl.this.pullAPIWrapper.processPullResult(pullRequest.getMessageQueue(), pullResult,\n                        subscriptionData);\n\n                    switch (pullResult.getPullStatus()) {\n                        case FOUND:\n                            long prevRequestOffset = pullRequest.getNextOffset();\n                            pullRequest.setNextOffset(pullResult.getNextBeginOffset());\n                            long pullRT = System.currentTimeMillis() - beginTimestamp;\n                            DefaultMQPushConsumerImpl.this.getConsumerStatsManager().incPullRT(pullRequest.getConsumerGroup(),\n                                pullRequest.getMessageQueue().getTopic(), pullRT);\n\n                            long firstMsgOffset = Long.MAX_VALUE;\n                            if (pullResult.getMsgFoundList() == null || pullResult.getMsgFoundList().isEmpty()) {\n                                DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);\n                            } else {\n                                firstMsgOffset = pullResult.getMsgFoundList().get(0).getQueueOffset();\n\n                                DefaultMQPushConsumerImpl.this.getConsumerStatsManager().incPullTPS(pullRequest.getConsumerGroup(),\n                                    pullRequest.getMessageQueue().getTopic(), pullResult.getMsgFoundList().size());\n\n                                boolean dispatchToConsume = processQueue.putMessage(pullResult.getMsgFoundList());\n                                DefaultMQPushConsumerImpl.this.consumeMessageService.submitConsumeRequest(\n                                    pullResult.getMsgFoundList(),\n                                    processQueue,\n                                    pullRequest.getMessageQueue(),\n                                    dispatchToConsume);\n\n                                if (DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval() > 0) {\n                                    DefaultMQPushConsumerImpl.this.executePullRequestLater(pullRequest,\n                                        DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval());\n                                } else {\n                                    DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);\n                                }\n                            }\n\n                            if (pullResult.getNextBeginOffset() < prevRequestOffset\n                                || firstMsgOffset < prevRequestOffset) {\n                                log.warn(\n                                    \"[BUG] pull message result maybe data wrong, nextBeginOffset: {} firstMsgOffset: {} prevRequestOffset: {}\",\n                                    pullResult.getNextBeginOffset(),\n                                    firstMsgOffset,\n                                    prevRequestOffset);\n                            }\n\n                            break;\n                        case NO_NEW_MSG:\n                        case NO_MATCHED_MSG:\n                            pullRequest.setNextOffset(pullResult.getNextBeginOffset());\n\n                            DefaultMQPushConsumerImpl.this.correctTagsOffset(pullRequest);\n\n                            DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);\n                            break;\n                        case OFFSET_ILLEGAL:\n                            log.warn(\"the pull request offset illegal, {} {}\",\n                                pullRequest.toString(), pullResult.toString());\n                            pullRequest.setNextOffset(pullResult.getNextBeginOffset());\n\n                            pullRequest.getProcessQueue().setDropped(true);\n                            DefaultMQPushConsumerImpl.this.executeTask(new Runnable() {\n\n                                @Override\n                                public void run() {\n                                    try {\n                                        DefaultMQPushConsumerImpl.this.offsetStore.updateAndFreezeOffset(pullRequest.getMessageQueue(),\n                                            pullRequest.getNextOffset());\n\n                                        DefaultMQPushConsumerImpl.this.offsetStore.persist(pullRequest.getMessageQueue());\n\n                                        // removeProcessQueue will also remove offset to cancel the frozen status.\n                                        DefaultMQPushConsumerImpl.this.rebalanceImpl.removeProcessQueue(pullRequest.getMessageQueue());\n                                        DefaultMQPushConsumerImpl.this.rebalanceImpl.getmQClientFactory().rebalanceImmediately();\n\n                                        log.warn(\"fix the pull request offset, {}\", pullRequest);\n                                    } catch (Throwable e) {\n                                        log.error(\"executeTaskLater Exception\", e);\n                                    }\n                                }\n                            });\n                            break;\n                        default:\n                            break;\n                    }\n                }\n            }\n\n            @Override\n            public void onException(Throwable e) {\n                if (!pullRequest.getMessageQueue().getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {\n                    if (e instanceof MQBrokerException && ((MQBrokerException) e).getResponseCode() == ResponseCode.SUBSCRIPTION_NOT_LATEST) {\n                        log.warn(\"the subscription is not latest, group={}, messageQueue={}\", groupName(), messageQueue);\n                    } else {\n                        log.warn(\"execute the pull request exception, group={}, messageQueue={}\", groupName(), messageQueue, e);\n                    }\n                }\n\n                if (e instanceof MQBrokerException && ((MQBrokerException) e).getResponseCode() == ResponseCode.FLOW_CONTROL) {\n                    DefaultMQPushConsumerImpl.this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_BROKER_FLOW_CONTROL);\n                } else {\n                    DefaultMQPushConsumerImpl.this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);\n                }\n            }\n        };\n\n        boolean commitOffsetEnable = false;\n        long commitOffsetValue = 0L;\n        if (MessageModel.CLUSTERING == this.defaultMQPushConsumer.getMessageModel()) {\n            commitOffsetValue = this.offsetStore.readOffset(pullRequest.getMessageQueue(), ReadOffsetType.READ_FROM_MEMORY);\n            if (commitOffsetValue > 0) {\n                commitOffsetEnable = true;\n            }\n        }\n\n        String subExpression = null;\n        boolean classFilter = false;\n        SubscriptionData sd = this.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());\n        if (sd != null) {\n            if (this.defaultMQPushConsumer.isPostSubscriptionWhenPull() && !sd.isClassFilterMode()) {\n                subExpression = sd.getSubString();\n            }\n\n            classFilter = sd.isClassFilterMode();\n        }\n\n        int sysFlag = PullSysFlag.buildSysFlag(\n            commitOffsetEnable, // commitOffset\n            true, // suspend\n            subExpression != null, // subscription\n            classFilter // class filter\n        );\n        try {\n            this.pullAPIWrapper.pullKernelImpl(\n                pullRequest.getMessageQueue(),\n                subExpression,\n                subscriptionData.getExpressionType(),\n                subscriptionData.getSubVersion(),\n                pullRequest.getNextOffset(),\n                this.defaultMQPushConsumer.getPullBatchSize(),\n                this.defaultMQPushConsumer.getPullBatchSizeInBytes(),\n                sysFlag,\n                commitOffsetValue,\n                BROKER_SUSPEND_MAX_TIME_MILLIS,\n                CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND,\n                CommunicationMode.ASYNC,\n                pullCallback\n            );\n        } catch (Exception e) {\n            log.error(\"pullKernelImpl exception\", e);\n            this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);\n        }\n    }\n\n    void popMessage(final PopRequest popRequest) {\n        final PopProcessQueue processQueue = popRequest.getPopProcessQueue();\n        if (processQueue.isDropped()) {\n            log.info(\"the pop request[{}] is dropped.\", popRequest.toString());\n            return;\n        }\n\n        processQueue.setLastPopTimestamp(System.currentTimeMillis());\n\n        try {\n            this.makeSureStateOK();\n        } catch (MQClientException e) {\n            log.warn(\"pullMessage exception, consumer state not ok\", e);\n            this.executePopPullRequestLater(popRequest, pullTimeDelayMillsWhenException);\n            return;\n        }\n\n        if (this.isPause()) {\n            log.warn(\"consumer was paused, execute pull request later. instanceName={}, group={}\", this.defaultMQPushConsumer.getInstanceName(), this.defaultMQPushConsumer.getConsumerGroup());\n            this.executePopPullRequestLater(popRequest, PULL_TIME_DELAY_MILLS_WHEN_SUSPEND);\n            return;\n        }\n\n        if (processQueue.getWaiAckMsgCount() > this.defaultMQPushConsumer.getPopThresholdForQueue()) {\n            this.executePopPullRequestLater(popRequest, PULL_TIME_DELAY_MILLS_WHEN_CACHE_FLOW_CONTROL);\n            if ((queueFlowControlTimes++ % 1000) == 0) {\n                log.warn(\"the messages waiting to ack exceeds the threshold {}, so do flow control, popRequest={}, flowControlTimes={}, wait count={}\",\n                    this.defaultMQPushConsumer.getPopThresholdForQueue(), popRequest, queueFlowControlTimes, processQueue.getWaiAckMsgCount());\n            }\n            return;\n        }\n\n        //POPTODO think of pop mode orderly implementation later.\n        final SubscriptionData subscriptionData = this.rebalanceImpl.getSubscriptionInner().get(popRequest.getMessageQueue().getTopic());\n        if (null == subscriptionData) {\n            this.executePopPullRequestLater(popRequest, pullTimeDelayMillsWhenException);\n            log.warn(\"find the consumer's subscription failed, {}\", popRequest);\n            return;\n        }\n\n        final long beginTimestamp = System.currentTimeMillis();\n\n        PopCallback popCallback = new PopCallback() {\n            @Override\n            public void onSuccess(PopResult popResult) {\n                if (popResult == null) {\n                    log.error(\"pop callback popResult is null\");\n                    DefaultMQPushConsumerImpl.this.executePopPullRequestImmediately(popRequest);\n                    return;\n                }\n\n                processPopResult(popResult, subscriptionData);\n\n                switch (popResult.getPopStatus()) {\n                    case FOUND:\n                        long pullRT = System.currentTimeMillis() - beginTimestamp;\n                        DefaultMQPushConsumerImpl.this.getConsumerStatsManager().incPullRT(popRequest.getConsumerGroup(),\n                            popRequest.getMessageQueue().getTopic(), pullRT);\n                        if (popResult.getMsgFoundList() == null || popResult.getMsgFoundList().isEmpty()) {\n                            DefaultMQPushConsumerImpl.this.executePopPullRequestImmediately(popRequest);\n                        } else {\n                            DefaultMQPushConsumerImpl.this.getConsumerStatsManager().incPullTPS(popRequest.getConsumerGroup(),\n                                popRequest.getMessageQueue().getTopic(), popResult.getMsgFoundList().size());\n                            popRequest.getPopProcessQueue().incFoundMsg(popResult.getMsgFoundList().size());\n\n                            DefaultMQPushConsumerImpl.this.consumeMessagePopService.submitPopConsumeRequest(\n                                popResult.getMsgFoundList(),\n                                processQueue,\n                                popRequest.getMessageQueue());\n\n                            if (DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval() > 0) {\n                                DefaultMQPushConsumerImpl.this.executePopPullRequestLater(popRequest,\n                                    DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval());\n                            } else {\n                                DefaultMQPushConsumerImpl.this.executePopPullRequestImmediately(popRequest);\n                            }\n                        }\n                        break;\n                    case NO_NEW_MSG:\n                    case POLLING_NOT_FOUND:\n                        DefaultMQPushConsumerImpl.this.executePopPullRequestImmediately(popRequest);\n                        break;\n                    case POLLING_FULL:\n                        DefaultMQPushConsumerImpl.this.executePopPullRequestLater(popRequest, pullTimeDelayMillsWhenException);\n                        break;\n                    default:\n                        DefaultMQPushConsumerImpl.this.executePopPullRequestLater(popRequest, pullTimeDelayMillsWhenException);\n                        break;\n                }\n\n            }\n\n            @Override\n            public void onException(Throwable e) {\n                if (!popRequest.getMessageQueue().getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {\n                    log.warn(\"execute the pull request exception: {}\", e);\n                }\n\n                if (e instanceof MQBrokerException && ((MQBrokerException) e).getResponseCode() == ResponseCode.FLOW_CONTROL) {\n                    DefaultMQPushConsumerImpl.this.executePopPullRequestLater(popRequest, PULL_TIME_DELAY_MILLS_WHEN_BROKER_FLOW_CONTROL);\n                } else {\n                    DefaultMQPushConsumerImpl.this.executePopPullRequestLater(popRequest, pullTimeDelayMillsWhenException);\n                }\n            }\n        };\n\n\n        try {\n\n            long invisibleTime = this.defaultMQPushConsumer.getPopInvisibleTime();\n            if (invisibleTime < MIN_POP_INVISIBLE_TIME || invisibleTime > MAX_POP_INVISIBLE_TIME) {\n                invisibleTime = 60000;\n            }\n            this.pullAPIWrapper.popAsync(popRequest.getMessageQueue(), invisibleTime, this.defaultMQPushConsumer.getPopBatchNums(),\n                popRequest.getConsumerGroup(), BROKER_SUSPEND_MAX_TIME_MILLIS, popCallback, true, popRequest.getInitMode(),\n                false, subscriptionData.getExpressionType(), subscriptionData.getSubString());\n        } catch (Exception e) {\n            log.error(\"popAsync exception\", e);\n            this.executePopPullRequestLater(popRequest, pullTimeDelayMillsWhenException);\n        }\n    }\n\n    private PopResult processPopResult(final PopResult popResult, final SubscriptionData subscriptionData) {\n        if (PopStatus.FOUND == popResult.getPopStatus()) {\n            List<MessageExt> msgFoundList = popResult.getMsgFoundList();\n            List<MessageExt> msgListFilterAgain = msgFoundList;\n            if (!subscriptionData.getTagsSet().isEmpty() && !subscriptionData.isClassFilterMode()\n                && popResult.getMsgFoundList().size() > 0) {\n                msgListFilterAgain = new ArrayList<>(popResult.getMsgFoundList().size());\n                for (MessageExt msg : popResult.getMsgFoundList()) {\n                    if (msg.getTags() != null) {\n                        if (subscriptionData.getTagsSet().contains(msg.getTags())) {\n                            msgListFilterAgain.add(msg);\n                        }\n                    }\n                }\n            }\n\n            if (!this.filterMessageHookList.isEmpty()) {\n                FilterMessageContext filterMessageContext = new FilterMessageContext();\n                filterMessageContext.setUnitMode(this.defaultMQPushConsumer.isUnitMode());\n                filterMessageContext.setMsgList(msgListFilterAgain);\n                if (!this.filterMessageHookList.isEmpty()) {\n                    for (FilterMessageHook hook : this.filterMessageHookList) {\n                        try {\n                            hook.filterMessage(filterMessageContext);\n                        } catch (Throwable e) {\n                            log.error(\"execute hook error. hookName={}\", hook.hookName());\n                        }\n                    }\n                }\n            }\n\n            if (msgFoundList.size() != msgListFilterAgain.size()) {\n                for (MessageExt msg : msgFoundList) {\n                    if (!msgListFilterAgain.contains(msg)) {\n                        ackAsync(msg, this.groupName());\n                    }\n                }\n            }\n\n            popResult.setMsgFoundList(msgListFilterAgain);\n        }\n\n        return popResult;\n    }\n\n    private void makeSureStateOK() throws MQClientException {\n        if (this.serviceState != ServiceState.RUNNING) {\n            throw new MQClientException(\"The consumer service state not OK, \"\n                + this.serviceState\n                + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),\n                null);\n        }\n    }\n\n    void executePullRequestLater(final PullRequest pullRequest, final long timeDelay) {\n        this.mQClientFactory.getPullMessageService().executePullRequestLater(pullRequest, timeDelay);\n    }\n\n    public boolean isPause() {\n        return pause;\n    }\n\n    public void setPause(boolean pause) {\n        this.pause = pause;\n    }\n\n    public ConsumerStatsManager getConsumerStatsManager() {\n        return this.mQClientFactory.getConsumerStatsManager();\n    }\n\n    public void executePullRequestImmediately(final PullRequest pullRequest) {\n        this.mQClientFactory.getPullMessageService().executePullRequestImmediately(pullRequest);\n    }\n\n    void executePopPullRequestLater(final PopRequest pullRequest, final long timeDelay) {\n        this.mQClientFactory.getPullMessageService().executePopPullRequestLater(pullRequest, timeDelay);\n    }\n\n    void executePopPullRequestImmediately(final PopRequest pullRequest) {\n        this.mQClientFactory.getPullMessageService().executePopPullRequestImmediately(pullRequest);\n    }\n\n    private void correctTagsOffset(final PullRequest pullRequest) {\n        if (0L == pullRequest.getProcessQueue().getMsgCount().get()) {\n            this.offsetStore.updateOffset(pullRequest.getMessageQueue(), pullRequest.getNextOffset(), true);\n        }\n    }\n\n    public void executeTaskLater(final Runnable r, final long timeDelay) {\n        this.mQClientFactory.getPullMessageService().executeTaskLater(r, timeDelay);\n    }\n\n    public void executeTask(final Runnable r) {\n        this.mQClientFactory.getPullMessageService().executeTask(r);\n    }\n\n    public QueryResult queryMessage(String topic, String key, int maxNum, long begin, long end)\n        throws MQClientException, InterruptedException {\n        return this.mQClientFactory.getMQAdminImpl().queryMessage(topic, key, maxNum, begin, end);\n    }\n\n    public MessageExt queryMessageByUniqKey(String topic, String uniqKey) throws MQClientException,\n        InterruptedException {\n        return this.mQClientFactory.getMQAdminImpl().queryMessageByUniqKey(topic, uniqKey);\n    }\n\n    public void registerMessageListener(MessageListener messageListener) {\n        this.messageListenerInner = messageListener;\n    }\n\n    public void resume() {\n        this.pause = false;\n        doRebalance();\n        log.info(\"resume this consumer, {}\", this.defaultMQPushConsumer.getConsumerGroup());\n    }\n\n    @Deprecated\n    public void sendMessageBack(MessageExt msg, int delayLevel, final String brokerName)\n            throws RemotingException, MQBrokerException, InterruptedException, MQClientException {\n        sendMessageBack(msg, delayLevel, brokerName, null);\n    }\n\n    public void sendMessageBack(MessageExt msg, int delayLevel, final MessageQueue mq)\n            throws RemotingException, MQBrokerException, InterruptedException, MQClientException {\n        sendMessageBack(msg, delayLevel, null, mq);\n    }\n\n\n    private void sendMessageBack(MessageExt msg, int delayLevel, final String brokerName, final MessageQueue mq)\n        throws RemotingException, MQBrokerException, InterruptedException, MQClientException {\n        boolean needRetry = true;\n        try {\n            if (brokerName != null && brokerName.startsWith(MixAll.LOGICAL_QUEUE_MOCK_BROKER_PREFIX)\n                || mq != null && mq.getBrokerName().startsWith(MixAll.LOGICAL_QUEUE_MOCK_BROKER_PREFIX)) {\n                needRetry = false;\n                sendMessageBackAsNormalMessage(msg);\n            } else {\n                String brokerAddr = (null != brokerName) ? this.mQClientFactory.findBrokerAddressInPublish(brokerName)\n                    : RemotingHelper.parseSocketAddressAddr(msg.getStoreHost());\n                this.mQClientFactory.getMQClientAPIImpl().consumerSendMessageBack(brokerAddr, brokerName, msg,\n                    this.defaultMQPushConsumer.getConsumerGroup(), delayLevel, 5000, getMaxReconsumeTimes());\n            }\n        } catch (Throwable t) {\n            log.error(\"Failed to send message back, consumerGroup={}, brokerName={}, mq={}, message={}\",\n                this.defaultMQPushConsumer.getConsumerGroup(), brokerName, mq, msg, t);\n            if (needRetry) {\n                sendMessageBackAsNormalMessage(msg);\n            }\n        } finally {\n            msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), this.defaultMQPushConsumer.getNamespace()));\n        }\n    }\n\n    private void sendMessageBackAsNormalMessage(MessageExt msg) throws  RemotingException, MQBrokerException, InterruptedException, MQClientException {\n        Message newMsg = new Message(MixAll.getRetryTopic(this.defaultMQPushConsumer.getConsumerGroup()), msg.getBody());\n\n        String originMsgId = MessageAccessor.getOriginMessageId(msg);\n        MessageAccessor.setOriginMessageId(newMsg, UtilAll.isBlank(originMsgId) ? msg.getMsgId() : originMsgId);\n\n        newMsg.setFlag(msg.getFlag());\n        MessageAccessor.setProperties(newMsg, msg.getProperties());\n        MessageAccessor.putProperty(newMsg, MessageConst.PROPERTY_RETRY_TOPIC, msg.getTopic());\n        MessageAccessor.setReconsumeTime(newMsg, String.valueOf(msg.getReconsumeTimes() + 1));\n        MessageAccessor.setMaxReconsumeTimes(newMsg, String.valueOf(getMaxReconsumeTimes()));\n        MessageAccessor.clearProperty(newMsg, MessageConst.PROPERTY_TRANSACTION_PREPARED);\n        newMsg.setDelayTimeLevel(3 + msg.getReconsumeTimes());\n\n        this.mQClientFactory.getDefaultMQProducer().send(newMsg);\n    }\n\n    void ackAsync(MessageExt message, String consumerGroup) {\n        final String extraInfo = message.getProperty(MessageConst.PROPERTY_POP_CK);\n\n        try {\n            String[] extraInfoStrs = ExtraInfoUtil.split(extraInfo);\n            String brokerName = ExtraInfoUtil.getBrokerName(extraInfoStrs);\n            int queueId = ExtraInfoUtil.getQueueId(extraInfoStrs);\n            long queueOffset = ExtraInfoUtil.getQueueOffset(extraInfoStrs);\n            String topic = message.getTopic();\n\n            String desBrokerName = brokerName;\n            if (brokerName != null && brokerName.startsWith(MixAll.LOGICAL_QUEUE_MOCK_BROKER_PREFIX)) {\n                desBrokerName = this.mQClientFactory.getBrokerNameFromMessageQueue(this.defaultMQPushConsumer.queueWithNamespace(new MessageQueue(topic, brokerName, queueId)));\n            }\n\n\n            FindBrokerResult\n                findBrokerResult = this.mQClientFactory.findBrokerAddressInSubscribe(desBrokerName, MixAll.MASTER_ID, true);\n            if (null == findBrokerResult) {\n                this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);\n                findBrokerResult = this.mQClientFactory.findBrokerAddressInSubscribe(desBrokerName, MixAll.MASTER_ID, true);\n            }\n\n            if (findBrokerResult == null) {\n                log.error(\"The broker[\" + desBrokerName + \"] not exist\");\n                return;\n            }\n\n            AckMessageRequestHeader requestHeader = new AckMessageRequestHeader();\n            requestHeader.setTopic(ExtraInfoUtil.getRealTopic(extraInfoStrs, topic, consumerGroup));\n            requestHeader.setQueueId(queueId);\n            requestHeader.setOffset(queueOffset);\n            requestHeader.setConsumerGroup(consumerGroup);\n            requestHeader.setExtraInfo(extraInfo);\n            requestHeader.setBrokerName(brokerName);\n            this.mQClientFactory.getMQClientAPIImpl().ackMessageAsync(findBrokerResult.getBrokerAddr(), ASYNC_TIMEOUT, new AckCallback() {\n                @Override\n                public void onSuccess(AckResult ackResult) {\n                    if (ackResult != null && !AckStatus.OK.equals(ackResult.getStatus())) {\n                        log.warn(\"Ack message fail. ackResult: {}, extraInfo: {}\", ackResult, extraInfo);\n                    }\n                }\n                @Override\n                public void onException(Throwable e) {\n                    log.warn(\"Ack message fail. extraInfo: {}  error message: {}\", extraInfo, e.toString());\n                }\n            }, requestHeader);\n\n        } catch (Throwable t) {\n            log.error(\"ack async error.\", t);\n        }\n    }\n\n    void changePopInvisibleTimeAsync(String topic, String consumerGroup, String extraInfo, long invisibleTime, AckCallback callback)\n        throws MQClientException, RemotingException, InterruptedException, MQBrokerException {\n        String[] extraInfoStrs = ExtraInfoUtil.split(extraInfo);\n        String brokerName = ExtraInfoUtil.getBrokerName(extraInfoStrs);\n        int queueId = ExtraInfoUtil.getQueueId(extraInfoStrs);\n\n        String desBrokerName = brokerName;\n        if (brokerName != null && brokerName.startsWith(MixAll.LOGICAL_QUEUE_MOCK_BROKER_PREFIX)) {\n            desBrokerName = this.mQClientFactory.getBrokerNameFromMessageQueue(this.defaultMQPushConsumer.queueWithNamespace(new MessageQueue(topic, brokerName, queueId)));\n        }\n\n        FindBrokerResult\n            findBrokerResult = this.mQClientFactory.findBrokerAddressInSubscribe(desBrokerName, MixAll.MASTER_ID, true);\n        if (null == findBrokerResult) {\n            this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);\n            findBrokerResult = this.mQClientFactory.findBrokerAddressInSubscribe(desBrokerName, MixAll.MASTER_ID, true);\n        }\n        if (findBrokerResult != null) {\n            ChangeInvisibleTimeRequestHeader requestHeader = new ChangeInvisibleTimeRequestHeader();\n            requestHeader.setTopic(ExtraInfoUtil.getRealTopic(extraInfoStrs, topic, consumerGroup));\n            requestHeader.setQueueId(queueId);\n            requestHeader.setOffset(ExtraInfoUtil.getQueueOffset(extraInfoStrs));\n            requestHeader.setConsumerGroup(consumerGroup);\n            requestHeader.setExtraInfo(extraInfo);\n            requestHeader.setInvisibleTime(invisibleTime);\n            requestHeader.setBrokerName(brokerName);\n            //here the broker should be polished\n            this.mQClientFactory.getMQClientAPIImpl().changeInvisibleTimeAsync(brokerName, findBrokerResult.getBrokerAddr(), requestHeader, ASYNC_TIMEOUT, callback);\n            return;\n        }\n        throw new MQClientException(\"The broker[\" + desBrokerName + \"] not exist\", null);\n    }\n\n    public int getMaxReconsumeTimes() {\n        // default reconsume times: 16\n        if (this.defaultMQPushConsumer.getMaxReconsumeTimes() == -1) {\n            return 16;\n        } else {\n            return this.defaultMQPushConsumer.getMaxReconsumeTimes();\n        }\n    }\n\n    public void shutdown() {\n        shutdown(0);\n    }\n\n    public synchronized void shutdown(long awaitTerminateMillis) {\n        switch (this.serviceState) {\n            case CREATE_JUST:\n                break;\n            case RUNNING:\n                this.consumeMessageService.shutdown(awaitTerminateMillis);\n                this.persistConsumerOffset();\n                this.mQClientFactory.unregisterConsumer(this.defaultMQPushConsumer.getConsumerGroup());\n                this.mQClientFactory.shutdown();\n                log.info(\"the consumer [{}] shutdown OK\", this.defaultMQPushConsumer.getConsumerGroup());\n                this.rebalanceImpl.destroy();\n                this.serviceState = ServiceState.SHUTDOWN_ALREADY;\n                break;\n            case SHUTDOWN_ALREADY:\n                break;\n            default:\n                break;\n        }\n    }\n\n    public synchronized void start() throws MQClientException {\n        switch (this.serviceState) {\n            case CREATE_JUST:\n                log.info(\"the consumer [{}] start beginning. messageModel={}, isUnitMode={}\", this.defaultMQPushConsumer.getConsumerGroup(),\n                    this.defaultMQPushConsumer.getMessageModel(), this.defaultMQPushConsumer.isUnitMode());\n                this.serviceState = ServiceState.START_FAILED;\n\n                this.checkConfig();\n\n                this.copySubscription();\n\n                if (this.defaultMQPushConsumer.getMessageModel() == MessageModel.CLUSTERING) {\n                    this.defaultMQPushConsumer.changeInstanceNameToPID();\n                }\n\n                this.mQClientFactory = MQClientManager.getInstance().getOrCreateMQClientInstance(this.defaultMQPushConsumer, this.rpcHook);\n\n                this.rebalanceImpl.setConsumerGroup(this.defaultMQPushConsumer.getConsumerGroup());\n                this.rebalanceImpl.setMessageModel(this.defaultMQPushConsumer.getMessageModel());\n                this.rebalanceImpl.setAllocateMessageQueueStrategy(this.defaultMQPushConsumer.getAllocateMessageQueueStrategy());\n                this.rebalanceImpl.setmQClientFactory(this.mQClientFactory);\n\n                if (this.pullAPIWrapper == null) {\n                    this.pullAPIWrapper = new PullAPIWrapper(\n                        mQClientFactory,\n                        this.defaultMQPushConsumer.getConsumerGroup(), isUnitMode());\n                }\n                this.pullAPIWrapper.registerFilterMessageHook(filterMessageHookList);\n\n                if (this.defaultMQPushConsumer.getOffsetStore() != null) {\n                    this.offsetStore = this.defaultMQPushConsumer.getOffsetStore();\n                } else {\n                    switch (this.defaultMQPushConsumer.getMessageModel()) {\n                        case BROADCASTING:\n                            this.offsetStore = new LocalFileOffsetStore(this.mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup());\n                            break;\n                        case CLUSTERING:\n                            this.offsetStore = new RemoteBrokerOffsetStore(this.mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup());\n                            break;\n                        default:\n                            break;\n                    }\n                    this.defaultMQPushConsumer.setOffsetStore(this.offsetStore);\n                }\n                this.offsetStore.load();\n\n                if (this.getMessageListenerInner() instanceof MessageListenerOrderly) {\n                    this.consumeOrderly = true;\n                    this.consumeMessageService =\n                        new ConsumeMessageOrderlyService(this, (MessageListenerOrderly) this.getMessageListenerInner());\n                    //POPTODO reuse Executor ?\n                    this.consumeMessagePopService = new ConsumeMessagePopOrderlyService(this, (MessageListenerOrderly) this.getMessageListenerInner());\n                } else if (this.getMessageListenerInner() instanceof MessageListenerConcurrently) {\n                    this.consumeOrderly = false;\n                    this.consumeMessageService =\n                        new ConsumeMessageConcurrentlyService(this, (MessageListenerConcurrently) this.getMessageListenerInner());\n                    //POPTODO reuse Executor ?\n                    this.consumeMessagePopService =\n                        new ConsumeMessagePopConcurrentlyService(this, (MessageListenerConcurrently) this.getMessageListenerInner());\n                }\n\n                this.consumeMessageService.start();\n                // POPTODO\n                this.consumeMessagePopService.start();\n\n                boolean registerOK = mQClientFactory.registerConsumer(this.defaultMQPushConsumer.getConsumerGroup(), this);\n                if (!registerOK) {\n                    this.serviceState = ServiceState.CREATE_JUST;\n                    this.consumeMessageService.shutdown(defaultMQPushConsumer.getAwaitTerminationMillisWhenShutdown());\n                    throw new MQClientException(\"The consumer group[\" + this.defaultMQPushConsumer.getConsumerGroup()\n                        + \"] has been created before, specify another name please.\" + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),\n                        null);\n                }\n\n                mQClientFactory.start();\n                log.info(\"the consumer [{}] start OK.\", this.defaultMQPushConsumer.getConsumerGroup());\n                this.serviceState = ServiceState.RUNNING;\n                break;\n            case RUNNING:\n            case START_FAILED:\n            case SHUTDOWN_ALREADY:\n                throw new MQClientException(\"The PushConsumer service state not OK, maybe started once, \"\n                    + this.serviceState\n                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),\n                    null);\n            default:\n                break;\n        }\n\n        this.updateTopicSubscribeInfoWhenSubscriptionChanged();\n        this.mQClientFactory.checkClientInBroker();\n        if (this.mQClientFactory.sendHeartbeatToAllBrokerWithLock()) {\n            this.mQClientFactory.rebalanceImmediately();\n        }\n    }\n\n    private void checkConfig() throws MQClientException {\n        Validators.checkGroup(this.defaultMQPushConsumer.getConsumerGroup());\n\n        if (null == this.defaultMQPushConsumer.getConsumerGroup()) {\n            throw new MQClientException(\n                \"consumerGroup is null\"\n                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),\n                null);\n        }\n\n        if (this.defaultMQPushConsumer.getConsumerGroup().equals(MixAll.DEFAULT_CONSUMER_GROUP)) {\n            throw new MQClientException(\n                \"consumerGroup can not equal \"\n                    + MixAll.DEFAULT_CONSUMER_GROUP\n                    + \", please specify another one.\"\n                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),\n                null);\n        }\n\n        if (null == this.defaultMQPushConsumer.getMessageModel()) {\n            throw new MQClientException(\n                \"messageModel is null\"\n                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),\n                null);\n        }\n\n        if (null == this.defaultMQPushConsumer.getConsumeFromWhere()) {\n            throw new MQClientException(\n                \"consumeFromWhere is null\"\n                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),\n                null);\n        }\n\n        Date dt = UtilAll.parseDate(this.defaultMQPushConsumer.getConsumeTimestamp(), UtilAll.YYYYMMDDHHMMSS);\n        if (null == dt) {\n            throw new MQClientException(\n                \"consumeTimestamp is invalid, the valid format is yyyyMMddHHmmss,but received \"\n                    + this.defaultMQPushConsumer.getConsumeTimestamp()\n                    + \" \" + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL), null);\n        }\n\n        // allocateMessageQueueStrategy\n        if (null == this.defaultMQPushConsumer.getAllocateMessageQueueStrategy()) {\n            throw new MQClientException(\n                \"allocateMessageQueueStrategy is null\"\n                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),\n                null);\n        }\n\n        // subscription\n        if (null == this.defaultMQPushConsumer.getSubscription()) {\n            throw new MQClientException(\n                \"subscription is null\"\n                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),\n                null);\n        }\n\n        // messageListener\n        if (null == this.defaultMQPushConsumer.getMessageListener()) {\n            throw new MQClientException(\n                \"messageListener is null\"\n                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),\n                null);\n        }\n\n        boolean orderly = this.defaultMQPushConsumer.getMessageListener() instanceof MessageListenerOrderly;\n        boolean concurrently = this.defaultMQPushConsumer.getMessageListener() instanceof MessageListenerConcurrently;\n        if (!orderly && !concurrently) {\n            throw new MQClientException(\n                \"messageListener must be instanceof MessageListenerOrderly or MessageListenerConcurrently\"\n                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),\n                null);\n        }\n\n        // consumeThreadMin\n        if (this.defaultMQPushConsumer.getConsumeThreadMin() < 1\n            || this.defaultMQPushConsumer.getConsumeThreadMin() > 1000) {\n            throw new MQClientException(\n                \"consumeThreadMin Out of range [1, 1000]\"\n                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),\n                null);\n        }\n\n        // consumeThreadMax\n        if (this.defaultMQPushConsumer.getConsumeThreadMax() < 1 || this.defaultMQPushConsumer.getConsumeThreadMax() > 1000) {\n            throw new MQClientException(\n                \"consumeThreadMax Out of range [1, 1000]\"\n                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),\n                null);\n        }\n\n        // consumeThreadMin can't be larger than consumeThreadMax\n        if (this.defaultMQPushConsumer.getConsumeThreadMin() > this.defaultMQPushConsumer.getConsumeThreadMax()) {\n            throw new MQClientException(\n                \"consumeThreadMin (\" + this.defaultMQPushConsumer.getConsumeThreadMin() + \") \"\n                    + \"is larger than consumeThreadMax (\" + this.defaultMQPushConsumer.getConsumeThreadMax() + \")\",\n                null);\n        }\n\n        // consumeConcurrentlyMaxSpan\n        if (this.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan() < 1\n            || this.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan() > 65535) {\n            throw new MQClientException(\n                \"consumeConcurrentlyMaxSpan Out of range [1, 65535]\"\n                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),\n                null);\n        }\n\n        // pullThresholdForQueue\n        if (this.defaultMQPushConsumer.getPullThresholdForQueue() < 1 || this.defaultMQPushConsumer.getPullThresholdForQueue() > 65535) {\n            throw new MQClientException(\n                \"pullThresholdForQueue Out of range [1, 65535]\"\n                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),\n                null);\n        }\n\n        // pullThresholdForTopic\n        if (this.defaultMQPushConsumer.getPullThresholdForTopic() != -1) {\n            if (this.defaultMQPushConsumer.getPullThresholdForTopic() < 1 || this.defaultMQPushConsumer.getPullThresholdForTopic() > 6553500) {\n                throw new MQClientException(\n                    \"pullThresholdForTopic Out of range [1, 6553500]\"\n                        + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),\n                    null);\n            }\n        }\n\n        // pullThresholdSizeForQueue\n        if (this.defaultMQPushConsumer.getPullThresholdSizeForQueue() < 1 || this.defaultMQPushConsumer.getPullThresholdSizeForQueue() > 1024) {\n            throw new MQClientException(\n                \"pullThresholdSizeForQueue Out of range [1, 1024]\"\n                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),\n                null);\n        }\n\n        if (this.defaultMQPushConsumer.getPullThresholdSizeForTopic() != -1) {\n            // pullThresholdSizeForTopic\n            if (this.defaultMQPushConsumer.getPullThresholdSizeForTopic() < 1 || this.defaultMQPushConsumer.getPullThresholdSizeForTopic() > 102400) {\n                throw new MQClientException(\n                    \"pullThresholdSizeForTopic Out of range [1, 102400]\"\n                        + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),\n                    null);\n            }\n        }\n\n        // pullInterval\n        if (this.defaultMQPushConsumer.getPullInterval() < 0 || this.defaultMQPushConsumer.getPullInterval() > 65535) {\n            throw new MQClientException(\n                \"pullInterval Out of range [0, 65535]\"\n                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),\n                null);\n        }\n\n        // consumeMessageBatchMaxSize\n        if (this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize() < 1\n            || this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize() > 1024) {\n            throw new MQClientException(\n                \"consumeMessageBatchMaxSize Out of range [1, 1024]\"\n                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),\n                null);\n        }\n\n        // pullBatchSize\n        if (this.defaultMQPushConsumer.getPullBatchSize() < 1 || this.defaultMQPushConsumer.getPullBatchSize() > 1024) {\n            throw new MQClientException(\n                \"pullBatchSize Out of range [1, 1024]\"\n                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),\n                null);\n        }\n\n        // popInvisibleTime\n        if (this.defaultMQPushConsumer.getPopInvisibleTime() < MIN_POP_INVISIBLE_TIME\n            || this.defaultMQPushConsumer.getPopInvisibleTime() > MAX_POP_INVISIBLE_TIME) {\n            throw new MQClientException(\n                \"popInvisibleTime Out of range [\" + MIN_POP_INVISIBLE_TIME + \", \" + MAX_POP_INVISIBLE_TIME + \"]\"\n                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),\n                null);\n        }\n\n        // popBatchNums\n        if (this.defaultMQPushConsumer.getPopBatchNums() <= 0 || this.defaultMQPushConsumer.getPopBatchNums() > 32) {\n            throw new MQClientException(\n                \"popBatchNums Out of range [1, 32]\"\n                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),\n                null);\n        }\n    }\n\n    private void copySubscription() throws MQClientException {\n        try {\n            Map<String, String> sub = this.defaultMQPushConsumer.getSubscription();\n            if (sub != null) {\n                for (final Map.Entry<String, String> entry : sub.entrySet()) {\n                    final String topic = entry.getKey();\n                    final String subString = entry.getValue();\n                    SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(topic, subString);\n                    this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);\n                }\n            }\n\n            if (null == this.messageListenerInner) {\n                this.messageListenerInner = this.defaultMQPushConsumer.getMessageListener();\n            }\n\n            switch (this.defaultMQPushConsumer.getMessageModel()) {\n                case BROADCASTING:\n                    break;\n                case CLUSTERING:\n                    final String retryTopic = MixAll.getRetryTopic(this.defaultMQPushConsumer.getConsumerGroup());\n                    SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(retryTopic, SubscriptionData.SUB_ALL);\n                    this.rebalanceImpl.getSubscriptionInner().put(retryTopic, subscriptionData);\n                    break;\n                default:\n                    break;\n            }\n        } catch (Exception e) {\n            throw new MQClientException(\"subscription exception\", e);\n        }\n    }\n\n    public MessageListener getMessageListenerInner() {\n        return messageListenerInner;\n    }\n\n    private void updateTopicSubscribeInfoWhenSubscriptionChanged() {\n        if (doNotUpdateTopicSubscribeInfoWhenSubscriptionChanged) {\n            return;\n        }\n        Map<String, SubscriptionData> subTable = this.getSubscriptionInner();\n        if (subTable != null) {\n            for (final Map.Entry<String, SubscriptionData> entry : subTable.entrySet()) {\n                final String topic = entry.getKey();\n                this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);\n            }\n        }\n    }\n\n    public ConcurrentMap<String, SubscriptionData> getSubscriptionInner() {\n        return this.rebalanceImpl.getSubscriptionInner();\n    }\n\n    public void subscribe(String topic, String subExpression) throws MQClientException {\n        try {\n            SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(topic, subExpression);\n            this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);\n            if (this.mQClientFactory != null) {\n                this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();\n            }\n        } catch (Exception e) {\n            throw new MQClientException(\"subscription exception\", e);\n        }\n    }\n\n    public void subscribe(String topic, String fullClassName, String filterClassSource) throws MQClientException {\n        try {\n            SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(topic, SubscriptionData.SUB_ALL);\n            subscriptionData.setSubString(fullClassName);\n            subscriptionData.setClassFilterMode(true);\n            subscriptionData.setFilterClassSource(filterClassSource);\n            this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);\n            if (this.mQClientFactory != null) {\n                this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();\n            }\n\n        } catch (Exception e) {\n            throw new MQClientException(\"subscription exception\", e);\n        }\n    }\n\n    public void subscribe(final String topic, final MessageSelector messageSelector) throws MQClientException {\n        try {\n            if (messageSelector == null) {\n                subscribe(topic, SubscriptionData.SUB_ALL);\n                return;\n            }\n\n            SubscriptionData subscriptionData = FilterAPI.build(topic,\n                messageSelector.getExpression(), messageSelector.getExpressionType());\n\n            this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);\n            if (this.mQClientFactory != null) {\n                this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();\n            }\n        } catch (Exception e) {\n            throw new MQClientException(\"subscription exception\", e);\n        }\n    }\n\n    public void suspend() {\n        this.pause = true;\n        log.info(\"suspend this consumer, {}\", this.defaultMQPushConsumer.getConsumerGroup());\n    }\n\n    public void unsubscribe(String topic) {\n        this.rebalanceImpl.getSubscriptionInner().remove(topic);\n    }\n\n    public void updateConsumeOffset(MessageQueue mq, long offset) {\n        this.offsetStore.updateOffset(mq, offset, false);\n    }\n\n    public void updateCorePoolSize(int corePoolSize) {\n        this.consumeMessageService.updateCorePoolSize(corePoolSize);\n    }\n\n    public MessageExt viewMessage(String topic, String msgId)\n        throws RemotingException, MQBrokerException, InterruptedException, MQClientException {\n        return this.mQClientFactory.getMQAdminImpl().viewMessage(topic, msgId);\n    }\n\n    public RebalanceImpl getRebalanceImpl() {\n        return rebalanceImpl;\n    }\n\n    public boolean isConsumeOrderly() {\n        return consumeOrderly;\n    }\n\n    public void setConsumeOrderly(boolean consumeOrderly) {\n        this.consumeOrderly = consumeOrderly;\n    }\n\n    public void resetOffsetByTimeStamp(long timeStamp) throws MQClientException {\n        for (String topic : rebalanceImpl.getSubscriptionInner().keySet()) {\n            Set<MessageQueue> mqs = rebalanceImpl.getTopicSubscribeInfoTable().get(topic);\n            if (CollectionUtils.isNotEmpty(mqs)) {\n                Map<MessageQueue, Long> offsetTable = new HashMap<>(mqs.size(), 1);\n                for (MessageQueue mq : mqs) {\n                    long offset = searchOffset(mq, timeStamp);\n                    offsetTable.put(mq, offset);\n                }\n                this.mQClientFactory.resetOffset(topic, groupName(), offsetTable);\n            }\n        }\n    }\n\n    public long searchOffset(MessageQueue mq, long timestamp) throws MQClientException {\n        return this.mQClientFactory.getMQAdminImpl().searchOffset(mq, timestamp);\n    }\n\n    @Override\n    public String groupName() {\n        return this.defaultMQPushConsumer.getConsumerGroup();\n    }\n\n    @Override\n    public MessageModel messageModel() {\n        return this.defaultMQPushConsumer.getMessageModel();\n    }\n\n    @Override\n    public ConsumeType consumeType() {\n        return ConsumeType.CONSUME_PASSIVELY;\n    }\n\n    @Override\n    public ConsumeFromWhere consumeFromWhere() {\n        return this.defaultMQPushConsumer.getConsumeFromWhere();\n    }\n\n    @Override\n    public Set<SubscriptionData> subscriptions() {\n        return new HashSet<>(this.rebalanceImpl.getSubscriptionInner().values());\n    }\n\n    @Override\n    public void doRebalance() {\n        if (!this.pause) {\n            this.rebalanceImpl.doRebalance(this.isConsumeOrderly());\n        }\n    }\n\n    @Override\n    public boolean tryRebalance() {\n        if (!this.pause) {\n            return this.rebalanceImpl.doRebalance(this.isConsumeOrderly());\n        }\n        return false;\n    }\n\n    @Override\n    public void persistConsumerOffset() {\n        try {\n            this.makeSureStateOK();\n            Set<MessageQueue> mqs = new HashSet<>();\n            Set<MessageQueue> allocateMq = this.rebalanceImpl.getProcessQueueTable().keySet();\n            mqs.addAll(allocateMq);\n\n            this.offsetStore.persistAll(mqs);\n        } catch (Exception e) {\n            log.error(\"group: \" + this.defaultMQPushConsumer.getConsumerGroup() + \" persistConsumerOffset exception\", e);\n        }\n    }\n\n    @Override\n    public void updateTopicSubscribeInfo(String topic, Set<MessageQueue> info) {\n        Map<String, SubscriptionData> subTable = this.getSubscriptionInner();\n        if (subTable != null) {\n            if (subTable.containsKey(topic)) {\n                this.rebalanceImpl.topicSubscribeInfoTable.put(topic, info);\n            }\n        }\n    }\n\n    @Override\n    public boolean isSubscribeTopicNeedUpdate(String topic) {\n        Map<String, SubscriptionData> subTable = this.getSubscriptionInner();\n        if (subTable != null) {\n            if (subTable.containsKey(topic)) {\n                return !this.rebalanceImpl.topicSubscribeInfoTable.containsKey(topic);\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public boolean isUnitMode() {\n        return this.defaultMQPushConsumer.isUnitMode();\n    }\n\n    @Override\n    public ConsumerRunningInfo consumerRunningInfo() {\n        ConsumerRunningInfo info = new ConsumerRunningInfo();\n\n        Properties prop = MixAll.object2Properties(this.defaultMQPushConsumer);\n\n        prop.put(ConsumerRunningInfo.PROP_CONSUME_ORDERLY, String.valueOf(this.consumeOrderly));\n        prop.put(ConsumerRunningInfo.PROP_THREADPOOL_CORE_SIZE, String.valueOf(this.consumeMessageService.getCorePoolSize()));\n        prop.put(ConsumerRunningInfo.PROP_CONSUMER_START_TIMESTAMP, String.valueOf(this.consumerStartTimestamp));\n\n        info.setProperties(prop);\n\n        Set<SubscriptionData> subSet = this.subscriptions();\n        info.getSubscriptionSet().addAll(subSet);\n\n        Iterator<Entry<MessageQueue, ProcessQueue>> it = this.rebalanceImpl.getProcessQueueTable().entrySet().iterator();\n        while (it.hasNext()) {\n            Entry<MessageQueue, ProcessQueue> next = it.next();\n            MessageQueue mq = next.getKey();\n            ProcessQueue pq = next.getValue();\n\n            ProcessQueueInfo pqinfo = new ProcessQueueInfo();\n            pqinfo.setCommitOffset(this.offsetStore.readOffset(mq, ReadOffsetType.MEMORY_FIRST_THEN_STORE));\n            pq.fillProcessQueueInfo(pqinfo);\n            info.getMqTable().put(mq, pqinfo);\n        }\n\n        Iterator<Entry<MessageQueue, PopProcessQueue>> popIt = this.rebalanceImpl.getPopProcessQueueTable().entrySet().iterator();\n        while (popIt.hasNext()) {\n            Entry<MessageQueue, PopProcessQueue> next = popIt.next();\n            MessageQueue mq = next.getKey();\n            PopProcessQueue pq = next.getValue();\n\n            PopProcessQueueInfo pqinfo = new PopProcessQueueInfo();\n            pq.fillPopProcessQueueInfo(pqinfo);\n            info.getMqPopTable().put(mq, pqinfo);\n        }\n\n        for (SubscriptionData sd : subSet) {\n            ConsumeStatus consumeStatus = this.mQClientFactory.getConsumerStatsManager().consumeStatus(this.groupName(), sd.getTopic());\n            info.getStatusTable().put(sd.getTopic(), consumeStatus);\n        }\n\n        return info;\n    }\n\n    public MQClientInstance getmQClientFactory() {\n        return mQClientFactory;\n    }\n\n    public void setmQClientFactory(MQClientInstance mQClientFactory) {\n        this.mQClientFactory = mQClientFactory;\n    }\n\n    public ServiceState getServiceState() {\n        return serviceState;\n    }\n\n    //Don't use this deprecated setter, which will be removed soon.\n    @Deprecated\n    public synchronized void setServiceState(ServiceState serviceState) {\n        this.serviceState = serviceState;\n    }\n\n    public void adjustThreadPool() {\n        long computeAccTotal = this.computeAccumulationTotal();\n        long adjustThreadPoolNumsThreshold = this.defaultMQPushConsumer.getAdjustThreadPoolNumsThreshold();\n\n        long incThreshold = (long) (adjustThreadPoolNumsThreshold * 1.0);\n\n        long decThreshold = (long) (adjustThreadPoolNumsThreshold * 0.8);\n\n        if (computeAccTotal >= incThreshold) {\n            this.consumeMessageService.incCorePoolSize();\n        }\n\n        if (computeAccTotal < decThreshold) {\n            this.consumeMessageService.decCorePoolSize();\n        }\n    }\n\n    private long computeAccumulationTotal() {\n        long msgAccTotal = 0;\n        ConcurrentMap<MessageQueue, ProcessQueue> processQueueTable = this.rebalanceImpl.getProcessQueueTable();\n        Iterator<Entry<MessageQueue, ProcessQueue>> it = processQueueTable.entrySet().iterator();\n        while (it.hasNext()) {\n            Entry<MessageQueue, ProcessQueue> next = it.next();\n            ProcessQueue value = next.getValue();\n            msgAccTotal += value.getMsgAccCnt();\n        }\n\n        return msgAccTotal;\n    }\n\n    public List<QueueTimeSpan> queryConsumeTimeSpan(final String topic)\n        throws RemotingException, MQClientException, InterruptedException, MQBrokerException {\n        List<QueueTimeSpan> queueTimeSpan = new ArrayList<>();\n        TopicRouteData routeData = this.mQClientFactory.getMQClientAPIImpl().getTopicRouteInfoFromNameServer(topic, 3000);\n        for (BrokerData brokerData : routeData.getBrokerDatas()) {\n            String addr = brokerData.selectBrokerAddr();\n            queueTimeSpan.addAll(this.mQClientFactory.getMQClientAPIImpl().queryConsumeTimeSpan(addr, topic, groupName(), 3000));\n        }\n\n        return queueTimeSpan;\n    }\n\n    public void tryResetPopRetryTopic(final List<MessageExt> msgs, String consumerGroup) {\n        String popRetryPrefix = MixAll.RETRY_GROUP_TOPIC_PREFIX + consumerGroup + \"_\";\n        for (MessageExt msg : msgs) {\n            if (msg.getTopic().startsWith(popRetryPrefix)) {\n                String normalTopic = KeyBuilder.parseNormalTopic(msg.getTopic(), consumerGroup);\n                if (normalTopic != null && !normalTopic.isEmpty()) {\n                    msg.setTopic(normalTopic);\n                }\n            }\n        }\n    }\n\n\n    public void resetRetryAndNamespace(final List<MessageExt> msgs, String consumerGroup) {\n        final String groupTopic = MixAll.getRetryTopic(consumerGroup);\n        for (MessageExt msg : msgs) {\n            String retryTopic = msg.getProperty(MessageConst.PROPERTY_RETRY_TOPIC);\n            if (retryTopic != null && groupTopic.equals(msg.getTopic())) {\n                msg.setTopic(retryTopic);\n            }\n\n            if (StringUtils.isNotEmpty(this.defaultMQPushConsumer.getNamespace())) {\n                msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), this.defaultMQPushConsumer.getNamespace()));\n            }\n        }\n    }\n\n    public ConsumeMessageService getConsumeMessageService() {\n        return consumeMessageService;\n    }\n\n    public void setConsumeMessageService(ConsumeMessageService consumeMessageService) {\n        this.consumeMessageService = consumeMessageService;\n\n    }\n\n    public void setPullTimeDelayMillsWhenException(long pullTimeDelayMillsWhenException) {\n        this.pullTimeDelayMillsWhenException = pullTimeDelayMillsWhenException;\n    }\n\n    int[] getPopDelayLevel() {\n        return popDelayLevel;\n    }\n\n    public MessageQueueListener getMessageQueueListener() {\n        if (null == defaultMQPushConsumer) {\n            return null;\n        }\n        return defaultMQPushConsumer.getMessageQueueListener();\n    }\n}\n",
            "role": "user"
        },
        {
            "content": "//common/src/main/java/org/apache/rocketmq/common/BrokerConfig.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.rocketmq.common;\n\nimport org.apache.rocketmq.common.annotation.ImportantField;\nimport org.apache.rocketmq.common.constant.PermName;\nimport org.apache.rocketmq.common.message.MessageRequestMode;\nimport org.apache.rocketmq.common.metrics.MetricsExporterType;\nimport org.apache.rocketmq.common.topic.TopicValidator;\nimport org.apache.rocketmq.common.utils.NetworkUtil;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class BrokerConfig extends BrokerIdentity {\n\n    private String brokerConfigPath = null;\n\n    private String rocketmqHome = System.getProperty(MixAll.ROCKETMQ_HOME_PROPERTY, System.getenv(MixAll.ROCKETMQ_HOME_ENV));\n    @ImportantField\n    private String namesrvAddr = System.getProperty(MixAll.NAMESRV_ADDR_PROPERTY, System.getenv(MixAll.NAMESRV_ADDR_ENV));\n\n    /**\n     * Listen port for single broker\n     */\n    @ImportantField\n    private int listenPort = 6888;\n\n    @ImportantField\n    private String brokerIP1 = NetworkUtil.getLocalAddress();\n    private String brokerIP2 = NetworkUtil.getLocalAddress();\n\n    @ImportantField\n    private boolean recoverConcurrently = false;\n\n    private int brokerPermission = PermName.PERM_READ | PermName.PERM_WRITE;\n    private int defaultTopicQueueNums = 8;\n    @ImportantField\n    private boolean autoCreateTopicEnable = true;\n\n    private boolean clusterTopicEnable = true;\n\n    private boolean brokerTopicEnable = true;\n    @ImportantField\n    private boolean autoCreateSubscriptionGroup = true;\n    private String messageStorePlugIn = \"\";\n\n    private static final int PROCESSOR_NUMBER = Runtime.getRuntime().availableProcessors();\n    @ImportantField\n    private String msgTraceTopicName = TopicValidator.RMQ_SYS_TRACE_TOPIC;\n    @ImportantField\n    private boolean traceTopicEnable = false;\n    /**\n     * thread numbers for send message thread pool.\n     */\n    private int sendMessageThreadPoolNums = Math.min(PROCESSOR_NUMBER, 4);\n    private int putMessageFutureThreadPoolNums = Math.min(PROCESSOR_NUMBER, 4);\n    private int pullMessageThreadPoolNums = 16 + PROCESSOR_NUMBER * 2;\n    private int litePullMessageThreadPoolNums = 16 + PROCESSOR_NUMBER * 2;\n    private int ackMessageThreadPoolNums = 3;\n    private int processReplyMessageThreadPoolNums = 16 + PROCESSOR_NUMBER * 2;\n    private int queryMessageThreadPoolNums = 8 + PROCESSOR_NUMBER;\n\n    private int adminBrokerThreadPoolNums = 16;\n    private int clientManageThreadPoolNums = 32;\n    private int consumerManageThreadPoolNums = 32;\n    private int loadBalanceProcessorThreadPoolNums = 32;\n    private int heartbeatThreadPoolNums = Math.min(32, PROCESSOR_NUMBER);\n    private int recoverThreadPoolNums = 32;\n\n    /**\n     * Thread numbers for EndTransactionProcessor\n     */\n    private int endTransactionThreadPoolNums = Math.max(8 + PROCESSOR_NUMBER * 2,\n            sendMessageThreadPoolNums * 4);\n\n    private int flushConsumerOffsetInterval = 1000 * 5;\n\n    private int flushConsumerOffsetHistoryInterval = 1000 * 60;\n\n    @ImportantField\n    private boolean rejectTransactionMessage = false;\n\n    @ImportantField\n    private boolean fetchNameSrvAddrByDnsLookup = false;\n\n    @ImportantField\n    private boolean fetchNamesrvAddrByAddressServer = false;\n\n    private int sendThreadPoolQueueCapacity = 10000;\n    private int putThreadPoolQueueCapacity = 10000;\n    private int pullThreadPoolQueueCapacity = 100000;\n    private int litePullThreadPoolQueueCapacity = 100000;\n    private int ackThreadPoolQueueCapacity = 100000;\n    private int replyThreadPoolQueueCapacity = 10000;\n    private int queryThreadPoolQueueCapacity = 20000;\n    private int clientManagerThreadPoolQueueCapacity = 1000000;\n    private int consumerManagerThreadPoolQueueCapacity = 1000000;\n    private int heartbeatThreadPoolQueueCapacity = 50000;\n    private int endTransactionPoolQueueCapacity = 100000;\n    private int adminBrokerThreadPoolQueueCapacity = 10000;\n    private int loadBalanceThreadPoolQueueCapacity = 100000;\n\n    private boolean longPollingEnable = true;\n\n    private long shortPollingTimeMills = 1000;\n\n    private boolean notifyConsumerIdsChangedEnable = true;\n\n    private boolean highSpeedMode = false;\n\n    private int commercialBaseCount = 1;\n\n    private int commercialSizePerMsg = 4 * 1024;\n\n    private boolean accountStatsEnable = true;\n    private boolean accountStatsPrintZeroValues = true;\n\n    private boolean transferMsgByHeap = true;\n\n    private String regionId = MixAll.DEFAULT_TRACE_REGION_ID;\n    private int registerBrokerTimeoutMills = 24000;\n\n    private int sendHeartbeatTimeoutMillis = 1000;\n\n    private boolean slaveReadEnable = false;\n\n    private boolean disableConsumeIfConsumerReadSlowly = false;\n    private long consumerFallbehindThreshold = 1024L * 1024 * 1024 * 16;\n\n    private boolean brokerFastFailureEnable = true;\n    private long waitTimeMillsInSendQueue = 200;\n    private long waitTimeMillsInPullQueue = 5 * 1000;\n    private long waitTimeMillsInLitePullQueue = 5 * 1000;\n    private long waitTimeMillsInHeartbeatQueue = 31 * 1000;\n    private long waitTimeMillsInTransactionQueue = 3 * 1000;\n    private long waitTimeMillsInAckQueue = 3000;\n\n    private long startAcceptSendRequestTimeStamp = 0L;\n\n    private boolean traceOn = true;\n\n    // Switch of filter bit map calculation.\n    // If switch on:\n    // 1. Calculate filter bit map when construct queue.\n    // 2. Filter bit map will be saved to consume queue extend file if allowed.\n    private boolean enableCalcFilterBitMap = false;\n\n    //Reject the pull consumer instance to pull messages from broker.\n    private boolean rejectPullConsumerEnable = false;\n\n    // Expect num of consumers will use filter.\n    private int expectConsumerNumUseFilter = 32;\n\n    // Error rate of bloom filter, 1~100.\n    private int maxErrorRateOfBloomFilter = 20;\n\n    //how long to clean filter data after dead.Default: 24h\n    private long filterDataCleanTimeSpan = 24 * 3600 * 1000;\n\n    // whether do filter when retry.\n    private boolean filterSupportRetry = false;\n    private boolean enablePropertyFilter = false;\n\n    private boolean compressedRegister = false;\n\n    private boolean forceRegister = true;\n\n    /**\n     * This configurable item defines interval of topics registration of broker to name server. Allowing values are\n     * between 10,000 and 60,000 milliseconds.\n     */\n    private int registerNameServerPeriod = 1000 * 30;\n\n    /**\n     * the interval to send heartbeat to name server for liveness detection.\n     */\n    private int brokerHeartbeatInterval = 1000;\n\n    /**\n     * How long the broker will be considered as inactive by nameserver since last heartbeat. Effective only if\n     * enableSlaveActingMaster is true\n     */\n    private long brokerNotActiveTimeoutMillis = 10 * 1000;\n\n    private boolean enableNetWorkFlowControl = false;\n\n    private boolean enableBroadcastOffsetStore = true;\n\n    private long broadcastOffsetExpireSecond = 2 * 60;\n\n    private long broadcastOffsetExpireMaxSecond = 5 * 60;\n\n    private int popPollingSize = 1024;\n    private int popPollingMapSize = 100000;\n    // 20w cost 200M heap memory.\n    private long maxPopPollingSize = 100000;\n    private int reviveQueueNum = 8;\n    private long reviveInterval = 1000;\n    private long reviveMaxSlow = 3;\n    private long reviveScanTime = 10000;\n    private boolean enableSkipLongAwaitingAck = false;\n    private long reviveAckWaitMs = TimeUnit.MINUTES.toMillis(3);\n    private boolean enablePopLog = false;\n    private boolean enablePopBufferMerge = false;\n    private int popCkStayBufferTime = 10 * 1000;\n    private int popCkStayBufferTimeOut = 3 * 1000;\n    private int popCkMaxBufferSize = 200000;\n    private int popCkOffsetMaxQueueSize = 20000;\n    private boolean enablePopBatchAck = false;\n    private boolean enableNotifyAfterPopOrderLockRelease = true;\n    private boolean initPopOffsetByCheckMsgInMem = true;\n    // read message from pop retry topic v1, for the compatibility, will be removed in the future version\n    private boolean retrieveMessageFromPopRetryTopicV1 = true;\n    private boolean enableRetryTopicV2 = false;\n\n    private boolean realTimeNotifyConsumerChange = true;\n\n    private boolean litePullMessageEnable = true;\n\n    // The period to sync broker member group from namesrv, default value is 1 second\n    private int syncBrokerMemberGroupPeriod = 1000;\n\n    /**\n     * the interval of pulling topic information from the named server\n     */\n    private long loadBalancePollNameServerInterval = 1000 * 30;\n\n    /**\n     * the interval of cleaning\n     */\n    private int cleanOfflineBrokerInterval = 1000 * 30;\n\n    private boolean serverLoadBalancerEnable = true;\n\n    private MessageRequestMode defaultMessageRequestMode = MessageRequestMode.PULL;\n\n    private int defaultPopShareQueueNum = -1;\n\n    /**\n     * The minimum time of the transactional message  to be checked firstly, one message only exceed this time interval\n     * that can be checked.\n     */\n    @ImportantField\n    private long transactionTimeOut = 6 * 1000;\n\n    /**\n     * The maximum number of times the message was checked, if exceed this value, this message will be discarded.\n     */\n    @ImportantField\n    private int transactionCheckMax = 15;\n\n    /**\n     * Transaction message check interval.\n     */\n    @ImportantField\n    private long transactionCheckInterval = 30 * 1000;\n\n    private long transactionMetricFlushInterval = 3 * 1000;\n\n    /**\n     * transaction batch op message\n     */\n    private int transactionOpMsgMaxSize = 4096;\n\n    private int transactionOpBatchInterval = 3000;\n\n    /**\n     * Acl feature switch\n     */\n    @ImportantField\n    private boolean aclEnable = false;\n\n    private boolean storeReplyMessageEnable = true;\n\n    private boolean enableDetailStat = true;\n\n    private boolean autoDeleteUnusedStats = false;\n\n    /**\n     * Whether to distinguish log paths when multiple brokers are deployed on the same machine\n     */\n    private boolean isolateLogEnable = false;\n\n    private long forwardTimeout = 3 * 1000;\n\n    /**\n     * Slave will act master when failover. For example, if master down, timer or transaction message which is expire in slave will\n     * put to master (master of the same process in broker container mode or other masters in cluster when enableFailoverRemotingActing is true)\n     * when enableSlaveActingMaster is true\n     */\n    private boolean enableSlaveActingMaster = false;\n\n    private boolean enableRemoteEscape = false;\n\n    private boolean skipPreOnline = false;\n\n    private boolean asyncSendEnable = true;\n\n    private boolean useServerSideResetOffset = true;\n\n    private long consumerOffsetUpdateVersionStep = 500;\n\n    private long delayOffsetUpdateVersionStep = 200;\n\n    /**\n     * Whether to lock quorum replicas.\n     *\n     * True: need to lock quorum replicas succeed. False: only need to lock one replica succeed.\n     */\n    private boolean lockInStrictMode = false;\n\n    private boolean compatibleWithOldNameSrv = true;\n\n    /**\n     * Is startup controller mode, which support auto switch broker's role.\n     */\n    private boolean enableControllerMode = false;\n\n    private String controllerAddr = \"\";\n\n    private boolean fetchControllerAddrByDnsLookup = false;\n\n    private long syncBrokerMetadataPeriod = 5 * 1000;\n\n    private long checkSyncStateSetPeriod = 5 * 1000;\n\n    private long syncControllerMetadataPeriod = 10 * 1000;\n\n    private long controllerHeartBeatTimeoutMills = 10 * 1000;\n\n    private boolean validateSystemTopicWhenUpdateTopic = true;\n\n    /**\n     * It is an important basis for the controller to choose the broker master.\n     * The lower the value of brokerElectionPriority, the higher the priority of the broker being selected as the master.\n     * You can set a lower priority for the broker with better machine conditions.\n     */\n    private int brokerElectionPriority = Integer.MAX_VALUE;\n\n    private boolean useStaticSubscription = false;\n\n    private MetricsExporterType metricsExporterType = MetricsExporterType.DISABLE;\n\n    private int metricsOtelCardinalityLimit = 50 * 1000;\n    private String metricsGrpcExporterTarget = \"\";\n    private String metricsGrpcExporterHeader = \"\";\n    private long metricGrpcExporterTimeOutInMills = 3 * 1000;\n    private long metricGrpcExporterIntervalInMills = 60 * 1000;\n    private long metricLoggingExporterIntervalInMills = 10 * 1000;\n\n    private int metricsPromExporterPort = 5557;\n    private String metricsPromExporterHost = \"\";\n\n    // Label pairs in CSV. Each label follows pattern of Key:Value. eg: instance_id:xxx,uid:xxx\n    private String metricsLabel = \"\";\n\n    private boolean metricsInDelta = false;\n\n    private long channelExpiredTimeout = 1000 * 120;\n    private long subscriptionExpiredTimeout = 1000 * 60 * 10;\n\n    /**\n     * Estimate accumulation or not when subscription filter type is tag and is not SUB_ALL.\n     */\n    private boolean estimateAccumulation = true;\n\n    private boolean coldCtrStrategyEnable = false;\n    private boolean usePIDColdCtrStrategy = true;\n    private long cgColdReadThreshold = 3 * 1024 * 1024;\n    private long globalColdReadThreshold = 100 * 1024 * 1024;\n    \n    /**\n     * The interval to fetch namesrv addr, default value is 10 second\n     */\n    private long fetchNamesrvAddrInterval = 10 * 1000;\n\n    /**\n     * Pop response returns the actual retry topic rather than tampering with the original topic\n     */\n    private boolean popResponseReturnActualRetryTopic = false;\n\n    /**\n     * If both the deleteTopicWithBrokerRegistration flag in the NameServer configuration and this flag are set to true,\n     * it guarantees the ultimate consistency of data between the broker and the nameserver during topic deletion.\n     */\n    private boolean enableSingleTopicRegister = false;\n\n    private boolean enableMixedMessageType = false;\n\n    /**\n     * This flag and deleteTopicWithBrokerRegistration flag in the NameServer cannot be set to true at the same time,\n     * otherwise there will be a loss of routing\n     */\n    private boolean enableSplitRegistration = false;\n\n    private long popInflightMessageThreshold = 10000;\n    private boolean enablePopMessageThreshold = false;\n\n    private int splitRegistrationSize = 800;\n\n    /**\n     * Config in this black list will be not allowed to update by command.\n     * Try to update this config black list by restart process.\n     * Try to update configures in black list by restart process.\n     */\n    private String configBlackList = \"configBlackList;brokerConfigPath\";\n\n    public String getConfigBlackList() {\n        return configBlackList;\n    }\n\n    public void setConfigBlackList(String configBlackList) {\n        this.configBlackList = configBlackList;\n    }\n\n    public long getMaxPopPollingSize() {\n        return maxPopPollingSize;\n    }\n\n    public void setMaxPopPollingSize(long maxPopPollingSize) {\n        this.maxPopPollingSize = maxPopPollingSize;\n    }\n\n    public int getReviveQueueNum() {\n        return reviveQueueNum;\n    }\n\n    public void setReviveQueueNum(int reviveQueueNum) {\n        this.reviveQueueNum = reviveQueueNum;\n    }\n\n    public long getReviveInterval() {\n        return reviveInterval;\n    }\n\n    public void setReviveInterval(long reviveInterval) {\n        this.reviveInterval = reviveInterval;\n    }\n\n    public int getPopCkStayBufferTime() {\n        return popCkStayBufferTime;\n    }\n\n    public void setPopCkStayBufferTime(int popCkStayBufferTime) {\n        this.popCkStayBufferTime = popCkStayBufferTime;\n    }\n\n    public int getPopCkStayBufferTimeOut() {\n        return popCkStayBufferTimeOut;\n    }\n\n    public void setPopCkStayBufferTimeOut(int popCkStayBufferTimeOut) {\n        this.popCkStayBufferTimeOut = popCkStayBufferTimeOut;\n    }\n\n    public int getPopPollingMapSize() {\n        return popPollingMapSize;\n    }\n\n    public void setPopPollingMapSize(int popPollingMapSize) {\n        this.popPollingMapSize = popPollingMapSize;\n    }\n\n    public long getReviveScanTime() {\n        return reviveScanTime;\n    }\n\n    public void setReviveScanTime(long reviveScanTime) {\n        this.reviveScanTime = reviveScanTime;\n    }\n\n    public long getReviveMaxSlow() {\n        return reviveMaxSlow;\n    }\n\n    public void setReviveMaxSlow(long reviveMaxSlow) {\n        this.reviveMaxSlow = reviveMaxSlow;\n    }\n\n    public int getPopPollingSize() {\n        return popPollingSize;\n    }\n\n    public void setPopPollingSize(int popPollingSize) {\n        this.popPollingSize = popPollingSize;\n    }\n\n    public boolean isEnablePopBufferMerge() {\n        return enablePopBufferMerge;\n    }\n\n    public void setEnablePopBufferMerge(boolean enablePopBufferMerge) {\n        this.enablePopBufferMerge = enablePopBufferMerge;\n    }\n\n    public int getPopCkMaxBufferSize() {\n        return popCkMaxBufferSize;\n    }\n\n    public void setPopCkMaxBufferSize(int popCkMaxBufferSize) {\n        this.popCkMaxBufferSize = popCkMaxBufferSize;\n    }\n\n    public int getPopCkOffsetMaxQueueSize() {\n        return popCkOffsetMaxQueueSize;\n    }\n\n    public void setPopCkOffsetMaxQueueSize(int popCkOffsetMaxQueueSize) {\n        this.popCkOffsetMaxQueueSize = popCkOffsetMaxQueueSize;\n    }\n\n    public boolean isEnablePopBatchAck() {\n        return enablePopBatchAck;\n    }\n\n    public void setEnablePopBatchAck(boolean enablePopBatchAck) {\n        this.enablePopBatchAck = enablePopBatchAck;\n    }\n\n    public boolean isEnableSkipLongAwaitingAck() {\n        return enableSkipLongAwaitingAck;\n    }\n\n    public void setEnableSkipLongAwaitingAck(boolean enableSkipLongAwaitingAck) {\n        this.enableSkipLongAwaitingAck = enableSkipLongAwaitingAck;\n    }\n\n    public long getReviveAckWaitMs() {\n        return reviveAckWaitMs;\n    }\n\n    public void setReviveAckWaitMs(long reviveAckWaitMs) {\n        this.reviveAckWaitMs = reviveAckWaitMs;\n    }\n\n    public boolean isEnablePopLog() {\n        return enablePopLog;\n    }\n\n    public void setEnablePopLog(boolean enablePopLog) {\n        this.enablePopLog = enablePopLog;\n    }\n\n    public boolean isTraceOn() {\n        return traceOn;\n    }\n\n    public void setTraceOn(final boolean traceOn) {\n        this.traceOn = traceOn;\n    }\n\n    public long getStartAcceptSendRequestTimeStamp() {\n        return startAcceptSendRequestTimeStamp;\n    }\n\n    public void setStartAcceptSendRequestTimeStamp(final long startAcceptSendRequestTimeStamp) {\n        this.startAcceptSendRequestTimeStamp = startAcceptSendRequestTimeStamp;\n    }\n\n    public long getWaitTimeMillsInSendQueue() {\n        return waitTimeMillsInSendQueue;\n    }\n\n    public void setWaitTimeMillsInSendQueue(final long waitTimeMillsInSendQueue) {\n        this.waitTimeMillsInSendQueue = waitTimeMillsInSendQueue;\n    }\n\n    public long getConsumerFallbehindThreshold() {\n        return consumerFallbehindThreshold;\n    }\n\n    public void setConsumerFallbehindThreshold(final long consumerFallbehindThreshold) {\n        this.consumerFallbehindThreshold = consumerFallbehindThreshold;\n    }\n\n    public boolean isBrokerFastFailureEnable() {\n        return brokerFastFailureEnable;\n    }\n\n    public void setBrokerFastFailureEnable(final boolean brokerFastFailureEnable) {\n        this.brokerFastFailureEnable = brokerFastFailureEnable;\n    }\n\n    public long getWaitTimeMillsInPullQueue() {\n        return waitTimeMillsInPullQueue;\n    }\n\n    public void setWaitTimeMillsInPullQueue(final long waitTimeMillsInPullQueue) {\n        this.waitTimeMillsInPullQueue = waitTimeMillsInPullQueue;\n    }\n\n    public boolean isDisableConsumeIfConsumerReadSlowly() {\n        return disableConsumeIfConsumerReadSlowly;\n    }\n\n    public void setDisableConsumeIfConsumerReadSlowly(final boolean disableConsumeIfConsumerReadSlowly) {\n        this.disableConsumeIfConsumerReadSlowly = disableConsumeIfConsumerReadSlowly;\n    }\n\n    public boolean isSlaveReadEnable() {\n        return slaveReadEnable;\n    }\n\n    public void setSlaveReadEnable(final boolean slaveReadEnable) {\n        this.slaveReadEnable = slaveReadEnable;\n    }\n\n    public int getRegisterBrokerTimeoutMills() {\n        return registerBrokerTimeoutMills;\n    }\n\n    public void setRegisterBrokerTimeoutMills(final int registerBrokerTimeoutMills) {\n        this.registerBrokerTimeoutMills = registerBrokerTimeoutMills;\n    }\n\n    public String getRegionId() {\n        return regionId;\n    }\n\n    public void setRegionId(final String regionId) {\n        this.regionId = regionId;\n    }\n\n    public boolean isTransferMsgByHeap() {\n        return transferMsgByHeap;\n    }\n\n    public void setTransferMsgByHeap(final boolean transferMsgByHeap) {\n        this.transferMsgByHeap = transferMsgByHeap;\n    }\n\n    public String getMessageStorePlugIn() {\n        return messageStorePlugIn;\n    }\n\n    public void setMessageStorePlugIn(String messageStorePlugIn) {\n        this.messageStorePlugIn = messageStorePlugIn;\n    }\n\n    public boolean isHighSpeedMode() {\n        return highSpeedMode;\n    }\n\n    public void setHighSpeedMode(final boolean highSpeedMode) {\n        this.highSpeedMode = highSpeedMode;\n    }\n\n    public int getBrokerPermission() {\n        return brokerPermission;\n    }\n\n    public void setBrokerPermission(int brokerPermission) {\n        this.brokerPermission = brokerPermission;\n    }\n\n    public int getDefaultTopicQueueNums() {\n        return defaultTopicQueueNums;\n    }\n\n    public void setDefaultTopicQueueNums(int defaultTopicQueueNums) {\n        this.defaultTopicQueueNums = defaultTopicQueueNums;\n    }\n\n    public boolean isAutoCreateTopicEnable() {\n        return autoCreateTopicEnable;\n    }\n\n    public void setAutoCreateTopicEnable(boolean autoCreateTopic) {\n        this.autoCreateTopicEnable = autoCreateTopic;\n    }\n\n    public String getBrokerIP1() {\n        return brokerIP1;\n    }\n\n    public void setBrokerIP1(String brokerIP1) {\n        this.brokerIP1 = brokerIP1;\n    }\n\n    public String getBrokerIP2() {\n        return brokerIP2;\n    }\n\n    public void setBrokerIP2(String brokerIP2) {\n        this.brokerIP2 = brokerIP2;\n    }\n\n    public int getSendMessageThreadPoolNums() {\n        return sendMessageThreadPoolNums;\n    }\n\n    public void setSendMessageThreadPoolNums(int sendMessageThreadPoolNums) {\n        this.sendMessageThreadPoolNums = sendMessageThreadPoolNums;\n    }\n\n    public int getPutMessageFutureThreadPoolNums() {\n        return putMessageFutureThreadPoolNums;\n    }\n\n    public void setPutMessageFutureThreadPoolNums(int putMessageFutureThreadPoolNums) {\n        this.putMessageFutureThreadPoolNums = putMessageFutureThreadPoolNums;\n    }\n\n    public int getPullMessageThreadPoolNums() {\n        return pullMessageThreadPoolNums;\n    }\n\n    public void setPullMessageThreadPoolNums(int pullMessageThreadPoolNums) {\n        this.pullMessageThreadPoolNums = pullMessageThreadPoolNums;\n    }\n\n    public int getAckMessageThreadPoolNums() {\n        return ackMessageThreadPoolNums;\n    }\n\n    public void setAckMessageThreadPoolNums(int ackMessageThreadPoolNums) {\n        this.ackMessageThreadPoolNums = ackMessageThreadPoolNums;\n    }\n\n    public int getProcessReplyMessageThreadPoolNums() {\n        return processReplyMessageThreadPoolNums;\n    }\n\n    public void setProcessReplyMessageThreadPoolNums(int processReplyMessageThreadPoolNums) {\n        this.processReplyMessageThreadPoolNums = processReplyMessageThreadPoolNums;\n    }\n\n    public int getQueryMessageThreadPoolNums() {\n        return queryMessageThreadPoolNums;\n    }\n\n    public void setQueryMessageThreadPoolNums(final int queryMessageThreadPoolNums) {\n        this.queryMessageThreadPoolNums = queryMessageThreadPoolNums;\n    }\n\n    public int getAdminBrokerThreadPoolNums() {\n        return adminBrokerThreadPoolNums;\n    }\n\n    public void setAdminBrokerThreadPoolNums(int adminBrokerThreadPoolNums) {\n        this.adminBrokerThreadPoolNums = adminBrokerThreadPoolNums;\n    }\n\n    public int getFlushConsumerOffsetInterval() {\n        return flushConsumerOffsetInterval;\n    }\n\n    public void setFlushConsumerOffsetInterval(int flushConsumerOffsetInterval) {\n        this.flushConsumerOffsetInterval = flushConsumerOffsetInterval;\n    }\n\n    public int getFlushConsumerOffsetHistoryInterval() {\n        return flushConsumerOffsetHistoryInterval;\n    }\n\n    public void setFlushConsumerOffsetHistoryInterval(int flushConsumerOffsetHistoryInterval) {\n        this.flushConsumerOffsetHistoryInterval = flushConsumerOffsetHistoryInterval;\n    }\n\n    public boolean isClusterTopicEnable() {\n        return clusterTopicEnable;\n    }\n\n    public void setClusterTopicEnable(boolean clusterTopicEnable) {\n        this.clusterTopicEnable = clusterTopicEnable;\n    }\n\n    public String getNamesrvAddr() {\n        return namesrvAddr;\n    }\n\n    public void setNamesrvAddr(String namesrvAddr) {\n        this.namesrvAddr = namesrvAddr;\n    }\n\n    public boolean isAutoCreateSubscriptionGroup() {\n        return autoCreateSubscriptionGroup;\n    }\n\n    public void setAutoCreateSubscriptionGroup(boolean autoCreateSubscriptionGroup) {\n        this.autoCreateSubscriptionGroup = autoCreateSubscriptionGroup;\n    }\n\n    public String getBrokerConfigPath() {\n        return brokerConfigPath;\n    }\n\n    public void setBrokerConfigPath(String brokerConfigPath) {\n        this.brokerConfigPath = brokerConfigPath;\n    }\n\n    public String getRocketmqHome() {\n        return rocketmqHome;\n    }\n\n    public void setRocketmqHome(String rocketmqHome) {\n        this.rocketmqHome = rocketmqHome;\n    }\n\n    public int getListenPort() {\n        return listenPort;\n    }\n\n    public void setListenPort(int listenPort) {\n        this.listenPort = listenPort;\n    }\n\n    public int getLitePullMessageThreadPoolNums() {\n        return litePullMessageThreadPoolNums;\n    }\n\n    public void setLitePullMessageThreadPoolNums(int litePullMessageThreadPoolNums) {\n        this.litePullMessageThreadPoolNums = litePullMessageThreadPoolNums;\n    }\n\n    public int getLitePullThreadPoolQueueCapacity() {\n        return litePullThreadPoolQueueCapacity;\n    }\n\n    public void setLitePullThreadPoolQueueCapacity(int litePullThreadPoolQueueCapacity) {\n        this.litePullThreadPoolQueueCapacity = litePullThreadPoolQueueCapacity;\n    }\n\n    public int getAdminBrokerThreadPoolQueueCapacity() {\n        return adminBrokerThreadPoolQueueCapacity;\n    }\n\n    public void setAdminBrokerThreadPoolQueueCapacity(int adminBrokerThreadPoolQueueCapacity) {\n        this.adminBrokerThreadPoolQueueCapacity = adminBrokerThreadPoolQueueCapacity;\n    }\n\n    public int getLoadBalanceThreadPoolQueueCapacity() {\n        return loadBalanceThreadPoolQueueCapacity;\n    }\n\n    public void setLoadBalanceThreadPoolQueueCapacity(int loadBalanceThreadPoolQueueCapacity) {\n        this.loadBalanceThreadPoolQueueCapacity = loadBalanceThreadPoolQueueCapacity;\n    }\n\n    public int getSendHeartbeatTimeoutMillis() {\n        return sendHeartbeatTimeoutMillis;\n    }\n\n    public void setSendHeartbeatTimeoutMillis(int sendHeartbeatTimeoutMillis) {\n        this.sendHeartbeatTimeoutMillis = sendHeartbeatTimeoutMillis;\n    }\n\n    public long getWaitTimeMillsInLitePullQueue() {\n        return waitTimeMillsInLitePullQueue;\n    }\n\n    public void setWaitTimeMillsInLitePullQueue(long waitTimeMillsInLitePullQueue) {\n        this.waitTimeMillsInLitePullQueue = waitTimeMillsInLitePullQueue;\n    }\n\n    public boolean isLitePullMessageEnable() {\n        return litePullMessageEnable;\n    }\n\n    public void setLitePullMessageEnable(boolean litePullMessageEnable) {\n        this.litePullMessageEnable = litePullMessageEnable;\n    }\n\n    public int getSyncBrokerMemberGroupPeriod() {\n        return syncBrokerMemberGroupPeriod;\n    }\n\n    public void setSyncBrokerMemberGroupPeriod(int syncBrokerMemberGroupPeriod) {\n        this.syncBrokerMemberGroupPeriod = syncBrokerMemberGroupPeriod;\n    }\n\n    public boolean isRejectTransactionMessage() {\n        return rejectTransactionMessage;\n    }\n\n    public void setRejectTransactionMessage(boolean rejectTransactionMessage) {\n        this.rejectTransactionMessage = rejectTransactionMessage;\n    }\n\n    public boolean isFetchNamesrvAddrByAddressServer() {\n        return fetchNamesrvAddrByAddressServer;\n    }\n\n    public void setFetchNamesrvAddrByAddressServer(boolean fetchNamesrvAddrByAddressServer) {\n        this.fetchNamesrvAddrByAddressServer = fetchNamesrvAddrByAddressServer;\n    }\n\n    public int getSendThreadPoolQueueCapacity() {\n        return sendThreadPoolQueueCapacity;\n    }\n\n    public void setSendThreadPoolQueueCapacity(int sendThreadPoolQueueCapacity) {\n        this.sendThreadPoolQueueCapacity = sendThreadPoolQueueCapacity;\n    }\n\n    public int getPutThreadPoolQueueCapacity() {\n        return putThreadPoolQueueCapacity;\n    }\n\n    public void setPutThreadPoolQueueCapacity(int putThreadPoolQueueCapacity) {\n        this.putThreadPoolQueueCapacity = putThreadPoolQueueCapacity;\n    }\n\n    public int getPullThreadPoolQueueCapacity() {\n        return pullThreadPoolQueueCapacity;\n    }\n\n    public void setPullThreadPoolQueueCapacity(int pullThreadPoolQueueCapacity) {\n        this.pullThreadPoolQueueCapacity = pullThreadPoolQueueCapacity;\n    }\n\n    public int getAckThreadPoolQueueCapacity() {\n        return ackThreadPoolQueueCapacity;\n    }\n\n    public void setAckThreadPoolQueueCapacity(int ackThreadPoolQueueCapacity) {\n        this.ackThreadPoolQueueCapacity = ackThreadPoolQueueCapacity;\n    }\n\n    public int getReplyThreadPoolQueueCapacity() {\n        return replyThreadPoolQueueCapacity;\n    }\n\n    public void setReplyThreadPoolQueueCapacity(int replyThreadPoolQueueCapacity) {\n        this.replyThreadPoolQueueCapacity = replyThreadPoolQueueCapacity;\n    }\n\n    public int getQueryThreadPoolQueueCapacity() {\n        return queryThreadPoolQueueCapacity;\n    }\n\n    public void setQueryThreadPoolQueueCapacity(final int queryThreadPoolQueueCapacity) {\n        this.queryThreadPoolQueueCapacity = queryThreadPoolQueueCapacity;\n    }\n\n    public boolean isBrokerTopicEnable() {\n        return brokerTopicEnable;\n    }\n\n    public void setBrokerTopicEnable(boolean brokerTopicEnable) {\n        this.brokerTopicEnable = brokerTopicEnable;\n    }\n\n    public boolean isLongPollingEnable() {\n        return longPollingEnable;\n    }\n\n    public void setLongPollingEnable(boolean longPollingEnable) {\n        this.longPollingEnable = longPollingEnable;\n    }\n\n    public boolean isNotifyConsumerIdsChangedEnable() {\n        return notifyConsumerIdsChangedEnable;\n    }\n\n    public void setNotifyConsumerIdsChangedEnable(boolean notifyConsumerIdsChangedEnable) {\n        this.notifyConsumerIdsChangedEnable = notifyConsumerIdsChangedEnable;\n    }\n\n    public long getShortPollingTimeMills() {\n        return shortPollingTimeMills;\n    }\n\n    public void setShortPollingTimeMills(long shortPollingTimeMills) {\n        this.shortPollingTimeMills = shortPollingTimeMills;\n    }\n\n    public int getClientManageThreadPoolNums() {\n        return clientManageThreadPoolNums;\n    }\n\n    public void setClientManageThreadPoolNums(int clientManageThreadPoolNums) {\n        this.clientManageThreadPoolNums = clientManageThreadPoolNums;\n    }\n\n    public int getClientManagerThreadPoolQueueCapacity() {\n        return clientManagerThreadPoolQueueCapacity;\n    }\n\n    public void setClientManagerThreadPoolQueueCapacity(int clientManagerThreadPoolQueueCapacity) {\n        this.clientManagerThreadPoolQueueCapacity = clientManagerThreadPoolQueueCapacity;\n    }\n\n    public int getConsumerManagerThreadPoolQueueCapacity() {\n        return consumerManagerThreadPoolQueueCapacity;\n    }\n\n    public void setConsumerManagerThreadPoolQueueCapacity(int consumerManagerThreadPoolQueueCapacity) {\n        this.consumerManagerThreadPoolQueueCapacity = consumerManagerThreadPoolQueueCapacity;\n    }\n\n    public int getConsumerManageThreadPoolNums() {\n        return consumerManageThreadPoolNums;\n    }\n\n    public void setConsumerManageThreadPoolNums(int consumerManageThreadPoolNums) {\n        this.consumerManageThreadPoolNums = consumerManageThreadPoolNums;\n    }\n\n    public int getCommercialBaseCount() {\n        return commercialBaseCount;\n    }\n\n    public void setCommercialBaseCount(int commercialBaseCount) {\n        this.commercialBaseCount = commercialBaseCount;\n    }\n\n    public boolean isEnableCalcFilterBitMap() {\n        return enableCalcFilterBitMap;\n    }\n\n    public void setEnableCalcFilterBitMap(boolean enableCalcFilterBitMap) {\n        this.enableCalcFilterBitMap = enableCalcFilterBitMap;\n    }\n\n    public int getExpectConsumerNumUseFilter() {\n        return expectConsumerNumUseFilter;\n    }\n\n    public void setExpectConsumerNumUseFilter(int expectConsumerNumUseFilter) {\n        this.expectConsumerNumUseFilter = expectConsumerNumUseFilter;\n    }\n\n    public int getMaxErrorRateOfBloomFilter() {\n        return maxErrorRateOfBloomFilter;\n    }\n\n    public void setMaxErrorRateOfBloomFilter(int maxErrorRateOfBloomFilter) {\n        this.maxErrorRateOfBloomFilter = maxErrorRateOfBloomFilter;\n    }\n\n    public long getFilterDataCleanTimeSpan() {\n        return filterDataCleanTimeSpan;\n    }\n\n    public void setFilterDataCleanTimeSpan(long filterDataCleanTimeSpan) {\n        this.filterDataCleanTimeSpan = filterDataCleanTimeSpan;\n    }\n\n    public boolean isFilterSupportRetry() {\n        return filterSupportRetry;\n    }\n\n    public void setFilterSupportRetry(boolean filterSupportRetry) {\n        this.filterSupportRetry = filterSupportRetry;\n    }\n\n    public boolean isEnablePropertyFilter() {\n        return enablePropertyFilter;\n    }\n\n    public void setEnablePropertyFilter(boolean enablePropertyFilter) {\n        this.enablePropertyFilter = enablePropertyFilter;\n    }\n\n    public boolean isCompressedRegister() {\n        return compressedRegister;\n    }\n\n    public void setCompressedRegister(boolean compressedRegister) {\n        this.compressedRegister = compressedRegister;\n    }\n\n    public boolean isForceRegister() {\n        return forceRegister;\n    }\n\n    public void setForceRegister(boolean forceRegister) {\n        this.forceRegister = forceRegister;\n    }\n\n    public int getHeartbeatThreadPoolQueueCapacity() {\n        return heartbeatThreadPoolQueueCapacity;\n    }\n\n    public void setHeartbeatThreadPoolQueueCapacity(int heartbeatThreadPoolQueueCapacity) {\n        this.heartbeatThreadPoolQueueCapacity = heartbeatThreadPoolQueueCapacity;\n    }\n\n    public int getHeartbeatThreadPoolNums() {\n        return heartbeatThreadPoolNums;\n    }\n\n    public void setHeartbeatThreadPoolNums(int heartbeatThreadPoolNums) {\n        this.heartbeatThreadPoolNums = heartbeatThreadPoolNums;\n    }\n\n    public long getWaitTimeMillsInHeartbeatQueue() {\n        return waitTimeMillsInHeartbeatQueue;\n    }\n\n    public void setWaitTimeMillsInHeartbeatQueue(long waitTimeMillsInHeartbeatQueue) {\n        this.waitTimeMillsInHeartbeatQueue = waitTimeMillsInHeartbeatQueue;\n    }\n\n    public int getRegisterNameServerPeriod() {\n        return registerNameServerPeriod;\n    }\n\n    public void setRegisterNameServerPeriod(int registerNameServerPeriod) {\n        this.registerNameServerPeriod = registerNameServerPeriod;\n    }\n\n    public long getTransactionTimeOut() {\n        return transactionTimeOut;\n    }\n\n    public void setTransactionTimeOut(long transactionTimeOut) {\n        this.transactionTimeOut = transactionTimeOut;\n    }\n\n    public int getTransactionCheckMax() {\n        return transactionCheckMax;\n    }\n\n    public void setTransactionCheckMax(int transactionCheckMax) {\n        this.transactionCheckMax = transactionCheckMax;\n    }\n\n    public long getTransactionCheckInterval() {\n        return transactionCheckInterval;\n    }\n\n    public void setTransactionCheckInterval(long transactionCheckInterval) {\n        this.transactionCheckInterval = transactionCheckInterval;\n    }\n\n    public int getEndTransactionThreadPoolNums() {\n        return endTransactionThreadPoolNums;\n    }\n\n    public void setEndTransactionThreadPoolNums(int endTransactionThreadPoolNums) {\n        this.endTransactionThreadPoolNums = endTransactionThreadPoolNums;\n    }\n\n    public int getEndTransactionPoolQueueCapacity() {\n        return endTransactionPoolQueueCapacity;\n    }\n\n    public void setEndTransactionPoolQueueCapacity(int endTransactionPoolQueueCapacity) {\n        this.endTransactionPoolQueueCapacity = endTransactionPoolQueueCapacity;\n    }\n\n    public long getWaitTimeMillsInTransactionQueue() {\n        return waitTimeMillsInTransactionQueue;\n    }\n\n    public void setWaitTimeMillsInTransactionQueue(long waitTimeMillsInTransactionQueue) {\n        this.waitTimeMillsInTransactionQueue = waitTimeMillsInTransactionQueue;\n    }\n\n    public String getMsgTraceTopicName() {\n        return msgTraceTopicName;\n    }\n\n    public void setMsgTraceTopicName(String msgTraceTopicName) {\n        this.msgTraceTopicName = msgTraceTopicName;\n    }\n\n    public boolean isTraceTopicEnable() {\n        return traceTopicEnable;\n    }\n\n    public void setTraceTopicEnable(boolean traceTopicEnable) {\n        this.traceTopicEnable = traceTopicEnable;\n    }\n\n    public boolean isAclEnable() {\n        return aclEnable;\n    }\n\n    public void setAclEnable(boolean aclEnable) {\n        this.aclEnable = aclEnable;\n    }\n\n    public boolean isStoreReplyMessageEnable() {\n        return storeReplyMessageEnable;\n    }\n\n    public void setStoreReplyMessageEnable(boolean storeReplyMessageEnable) {\n        this.storeReplyMessageEnable = storeReplyMessageEnable;\n    }\n\n    public boolean isEnableDetailStat() {\n        return enableDetailStat;\n    }\n\n    public void setEnableDetailStat(boolean enableDetailStat) {\n        this.enableDetailStat = enableDetailStat;\n    }\n\n    public boolean isAutoDeleteUnusedStats() {\n        return autoDeleteUnusedStats;\n    }\n\n    public void setAutoDeleteUnusedStats(boolean autoDeleteUnusedStats) {\n        this.autoDeleteUnusedStats = autoDeleteUnusedStats;\n    }\n\n    public long getLoadBalancePollNameServerInterval() {\n        return loadBalancePollNameServerInterval;\n    }\n\n    public void setLoadBalancePollNameServerInterval(long loadBalancePollNameServerInterval) {\n        this.loadBalancePollNameServerInterval = loadBalancePollNameServerInterval;\n    }\n\n    public int getCleanOfflineBrokerInterval() {\n        return cleanOfflineBrokerInterval;\n    }\n\n    public void setCleanOfflineBrokerInterval(int cleanOfflineBrokerInterval) {\n        this.cleanOfflineBrokerInterval = cleanOfflineBrokerInterval;\n    }\n\n    public int getLoadBalanceProcessorThreadPoolNums() {\n        return loadBalanceProcessorThreadPoolNums;\n    }\n\n    public void setLoadBalanceProcessorThreadPoolNums(int loadBalanceProcessorThreadPoolNums) {\n        this.loadBalanceProcessorThreadPoolNums = loadBalanceProcessorThreadPoolNums;\n    }\n\n    public boolean isServerLoadBalancerEnable() {\n        return serverLoadBalancerEnable;\n    }\n\n    public void setServerLoadBalancerEnable(boolean serverLoadBalancerEnable) {\n        this.serverLoadBalancerEnable = serverLoadBalancerEnable;\n    }\n\n    public MessageRequestMode getDefaultMessageRequestMode() {\n        return defaultMessageRequestMode;\n    }\n\n    public void setDefaultMessageRequestMode(String defaultMessageRequestMode) {\n        this.defaultMessageRequestMode = MessageRequestMode.valueOf(defaultMessageRequestMode);\n    }\n\n    public int getDefaultPopShareQueueNum() {\n        return defaultPopShareQueueNum;\n    }\n\n    public void setDefaultPopShareQueueNum(int defaultPopShareQueueNum) {\n        this.defaultPopShareQueueNum = defaultPopShareQueueNum;\n    }\n\n    public long getForwardTimeout() {\n        return forwardTimeout;\n    }\n\n    public void setForwardTimeout(long timeout) {\n        this.forwardTimeout = timeout;\n    }\n\n    public int getBrokerHeartbeatInterval() {\n        return brokerHeartbeatInterval;\n    }\n\n    public void setBrokerHeartbeatInterval(int brokerHeartbeatInterval) {\n        this.brokerHeartbeatInterval = brokerHeartbeatInterval;\n    }\n\n    public long getBrokerNotActiveTimeoutMillis() {\n        return brokerNotActiveTimeoutMillis;\n    }\n\n    public void setBrokerNotActiveTimeoutMillis(long brokerNotActiveTimeoutMillis) {\n        this.brokerNotActiveTimeoutMillis = brokerNotActiveTimeoutMillis;\n    }\n\n    public boolean isEnableNetWorkFlowControl() {\n        return enableNetWorkFlowControl;\n    }\n\n    public void setEnableNetWorkFlowControl(boolean enableNetWorkFlowControl) {\n        this.enableNetWorkFlowControl = enableNetWorkFlowControl;\n    }\n\n    public boolean isEnableNotifyAfterPopOrderLockRelease() {\n        return enableNotifyAfterPopOrderLockRelease;\n    }\n\n    public void setEnableNotifyAfterPopOrderLockRelease(boolean enableNotifyAfterPopOrderLockRelease) {\n        this.enableNotifyAfterPopOrderLockRelease = enableNotifyAfterPopOrderLockRelease;\n    }\n\n    public boolean isInitPopOffsetByCheckMsgInMem() {\n        return initPopOffsetByCheckMsgInMem;\n    }\n\n    public void setInitPopOffsetByCheckMsgInMem(boolean initPopOffsetByCheckMsgInMem) {\n        this.initPopOffsetByCheckMsgInMem = initPopOffsetByCheckMsgInMem;\n    }\n\n    public boolean isRetrieveMessageFromPopRetryTopicV1() {\n        return retrieveMessageFromPopRetryTopicV1;\n    }\n\n    public void setRetrieveMessageFromPopRetryTopicV1(boolean retrieveMessageFromPopRetryTopicV1) {\n        this.retrieveMessageFromPopRetryTopicV1 = retrieveMessageFromPopRetryTopicV1;\n    }\n\n    public boolean isEnableRetryTopicV2() {\n        return enableRetryTopicV2;\n    }\n\n    public void setEnableRetryTopicV2(boolean enableRetryTopicV2) {\n        this.enableRetryTopicV2 = enableRetryTopicV2;\n    }\n\n    public boolean isRealTimeNotifyConsumerChange() {\n        return realTimeNotifyConsumerChange;\n    }\n\n    public void setRealTimeNotifyConsumerChange(boolean realTimeNotifyConsumerChange) {\n        this.realTimeNotifyConsumerChange = realTimeNotifyConsumerChange;\n    }\n\n    public boolean isEnableSlaveActingMaster() {\n        return enableSlaveActingMaster;\n    }\n\n    public void setEnableSlaveActingMaster(boolean enableSlaveActingMaster) {\n        this.enableSlaveActingMaster = enableSlaveActingMaster;\n    }\n\n    public boolean isEnableRemoteEscape() {\n        return enableRemoteEscape;\n    }\n\n    public void setEnableRemoteEscape(boolean enableRemoteEscape) {\n        this.enableRemoteEscape = enableRemoteEscape;\n    }\n\n    public boolean isSkipPreOnline() {\n        return skipPreOnline;\n    }\n\n    public void setSkipPreOnline(boolean skipPreOnline) {\n        this.skipPreOnline = skipPreOnline;\n    }\n\n    public boolean isAsyncSendEnable() {\n        return asyncSendEnable;\n    }\n\n    public void setAsyncSendEnable(boolean asyncSendEnable) {\n        this.asyncSendEnable = asyncSendEnable;\n    }\n\n    public long getConsumerOffsetUpdateVersionStep() {\n        return consumerOffsetUpdateVersionStep;\n    }\n\n    public void setConsumerOffsetUpdateVersionStep(long consumerOffsetUpdateVersionStep) {\n        this.consumerOffsetUpdateVersionStep = consumerOffsetUpdateVersionStep;\n    }\n\n    public long getDelayOffsetUpdateVersionStep() {\n        return delayOffsetUpdateVersionStep;\n    }\n\n    public void setDelayOffsetUpdateVersionStep(long delayOffsetUpdateVersionStep) {\n        this.delayOffsetUpdateVersionStep = delayOffsetUpdateVersionStep;\n    }\n\n    public int getCommercialSizePerMsg() {\n        return commercialSizePerMsg;\n    }\n\n    public void setCommercialSizePerMsg(int commercialSizePerMsg) {\n        this.commercialSizePerMsg = commercialSizePerMsg;\n    }\n\n    public long getWaitTimeMillsInAckQueue() {\n        return waitTimeMillsInAckQueue;\n    }\n\n    public void setWaitTimeMillsInAckQueue(long waitTimeMillsInAckQueue) {\n        this.waitTimeMillsInAckQueue = waitTimeMillsInAckQueue;\n    }\n\n    public boolean isRejectPullConsumerEnable() {\n        return rejectPullConsumerEnable;\n    }\n\n    public void setRejectPullConsumerEnable(boolean rejectPullConsumerEnable) {\n        this.rejectPullConsumerEnable = rejectPullConsumerEnable;\n    }\n\n    public boolean isAccountStatsEnable() {\n        return accountStatsEnable;\n    }\n\n    public void setAccountStatsEnable(boolean accountStatsEnable) {\n        this.accountStatsEnable = accountStatsEnable;\n    }\n\n    public boolean isAccountStatsPrintZeroValues() {\n        return accountStatsPrintZeroValues;\n    }\n\n    public void setAccountStatsPrintZeroValues(boolean accountStatsPrintZeroValues) {\n        this.accountStatsPrintZeroValues = accountStatsPrintZeroValues;\n    }\n\n    public boolean isLockInStrictMode() {\n        return lockInStrictMode;\n    }\n\n    public void setLockInStrictMode(boolean lockInStrictMode) {\n        this.lockInStrictMode = lockInStrictMode;\n    }\n\n    public boolean isIsolateLogEnable() {\n        return isolateLogEnable;\n    }\n\n    public void setIsolateLogEnable(boolean isolateLogEnable) {\n        this.isolateLogEnable = isolateLogEnable;\n    }\n\n    public boolean isCompatibleWithOldNameSrv() {\n        return compatibleWithOldNameSrv;\n    }\n\n    public void setCompatibleWithOldNameSrv(boolean compatibleWithOldNameSrv) {\n        this.compatibleWithOldNameSrv = compatibleWithOldNameSrv;\n    }\n\n    public boolean isEnableControllerMode() {\n        return enableControllerMode;\n    }\n\n    public void setEnableControllerMode(boolean enableControllerMode) {\n        this.enableControllerMode = enableControllerMode;\n    }\n\n    public String getControllerAddr() {\n        return controllerAddr;\n    }\n\n    public void setControllerAddr(String controllerAddr) {\n        this.controllerAddr = controllerAddr;\n    }\n\n    public boolean isFetchControllerAddrByDnsLookup() {\n        return fetchControllerAddrByDnsLookup;\n    }\n\n    public void setFetchControllerAddrByDnsLookup(boolean fetchControllerAddrByDnsLookup) {\n        this.fetchControllerAddrByDnsLookup = fetchControllerAddrByDnsLookup;\n    }\n\n    public long getSyncBrokerMetadataPeriod() {\n        return syncBrokerMetadataPeriod;\n    }\n\n    public void setSyncBrokerMetadataPeriod(long syncBrokerMetadataPeriod) {\n        this.syncBrokerMetadataPeriod = syncBrokerMetadataPeriod;\n    }\n\n    public long getCheckSyncStateSetPeriod() {\n        return checkSyncStateSetPeriod;\n    }\n\n    public void setCheckSyncStateSetPeriod(long checkSyncStateSetPeriod) {\n        this.checkSyncStateSetPeriod = checkSyncStateSetPeriod;\n    }\n\n    public long getSyncControllerMetadataPeriod() {\n        return syncControllerMetadataPeriod;\n    }\n\n    public void setSyncControllerMetadataPeriod(long syncControllerMetadataPeriod) {\n        this.syncControllerMetadataPeriod = syncControllerMetadataPeriod;\n    }\n\n    public int getBrokerElectionPriority() {\n        return brokerElectionPriority;\n    }\n\n    public void setBrokerElectionPriority(int brokerElectionPriority) {\n        this.brokerElectionPriority = brokerElectionPriority;\n    }\n\n    public long getControllerHeartBeatTimeoutMills() {\n        return controllerHeartBeatTimeoutMills;\n    }\n\n    public void setControllerHeartBeatTimeoutMills(long controllerHeartBeatTimeoutMills) {\n        this.controllerHeartBeatTimeoutMills = controllerHeartBeatTimeoutMills;\n    }\n\n    public boolean isRecoverConcurrently() {\n        return recoverConcurrently;\n    }\n\n    public void setRecoverConcurrently(boolean recoverConcurrently) {\n        this.recoverConcurrently = recoverConcurrently;\n    }\n\n    public int getRecoverThreadPoolNums() {\n        return recoverThreadPoolNums;\n    }\n\n    public void setRecoverThreadPoolNums(int recoverThreadPoolNums) {\n        this.recoverThreadPoolNums = recoverThreadPoolNums;\n    }\n\n    public boolean isFetchNameSrvAddrByDnsLookup() {\n        return fetchNameSrvAddrByDnsLookup;\n    }\n\n    public void setFetchNameSrvAddrByDnsLookup(boolean fetchNameSrvAddrByDnsLookup) {\n        this.fetchNameSrvAddrByDnsLookup = fetchNameSrvAddrByDnsLookup;\n    }\n\n    public boolean isUseServerSideResetOffset() {\n        return useServerSideResetOffset;\n    }\n\n    public void setUseServerSideResetOffset(boolean useServerSideResetOffset) {\n        this.useServerSideResetOffset = useServerSideResetOffset;\n    }\n\n    public boolean isEnableBroadcastOffsetStore() {\n        return enableBroadcastOffsetStore;\n    }\n\n    public void setEnableBroadcastOffsetStore(boolean enableBroadcastOffsetStore) {\n        this.enableBroadcastOffsetStore = enableBroadcastOffsetStore;\n    }\n\n    public long getBroadcastOffsetExpireSecond() {\n        return broadcastOffsetExpireSecond;\n    }\n\n    public void setBroadcastOffsetExpireSecond(long broadcastOffsetExpireSecond) {\n        this.broadcastOffsetExpireSecond = broadcastOffsetExpireSecond;\n    }\n\n    public long getBroadcastOffsetExpireMaxSecond() {\n        return broadcastOffsetExpireMaxSecond;\n    }\n\n    public void setBroadcastOffsetExpireMaxSecond(long broadcastOffsetExpireMaxSecond) {\n        this.broadcastOffsetExpireMaxSecond = broadcastOffsetExpireMaxSecond;\n    }\n\n    public MetricsExporterType getMetricsExporterType() {\n        return metricsExporterType;\n    }\n\n    public void setMetricsExporterType(MetricsExporterType metricsExporterType) {\n        this.metricsExporterType = metricsExporterType;\n    }\n\n    public void setMetricsExporterType(int metricsExporterType) {\n        this.metricsExporterType = MetricsExporterType.valueOf(metricsExporterType);\n    }\n\n    public void setMetricsExporterType(String metricsExporterType) {\n        this.metricsExporterType = MetricsExporterType.valueOf(metricsExporterType);\n    }\n\n    public int getMetricsOtelCardinalityLimit() {\n        return metricsOtelCardinalityLimit;\n    }\n\n    public void setMetricsOtelCardinalityLimit(int metricsOtelCardinalityLimit) {\n        this.metricsOtelCardinalityLimit = metricsOtelCardinalityLimit;\n    }\n\n    public String getMetricsGrpcExporterTarget() {\n        return metricsGrpcExporterTarget;\n    }\n\n    public void setMetricsGrpcExporterTarget(String metricsGrpcExporterTarget) {\n        this.metricsGrpcExporterTarget = metricsGrpcExporterTarget;\n    }\n\n    public String getMetricsGrpcExporterHeader() {\n        return metricsGrpcExporterHeader;\n    }\n\n    public void setMetricsGrpcExporterHeader(String metricsGrpcExporterHeader) {\n        this.metricsGrpcExporterHeader = metricsGrpcExporterHeader;\n    }\n\n    public long getMetricGrpcExporterTimeOutInMills() {\n        return metricGrpcExporterTimeOutInMills;\n    }\n\n    public void setMetricGrpcExporterTimeOutInMills(long metricGrpcExporterTimeOutInMills) {\n        this.metricGrpcExporterTimeOutInMills = metricGrpcExporterTimeOutInMills;\n    }\n\n    public long getMetricGrpcExporterIntervalInMills() {\n        return metricGrpcExporterIntervalInMills;\n    }\n\n    public void setMetricGrpcExporterIntervalInMills(long metricGrpcExporterIntervalInMills) {\n        this.metricGrpcExporterIntervalInMills = metricGrpcExporterIntervalInMills;\n    }\n\n    public long getMetricLoggingExporterIntervalInMills() {\n        return metricLoggingExporterIntervalInMills;\n    }\n\n    public void setMetricLoggingExporterIntervalInMills(long metricLoggingExporterIntervalInMills) {\n        this.metricLoggingExporterIntervalInMills = metricLoggingExporterIntervalInMills;\n    }\n\n    public String getMetricsLabel() {\n        return metricsLabel;\n    }\n\n    public void setMetricsLabel(String metricsLabel) {\n        this.metricsLabel = metricsLabel;\n    }\n\n    public boolean isMetricsInDelta() {\n        return metricsInDelta;\n    }\n\n    public void setMetricsInDelta(boolean metricsInDelta) {\n        this.metricsInDelta = metricsInDelta;\n    }\n\n    public int getMetricsPromExporterPort() {\n        return metricsPromExporterPort;\n    }\n\n    public void setMetricsPromExporterPort(int metricsPromExporterPort) {\n        this.metricsPromExporterPort = metricsPromExporterPort;\n    }\n\n    public String getMetricsPromExporterHost() {\n        return metricsPromExporterHost;\n    }\n\n    public void setMetricsPromExporterHost(String metricsPromExporterHost) {\n        this.metricsPromExporterHost = metricsPromExporterHost;\n    }\n\n    public int getTransactionOpMsgMaxSize() {\n        return transactionOpMsgMaxSize;\n    }\n\n    public void setTransactionOpMsgMaxSize(int transactionOpMsgMaxSize) {\n        this.transactionOpMsgMaxSize = transactionOpMsgMaxSize;\n    }\n\n    public int getTransactionOpBatchInterval() {\n        return transactionOpBatchInterval;\n    }\n\n    public void setTransactionOpBatchInterval(int transactionOpBatchInterval) {\n        this.transactionOpBatchInterval = transactionOpBatchInterval;\n    }\n\n    public long getChannelExpiredTimeout() {\n        return channelExpiredTimeout;\n    }\n\n    public void setChannelExpiredTimeout(long channelExpiredTimeout) {\n        this.channelExpiredTimeout = channelExpiredTimeout;\n    }\n\n    public long getSubscriptionExpiredTimeout() {\n        return subscriptionExpiredTimeout;\n    }\n\n    public void setSubscriptionExpiredTimeout(long subscriptionExpiredTimeout) {\n        this.subscriptionExpiredTimeout = subscriptionExpiredTimeout;\n    }\n\n    public boolean isValidateSystemTopicWhenUpdateTopic() {\n        return validateSystemTopicWhenUpdateTopic;\n    }\n\n    public void setValidateSystemTopicWhenUpdateTopic(boolean validateSystemTopicWhenUpdateTopic) {\n        this.validateSystemTopicWhenUpdateTopic = validateSystemTopicWhenUpdateTopic;\n    }\n\n    public boolean isEstimateAccumulation() {\n        return estimateAccumulation;\n    }\n\n    public void setEstimateAccumulation(boolean estimateAccumulation) {\n        this.estimateAccumulation = estimateAccumulation;\n    }\n\n    public boolean isColdCtrStrategyEnable() {\n        return coldCtrStrategyEnable;\n    }\n\n    public void setColdCtrStrategyEnable(boolean coldCtrStrategyEnable) {\n        this.coldCtrStrategyEnable = coldCtrStrategyEnable;\n    }\n\n    public boolean isUsePIDColdCtrStrategy() {\n        return usePIDColdCtrStrategy;\n    }\n\n    public void setUsePIDColdCtrStrategy(boolean usePIDColdCtrStrategy) {\n        this.usePIDColdCtrStrategy = usePIDColdCtrStrategy;\n    }\n\n    public long getCgColdReadThreshold() {\n        return cgColdReadThreshold;\n    }\n\n    public void setCgColdReadThreshold(long cgColdReadThreshold) {\n        this.cgColdReadThreshold = cgColdReadThreshold;\n    }\n\n    public long getGlobalColdReadThreshold() {\n        return globalColdReadThreshold;\n    }\n\n    public void setGlobalColdReadThreshold(long globalColdReadThreshold) {\n        this.globalColdReadThreshold = globalColdReadThreshold;\n    }\n\n    public boolean isUseStaticSubscription() {\n        return useStaticSubscription;\n    }\n\n    public void setUseStaticSubscription(boolean useStaticSubscription) {\n        this.useStaticSubscription = useStaticSubscription;\n    }\n    \n    public long getFetchNamesrvAddrInterval() {\n        return fetchNamesrvAddrInterval;\n    }\n    \n    public void setFetchNamesrvAddrInterval(final long fetchNamesrvAddrInterval) {\n        this.fetchNamesrvAddrInterval = fetchNamesrvAddrInterval;\n    }\n\n    public boolean isPopResponseReturnActualRetryTopic() {\n        return popResponseReturnActualRetryTopic;\n    }\n\n    public void setPopResponseReturnActualRetryTopic(boolean popResponseReturnActualRetryTopic) {\n        this.popResponseReturnActualRetryTopic = popResponseReturnActualRetryTopic;\n    }\n\n    public boolean isEnableSingleTopicRegister() {\n        return enableSingleTopicRegister;\n    }\n\n    public void setEnableSingleTopicRegister(boolean enableSingleTopicRegister) {\n        this.enableSingleTopicRegister = enableSingleTopicRegister;\n    }\n\n    public boolean isEnableMixedMessageType() {\n        return enableMixedMessageType;\n    }\n\n    public void setEnableMixedMessageType(boolean enableMixedMessageType) {\n        this.enableMixedMessageType = enableMixedMessageType;\n    }\n\n    public boolean isEnableSplitRegistration() {\n        return enableSplitRegistration;\n    }\n\n    public void setEnableSplitRegistration(boolean enableSplitRegistration) {\n        this.enableSplitRegistration = enableSplitRegistration;\n    }\n\n    public int getSplitRegistrationSize() {\n        return splitRegistrationSize;\n    }\n\n    public void setSplitRegistrationSize(int splitRegistrationSize) {\n        this.splitRegistrationSize = splitRegistrationSize;\n    }\n\n    public long getTransactionMetricFlushInterval() {\n        return transactionMetricFlushInterval;\n    }\n\n    public void setTransactionMetricFlushInterval(long transactionMetricFlushInterval) {\n        this.transactionMetricFlushInterval = transactionMetricFlushInterval;\n    }\n\n    public long getPopInflightMessageThreshold() {\n        return popInflightMessageThreshold;\n    }\n\n    public void setPopInflightMessageThreshold(long popInflightMessageThreshold) {\n        this.popInflightMessageThreshold = popInflightMessageThreshold;\n    }\n\n    public boolean isEnablePopMessageThreshold() {\n        return enablePopMessageThreshold;\n    }\n\n    public void setEnablePopMessageThreshold(boolean enablePopMessageThreshold) {\n        this.enablePopMessageThreshold = enablePopMessageThreshold;\n    }\n}\n",
            "role": "user"
        },
        {
            "content": "//proxy/src/main/java/org/apache/rocketmq/proxy/config/ProxyConfig.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.rocketmq.proxy.config;\n\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.time.Duration;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentSkipListMap;\nimport java.util.concurrent.TimeUnit;\nimport java.util.stream.Collectors;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.rocketmq.common.MixAll;\nimport org.apache.rocketmq.common.constant.LoggerName;\nimport org.apache.rocketmq.common.metrics.MetricsExporterType;\nimport org.apache.rocketmq.common.utils.NetworkUtil;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\nimport org.apache.rocketmq.proxy.ProxyMode;\nimport org.apache.rocketmq.proxy.common.ProxyException;\nimport org.apache.rocketmq.proxy.common.ProxyExceptionCode;\n\npublic class ProxyConfig implements ConfigFile {\n    private final static Logger log = LoggerFactory.getLogger(LoggerName.PROXY_LOGGER_NAME);\n    public final static String DEFAULT_CONFIG_FILE_NAME = \"rmq-proxy.json\";\n    private static final int PROCESSOR_NUMBER = Runtime.getRuntime().availableProcessors();\n    private static final String DEFAULT_CLUSTER_NAME = \"DefaultCluster\";\n\n    private static String localHostName;\n\n    static {\n        try {\n            localHostName = InetAddress.getLocalHost().getHostName();\n        } catch (UnknownHostException e) {\n            log.error(\"Failed to obtain the host name\", e);\n        }\n    }\n\n    private String rocketMQClusterName = DEFAULT_CLUSTER_NAME;\n    private String proxyClusterName = DEFAULT_CLUSTER_NAME;\n    private String proxyName = StringUtils.isEmpty(localHostName) ? \"DEFAULT_PROXY\" : localHostName;\n\n    private String localServeAddr = \"\";\n\n    private String heartbeatSyncerTopicClusterName = \"\";\n    private int heartbeatSyncerThreadPoolNums = 4;\n    private int heartbeatSyncerThreadPoolQueueCapacity = 100;\n\n    private String heartbeatSyncerTopicName = \"DefaultHeartBeatSyncerTopic\";\n\n    /**\n     * configuration for ThreadPoolMonitor\n     */\n    private boolean enablePrintJstack = true;\n    private long printJstackInMillis = Duration.ofSeconds(60).toMillis();\n    private long printThreadPoolStatusInMillis = Duration.ofSeconds(3).toMillis();\n\n    private String namesrvAddr = System.getProperty(MixAll.NAMESRV_ADDR_PROPERTY, System.getenv(MixAll.NAMESRV_ADDR_ENV));\n    private String namesrvDomain = \"\";\n    private String namesrvDomainSubgroup = \"\";\n    /**\n     * TLS\n     */\n    private boolean tlsTestModeEnable = true;\n    private String tlsKeyPath = ConfigurationManager.getProxyHome() + \"/conf/tls/rocketmq.key\";\n    private String tlsCertPath = ConfigurationManager.getProxyHome() + \"/conf/tls/rocketmq.crt\";\n    /**\n     * gRPC\n     */\n    private String proxyMode = ProxyMode.CLUSTER.name();\n    private Integer grpcServerPort = 8081;\n    private long grpcShutdownTimeSeconds = 30;\n    private int grpcBossLoopNum = 1;\n    private int grpcWorkerLoopNum = PROCESSOR_NUMBER * 2;\n    private boolean enableGrpcEpoll = false;\n    private int grpcThreadPoolNums = 16 + PROCESSOR_NUMBER * 2;\n    private int grpcThreadPoolQueueCapacity = 100000;\n    private String brokerConfigPath = ConfigurationManager.getProxyHome() + \"/conf/broker.conf\";\n    /**\n     * gRPC max message size\n     * 130M = 4M * 32 messages + 2M attributes\n     */\n    private int grpcMaxInboundMessageSize = 130 * 1024 * 1024;\n    /**\n     * max message body size, 0 or negative number means no limit for proxy\n     */\n    private int maxMessageSize = 4 * 1024 * 1024;\n    /**\n     * max user property size, 0 or negative number means no limit for proxy\n     */\n    private int maxUserPropertySize = 16 * 1024;\n    private int userPropertyMaxNum = 128;\n\n    /**\n     * max message group size, 0 or negative number means no limit for proxy\n     */\n    private int maxMessageGroupSize = 64;\n\n    /**\n     * When a message pops, the message is invisible by default\n     */\n    private long defaultInvisibleTimeMills = Duration.ofSeconds(60).toMillis();\n    private long minInvisibleTimeMillsForRecv = Duration.ofSeconds(10).toMillis();\n    private long maxInvisibleTimeMills = Duration.ofHours(12).toMillis();\n    private long maxDelayTimeMills = Duration.ofDays(1).toMillis();\n    private long maxTransactionRecoverySecond = Duration.ofHours(1).getSeconds();\n    private boolean enableTopicMessageTypeCheck = true;\n\n    private int grpcClientProducerMaxAttempts = 3;\n    private long grpcClientProducerBackoffInitialMillis = 10;\n    private long grpcClientProducerBackoffMaxMillis = 1000;\n    private int grpcClientProducerBackoffMultiplier = 2;\n    private long grpcClientConsumerMinLongPollingTimeoutMillis = Duration.ofSeconds(5).toMillis();\n    private long grpcClientConsumerMaxLongPollingTimeoutMillis = Duration.ofSeconds(20).toMillis();\n    private int grpcClientConsumerLongPollingBatchSize = 32;\n    private long grpcClientIdleTimeMills = Duration.ofSeconds(120).toMillis();\n\n    private int channelExpiredInSeconds = 60;\n    private int contextExpiredInSeconds = 30;\n\n    private int rocketmqMQClientNum = 6;\n\n    private long grpcProxyRelayRequestTimeoutInSeconds = 5;\n    private int grpcProducerThreadPoolNums = PROCESSOR_NUMBER;\n    private int grpcProducerThreadQueueCapacity = 10000;\n    private int grpcConsumerThreadPoolNums = PROCESSOR_NUMBER;\n    private int grpcConsumerThreadQueueCapacity = 10000;\n    private int grpcRouteThreadPoolNums = PROCESSOR_NUMBER;\n    private int grpcRouteThreadQueueCapacity = 10000;\n    private int grpcClientManagerThreadPoolNums = PROCESSOR_NUMBER;\n    private int grpcClientManagerThreadQueueCapacity = 10000;\n    private int grpcTransactionThreadPoolNums = PROCESSOR_NUMBER;\n    private int grpcTransactionThreadQueueCapacity = 10000;\n\n    private int producerProcessorThreadPoolNums = PROCESSOR_NUMBER;\n    private int producerProcessorThreadPoolQueueCapacity = 10000;\n    private int consumerProcessorThreadPoolNums = PROCESSOR_NUMBER;\n    private int consumerProcessorThreadPoolQueueCapacity = 10000;\n\n    private boolean useEndpointPortFromRequest = false;\n\n    private int topicRouteServiceCacheExpiredSeconds = 300;\n    private int topicRouteServiceCacheRefreshSeconds = 20;\n    private int topicRouteServiceCacheMaxNum = 20000;\n    private int topicRouteServiceThreadPoolNums = PROCESSOR_NUMBER;\n    private int topicRouteServiceThreadPoolQueueCapacity = 5000;\n    private int topicConfigCacheExpiredSeconds = 300;\n    private int topicConfigCacheRefreshSeconds = 20;\n    private int topicConfigCacheMaxNum = 20000;\n    private int subscriptionGroupConfigCacheExpiredSeconds = 300;\n    private int subscriptionGroupConfigCacheRefreshSeconds = 20;\n    private int subscriptionGroupConfigCacheMaxNum = 20000;\n    private int userCacheExpiredSeconds = 300;\n    private int userCacheRefreshSeconds = 20;\n    private int userCacheMaxNum = 20000;\n    private int aclCacheExpiredSeconds = 300;\n    private int aclCacheRefreshSeconds = 20;\n    private int aclCacheMaxNum = 20000;\n    private int metadataThreadPoolNums = 3;\n    private int metadataThreadPoolQueueCapacity = 100000;\n\n    private int transactionHeartbeatThreadPoolNums = 20;\n    private int transactionHeartbeatThreadPoolQueueCapacity = 200;\n    private int transactionHeartbeatPeriodSecond = 20;\n    private int transactionHeartbeatBatchNum = 100;\n    private long transactionDataExpireScanPeriodMillis = Duration.ofSeconds(10).toMillis();\n    private long transactionDataMaxWaitClearMillis = Duration.ofSeconds(30).toMillis();\n    private long transactionDataExpireMillis = Duration.ofSeconds(30).toMillis();\n    private int transactionDataMaxNum = 15;\n\n    private long longPollingReserveTimeInMillis = 100;\n\n    private long invisibleTimeMillisWhenClear = 1000L;\n    private boolean enableProxyAutoRenew = true;\n    private int maxRenewRetryTimes = 3;\n    private int renewThreadPoolNums = 2;\n    private int renewMaxThreadPoolNums = 4;\n    private int renewThreadPoolQueueCapacity = 300;\n    private long lockTimeoutMsInHandleGroup = TimeUnit.SECONDS.toMillis(3);\n    private long renewAheadTimeMillis = TimeUnit.SECONDS.toMillis(10);\n    private long renewMaxTimeMillis = TimeUnit.HOURS.toMillis(3);\n    private long renewSchedulePeriodMillis = TimeUnit.SECONDS.toMillis(5);\n\n    private boolean enableACL = false;\n\n    private boolean enableAclRpcHookForClusterMode = false;\n\n    private boolean useDelayLevel = false;\n    private String messageDelayLevel = \"1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h\";\n    private transient ConcurrentSkipListMap<Integer /* level */, Long/* delay timeMillis */> delayLevelTable = new ConcurrentSkipListMap<>();\n\n    private String metricCollectorMode = MetricCollectorMode.OFF.getModeString();\n    // Example address: 127.0.0.1:1234\n    private String metricCollectorAddress = \"\";\n\n    private String regionId = \"\";\n\n    private boolean traceOn = false;\n\n    private MetricsExporterType metricsExporterType = MetricsExporterType.DISABLE;\n\n    private String metricsGrpcExporterTarget = \"\";\n    private String metricsGrpcExporterHeader = \"\";\n    private long metricGrpcExporterTimeOutInMills = 3 * 1000;\n    private long metricGrpcExporterIntervalInMills = 60 * 1000;\n    private long metricLoggingExporterIntervalInMills = 10 * 1000;\n\n    private int metricsPromExporterPort = 5557;\n    private String metricsPromExporterHost = \"\";\n\n    // Label pairs in CSV. Each label follows pattern of Key:Value. eg: instance_id:xxx,uid:xxx\n    private String metricsLabel = \"\";\n\n    private boolean metricsInDelta = false;\n\n    private long channelExpiredTimeout = 1000 * 120;\n\n    // remoting\n    private boolean enableRemotingLocalProxyGrpc = true;\n    private int localProxyConnectTimeoutMs = 3000;\n    private String remotingAccessAddr = \"\";\n    private int remotingListenPort = 8080;\n\n    // related to proxy's send strategy in cluster mode.\n    private boolean sendLatencyEnable = false;\n    private boolean startDetectorEnable = false;\n    private int detectTimeout = 200;\n    private int detectInterval = 2 * 1000;\n\n    private int remotingHeartbeatThreadPoolNums = 2 * PROCESSOR_NUMBER;\n    private int remotingTopicRouteThreadPoolNums = 2 * PROCESSOR_NUMBER;\n    private int remotingSendMessageThreadPoolNums = 4 * PROCESSOR_NUMBER;\n    private int remotingPullMessageThreadPoolNums = 4 * PROCESSOR_NUMBER;\n    private int remotingUpdateOffsetThreadPoolNums = 4 * PROCESSOR_NUMBER;\n    private int remotingDefaultThreadPoolNums = 4 * PROCESSOR_NUMBER;\n\n    private int remotingHeartbeatThreadPoolQueueCapacity = 50000;\n    private int remotingTopicRouteThreadPoolQueueCapacity = 50000;\n    private int remotingSendThreadPoolQueueCapacity = 10000;\n    private int remotingPullThreadPoolQueueCapacity = 50000;\n    private int remotingUpdateOffsetThreadPoolQueueCapacity = 10000;\n    private int remotingDefaultThreadPoolQueueCapacity = 50000;\n\n    private long remotingWaitTimeMillsInSendQueue = 3 * 1000;\n    private long remotingWaitTimeMillsInPullQueue = 5 * 1000;\n    private long remotingWaitTimeMillsInHeartbeatQueue = 31 * 1000;\n    private long remotingWaitTimeMillsInUpdateOffsetQueue = 3 * 1000;\n    private long remotingWaitTimeMillsInTopicRouteQueue = 3 * 1000;\n    private long remotingWaitTimeMillsInDefaultQueue = 3 * 1000;\n\n    private boolean enableBatchAck = false;\n\n    @Override\n    public void initData() {\n        parseDelayLevel();\n        if (StringUtils.isEmpty(localServeAddr)) {\n            this.localServeAddr = NetworkUtil.getLocalAddress();\n        }\n        if (StringUtils.isBlank(localServeAddr)) {\n            throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \"get local serve ip failed\");\n        }\n        if (StringUtils.isBlank(remotingAccessAddr)) {\n            this.remotingAccessAddr = this.localServeAddr;\n        }\n        if (StringUtils.isBlank(heartbeatSyncerTopicClusterName)) {\n            this.heartbeatSyncerTopicClusterName = this.rocketMQClusterName;\n        }\n    }\n\n    public int computeDelayLevel(long timeMillis) {\n        long intervalMillis = timeMillis - System.currentTimeMillis();\n        List<Map.Entry<Integer, Long>> sortedLevels = delayLevelTable.entrySet().stream().sorted(Comparator.comparingLong(Map.Entry::getValue)).collect(Collectors.toList());\n        for (Map.Entry<Integer, Long> entry : sortedLevels) {\n            if (entry.getValue() > intervalMillis) {\n                return entry.getKey();\n            }\n        }\n        return sortedLevels.get(sortedLevels.size() - 1).getKey();\n    }\n\n    public void parseDelayLevel() {\n        this.delayLevelTable = new ConcurrentSkipListMap<>();\n        Map<String, Long> timeUnitTable = new HashMap<>();\n        timeUnitTable.put(\"s\", 1000L);\n        timeUnitTable.put(\"m\", 1000L * 60);\n        timeUnitTable.put(\"h\", 1000L * 60 * 60);\n        timeUnitTable.put(\"d\", 1000L * 60 * 60 * 24);\n\n        String levelString = this.getMessageDelayLevel();\n        try {\n            String[] levelArray = levelString.split(\" \");\n            for (int i = 0; i < levelArray.length; i++) {\n                String value = levelArray[i];\n                String ch = value.substring(value.length() - 1);\n                Long tu = timeUnitTable.get(ch);\n\n                int level = i + 1;\n                long num = Long.parseLong(value.substring(0, value.length() - 1));\n                long delayTimeMillis = tu * num;\n                this.delayLevelTable.put(level, delayTimeMillis);\n            }\n        } catch (Exception e) {\n            log.error(\"parse delay level failed. messageDelayLevel:{}\", messageDelayLevel, e);\n        }\n    }\n\n    public String getRocketMQClusterName() {\n        return rocketMQClusterName;\n    }\n\n    public void setRocketMQClusterName(String rocketMQClusterName) {\n        this.rocketMQClusterName = rocketMQClusterName;\n    }\n\n    public String getProxyClusterName() {\n        return proxyClusterName;\n    }\n\n    public void setProxyClusterName(String proxyClusterName) {\n        this.proxyClusterName = proxyClusterName;\n    }\n\n    public String getProxyName() {\n        return proxyName;\n    }\n\n    public void setProxyName(String proxyName) {\n        this.proxyName = proxyName;\n    }\n\n    public String getLocalServeAddr() {\n        return localServeAddr;\n    }\n\n    public void setLocalServeAddr(String localServeAddr) {\n        this.localServeAddr = localServeAddr;\n    }\n\n    public String getHeartbeatSyncerTopicClusterName() {\n        return heartbeatSyncerTopicClusterName;\n    }\n\n    public void setHeartbeatSyncerTopicClusterName(String heartbeatSyncerTopicClusterName) {\n        this.heartbeatSyncerTopicClusterName = heartbeatSyncerTopicClusterName;\n    }\n\n    public int getHeartbeatSyncerThreadPoolNums() {\n        return heartbeatSyncerThreadPoolNums;\n    }\n\n    public void setHeartbeatSyncerThreadPoolNums(int heartbeatSyncerThreadPoolNums) {\n        this.heartbeatSyncerThreadPoolNums = heartbeatSyncerThreadPoolNums;\n    }\n\n    public int getHeartbeatSyncerThreadPoolQueueCapacity() {\n        return heartbeatSyncerThreadPoolQueueCapacity;\n    }\n\n    public void setHeartbeatSyncerThreadPoolQueueCapacity(int heartbeatSyncerThreadPoolQueueCapacity) {\n        this.heartbeatSyncerThreadPoolQueueCapacity = heartbeatSyncerThreadPoolQueueCapacity;\n    }\n\n    public String getHeartbeatSyncerTopicName() {\n        return heartbeatSyncerTopicName;\n    }\n\n    public void setHeartbeatSyncerTopicName(String heartbeatSyncerTopicName) {\n        this.heartbeatSyncerTopicName = heartbeatSyncerTopicName;\n    }\n\n    public boolean isEnablePrintJstack() {\n        return enablePrintJstack;\n    }\n\n    public void setEnablePrintJstack(boolean enablePrintJstack) {\n        this.enablePrintJstack = enablePrintJstack;\n    }\n\n    public long getPrintJstackInMillis() {\n        return printJstackInMillis;\n    }\n\n    public void setPrintJstackInMillis(long printJstackInMillis) {\n        this.printJstackInMillis = printJstackInMillis;\n    }\n\n    public long getPrintThreadPoolStatusInMillis() {\n        return printThreadPoolStatusInMillis;\n    }\n\n    public void setPrintThreadPoolStatusInMillis(long printThreadPoolStatusInMillis) {\n        this.printThreadPoolStatusInMillis = printThreadPoolStatusInMillis;\n    }\n\n    public String getNamesrvAddr() {\n        return namesrvAddr;\n    }\n\n    public void setNamesrvAddr(String namesrvAddr) {\n        this.namesrvAddr = namesrvAddr;\n    }\n\n    public String getNamesrvDomain() {\n        return namesrvDomain;\n    }\n\n    public void setNamesrvDomain(String namesrvDomain) {\n        this.namesrvDomain = namesrvDomain;\n    }\n\n    public String getNamesrvDomainSubgroup() {\n        return namesrvDomainSubgroup;\n    }\n\n    public void setNamesrvDomainSubgroup(String namesrvDomainSubgroup) {\n        this.namesrvDomainSubgroup = namesrvDomainSubgroup;\n    }\n\n    public String getProxyMode() {\n        return proxyMode;\n    }\n\n    public void setProxyMode(String proxyMode) {\n        this.proxyMode = proxyMode;\n    }\n\n    public Integer getGrpcServerPort() {\n        return grpcServerPort;\n    }\n\n    public void setGrpcServerPort(Integer grpcServerPort) {\n        this.grpcServerPort = grpcServerPort;\n    }\n\n    public long getGrpcShutdownTimeSeconds() {\n        return grpcShutdownTimeSeconds;\n    }\n\n    public void setGrpcShutdownTimeSeconds(long grpcShutdownTimeSeconds) {\n        this.grpcShutdownTimeSeconds = grpcShutdownTimeSeconds;\n    }\n\n    public boolean isUseEndpointPortFromRequest() {\n        return useEndpointPortFromRequest;\n    }\n\n    public void setUseEndpointPortFromRequest(boolean useEndpointPortFromRequest) {\n        this.useEndpointPortFromRequest = useEndpointPortFromRequest;\n    }\n\n    public boolean isTlsTestModeEnable() {\n        return tlsTestModeEnable;\n    }\n\n    public void setTlsTestModeEnable(boolean tlsTestModeEnable) {\n        this.tlsTestModeEnable = tlsTestModeEnable;\n    }\n\n    public String getTlsKeyPath() {\n        return tlsKeyPath;\n    }\n\n    public void setTlsKeyPath(String tlsKeyPath) {\n        this.tlsKeyPath = tlsKeyPath;\n    }\n\n    public String getTlsCertPath() {\n        return tlsCertPath;\n    }\n\n    public void setTlsCertPath(String tlsCertPath) {\n        this.tlsCertPath = tlsCertPath;\n    }\n\n    public int getGrpcBossLoopNum() {\n        return grpcBossLoopNum;\n    }\n\n    public void setGrpcBossLoopNum(int grpcBossLoopNum) {\n        this.grpcBossLoopNum = grpcBossLoopNum;\n    }\n\n    public int getGrpcWorkerLoopNum() {\n        return grpcWorkerLoopNum;\n    }\n\n    public void setGrpcWorkerLoopNum(int grpcWorkerLoopNum) {\n        this.grpcWorkerLoopNum = grpcWorkerLoopNum;\n    }\n\n    public boolean isEnableGrpcEpoll() {\n        return enableGrpcEpoll;\n    }\n\n    public void setEnableGrpcEpoll(boolean enableGrpcEpoll) {\n        this.enableGrpcEpoll = enableGrpcEpoll;\n    }\n\n    public int getGrpcThreadPoolNums() {\n        return grpcThreadPoolNums;\n    }\n\n    public void setGrpcThreadPoolNums(int grpcThreadPoolNums) {\n        this.grpcThreadPoolNums = grpcThreadPoolNums;\n    }\n\n    public int getGrpcThreadPoolQueueCapacity() {\n        return grpcThreadPoolQueueCapacity;\n    }\n\n    public void setGrpcThreadPoolQueueCapacity(int grpcThreadPoolQueueCapacity) {\n        this.grpcThreadPoolQueueCapacity = grpcThreadPoolQueueCapacity;\n    }\n\n    public String getBrokerConfigPath() {\n        return brokerConfigPath;\n    }\n\n    public void setBrokerConfigPath(String brokerConfigPath) {\n        this.brokerConfigPath = brokerConfigPath;\n    }\n\n    public int getGrpcMaxInboundMessageSize() {\n        return grpcMaxInboundMessageSize;\n    }\n\n    public void setGrpcMaxInboundMessageSize(int grpcMaxInboundMessageSize) {\n        this.grpcMaxInboundMessageSize = grpcMaxInboundMessageSize;\n    }\n\n    public int getMaxMessageSize() {\n        return maxMessageSize;\n    }\n\n    public void setMaxMessageSize(int maxMessageSize) {\n        this.maxMessageSize = maxMessageSize;\n    }\n\n    public int getMaxUserPropertySize() {\n        return maxUserPropertySize;\n    }\n\n    public void setMaxUserPropertySize(int maxUserPropertySize) {\n        this.maxUserPropertySize = maxUserPropertySize;\n    }\n\n    public int getUserPropertyMaxNum() {\n        return userPropertyMaxNum;\n    }\n\n    public void setUserPropertyMaxNum(int userPropertyMaxNum) {\n        this.userPropertyMaxNum = userPropertyMaxNum;\n    }\n\n    public int getMaxMessageGroupSize() {\n        return maxMessageGroupSize;\n    }\n\n    public void setMaxMessageGroupSize(int maxMessageGroupSize) {\n        this.maxMessageGroupSize = maxMessageGroupSize;\n    }\n\n    public long getMinInvisibleTimeMillsForRecv() {\n        return minInvisibleTimeMillsForRecv;\n    }\n\n    public void setMinInvisibleTimeMillsForRecv(long minInvisibleTimeMillsForRecv) {\n        this.minInvisibleTimeMillsForRecv = minInvisibleTimeMillsForRecv;\n    }\n\n    public long getDefaultInvisibleTimeMills() {\n        return defaultInvisibleTimeMills;\n    }\n\n    public void setDefaultInvisibleTimeMills(long defaultInvisibleTimeMills) {\n        this.defaultInvisibleTimeMills = defaultInvisibleTimeMills;\n    }\n\n    public long getMaxInvisibleTimeMills() {\n        return maxInvisibleTimeMills;\n    }\n\n    public void setMaxInvisibleTimeMills(long maxInvisibleTimeMills) {\n        this.maxInvisibleTimeMills = maxInvisibleTimeMills;\n    }\n\n    public long getMaxDelayTimeMills() {\n        return maxDelayTimeMills;\n    }\n\n    public void setMaxDelayTimeMills(long maxDelayTimeMills) {\n        this.maxDelayTimeMills = maxDelayTimeMills;\n    }\n\n    public long getMaxTransactionRecoverySecond() {\n        return maxTransactionRecoverySecond;\n    }\n\n    public void setMaxTransactionRecoverySecond(long maxTransactionRecoverySecond) {\n        this.maxTransactionRecoverySecond = maxTransactionRecoverySecond;\n    }\n\n    public int getGrpcClientProducerMaxAttempts() {\n        return grpcClientProducerMaxAttempts;\n    }\n\n    public void setGrpcClientProducerMaxAttempts(int grpcClientProducerMaxAttempts) {\n        this.grpcClientProducerMaxAttempts = grpcClientProducerMaxAttempts;\n    }\n\n    public long getGrpcClientProducerBackoffInitialMillis() {\n        return grpcClientProducerBackoffInitialMillis;\n    }\n\n    public void setGrpcClientProducerBackoffInitialMillis(long grpcClientProducerBackoffInitialMillis) {\n        this.grpcClientProducerBackoffInitialMillis = grpcClientProducerBackoffInitialMillis;\n    }\n\n    public long getGrpcClientProducerBackoffMaxMillis() {\n        return grpcClientProducerBackoffMaxMillis;\n    }\n\n    public void setGrpcClientProducerBackoffMaxMillis(long grpcClientProducerBackoffMaxMillis) {\n        this.grpcClientProducerBackoffMaxMillis = grpcClientProducerBackoffMaxMillis;\n    }\n\n    public int getGrpcClientProducerBackoffMultiplier() {\n        return grpcClientProducerBackoffMultiplier;\n    }\n\n    public void setGrpcClientProducerBackoffMultiplier(int grpcClientProducerBackoffMultiplier) {\n        this.grpcClientProducerBackoffMultiplier = grpcClientProducerBackoffMultiplier;\n    }\n\n    public long getGrpcClientConsumerMinLongPollingTimeoutMillis() {\n        return grpcClientConsumerMinLongPollingTimeoutMillis;\n    }\n\n    public void setGrpcClientConsumerMinLongPollingTimeoutMillis(long grpcClientConsumerMinLongPollingTimeoutMillis) {\n        this.grpcClientConsumerMinLongPollingTimeoutMillis = grpcClientConsumerMinLongPollingTimeoutMillis;\n    }\n\n    public long getGrpcClientConsumerMaxLongPollingTimeoutMillis() {\n        return grpcClientConsumerMaxLongPollingTimeoutMillis;\n    }\n\n    public void setGrpcClientConsumerMaxLongPollingTimeoutMillis(long grpcClientConsumerMaxLongPollingTimeoutMillis) {\n        this.grpcClientConsumerMaxLongPollingTimeoutMillis = grpcClientConsumerMaxLongPollingTimeoutMillis;\n    }\n\n    public int getGrpcClientConsumerLongPollingBatchSize() {\n        return grpcClientConsumerLongPollingBatchSize;\n    }\n\n    public void setGrpcClientConsumerLongPollingBatchSize(int grpcClientConsumerLongPollingBatchSize) {\n        this.grpcClientConsumerLongPollingBatchSize = grpcClientConsumerLongPollingBatchSize;\n    }\n\n    public int getChannelExpiredInSeconds() {\n        return channelExpiredInSeconds;\n    }\n\n    public void setChannelExpiredInSeconds(int channelExpiredInSeconds) {\n        this.channelExpiredInSeconds = channelExpiredInSeconds;\n    }\n\n    public int getContextExpiredInSeconds() {\n        return contextExpiredInSeconds;\n    }\n\n    public void setContextExpiredInSeconds(int contextExpiredInSeconds) {\n        this.contextExpiredInSeconds = contextExpiredInSeconds;\n    }\n\n    public int getRocketmqMQClientNum() {\n        return rocketmqMQClientNum;\n    }\n\n    public void setRocketmqMQClientNum(int rocketmqMQClientNum) {\n        this.rocketmqMQClientNum = rocketmqMQClientNum;\n    }\n\n    public long getGrpcProxyRelayRequestTimeoutInSeconds() {\n        return grpcProxyRelayRequestTimeoutInSeconds;\n    }\n\n    public void setGrpcProxyRelayRequestTimeoutInSeconds(long grpcProxyRelayRequestTimeoutInSeconds) {\n        this.grpcProxyRelayRequestTimeoutInSeconds = grpcProxyRelayRequestTimeoutInSeconds;\n    }\n\n    public int getGrpcProducerThreadPoolNums() {\n        return grpcProducerThreadPoolNums;\n    }\n\n    public void setGrpcProducerThreadPoolNums(int grpcProducerThreadPoolNums) {\n        this.grpcProducerThreadPoolNums = grpcProducerThreadPoolNums;\n    }\n\n    public int getGrpcProducerThreadQueueCapacity() {\n        return grpcProducerThreadQueueCapacity;\n    }\n\n    public void setGrpcProducerThreadQueueCapacity(int grpcProducerThreadQueueCapacity) {\n        this.grpcProducerThreadQueueCapacity = grpcProducerThreadQueueCapacity;\n    }\n\n    public int getGrpcConsumerThreadPoolNums() {\n        return grpcConsumerThreadPoolNums;\n    }\n\n    public void setGrpcConsumerThreadPoolNums(int grpcConsumerThreadPoolNums) {\n        this.grpcConsumerThreadPoolNums = grpcConsumerThreadPoolNums;\n    }\n\n    public int getGrpcConsumerThreadQueueCapacity() {\n        return grpcConsumerThreadQueueCapacity;\n    }\n\n    public void setGrpcConsumerThreadQueueCapacity(int grpcConsumerThreadQueueCapacity) {\n        this.grpcConsumerThreadQueueCapacity = grpcConsumerThreadQueueCapacity;\n    }\n\n    public int getGrpcRouteThreadPoolNums() {\n        return grpcRouteThreadPoolNums;\n    }\n\n    public void setGrpcRouteThreadPoolNums(int grpcRouteThreadPoolNums) {\n        this.grpcRouteThreadPoolNums = grpcRouteThreadPoolNums;\n    }\n\n    public int getGrpcRouteThreadQueueCapacity() {\n        return grpcRouteThreadQueueCapacity;\n    }\n\n    public void setGrpcRouteThreadQueueCapacity(int grpcRouteThreadQueueCapacity) {\n        this.grpcRouteThreadQueueCapacity = grpcRouteThreadQueueCapacity;\n    }\n\n    public int getGrpcClientManagerThreadPoolNums() {\n        return grpcClientManagerThreadPoolNums;\n    }\n\n    public void setGrpcClientManagerThreadPoolNums(int grpcClientManagerThreadPoolNums) {\n        this.grpcClientManagerThreadPoolNums = grpcClientManagerThreadPoolNums;\n    }\n\n    public int getGrpcClientManagerThreadQueueCapacity() {\n        return grpcClientManagerThreadQueueCapacity;\n    }\n\n    public void setGrpcClientManagerThreadQueueCapacity(int grpcClientManagerThreadQueueCapacity) {\n        this.grpcClientManagerThreadQueueCapacity = grpcClientManagerThreadQueueCapacity;\n    }\n\n    public int getGrpcTransactionThreadPoolNums() {\n        return grpcTransactionThreadPoolNums;\n    }\n\n    public void setGrpcTransactionThreadPoolNums(int grpcTransactionThreadPoolNums) {\n        this.grpcTransactionThreadPoolNums = grpcTransactionThreadPoolNums;\n    }\n\n    public int getGrpcTransactionThreadQueueCapacity() {\n        return grpcTransactionThreadQueueCapacity;\n    }\n\n    public void setGrpcTransactionThreadQueueCapacity(int grpcTransactionThreadQueueCapacity) {\n        this.grpcTransactionThreadQueueCapacity = grpcTransactionThreadQueueCapacity;\n    }\n\n    public int getProducerProcessorThreadPoolNums() {\n        return producerProcessorThreadPoolNums;\n    }\n\n    public void setProducerProcessorThreadPoolNums(int producerProcessorThreadPoolNums) {\n        this.producerProcessorThreadPoolNums = producerProcessorThreadPoolNums;\n    }\n\n    public int getProducerProcessorThreadPoolQueueCapacity() {\n        return producerProcessorThreadPoolQueueCapacity;\n    }\n\n    public void setProducerProcessorThreadPoolQueueCapacity(int producerProcessorThreadPoolQueueCapacity) {\n        this.producerProcessorThreadPoolQueueCapacity = producerProcessorThreadPoolQueueCapacity;\n    }\n\n    public int getConsumerProcessorThreadPoolNums() {\n        return consumerProcessorThreadPoolNums;\n    }\n\n    public void setConsumerProcessorThreadPoolNums(int consumerProcessorThreadPoolNums) {\n        this.consumerProcessorThreadPoolNums = consumerProcessorThreadPoolNums;\n    }\n\n    public int getConsumerProcessorThreadPoolQueueCapacity() {\n        return consumerProcessorThreadPoolQueueCapacity;\n    }\n\n    public void setConsumerProcessorThreadPoolQueueCapacity(int consumerProcessorThreadPoolQueueCapacity) {\n        this.consumerProcessorThreadPoolQueueCapacity = consumerProcessorThreadPoolQueueCapacity;\n    }\n\n    public int getTopicRouteServiceCacheExpiredSeconds() {\n        return topicRouteServiceCacheExpiredSeconds;\n    }\n\n    public void setTopicRouteServiceCacheExpiredSeconds(int topicRouteServiceCacheExpiredSeconds) {\n        this.topicRouteServiceCacheExpiredSeconds = topicRouteServiceCacheExpiredSeconds;\n    }\n\n    public int getTopicRouteServiceCacheRefreshSeconds() {\n        return topicRouteServiceCacheRefreshSeconds;\n    }\n\n    public void setTopicRouteServiceCacheRefreshSeconds(int topicRouteServiceCacheRefreshSeconds) {\n        this.topicRouteServiceCacheRefreshSeconds = topicRouteServiceCacheRefreshSeconds;\n    }\n\n    public int getTopicRouteServiceCacheMaxNum() {\n        return topicRouteServiceCacheMaxNum;\n    }\n\n    public void setTopicRouteServiceCacheMaxNum(int topicRouteServiceCacheMaxNum) {\n        this.topicRouteServiceCacheMaxNum = topicRouteServiceCacheMaxNum;\n    }\n\n    public int getTopicRouteServiceThreadPoolNums() {\n        return topicRouteServiceThreadPoolNums;\n    }\n\n    public void setTopicRouteServiceThreadPoolNums(int topicRouteServiceThreadPoolNums) {\n        this.topicRouteServiceThreadPoolNums = topicRouteServiceThreadPoolNums;\n    }\n\n    public int getTopicRouteServiceThreadPoolQueueCapacity() {\n        return topicRouteServiceThreadPoolQueueCapacity;\n    }\n\n    public void setTopicRouteServiceThreadPoolQueueCapacity(int topicRouteServiceThreadPoolQueueCapacity) {\n        this.topicRouteServiceThreadPoolQueueCapacity = topicRouteServiceThreadPoolQueueCapacity;\n    }\n\n    public int getTopicConfigCacheRefreshSeconds() {\n        return topicConfigCacheRefreshSeconds;\n    }\n\n    public void setTopicConfigCacheRefreshSeconds(int topicConfigCacheRefreshSeconds) {\n        this.topicConfigCacheRefreshSeconds = topicConfigCacheRefreshSeconds;\n    }\n\n    public int getTopicConfigCacheExpiredSeconds() {\n        return topicConfigCacheExpiredSeconds;\n    }\n\n    public void setTopicConfigCacheExpiredSeconds(int topicConfigCacheExpiredSeconds) {\n        this.topicConfigCacheExpiredSeconds = topicConfigCacheExpiredSeconds;\n    }\n\n    public int getTopicConfigCacheMaxNum() {\n        return topicConfigCacheMaxNum;\n    }\n\n    public void setTopicConfigCacheMaxNum(int topicConfigCacheMaxNum) {\n        this.topicConfigCacheMaxNum = topicConfigCacheMaxNum;\n    }\n\n    public int getSubscriptionGroupConfigCacheRefreshSeconds() {\n        return subscriptionGroupConfigCacheRefreshSeconds;\n    }\n\n    public void setSubscriptionGroupConfigCacheRefreshSeconds(int subscriptionGroupConfigCacheRefreshSeconds) {\n        this.subscriptionGroupConfigCacheRefreshSeconds = subscriptionGroupConfigCacheRefreshSeconds;\n    }\n\n    public int getSubscriptionGroupConfigCacheExpiredSeconds() {\n        return subscriptionGroupConfigCacheExpiredSeconds;\n    }\n\n    public void setSubscriptionGroupConfigCacheExpiredSeconds(int subscriptionGroupConfigCacheExpiredSeconds) {\n        this.subscriptionGroupConfigCacheExpiredSeconds = subscriptionGroupConfigCacheExpiredSeconds;\n    }\n\n    public int getSubscriptionGroupConfigCacheMaxNum() {\n        return subscriptionGroupConfigCacheMaxNum;\n    }\n\n    public void setSubscriptionGroupConfigCacheMaxNum(int subscriptionGroupConfigCacheMaxNum) {\n        this.subscriptionGroupConfigCacheMaxNum = subscriptionGroupConfigCacheMaxNum;\n    }\n\n    public int getUserCacheExpiredSeconds() {\n        return userCacheExpiredSeconds;\n    }\n\n    public void setUserCacheExpiredSeconds(int userCacheExpiredSeconds) {\n        this.userCacheExpiredSeconds = userCacheExpiredSeconds;\n    }\n\n    public int getUserCacheRefreshSeconds() {\n        return userCacheRefreshSeconds;\n    }\n\n    public void setUserCacheRefreshSeconds(int userCacheRefreshSeconds) {\n        this.userCacheRefreshSeconds = userCacheRefreshSeconds;\n    }\n\n    public int getUserCacheMaxNum() {\n        return userCacheMaxNum;\n    }\n\n    public void setUserCacheMaxNum(int userCacheMaxNum) {\n        this.userCacheMaxNum = userCacheMaxNum;\n    }\n\n    public int getAclCacheExpiredSeconds() {\n        return aclCacheExpiredSeconds;\n    }\n\n    public void setAclCacheExpiredSeconds(int aclCacheExpiredSeconds) {\n        this.aclCacheExpiredSeconds = aclCacheExpiredSeconds;\n    }\n\n    public int getAclCacheRefreshSeconds() {\n        return aclCacheRefreshSeconds;\n    }\n\n    public void setAclCacheRefreshSeconds(int aclCacheRefreshSeconds) {\n        this.aclCacheRefreshSeconds = aclCacheRefreshSeconds;\n    }\n\n    public int getAclCacheMaxNum() {\n        return aclCacheMaxNum;\n    }\n\n    public void setAclCacheMaxNum(int aclCacheMaxNum) {\n        this.aclCacheMaxNum = aclCacheMaxNum;\n    }\n\n    public int getMetadataThreadPoolNums() {\n        return metadataThreadPoolNums;\n    }\n\n    public void setMetadataThreadPoolNums(int metadataThreadPoolNums) {\n        this.metadataThreadPoolNums = metadataThreadPoolNums;\n    }\n\n    public int getMetadataThreadPoolQueueCapacity() {\n        return metadataThreadPoolQueueCapacity;\n    }\n\n    public void setMetadataThreadPoolQueueCapacity(int metadataThreadPoolQueueCapacity) {\n        this.metadataThreadPoolQueueCapacity = metadataThreadPoolQueueCapacity;\n    }\n\n    public int getTransactionHeartbeatThreadPoolNums() {\n        return transactionHeartbeatThreadPoolNums;\n    }\n\n    public void setTransactionHeartbeatThreadPoolNums(int transactionHeartbeatThreadPoolNums) {\n        this.transactionHeartbeatThreadPoolNums = transactionHeartbeatThreadPoolNums;\n    }\n\n    public int getTransactionHeartbeatThreadPoolQueueCapacity() {\n        return transactionHeartbeatThreadPoolQueueCapacity;\n    }\n\n    public void setTransactionHeartbeatThreadPoolQueueCapacity(int transactionHeartbeatThreadPoolQueueCapacity) {\n        this.transactionHeartbeatThreadPoolQueueCapacity = transactionHeartbeatThreadPoolQueueCapacity;\n    }\n\n    public int getTransactionHeartbeatPeriodSecond() {\n        return transactionHeartbeatPeriodSecond;\n    }\n\n    public void setTransactionHeartbeatPeriodSecond(int transactionHeartbeatPeriodSecond) {\n        this.transactionHeartbeatPeriodSecond = transactionHeartbeatPeriodSecond;\n    }\n\n    public int getTransactionHeartbeatBatchNum() {\n        return transactionHeartbeatBatchNum;\n    }\n\n    public void setTransactionHeartbeatBatchNum(int transactionHeartbeatBatchNum) {\n        this.transactionHeartbeatBatchNum = transactionHeartbeatBatchNum;\n    }\n\n    public long getTransactionDataExpireScanPeriodMillis() {\n        return transactionDataExpireScanPeriodMillis;\n    }\n\n    public void setTransactionDataExpireScanPeriodMillis(long transactionDataExpireScanPeriodMillis) {\n        this.transactionDataExpireScanPeriodMillis = transactionDataExpireScanPeriodMillis;\n    }\n\n    public long getTransactionDataMaxWaitClearMillis() {\n        return transactionDataMaxWaitClearMillis;\n    }\n\n    public void setTransactionDataMaxWaitClearMillis(long transactionDataMaxWaitClearMillis) {\n        this.transactionDataMaxWaitClearMillis = transactionDataMaxWaitClearMillis;\n    }\n\n    public long getTransactionDataExpireMillis() {\n        return transactionDataExpireMillis;\n    }\n\n    public void setTransactionDataExpireMillis(long transactionDataExpireMillis) {\n        this.transactionDataExpireMillis = transactionDataExpireMillis;\n    }\n\n    public int getTransactionDataMaxNum() {\n        return transactionDataMaxNum;\n    }\n\n    public void setTransactionDataMaxNum(int transactionDataMaxNum) {\n        this.transactionDataMaxNum = transactionDataMaxNum;\n    }\n\n    public long getLongPollingReserveTimeInMillis() {\n        return longPollingReserveTimeInMillis;\n    }\n\n    public void setLongPollingReserveTimeInMillis(long longPollingReserveTimeInMillis) {\n        this.longPollingReserveTimeInMillis = longPollingReserveTimeInMillis;\n    }\n\n    public boolean isEnableACL() {\n        return enableACL;\n    }\n\n    public void setEnableACL(boolean enableACL) {\n        this.enableACL = enableACL;\n    }\n\n    public boolean isEnableAclRpcHookForClusterMode() {\n        return enableAclRpcHookForClusterMode;\n    }\n\n    public void setEnableAclRpcHookForClusterMode(boolean enableAclRpcHookForClusterMode) {\n        this.enableAclRpcHookForClusterMode = enableAclRpcHookForClusterMode;\n    }\n\n    public boolean isEnableTopicMessageTypeCheck() {\n        return enableTopicMessageTypeCheck;\n    }\n\n    public void setEnableTopicMessageTypeCheck(boolean enableTopicMessageTypeCheck) {\n        this.enableTopicMessageTypeCheck = enableTopicMessageTypeCheck;\n    }\n\n    public long getInvisibleTimeMillisWhenClear() {\n        return invisibleTimeMillisWhenClear;\n    }\n\n    public void setInvisibleTimeMillisWhenClear(long invisibleTimeMillisWhenClear) {\n        this.invisibleTimeMillisWhenClear = invisibleTimeMillisWhenClear;\n    }\n\n    public boolean isEnableProxyAutoRenew() {\n        return enableProxyAutoRenew;\n    }\n\n    public void setEnableProxyAutoRenew(boolean enableProxyAutoRenew) {\n        this.enableProxyAutoRenew = enableProxyAutoRenew;\n    }\n\n    public int getMaxRenewRetryTimes() {\n        return maxRenewRetryTimes;\n    }\n\n    public void setMaxRenewRetryTimes(int maxRenewRetryTimes) {\n        this.maxRenewRetryTimes = maxRenewRetryTimes;\n    }\n\n    public int getRenewThreadPoolNums() {\n        return renewThreadPoolNums;\n    }\n\n    public void setRenewThreadPoolNums(int renewThreadPoolNums) {\n        this.renewThreadPoolNums = renewThreadPoolNums;\n    }\n\n    public int getRenewMaxThreadPoolNums() {\n        return renewMaxThreadPoolNums;\n    }\n\n    public void setRenewMaxThreadPoolNums(int renewMaxThreadPoolNums) {\n        this.renewMaxThreadPoolNums = renewMaxThreadPoolNums;\n    }\n\n    public int getRenewThreadPoolQueueCapacity() {\n        return renewThreadPoolQueueCapacity;\n    }\n\n    public void setRenewThreadPoolQueueCapacity(int renewThreadPoolQueueCapacity) {\n        this.renewThreadPoolQueueCapacity = renewThreadPoolQueueCapacity;\n    }\n\n    public long getLockTimeoutMsInHandleGroup() {\n        return lockTimeoutMsInHandleGroup;\n    }\n\n    public void setLockTimeoutMsInHandleGroup(long lockTimeoutMsInHandleGroup) {\n        this.lockTimeoutMsInHandleGroup = lockTimeoutMsInHandleGroup;\n    }\n\n    public long getRenewAheadTimeMillis() {\n        return renewAheadTimeMillis;\n    }\n\n    public void setRenewAheadTimeMillis(long renewAheadTimeMillis) {\n        this.renewAheadTimeMillis = renewAheadTimeMillis;\n    }\n\n    public long getRenewMaxTimeMillis() {\n        return renewMaxTimeMillis;\n    }\n\n    public void setRenewMaxTimeMillis(long renewMaxTimeMillis) {\n        this.renewMaxTimeMillis = renewMaxTimeMillis;\n    }\n\n    public long getRenewSchedulePeriodMillis() {\n        return renewSchedulePeriodMillis;\n    }\n\n    public void setRenewSchedulePeriodMillis(long renewSchedulePeriodMillis) {\n        this.renewSchedulePeriodMillis = renewSchedulePeriodMillis;\n    }\n\n    public String getMetricCollectorMode() {\n        return metricCollectorMode;\n    }\n\n    public void setMetricCollectorMode(String metricCollectorMode) {\n        this.metricCollectorMode = metricCollectorMode;\n    }\n\n    public String getMetricCollectorAddress() {\n        return metricCollectorAddress;\n    }\n\n    public void setMetricCollectorAddress(String metricCollectorAddress) {\n        this.metricCollectorAddress = metricCollectorAddress;\n    }\n\n    public boolean isUseDelayLevel() {\n        return useDelayLevel;\n    }\n\n    public void setUseDelayLevel(boolean useDelayLevel) {\n        this.useDelayLevel = useDelayLevel;\n    }\n\n    public String getMessageDelayLevel() {\n        return messageDelayLevel;\n    }\n\n    public void setMessageDelayLevel(String messageDelayLevel) {\n        this.messageDelayLevel = messageDelayLevel;\n    }\n\n    public ConcurrentSkipListMap<Integer, Long> getDelayLevelTable() {\n        return delayLevelTable;\n    }\n\n    public long getGrpcClientIdleTimeMills() {\n        return grpcClientIdleTimeMills;\n    }\n\n    public void setGrpcClientIdleTimeMills(final long grpcClientIdleTimeMills) {\n        this.grpcClientIdleTimeMills = grpcClientIdleTimeMills;\n    }\n\n    public String getRegionId() {\n        return regionId;\n    }\n\n    public void setRegionId(String regionId) {\n        this.regionId = regionId;\n    }\n\n    public boolean isTraceOn() {\n        return traceOn;\n    }\n\n    public void setTraceOn(boolean traceOn) {\n        this.traceOn = traceOn;\n    }\n\n    public String getRemotingAccessAddr() {\n        return remotingAccessAddr;\n    }\n\n    public void setRemotingAccessAddr(String remotingAccessAddr) {\n        this.remotingAccessAddr = remotingAccessAddr;\n    }\n\n    public MetricsExporterType getMetricsExporterType() {\n        return metricsExporterType;\n    }\n\n    public void setMetricsExporterType(MetricsExporterType metricsExporterType) {\n        this.metricsExporterType = metricsExporterType;\n    }\n\n    public void setMetricsExporterType(int metricsExporterType) {\n        this.metricsExporterType = MetricsExporterType.valueOf(metricsExporterType);\n    }\n\n    public void setMetricsExporterType(String metricsExporterType) {\n        this.metricsExporterType = MetricsExporterType.valueOf(metricsExporterType);\n    }\n\n    public String getMetricsGrpcExporterTarget() {\n        return metricsGrpcExporterTarget;\n    }\n\n    public void setMetricsGrpcExporterTarget(String metricsGrpcExporterTarget) {\n        this.metricsGrpcExporterTarget = metricsGrpcExporterTarget;\n    }\n\n    public String getMetricsGrpcExporterHeader() {\n        return metricsGrpcExporterHeader;\n    }\n\n    public void setMetricsGrpcExporterHeader(String metricsGrpcExporterHeader) {\n        this.metricsGrpcExporterHeader = metricsGrpcExporterHeader;\n    }\n\n    public long getMetricGrpcExporterTimeOutInMills() {\n        return metricGrpcExporterTimeOutInMills;\n    }\n\n    public void setMetricGrpcExporterTimeOutInMills(long metricGrpcExporterTimeOutInMills) {\n        this.metricGrpcExporterTimeOutInMills = metricGrpcExporterTimeOutInMills;\n    }\n\n    public long getMetricGrpcExporterIntervalInMills() {\n        return metricGrpcExporterIntervalInMills;\n    }\n\n    public void setMetricGrpcExporterIntervalInMills(long metricGrpcExporterIntervalInMills) {\n        this.metricGrpcExporterIntervalInMills = metricGrpcExporterIntervalInMills;\n    }\n\n    public long getMetricLoggingExporterIntervalInMills() {\n        return metricLoggingExporterIntervalInMills;\n    }\n\n    public void setMetricLoggingExporterIntervalInMills(long metricLoggingExporterIntervalInMills) {\n        this.metricLoggingExporterIntervalInMills = metricLoggingExporterIntervalInMills;\n    }\n\n    public int getMetricsPromExporterPort() {\n        return metricsPromExporterPort;\n    }\n\n    public void setMetricsPromExporterPort(int metricsPromExporterPort) {\n        this.metricsPromExporterPort = metricsPromExporterPort;\n    }\n\n    public String getMetricsPromExporterHost() {\n        return metricsPromExporterHost;\n    }\n\n    public void setMetricsPromExporterHost(String metricsPromExporterHost) {\n        this.metricsPromExporterHost = metricsPromExporterHost;\n    }\n\n    public String getMetricsLabel() {\n        return metricsLabel;\n    }\n\n    public void setMetricsLabel(String metricsLabel) {\n        this.metricsLabel = metricsLabel;\n    }\n\n    public boolean isMetricsInDelta() {\n        return metricsInDelta;\n    }\n\n    public void setMetricsInDelta(boolean metricsInDelta) {\n        this.metricsInDelta = metricsInDelta;\n    }\n\n    public long getChannelExpiredTimeout() {\n        return channelExpiredTimeout;\n    }\n\n    public boolean isEnableRemotingLocalProxyGrpc() {\n        return enableRemotingLocalProxyGrpc;\n    }\n\n    public void setChannelExpiredTimeout(long channelExpiredTimeout) {\n        this.channelExpiredTimeout = channelExpiredTimeout;\n    }\n\n    public void setEnableRemotingLocalProxyGrpc(boolean enableRemotingLocalProxyGrpc) {\n        this.enableRemotingLocalProxyGrpc = enableRemotingLocalProxyGrpc;\n    }\n\n    public int getLocalProxyConnectTimeoutMs() {\n        return localProxyConnectTimeoutMs;\n    }\n\n    public void setLocalProxyConnectTimeoutMs(int localProxyConnectTimeoutMs) {\n        this.localProxyConnectTimeoutMs = localProxyConnectTimeoutMs;\n    }\n\n    public int getRemotingListenPort() {\n        return remotingListenPort;\n    }\n\n    public void setRemotingListenPort(int remotingListenPort) {\n        this.remotingListenPort = remotingListenPort;\n    }\n\n    public int getRemotingHeartbeatThreadPoolNums() {\n        return remotingHeartbeatThreadPoolNums;\n    }\n\n    public void setRemotingHeartbeatThreadPoolNums(int remotingHeartbeatThreadPoolNums) {\n        this.remotingHeartbeatThreadPoolNums = remotingHeartbeatThreadPoolNums;\n    }\n\n    public int getRemotingTopicRouteThreadPoolNums() {\n        return remotingTopicRouteThreadPoolNums;\n    }\n\n    public void setRemotingTopicRouteThreadPoolNums(int remotingTopicRouteThreadPoolNums) {\n        this.remotingTopicRouteThreadPoolNums = remotingTopicRouteThreadPoolNums;\n    }\n\n    public int getRemotingSendMessageThreadPoolNums() {\n        return remotingSendMessageThreadPoolNums;\n    }\n\n    public void setRemotingSendMessageThreadPoolNums(int remotingSendMessageThreadPoolNums) {\n        this.remotingSendMessageThreadPoolNums = remotingSendMessageThreadPoolNums;\n    }\n\n    public int getRemotingPullMessageThreadPoolNums() {\n        return remotingPullMessageThreadPoolNums;\n    }\n\n    public void setRemotingPullMessageThreadPoolNums(int remotingPullMessageThreadPoolNums) {\n        this.remotingPullMessageThreadPoolNums = remotingPullMessageThreadPoolNums;\n    }\n\n    public int getRemotingUpdateOffsetThreadPoolNums() {\n        return remotingUpdateOffsetThreadPoolNums;\n    }\n\n    public void setRemotingUpdateOffsetThreadPoolNums(int remotingUpdateOffsetThreadPoolNums) {\n        this.remotingUpdateOffsetThreadPoolNums = remotingUpdateOffsetThreadPoolNums;\n    }\n\n    public int getRemotingDefaultThreadPoolNums() {\n        return remotingDefaultThreadPoolNums;\n    }\n\n    public void setRemotingDefaultThreadPoolNums(int remotingDefaultThreadPoolNums) {\n        this.remotingDefaultThreadPoolNums = remotingDefaultThreadPoolNums;\n    }\n\n    public int getRemotingHeartbeatThreadPoolQueueCapacity() {\n        return remotingHeartbeatThreadPoolQueueCapacity;\n    }\n\n    public void setRemotingHeartbeatThreadPoolQueueCapacity(int remotingHeartbeatThreadPoolQueueCapacity) {\n        this.remotingHeartbeatThreadPoolQueueCapacity = remotingHeartbeatThreadPoolQueueCapacity;\n    }\n\n    public int getRemotingTopicRouteThreadPoolQueueCapacity() {\n        return remotingTopicRouteThreadPoolQueueCapacity;\n    }\n\n    public void setRemotingTopicRouteThreadPoolQueueCapacity(int remotingTopicRouteThreadPoolQueueCapacity) {\n        this.remotingTopicRouteThreadPoolQueueCapacity = remotingTopicRouteThreadPoolQueueCapacity;\n    }\n\n    public int getRemotingSendThreadPoolQueueCapacity() {\n        return remotingSendThreadPoolQueueCapacity;\n    }\n\n    public void setRemotingSendThreadPoolQueueCapacity(int remotingSendThreadPoolQueueCapacity) {\n        this.remotingSendThreadPoolQueueCapacity = remotingSendThreadPoolQueueCapacity;\n    }\n\n    public int getRemotingPullThreadPoolQueueCapacity() {\n        return remotingPullThreadPoolQueueCapacity;\n    }\n\n    public void setRemotingPullThreadPoolQueueCapacity(int remotingPullThreadPoolQueueCapacity) {\n        this.remotingPullThreadPoolQueueCapacity = remotingPullThreadPoolQueueCapacity;\n    }\n\n    public int getRemotingUpdateOffsetThreadPoolQueueCapacity() {\n        return remotingUpdateOffsetThreadPoolQueueCapacity;\n    }\n\n    public void setRemotingUpdateOffsetThreadPoolQueueCapacity(int remotingUpdateOffsetThreadPoolQueueCapacity) {\n        this.remotingUpdateOffsetThreadPoolQueueCapacity = remotingUpdateOffsetThreadPoolQueueCapacity;\n    }\n\n    public int getRemotingDefaultThreadPoolQueueCapacity() {\n        return remotingDefaultThreadPoolQueueCapacity;\n    }\n\n    public void setRemotingDefaultThreadPoolQueueCapacity(int remotingDefaultThreadPoolQueueCapacity) {\n        this.remotingDefaultThreadPoolQueueCapacity = remotingDefaultThreadPoolQueueCapacity;\n    }\n\n    public long getRemotingWaitTimeMillsInSendQueue() {\n        return remotingWaitTimeMillsInSendQueue;\n    }\n\n    public void setRemotingWaitTimeMillsInSendQueue(long remotingWaitTimeMillsInSendQueue) {\n        this.remotingWaitTimeMillsInSendQueue = remotingWaitTimeMillsInSendQueue;\n    }\n\n    public long getRemotingWaitTimeMillsInPullQueue() {\n        return remotingWaitTimeMillsInPullQueue;\n    }\n\n    public void setRemotingWaitTimeMillsInPullQueue(long remotingWaitTimeMillsInPullQueue) {\n        this.remotingWaitTimeMillsInPullQueue = remotingWaitTimeMillsInPullQueue;\n    }\n\n    public long getRemotingWaitTimeMillsInHeartbeatQueue() {\n        return remotingWaitTimeMillsInHeartbeatQueue;\n    }\n\n    public void setRemotingWaitTimeMillsInHeartbeatQueue(long remotingWaitTimeMillsInHeartbeatQueue) {\n        this.remotingWaitTimeMillsInHeartbeatQueue = remotingWaitTimeMillsInHeartbeatQueue;\n    }\n\n    public long getRemotingWaitTimeMillsInUpdateOffsetQueue() {\n        return remotingWaitTimeMillsInUpdateOffsetQueue;\n    }\n\n    public void setRemotingWaitTimeMillsInUpdateOffsetQueue(long remotingWaitTimeMillsInUpdateOffsetQueue) {\n        this.remotingWaitTimeMillsInUpdateOffsetQueue = remotingWaitTimeMillsInUpdateOffsetQueue;\n    }\n\n    public long getRemotingWaitTimeMillsInTopicRouteQueue() {\n        return remotingWaitTimeMillsInTopicRouteQueue;\n    }\n\n    public void setRemotingWaitTimeMillsInTopicRouteQueue(long remotingWaitTimeMillsInTopicRouteQueue) {\n        this.remotingWaitTimeMillsInTopicRouteQueue = remotingWaitTimeMillsInTopicRouteQueue;\n    }\n\n    public long getRemotingWaitTimeMillsInDefaultQueue() {\n        return remotingWaitTimeMillsInDefaultQueue;\n    }\n\n    public void setRemotingWaitTimeMillsInDefaultQueue(long remotingWaitTimeMillsInDefaultQueue) {\n        this.remotingWaitTimeMillsInDefaultQueue = remotingWaitTimeMillsInDefaultQueue;\n    }\n\n    public boolean isSendLatencyEnable() {\n        return sendLatencyEnable;\n    }\n\n    public boolean isStartDetectorEnable() {\n        return startDetectorEnable;\n    }\n\n    public void setStartDetectorEnable(boolean startDetectorEnable) {\n        this.startDetectorEnable = startDetectorEnable;\n    }\n\n    public void setSendLatencyEnable(boolean sendLatencyEnable) {\n        this.sendLatencyEnable = sendLatencyEnable;\n    }\n\n    public boolean getStartDetectorEnable() {\n        return this.startDetectorEnable;\n    }\n\n    public boolean getSendLatencyEnable() {\n        return this.sendLatencyEnable;\n    }\n\n    public int getDetectTimeout() {\n        return detectTimeout;\n    }\n\n    public void setDetectTimeout(int detectTimeout) {\n        this.detectTimeout = detectTimeout;\n    }\n\n    public int getDetectInterval() {\n        return detectInterval;\n    }\n\n    public void setDetectInterval(int detectInterval) {\n        this.detectInterval = detectInterval;\n    }\n\n    public boolean isEnableBatchAck() {\n        return enableBatchAck;\n    }\n\n    public void setEnableBatchAck(boolean enableBatchAck) {\n        this.enableBatchAck = enableBatchAck;\n    }\n}\n",
            "role": "user"
        },
        {
            "content": "//broker/src/main/java/org/apache/rocketmq/broker/metrics/ConsumerLagCalculator.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.rocketmq.broker.metrics;\n\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.function.Consumer;\nimport java.util.stream.Collectors;\nimport org.apache.rocketmq.broker.BrokerController;\nimport org.apache.rocketmq.broker.client.ConsumerGroupInfo;\nimport org.apache.rocketmq.broker.client.ConsumerManager;\nimport org.apache.rocketmq.broker.filter.ConsumerFilterData;\nimport org.apache.rocketmq.broker.filter.ConsumerFilterManager;\nimport org.apache.rocketmq.broker.filter.ExpressionMessageFilter;\nimport org.apache.rocketmq.broker.offset.ConsumerOffsetManager;\nimport org.apache.rocketmq.broker.processor.PopBufferMergeService;\nimport org.apache.rocketmq.broker.processor.PopInflightMessageCounter;\nimport org.apache.rocketmq.broker.subscription.SubscriptionGroupManager;\nimport org.apache.rocketmq.broker.topic.TopicConfigManager;\nimport org.apache.rocketmq.common.BrokerConfig;\nimport org.apache.rocketmq.common.KeyBuilder;\nimport org.apache.rocketmq.common.MixAll;\nimport org.apache.rocketmq.common.Pair;\nimport org.apache.rocketmq.common.TopicConfig;\nimport org.apache.rocketmq.common.constant.LoggerName;\nimport org.apache.rocketmq.common.constant.PermName;\nimport org.apache.rocketmq.common.filter.ExpressionType;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\nimport org.apache.rocketmq.remoting.protocol.filter.FilterAPI;\nimport org.apache.rocketmq.remoting.protocol.heartbeat.ConsumeType;\nimport org.apache.rocketmq.remoting.protocol.heartbeat.SubscriptionData;\nimport org.apache.rocketmq.remoting.protocol.subscription.SimpleSubscriptionData;\nimport org.apache.rocketmq.remoting.protocol.subscription.SubscriptionGroupConfig;\nimport org.apache.rocketmq.store.DefaultMessageFilter;\nimport org.apache.rocketmq.store.MessageStore;\n\npublic class ConsumerLagCalculator {\n    private final BrokerConfig brokerConfig;\n    private final TopicConfigManager topicConfigManager;\n    private final ConsumerManager consumerManager;\n    private final ConsumerOffsetManager offsetManager;\n    private final ConsumerFilterManager consumerFilterManager;\n    private final SubscriptionGroupManager subscriptionGroupManager;\n    private final MessageStore messageStore;\n    private final PopBufferMergeService popBufferMergeService;\n    private final PopInflightMessageCounter popInflightMessageCounter;\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(LoggerName.BROKER_LOGGER_NAME);\n\n    public ConsumerLagCalculator(BrokerController brokerController) {\n        this.brokerConfig = brokerController.getBrokerConfig();\n        this.topicConfigManager = brokerController.getTopicConfigManager();\n        this.consumerManager = brokerController.getConsumerManager();\n        this.offsetManager = brokerController.getConsumerOffsetManager();\n        this.consumerFilterManager = brokerController.getConsumerFilterManager();\n        this.subscriptionGroupManager = brokerController.getSubscriptionGroupManager();\n        this.messageStore = brokerController.getMessageStore();\n        this.popBufferMergeService = brokerController.getPopMessageProcessor().getPopBufferMergeService();\n        this.popInflightMessageCounter = brokerController.getPopInflightMessageCounter();\n    }\n\n    private static class ProcessGroupInfo {\n        public String group;\n        public String topic;\n        public boolean isPop;\n        public String retryTopic;\n\n        public ProcessGroupInfo(String group, String topic, boolean isPop,\n            String retryTopic) {\n            this.group = group;\n            this.topic = topic;\n            this.isPop = isPop;\n            this.retryTopic = retryTopic;\n        }\n    }\n\n    public static class BaseCalculateResult {\n        public String group;\n        public String topic;\n        public boolean isRetry;\n\n        public BaseCalculateResult(String group, String topic, boolean isRetry) {\n            this.group = group;\n            this.topic = topic;\n            this.isRetry = isRetry;\n        }\n    }\n\n    public static class CalculateLagResult extends BaseCalculateResult {\n        public long lag;\n        public long earliestUnconsumedTimestamp;\n\n        public CalculateLagResult(String group, String topic, boolean isRetry) {\n            super(group, topic, isRetry);\n        }\n    }\n\n    public static class CalculateInflightResult extends BaseCalculateResult {\n        public long inFlight;\n        public long earliestUnPulledTimestamp;\n\n        public CalculateInflightResult(String group, String topic, boolean isRetry) {\n            super(group, topic, isRetry);\n        }\n    }\n\n    public static class CalculateAvailableResult extends BaseCalculateResult {\n        public long available;\n\n        public CalculateAvailableResult(String group, String topic, boolean isRetry) {\n            super(group, topic, isRetry);\n        }\n    }\n\n    private void processAllGroup(Consumer<ProcessGroupInfo> consumer) {\n        for (Map.Entry<String, SubscriptionGroupConfig> subscriptionEntry :\n            subscriptionGroupManager.getSubscriptionGroupTable().entrySet()) {\n\n            String group = subscriptionEntry.getKey();\n            ConsumerGroupInfo consumerGroupInfo = consumerManager.getConsumerGroupInfo(group, true);\n            boolean isPop = false;\n            if (consumerGroupInfo != null) {\n                isPop = consumerGroupInfo.getConsumeType() == ConsumeType.CONSUME_POP;\n            }\n            Set<String> topics;\n            if (brokerConfig.isUseStaticSubscription()) {\n                SubscriptionGroupConfig subscriptionGroupConfig = subscriptionEntry.getValue();\n                if (subscriptionGroupConfig.getSubscriptionDataSet() == null ||\n                    subscriptionGroupConfig.getSubscriptionDataSet().isEmpty()) {\n                    continue;\n                }\n                topics = subscriptionGroupConfig.getSubscriptionDataSet()\n                    .stream()\n                    .map(SimpleSubscriptionData::getTopic)\n                    .collect(Collectors.toSet());\n            } else {\n                if (consumerGroupInfo == null) {\n                    continue;\n                }\n                topics = consumerGroupInfo.getSubscribeTopics();\n            }\n\n            if (null == topics || topics.isEmpty()) {\n                continue;\n            }\n            for (String topic : topics) {\n                // skip retry topic\n                if (topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {\n                    continue;\n                }\n\n                TopicConfig topicConfig = topicConfigManager.selectTopicConfig(topic);\n                if (topicConfig == null) {\n                    continue;\n                }\n\n                // skip no perm topic\n                int topicPerm = topicConfig.getPerm() & brokerConfig.getBrokerPermission();\n                if (!PermName.isReadable(topicPerm) && !PermName.isWriteable(topicPerm)) {\n                    continue;\n                }\n\n                if (isPop) {\n                    String retryTopic = KeyBuilder.buildPopRetryTopic(topic, group, brokerConfig.isEnableRetryTopicV2());\n                    TopicConfig retryTopicConfig = topicConfigManager.selectTopicConfig(retryTopic);\n                    if (retryTopicConfig != null) {\n                        int retryTopicPerm = retryTopicConfig.getPerm() & brokerConfig.getBrokerPermission();\n                        if (PermName.isReadable(retryTopicPerm) || PermName.isWriteable(retryTopicPerm)) {\n                            consumer.accept(new ProcessGroupInfo(group, topic, true, retryTopic));\n                            continue;\n                        }\n                    }\n                    if (brokerConfig.isEnableRetryTopicV2() && brokerConfig.isRetrieveMessageFromPopRetryTopicV1()) {\n                        String retryTopicV1 = KeyBuilder.buildPopRetryTopicV1(topic, group);\n                        TopicConfig retryTopicConfigV1 = topicConfigManager.selectTopicConfig(retryTopicV1);\n                        if (retryTopicConfigV1 != null) {\n                            int retryTopicPerm = retryTopicConfigV1.getPerm() & brokerConfig.getBrokerPermission();\n                            if (PermName.isReadable(retryTopicPerm) || PermName.isWriteable(retryTopicPerm)) {\n                                consumer.accept(new ProcessGroupInfo(group, topic, true, retryTopicV1));\n                                continue;\n                            }\n                        }\n                    }\n                    consumer.accept(new ProcessGroupInfo(group, topic, true, null));\n                } else {\n                    consumer.accept(new ProcessGroupInfo(group, topic, false, null));\n                }\n            }\n        }\n    }\n\n    public void calculateLag(Consumer<CalculateLagResult> lagRecorder) {\n        processAllGroup(info -> {\n            if (info.group == null || info.topic == null) {\n                return;\n            }\n\n            CalculateLagResult result = new CalculateLagResult(info.group, info.topic, false);\n\n            Pair<Long, Long> lag = getConsumerLagStats(info.group, info.topic, info.isPop);\n            if (lag != null) {\n                result.lag = lag.getObject1();\n                result.earliestUnconsumedTimestamp = lag.getObject2();\n            }\n            lagRecorder.accept(result);\n\n            if (info.isPop) {\n                Pair<Long, Long> retryLag = getConsumerLagStats(info.group, info.retryTopic, true);\n\n                result = new CalculateLagResult(info.group, info.topic, true);\n                if (retryLag != null) {\n                    result.lag = retryLag.getObject1();\n                    result.earliestUnconsumedTimestamp = retryLag.getObject2();\n                }\n                lagRecorder.accept(result);\n            }\n        });\n    }\n\n    public void calculateInflight(Consumer<CalculateInflightResult> inflightRecorder) {\n        processAllGroup(info -> {\n            CalculateInflightResult result = new CalculateInflightResult(info.group, info.topic, false);\n            Pair<Long, Long> inFlight = getInFlightMsgStats(info.group, info.topic, info.isPop);\n            if (inFlight != null) {\n                result.inFlight = inFlight.getObject1();\n                result.earliestUnPulledTimestamp = inFlight.getObject2();\n            }\n            inflightRecorder.accept(result);\n\n            if (info.isPop) {\n                Pair<Long, Long> retryInFlight = getInFlightMsgStats(info.group, info.retryTopic, true);\n\n                result = new CalculateInflightResult(info.group, info.topic, true);\n                if (retryInFlight != null) {\n                    result.inFlight = retryInFlight.getObject1();\n                    result.earliestUnPulledTimestamp = retryInFlight.getObject2();\n                }\n                inflightRecorder.accept(result);\n            }\n        });\n    }\n\n    public void calculateAvailable(Consumer<CalculateAvailableResult> availableRecorder) {\n        processAllGroup(info -> {\n            CalculateAvailableResult result = new CalculateAvailableResult(info.group, info.topic, false);\n\n            result.available = getAvailableMsgCount(info.group, info.topic, info.isPop);\n            availableRecorder.accept(result);\n\n            if (info.isPop) {\n                long retryAvailable = getAvailableMsgCount(info.group, info.retryTopic, true);\n\n                result = new CalculateAvailableResult(info.group, info.topic, true);\n                result.available = retryAvailable;\n                availableRecorder.accept(result);\n            }\n        });\n    }\n\n    public Pair<Long, Long> getConsumerLagStats(String group, String topic, boolean isPop) {\n        long total = 0L;\n        long earliestUnconsumedTimestamp = Long.MAX_VALUE;\n\n        if (group == null || topic == null) {\n            return new Pair<>(total, earliestUnconsumedTimestamp);\n        }\n\n        TopicConfig topicConfig = topicConfigManager.selectTopicConfig(topic);\n        if (topicConfig != null) {\n            for (int queueId = 0; queueId < topicConfig.getWriteQueueNums(); queueId++) {\n                Pair<Long, Long> pair = getConsumerLagStats(group, topic, queueId, isPop);\n                total += pair.getObject1();\n                earliestUnconsumedTimestamp = Math.min(earliestUnconsumedTimestamp, pair.getObject2());\n            }\n        } else {\n            LOGGER.warn(\"failed to get config of topic {}\", topic);\n        }\n\n        if (earliestUnconsumedTimestamp < 0 || earliestUnconsumedTimestamp == Long.MAX_VALUE) {\n            earliestUnconsumedTimestamp = 0L;\n        }\n\n        return new Pair<>(total, earliestUnconsumedTimestamp);\n    }\n\n    public Pair<Long, Long> getConsumerLagStats(String group, String topic, int queueId, boolean isPop) {\n        long brokerOffset = messageStore.getMaxOffsetInQueue(topic, queueId);\n        if (brokerOffset < 0) {\n            brokerOffset = 0;\n        }\n\n        if (isPop) {\n            long pullOffset = popBufferMergeService.getLatestOffset(topic, group, queueId);\n            if (pullOffset < 0) {\n                pullOffset = offsetManager.queryOffset(group, topic, queueId);\n            }\n            if (pullOffset < 0) {\n                pullOffset = brokerOffset;\n            }\n            long inFlightNum = popInflightMessageCounter.getGroupPopInFlightMessageNum(topic, group, queueId);\n            long lag = calculateMessageCount(group, topic, queueId, pullOffset, brokerOffset) + inFlightNum;\n            long consumerOffset = pullOffset - inFlightNum;\n            long consumerStoreTimeStamp = getStoreTimeStamp(topic, queueId, consumerOffset);\n            return new Pair<>(lag, consumerStoreTimeStamp);\n        }\n\n        long consumerOffset = offsetManager.queryOffset(group, topic, queueId);\n        if (consumerOffset < 0) {\n            consumerOffset = brokerOffset;\n        }\n\n        long lag = calculateMessageCount(group, topic, queueId, consumerOffset, brokerOffset);\n        long consumerStoreTimeStamp = getStoreTimeStamp(topic, queueId, consumerOffset);\n        return new Pair<>(lag, consumerStoreTimeStamp);\n    }\n\n    public Pair<Long, Long> getInFlightMsgStats(String group, String topic, boolean isPop) {\n        long total = 0L;\n        long earliestUnPulledTimestamp = Long.MAX_VALUE;\n\n        if (group == null || topic == null) {\n            return new Pair<>(total, earliestUnPulledTimestamp);\n        }\n\n        TopicConfig topicConfig = topicConfigManager.selectTopicConfig(topic);\n        if (topicConfig != null) {\n            for (int queueId = 0; queueId < topicConfig.getWriteQueueNums(); queueId++) {\n                Pair<Long, Long> pair = getInFlightMsgStats(group, topic, queueId, isPop);\n                total += pair.getObject1();\n                earliestUnPulledTimestamp = Math.min(earliestUnPulledTimestamp, pair.getObject2());\n            }\n        } else {\n            LOGGER.warn(\"failed to get config of topic {}\", topic);\n        }\n\n        if (earliestUnPulledTimestamp < 0 || earliestUnPulledTimestamp == Long.MAX_VALUE) {\n            earliestUnPulledTimestamp = 0L;\n        }\n\n        return new Pair<>(total, earliestUnPulledTimestamp);\n    }\n\n    public Pair<Long, Long> getInFlightMsgStats(String group, String topic, int queueId, boolean isPop) {\n        if (isPop) {\n            long inflight = popInflightMessageCounter.getGroupPopInFlightMessageNum(topic, group, queueId);\n            long pullOffset = popBufferMergeService.getLatestOffset(topic, group, queueId);\n            if (pullOffset < 0) {\n                pullOffset = offsetManager.queryOffset(group, topic, queueId);\n            }\n            if (pullOffset < 0) {\n                pullOffset = messageStore.getMaxOffsetInQueue(topic, queueId);\n            }\n            long pullStoreTimeStamp = getStoreTimeStamp(topic, queueId, pullOffset);\n            return new Pair<>(inflight, pullStoreTimeStamp);\n        }\n\n        long pullOffset = offsetManager.queryPullOffset(group, topic, queueId);\n        if (pullOffset < 0) {\n            pullOffset = 0;\n        }\n\n        long commitOffset = offsetManager.queryOffset(group, topic, queueId);\n        if (commitOffset < 0) {\n            commitOffset = pullOffset;\n        }\n\n        long inflight = calculateMessageCount(group, topic, queueId, commitOffset, pullOffset);\n        long pullStoreTimeStamp = getStoreTimeStamp(topic, queueId, pullOffset);\n        return new Pair<>(inflight, pullStoreTimeStamp);\n    }\n\n    public long getAvailableMsgCount(String group, String topic, boolean isPop) {\n        long total = 0L;\n\n        if (group == null || topic == null) {\n            return total;\n        }\n\n        TopicConfig topicConfig = topicConfigManager.selectTopicConfig(topic);\n        if (topicConfig != null) {\n            for (int queueId = 0; queueId < topicConfig.getWriteQueueNums(); queueId++) {\n                total += getAvailableMsgCount(group, topic, queueId, isPop);\n            }\n        } else {\n            LOGGER.warn(\"failed to get config of topic {}\", topic);\n        }\n\n        return total;\n    }\n\n    public long getAvailableMsgCount(String group, String topic, int queueId, boolean isPop) {\n        long brokerOffset = messageStore.getMaxOffsetInQueue(topic, queueId);\n        if (brokerOffset < 0) {\n            brokerOffset = 0;\n        }\n\n        long pullOffset;\n        if (isPop) {\n            pullOffset = popBufferMergeService.getLatestOffset(topic, group, queueId);\n            if (pullOffset < 0) {\n                pullOffset = offsetManager.queryOffset(group, topic, queueId);\n            }\n            if (pullOffset < 0) {\n                pullOffset = brokerOffset;\n            }\n        } else {\n            pullOffset = offsetManager.queryPullOffset(group, topic, queueId);\n        }\n        if (pullOffset < 0) {\n            pullOffset = brokerOffset;\n        }\n\n        return calculateMessageCount(group, topic, queueId, pullOffset, brokerOffset);\n    }\n\n    public long getStoreTimeStamp(String topic, int queueId, long offset) {\n        long storeTimeStamp = Long.MAX_VALUE;\n        if (offset >= 0) {\n            storeTimeStamp = messageStore.getMessageStoreTimeStamp(topic, queueId, offset);\n            storeTimeStamp = storeTimeStamp > 0 ? storeTimeStamp : Long.MAX_VALUE;\n        }\n        return storeTimeStamp;\n    }\n\n    public long calculateMessageCount(String group, String topic, int queueId, long from, long to) {\n        long count = to - from;\n\n        if (brokerConfig.isEstimateAccumulation() && to > from) {\n            SubscriptionData subscriptionData = null;\n            if (brokerConfig.isUseStaticSubscription()) {\n                SubscriptionGroupConfig subscriptionGroupConfig = subscriptionGroupManager.findSubscriptionGroupConfig(group);\n                if (subscriptionGroupConfig != null) {\n                    for (SimpleSubscriptionData simpleSubscriptionData : subscriptionGroupConfig.getSubscriptionDataSet()) {\n                        if (topic.equals(simpleSubscriptionData.getTopic())) {\n                            try {\n                                subscriptionData = FilterAPI.buildSubscriptionData(simpleSubscriptionData.getTopic(),\n                                    simpleSubscriptionData.getExpression(), simpleSubscriptionData.getExpressionType());\n                            } catch (Exception e) {\n                                LOGGER.error(\"Try to build subscription for group:{}, topic:{} exception.\", group, topic, e);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } else {\n                ConsumerGroupInfo consumerGroupInfo = consumerManager.getConsumerGroupInfo(group, true);\n                if (consumerGroupInfo != null) {\n                    subscriptionData = consumerGroupInfo.findSubscriptionData(topic);\n                }\n            }\n\n            if (null != subscriptionData) {\n                if (ExpressionType.TAG.equalsIgnoreCase(subscriptionData.getExpressionType())\n                    && !SubscriptionData.SUB_ALL.equals(subscriptionData.getSubString())) {\n                    count = messageStore.estimateMessageCount(topic, queueId, from, to,\n                        new DefaultMessageFilter(subscriptionData));\n                } else if (ExpressionType.SQL92.equalsIgnoreCase(subscriptionData.getExpressionType())) {\n                    ConsumerFilterData consumerFilterData = consumerFilterManager.get(topic, group);\n                    count = messageStore.estimateMessageCount(topic, queueId, from, to,\n                        new ExpressionMessageFilter(subscriptionData,\n                            consumerFilterData,\n                            consumerFilterManager));\n                }\n            }\n\n        }\n        return count < 0 ? 0 : count;\n    }\n}\n",
            "role": "user"
        },
        {
            "content": "//broker/src/main/java/org/apache/rocketmq/broker/out/BrokerOuterAPI.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.rocketmq.broker.out;\n\nimport com.alibaba.fastjson2.JSON;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.TimeUnit;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.rocketmq.acl.common.AclClientRPCHook;\nimport org.apache.rocketmq.acl.common.SessionCredentials;\nimport org.apache.rocketmq.auth.config.AuthConfig;\nimport org.apache.rocketmq.client.consumer.PullResult;\nimport org.apache.rocketmq.client.consumer.PullStatus;\nimport org.apache.rocketmq.client.exception.MQBrokerException;\nimport org.apache.rocketmq.client.impl.consumer.PullResultExt;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.client.producer.SendStatus;\nimport org.apache.rocketmq.common.AbstractBrokerRunnable;\nimport org.apache.rocketmq.common.BrokerIdentity;\nimport org.apache.rocketmq.common.LockCallback;\nimport org.apache.rocketmq.common.MixAll;\nimport org.apache.rocketmq.common.Pair;\nimport org.apache.rocketmq.common.ThreadFactoryImpl;\nimport org.apache.rocketmq.common.TopicConfig;\nimport org.apache.rocketmq.common.UnlockCallback;\nimport org.apache.rocketmq.common.UtilAll;\nimport org.apache.rocketmq.common.constant.LoggerName;\nimport org.apache.rocketmq.common.filter.ExpressionType;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageAccessor;\nimport org.apache.rocketmq.common.message.MessageBatch;\nimport org.apache.rocketmq.common.message.MessageClientIDSetter;\nimport org.apache.rocketmq.common.message.MessageConst;\nimport org.apache.rocketmq.common.message.MessageDecoder;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.common.message.MessageQueue;\nimport org.apache.rocketmq.common.namesrv.DefaultTopAddressing;\nimport org.apache.rocketmq.common.namesrv.TopAddressing;\nimport org.apache.rocketmq.common.sysflag.PullSysFlag;\nimport org.apache.rocketmq.common.topic.TopicValidator;\nimport org.apache.rocketmq.common.utils.ThreadUtils;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\nimport org.apache.rocketmq.remoting.InvokeCallback;\nimport org.apache.rocketmq.remoting.RPCHook;\nimport org.apache.rocketmq.remoting.RemotingClient;\nimport org.apache.rocketmq.remoting.exception.RemotingCommandException;\nimport org.apache.rocketmq.remoting.exception.RemotingConnectException;\nimport org.apache.rocketmq.remoting.exception.RemotingException;\nimport org.apache.rocketmq.remoting.exception.RemotingSendRequestException;\nimport org.apache.rocketmq.remoting.exception.RemotingTimeoutException;\nimport org.apache.rocketmq.remoting.exception.RemotingTooMuchRequestException;\nimport org.apache.rocketmq.remoting.netty.NettyClientConfig;\nimport org.apache.rocketmq.remoting.netty.NettyRemotingClient;\nimport org.apache.rocketmq.remoting.netty.ResponseFuture;\nimport org.apache.rocketmq.remoting.protocol.BrokerSyncInfo;\nimport org.apache.rocketmq.remoting.protocol.DataVersion;\nimport org.apache.rocketmq.remoting.protocol.RemotingCommand;\nimport org.apache.rocketmq.remoting.protocol.RemotingSerializable;\nimport org.apache.rocketmq.remoting.protocol.RequestCode;\nimport org.apache.rocketmq.remoting.protocol.ResponseCode;\nimport org.apache.rocketmq.remoting.protocol.body.BrokerMemberGroup;\nimport org.apache.rocketmq.remoting.protocol.body.ClusterInfo;\nimport org.apache.rocketmq.remoting.protocol.body.ConsumerOffsetSerializeWrapper;\nimport org.apache.rocketmq.remoting.protocol.body.ElectMasterResponseBody;\nimport org.apache.rocketmq.remoting.protocol.body.GetBrokerMemberGroupResponseBody;\nimport org.apache.rocketmq.remoting.protocol.body.KVTable;\nimport org.apache.rocketmq.remoting.protocol.body.LockBatchRequestBody;\nimport org.apache.rocketmq.remoting.protocol.body.LockBatchResponseBody;\nimport org.apache.rocketmq.remoting.protocol.body.MessageRequestModeSerializeWrapper;\nimport org.apache.rocketmq.remoting.protocol.body.RegisterBrokerBody;\nimport org.apache.rocketmq.remoting.protocol.body.SubscriptionGroupWrapper;\nimport org.apache.rocketmq.remoting.protocol.body.SyncStateSet;\nimport org.apache.rocketmq.remoting.protocol.body.TopicConfigAndMappingSerializeWrapper;\nimport org.apache.rocketmq.remoting.protocol.body.TopicConfigSerializeWrapper;\nimport org.apache.rocketmq.remoting.protocol.body.UnlockBatchRequestBody;\nimport org.apache.rocketmq.remoting.protocol.header.ExchangeHAInfoRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.ExchangeHAInfoResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.GetBrokerMemberGroupRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.GetMaxOffsetRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.GetMaxOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.GetMinOffsetRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.GetMinOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.LockBatchMqRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.PullMessageRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.PullMessageResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.SendMessageRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.SendMessageRequestHeaderV2;\nimport org.apache.rocketmq.remoting.protocol.header.SendMessageResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.UnlockBatchMqRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.controller.AlterSyncStateSetRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.controller.ElectMasterRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.controller.ElectMasterResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.controller.GetMetaDataResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.controller.GetReplicaInfoRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.controller.GetReplicaInfoResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.controller.register.ApplyBrokerIdRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.controller.register.ApplyBrokerIdResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.controller.register.GetNextBrokerIdRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.controller.register.GetNextBrokerIdResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.controller.register.RegisterBrokerToControllerRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.controller.register.RegisterBrokerToControllerResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.namesrv.BrokerHeartbeatRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.namesrv.GetRouteInfoRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.namesrv.QueryDataVersionRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.namesrv.QueryDataVersionResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.namesrv.RegisterBrokerRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.namesrv.RegisterBrokerResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.header.namesrv.RegisterTopicRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.header.namesrv.UnRegisterBrokerRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.heartbeat.SubscriptionData;\nimport org.apache.rocketmq.remoting.protocol.namesrv.RegisterBrokerResult;\nimport org.apache.rocketmq.remoting.protocol.route.BrokerData;\nimport org.apache.rocketmq.remoting.protocol.route.QueueData;\nimport org.apache.rocketmq.remoting.protocol.route.TopicRouteData;\nimport org.apache.rocketmq.remoting.rpc.ClientMetadata;\nimport org.apache.rocketmq.remoting.rpc.RpcClient;\nimport org.apache.rocketmq.remoting.rpc.RpcClientImpl;\nimport org.apache.rocketmq.remoting.rpchook.DynamicalExtFieldRPCHook;\nimport org.apache.rocketmq.store.timer.TimerCheckpoint;\nimport org.apache.rocketmq.store.timer.TimerMetrics;\n\nimport static org.apache.rocketmq.remoting.protocol.RemotingSysResponseCode.SUCCESS;\nimport static org.apache.rocketmq.remoting.protocol.ResponseCode.CONTROLLER_MASTER_STILL_EXIST;\n\npublic class BrokerOuterAPI {\n    private static final Logger LOGGER = LoggerFactory.getLogger(LoggerName.BROKER_LOGGER_NAME);\n    private final RemotingClient remotingClient;\n    private final TopAddressing topAddressing = new DefaultTopAddressing(MixAll.getWSAddr());\n    private final ExecutorService brokerOuterExecutor = ThreadUtils.newThreadPoolExecutor(4, 10, 1, TimeUnit.MINUTES,\n            new ArrayBlockingQueue<>(32), new ThreadFactoryImpl(\"brokerOutApi_thread_\", true));\n    private final ClientMetadata clientMetadata;\n    private final RpcClient rpcClient;\n    private String nameSrvAddr = null;\n\n    public BrokerOuterAPI(final NettyClientConfig nettyClientConfig, AuthConfig authConfig) {\n        this(nettyClientConfig, authConfig, new DynamicalExtFieldRPCHook(), new ClientMetadata());\n    }\n\n    private BrokerOuterAPI(final NettyClientConfig nettyClientConfig, AuthConfig authConfig, RPCHook rpcHook, ClientMetadata clientMetadata) {\n        this.remotingClient = new NettyRemotingClient(nettyClientConfig);\n        this.clientMetadata = clientMetadata;\n        this.remotingClient.registerRPCHook(rpcHook);\n        this.remotingClient.registerRPCHook(newAclRPCHook(authConfig));\n        this.rpcClient = new RpcClientImpl(this.clientMetadata, this.remotingClient);\n    }\n\n    private RPCHook newAclRPCHook(AuthConfig config) {\n        if (config == null || StringUtils.isBlank(config.getInnerClientAuthenticationCredentials())) {\n            return null;\n        }\n        SessionCredentials sessionCredentials =\n            JSON.parseObject(config.getInnerClientAuthenticationCredentials(), SessionCredentials.class);\n        if (StringUtils.isBlank(sessionCredentials.getAccessKey()) || StringUtils.isBlank(sessionCredentials.getSecretKey())) {\n            return null;\n        }\n        return new AclClientRPCHook(sessionCredentials);\n    }\n\n    public void start() {\n        this.remotingClient.start();\n    }\n\n    public void shutdown() {\n        this.remotingClient.shutdown();\n        this.brokerOuterExecutor.shutdown();\n    }\n\n    public List<String> getNameServerAddressList() {\n        return this.remotingClient.getNameServerAddressList();\n    }\n\n    public String fetchNameServerAddr() {\n        try {\n            String addrs = this.topAddressing.fetchNSAddr();\n            if (!UtilAll.isBlank(addrs)) {\n                if (!addrs.equals(this.nameSrvAddr)) {\n                    LOGGER.info(\"name server address changed, old: {} new: {}\", this.nameSrvAddr, addrs);\n                    this.updateNameServerAddressList(addrs);\n                    this.nameSrvAddr = addrs;\n                    return nameSrvAddr;\n                }\n            }\n        } catch (Exception e) {\n            LOGGER.error(\"fetchNameServerAddr Exception\", e);\n        }\n        return nameSrvAddr;\n    }\n\n    public List<String> dnsLookupAddressByDomain(String domain) {\n        List<String> addressList = new ArrayList<>();\n        try {\n            java.security.Security.setProperty(\"networkaddress.cache.ttl\", \"10\");\n            int index = domain.indexOf(\":\");\n            String portStr = domain.substring(index);\n            String domainStr = domain.substring(0, index);\n            InetAddress[] addresses = InetAddress.getAllByName(domainStr);\n            for (InetAddress address : addresses) {\n                addressList.add(address.getHostAddress() + portStr);\n            }\n            LOGGER.info(\"dns lookup address by domain success, domain={}, result={}\", domain, addressList);\n        } catch (Exception e) {\n            LOGGER.error(\"dns lookup address by domain error, domain={}\", domain, e);\n        }\n        return addressList;\n    }\n\n    public boolean checkAddressReachable(String address) {\n        return this.remotingClient.isAddressReachable(address);\n    }\n\n    public void updateNameServerAddressList(final String addrs) {\n        String[] addrArray = addrs.split(\";\");\n        List<String> lst = new ArrayList<String>(Arrays.asList(addrArray));\n        this.remotingClient.updateNameServerAddressList(lst);\n    }\n\n    public void updateNameServerAddressListByDnsLookup(final String domain) {\n        List<String> lst = this.dnsLookupAddressByDomain(domain);\n        this.remotingClient.updateNameServerAddressList(lst);\n    }\n\n    public BrokerMemberGroup syncBrokerMemberGroup(String clusterName, String brokerName)\n        throws InterruptedException, RemotingTimeoutException, RemotingSendRequestException, RemotingConnectException {\n        return syncBrokerMemberGroup(clusterName, brokerName, false);\n    }\n\n    public BrokerMemberGroup syncBrokerMemberGroup(String clusterName, String brokerName,\n        boolean isCompatibleWithOldNameSrv)\n        throws InterruptedException, RemotingTimeoutException, RemotingSendRequestException, RemotingConnectException {\n        if (isCompatibleWithOldNameSrv) {\n            return getBrokerMemberGroupCompatible(clusterName, brokerName);\n        } else {\n            return getBrokerMemberGroup(clusterName, brokerName);\n        }\n    }\n\n    public BrokerMemberGroup getBrokerMemberGroup(String clusterName, String brokerName)\n        throws InterruptedException, RemotingTimeoutException, RemotingSendRequestException, RemotingConnectException {\n        BrokerMemberGroup brokerMemberGroup = new BrokerMemberGroup(clusterName, brokerName);\n\n        GetBrokerMemberGroupRequestHeader requestHeader = new GetBrokerMemberGroupRequestHeader();\n        requestHeader.setClusterName(clusterName);\n        requestHeader.setBrokerName(brokerName);\n\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.GET_BROKER_MEMBER_GROUP, requestHeader);\n\n        RemotingCommand response = null;\n        response = this.remotingClient.invokeSync(null, request, 3000);\n        assert response != null;\n\n        switch (response.getCode()) {\n            case ResponseCode.SUCCESS: {\n                byte[] body = response.getBody();\n                if (body != null) {\n                    GetBrokerMemberGroupResponseBody brokerMemberGroupResponseBody =\n                        GetBrokerMemberGroupResponseBody.decode(body, GetBrokerMemberGroupResponseBody.class);\n\n                    return brokerMemberGroupResponseBody.getBrokerMemberGroup();\n                }\n            }\n            default:\n                break;\n        }\n\n        return brokerMemberGroup;\n    }\n\n    public BrokerMemberGroup getBrokerMemberGroupCompatible(String clusterName, String brokerName)\n        throws InterruptedException, RemotingTimeoutException, RemotingSendRequestException, RemotingConnectException {\n        BrokerMemberGroup brokerMemberGroup = new BrokerMemberGroup(clusterName, brokerName);\n\n        GetRouteInfoRequestHeader requestHeader = new GetRouteInfoRequestHeader();\n        requestHeader.setTopic(TopicValidator.SYNC_BROKER_MEMBER_GROUP_PREFIX + brokerName);\n\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.GET_ROUTEINFO_BY_TOPIC, requestHeader);\n\n        RemotingCommand response;\n        response = this.remotingClient.invokeSync(null, request, 3000);\n        assert response != null;\n\n        switch (response.getCode()) {\n            case ResponseCode.SUCCESS: {\n                byte[] body = response.getBody();\n                if (body != null) {\n                    TopicRouteData topicRouteData = TopicRouteData.decode(body, TopicRouteData.class);\n                    for (BrokerData brokerData : topicRouteData.getBrokerDatas()) {\n                        if (brokerData != null\n                            && brokerData.getBrokerName().equals(brokerName)\n                            && brokerData.getCluster().equals(clusterName)) {\n                            brokerMemberGroup.getBrokerAddrs().putAll(brokerData.getBrokerAddrs());\n                            break;\n                        }\n                    }\n                    return brokerMemberGroup;\n                }\n            }\n            default:\n                break;\n        }\n\n        return brokerMemberGroup;\n    }\n\n    public void sendHeartbeatViaDataVersion(\n        final String clusterName,\n        final String brokerAddr,\n        final String brokerName,\n        final Long brokerId,\n        final int timeoutMillis,\n        final DataVersion dataVersion,\n        final boolean isInBrokerContainer) {\n        List<String> nameServerAddressList = this.remotingClient.getAvailableNameSrvList();\n        if (nameServerAddressList != null && nameServerAddressList.size() > 0) {\n            final QueryDataVersionRequestHeader requestHeader = new QueryDataVersionRequestHeader();\n            requestHeader.setBrokerAddr(brokerAddr);\n            requestHeader.setBrokerName(brokerName);\n            requestHeader.setBrokerId(brokerId);\n            requestHeader.setClusterName(clusterName);\n\n            for (final String namesrvAddr : nameServerAddressList) {\n                brokerOuterExecutor.execute(new AbstractBrokerRunnable(new BrokerIdentity(clusterName, brokerName, brokerId, isInBrokerContainer)) {\n\n                    @Override\n                    public void run0() {\n                        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.QUERY_DATA_VERSION, requestHeader);\n                        request.setBody(dataVersion.encode());\n\n                        try {\n                            BrokerOuterAPI.this.remotingClient.invokeOneway(namesrvAddr, request, timeoutMillis);\n                        } catch (Exception e) {\n                            LOGGER.error(\"sendHeartbeat Exception \" + namesrvAddr, e);\n                        }\n                    }\n                });\n            }\n        }\n    }\n\n    public void sendHeartbeat(final String clusterName,\n        final String brokerAddr,\n        final String brokerName,\n        final Long brokerId,\n        final int timeoutMills,\n        final boolean isInBrokerContainer) {\n        List<String> nameServerAddressList = this.remotingClient.getAvailableNameSrvList();\n\n        final BrokerHeartbeatRequestHeader requestHeader = new BrokerHeartbeatRequestHeader();\n        requestHeader.setClusterName(clusterName);\n        requestHeader.setBrokerAddr(brokerAddr);\n        requestHeader.setBrokerName(brokerName);\n\n        if (nameServerAddressList != null && nameServerAddressList.size() > 0) {\n            for (final String namesrvAddr : nameServerAddressList) {\n                brokerOuterExecutor.execute(new AbstractBrokerRunnable(new BrokerIdentity(clusterName, brokerName, brokerId, isInBrokerContainer)) {\n                    @Override\n                    public void run0() {\n                        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.BROKER_HEARTBEAT, requestHeader);\n\n                        try {\n                            BrokerOuterAPI.this.remotingClient.invokeOneway(namesrvAddr, request, timeoutMills);\n                        } catch (Exception e) {\n                            LOGGER.error(\"sendHeartbeat Exception \" + namesrvAddr, e);\n                        }\n                    }\n                });\n            }\n        }\n    }\n\n    public BrokerSyncInfo retrieveBrokerHaInfo(String masterBrokerAddr)\n        throws InterruptedException, RemotingTimeoutException, RemotingSendRequestException, RemotingConnectException,\n        MQBrokerException, RemotingCommandException {\n        ExchangeHAInfoRequestHeader requestHeader = new ExchangeHAInfoRequestHeader();\n        requestHeader.setMasterHaAddress(null);\n\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.EXCHANGE_BROKER_HA_INFO, requestHeader);\n\n        RemotingCommand response = this.remotingClient.invokeSync(masterBrokerAddr, request, 3000);\n        assert response != null;\n        switch (response.getCode()) {\n            case ResponseCode.SUCCESS: {\n                ExchangeHAInfoResponseHeader responseHeader = (ExchangeHAInfoResponseHeader) response.decodeCommandCustomHeader(ExchangeHAInfoResponseHeader.class);\n                return new BrokerSyncInfo(responseHeader.getMasterHaAddress(), responseHeader.getMasterFlushOffset(), responseHeader.getMasterAddress());\n            }\n            default:\n                break;\n        }\n\n        throw new MQBrokerException(response.getCode(), response.getRemark());\n    }\n\n    public void sendBrokerHaInfo(String brokerAddr, String masterHaAddr, long brokerInitMaxOffset, String masterAddr)\n        throws InterruptedException, RemotingTimeoutException, RemotingSendRequestException, RemotingConnectException, MQBrokerException {\n        ExchangeHAInfoRequestHeader requestHeader = new ExchangeHAInfoRequestHeader();\n        requestHeader.setMasterHaAddress(masterHaAddr);\n        requestHeader.setMasterFlushOffset(brokerInitMaxOffset);\n        requestHeader.setMasterAddress(masterAddr);\n\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.EXCHANGE_BROKER_HA_INFO, requestHeader);\n\n        RemotingCommand response = this.remotingClient.invokeSync(brokerAddr, request, 3000);\n\n        assert response != null;\n        switch (response.getCode()) {\n            case ResponseCode.SUCCESS: {\n                return;\n            }\n            default:\n                break;\n        }\n\n        throw new MQBrokerException(response.getCode(), response.getRemark());\n    }\n\n    public List<RegisterBrokerResult> registerBrokerAll(\n        final String clusterName,\n        final String brokerAddr,\n        final String brokerName,\n        final long brokerId,\n        final String haServerAddr,\n        final TopicConfigSerializeWrapper topicConfigWrapper,\n        final List<String> filterServerList,\n        final boolean oneway,\n        final int timeoutMills,\n        final boolean enableActingMaster,\n        final boolean compressed,\n        final BrokerIdentity brokerIdentity) {\n        return registerBrokerAll(clusterName,\n            brokerAddr,\n            brokerName,\n            brokerId,\n            haServerAddr,\n            topicConfigWrapper,\n            filterServerList,\n            oneway, timeoutMills,\n            enableActingMaster,\n            compressed,\n            null,\n            brokerIdentity);\n    }\n\n    /**\n     * Considering compression brings much CPU overhead to name server, stream API will not support compression and\n     * compression feature is deprecated.\n     *\n     * @param clusterName\n     * @param brokerAddr\n     * @param brokerName\n     * @param brokerId\n     * @param haServerAddr\n     * @param topicConfigWrapper\n     * @param filterServerList\n     * @param oneway\n     * @param timeoutMills\n     * @param compressed         default false\n     * @return\n     */\n    public List<RegisterBrokerResult> registerBrokerAll(\n        final String clusterName,\n        final String brokerAddr,\n        final String brokerName,\n        final long brokerId,\n        final String haServerAddr,\n        final TopicConfigSerializeWrapper topicConfigWrapper,\n        final List<String> filterServerList,\n        final boolean oneway,\n        final int timeoutMills,\n        final boolean enableActingMaster,\n        final boolean compressed,\n        final Long heartbeatTimeoutMillis,\n        final BrokerIdentity brokerIdentity) {\n\n        final List<RegisterBrokerResult> registerBrokerResultList = new CopyOnWriteArrayList<>();\n        List<String> nameServerAddressList = this.remotingClient.getAvailableNameSrvList();\n        if (nameServerAddressList != null && nameServerAddressList.size() > 0) {\n\n            final RegisterBrokerRequestHeader requestHeader = new RegisterBrokerRequestHeader();\n            requestHeader.setBrokerAddr(brokerAddr);\n            requestHeader.setBrokerId(brokerId);\n            requestHeader.setBrokerName(brokerName);\n            requestHeader.setClusterName(clusterName);\n            requestHeader.setHaServerAddr(haServerAddr);\n            requestHeader.setEnableActingMaster(enableActingMaster);\n            requestHeader.setCompressed(false);\n            if (heartbeatTimeoutMillis != null) {\n                requestHeader.setHeartbeatTimeoutMillis(heartbeatTimeoutMillis);\n            }\n\n            RegisterBrokerBody requestBody = new RegisterBrokerBody();\n            requestBody.setTopicConfigSerializeWrapper(TopicConfigAndMappingSerializeWrapper.from(topicConfigWrapper));\n            requestBody.setFilterServerList(filterServerList);\n            final byte[] body = requestBody.encode(compressed);\n            final int bodyCrc32 = UtilAll.crc32(body);\n            requestHeader.setBodyCrc32(bodyCrc32);\n            final CountDownLatch countDownLatch = new CountDownLatch(nameServerAddressList.size());\n            for (final String namesrvAddr : nameServerAddressList) {\n                brokerOuterExecutor.execute(new AbstractBrokerRunnable(brokerIdentity) {\n                    @Override\n                    public void run0() {\n                        try {\n                            RegisterBrokerResult result = registerBroker(namesrvAddr, oneway, timeoutMills, requestHeader, body);\n                            if (result != null) {\n                                registerBrokerResultList.add(result);\n                            }\n\n                            LOGGER.info(\"Registering current broker to name server completed. TargetHost={}\", namesrvAddr);\n                        } catch (Exception e) {\n                            LOGGER.error(\"Failed to register current broker to name server. TargetHost={}\", namesrvAddr, e);\n                        } finally {\n                            countDownLatch.countDown();\n                        }\n                    }\n                });\n            }\n\n            try {\n                if (!countDownLatch.await(timeoutMills, TimeUnit.MILLISECONDS)) {\n                    LOGGER.warn(\"Registration to one or more name servers does NOT complete within deadline. Timeout threshold: {}ms\", timeoutMills);\n                }\n            } catch (InterruptedException ignore) {\n            }\n        }\n\n        return registerBrokerResultList;\n    }\n\n    private RegisterBrokerResult registerBroker(\n        final String namesrvAddr,\n        final boolean oneway,\n        final int timeoutMills,\n        final RegisterBrokerRequestHeader requestHeader,\n        final byte[] body\n    ) throws RemotingCommandException, MQBrokerException, RemotingConnectException, RemotingSendRequestException, RemotingTimeoutException,\n        InterruptedException {\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.REGISTER_BROKER, requestHeader);\n        request.setBody(body);\n\n        if (oneway) {\n            try {\n                this.remotingClient.invokeOneway(namesrvAddr, request, timeoutMills);\n            } catch (RemotingTooMuchRequestException e) {\n                // Ignore\n            }\n            return null;\n        }\n\n        RemotingCommand response = this.remotingClient.invokeSync(namesrvAddr, request, timeoutMills);\n        assert response != null;\n        switch (response.getCode()) {\n            case ResponseCode.SUCCESS: {\n                RegisterBrokerResponseHeader responseHeader =\n                    (RegisterBrokerResponseHeader) response.decodeCommandCustomHeader(RegisterBrokerResponseHeader.class);\n                RegisterBrokerResult result = new RegisterBrokerResult();\n                result.setMasterAddr(responseHeader.getMasterAddr());\n                result.setHaServerAddr(responseHeader.getHaServerAddr());\n                if (response.getBody() != null) {\n                    result.setKvTable(KVTable.decode(response.getBody(), KVTable.class));\n                }\n                return result;\n            }\n            default:\n                break;\n        }\n\n        throw new MQBrokerException(response.getCode(), response.getRemark(), requestHeader == null ? null : requestHeader.getBrokerAddr());\n    }\n\n    public void unregisterBrokerAll(\n        final String clusterName,\n        final String brokerAddr,\n        final String brokerName,\n        final long brokerId\n    ) {\n        List<String> nameServerAddressList = this.remotingClient.getNameServerAddressList();\n        if (nameServerAddressList != null) {\n            for (String namesrvAddr : nameServerAddressList) {\n                try {\n                    this.unregisterBroker(namesrvAddr, clusterName, brokerAddr, brokerName, brokerId);\n                    LOGGER.info(\"unregisterBroker OK, NamesrvAddr: {}\", namesrvAddr);\n                } catch (Exception e) {\n                    LOGGER.warn(\"unregisterBroker Exception, NamesrvAddr: {}\", namesrvAddr, e);\n                }\n            }\n        }\n    }\n\n    public void unregisterBroker(\n        final String namesrvAddr,\n        final String clusterName,\n        final String brokerAddr,\n        final String brokerName,\n        final long brokerId\n    ) throws RemotingConnectException, RemotingSendRequestException, RemotingTimeoutException, InterruptedException, MQBrokerException {\n        UnRegisterBrokerRequestHeader requestHeader = new UnRegisterBrokerRequestHeader();\n        requestHeader.setBrokerAddr(brokerAddr);\n        requestHeader.setBrokerId(brokerId);\n        requestHeader.setBrokerName(brokerName);\n        requestHeader.setClusterName(clusterName);\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.UNREGISTER_BROKER, requestHeader);\n\n        RemotingCommand response = this.remotingClient.invokeSync(namesrvAddr, request, 3000);\n        assert response != null;\n        switch (response.getCode()) {\n            case ResponseCode.SUCCESS: {\n                return;\n            }\n            default:\n                break;\n        }\n\n        throw new MQBrokerException(response.getCode(), response.getRemark(), brokerAddr);\n    }\n\n    /**\n     * Register the topic route info of single topic to all name server nodes.\n     * This method is used to replace incremental broker registration feature.\n     */\n    public void registerSingleTopicAll(\n        final String brokerName,\n        final TopicConfig topicConfig,\n        final int timeoutMills) {\n        String topic = topicConfig.getTopicName();\n        RegisterTopicRequestHeader requestHeader = new RegisterTopicRequestHeader();\n        requestHeader.setTopic(topic);\n\n        TopicRouteData topicRouteData = new TopicRouteData();\n        List<QueueData> queueDatas = new ArrayList<>();\n        topicRouteData.setQueueDatas(queueDatas);\n\n        final QueueData queueData = new QueueData();\n        queueData.setBrokerName(brokerName);\n        queueData.setPerm(topicConfig.getPerm());\n        queueData.setReadQueueNums(topicConfig.getReadQueueNums());\n        queueData.setWriteQueueNums(topicConfig.getWriteQueueNums());\n        queueData.setTopicSysFlag(topicConfig.getTopicSysFlag());\n        queueDatas.add(queueData);\n        final byte[] topicRouteBody = topicRouteData.encode();\n\n        List<String> nameServerAddressList = this.remotingClient.getNameServerAddressList();\n        final CountDownLatch countDownLatch = new CountDownLatch(nameServerAddressList.size());\n        for (final String namesrvAddr : nameServerAddressList) {\n            RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.REGISTER_TOPIC_IN_NAMESRV, requestHeader);\n            request.setBody(topicRouteBody);\n\n            try {\n                brokerOuterExecutor.execute(() -> {\n                    try {\n                        RemotingCommand response = BrokerOuterAPI.this.remotingClient.invokeSync(namesrvAddr, request, timeoutMills);\n                        assert response != null;\n                        LOGGER.info(\"Register single topic {} to broker {} with response code {}\", topic, brokerName, response.getCode());\n                    } catch (Exception e) {\n                        LOGGER.warn(\"Register single topic {} to broker {} exception\", topic, brokerName, e);\n                    } finally {\n                        countDownLatch.countDown();\n                    }\n                });\n            } catch (Exception e) {\n                LOGGER.warn(\"Execute single topic registration task failed, topic {}, broker name {}\", topic, brokerName);\n                countDownLatch.countDown();\n            }\n\n        }\n\n        try {\n            if (!countDownLatch.await(timeoutMills, TimeUnit.MILLISECONDS)) {\n                LOGGER.warn(\"Registration single topic to one or more name servers timeout. Timeout threshold: {}ms\", timeoutMills);\n            }\n        } catch (InterruptedException ignore) {\n        }\n    }\n\n    public List<Boolean> needRegister(\n        final String clusterName,\n        final String brokerAddr,\n        final String brokerName,\n        final long brokerId,\n        final TopicConfigSerializeWrapper topicConfigWrapper,\n        final int timeoutMills,\n        final boolean isInBrokerContainer) {\n        final List<Boolean> changedList = new CopyOnWriteArrayList<>();\n        List<String> nameServerAddressList = this.remotingClient.getNameServerAddressList();\n        if (nameServerAddressList != null && nameServerAddressList.size() > 0) {\n            final CountDownLatch countDownLatch = new CountDownLatch(nameServerAddressList.size());\n            for (final String namesrvAddr : nameServerAddressList) {\n                brokerOuterExecutor.execute(new AbstractBrokerRunnable(new BrokerIdentity(clusterName, brokerName, brokerId, isInBrokerContainer)) {\n                    @Override\n                    public void run0() {\n                        try {\n                            QueryDataVersionRequestHeader requestHeader = new QueryDataVersionRequestHeader();\n                            requestHeader.setBrokerAddr(brokerAddr);\n                            requestHeader.setBrokerId(brokerId);\n                            requestHeader.setBrokerName(brokerName);\n                            requestHeader.setClusterName(clusterName);\n                            RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.QUERY_DATA_VERSION, requestHeader);\n                            request.setBody(topicConfigWrapper.getDataVersion().encode());\n                            RemotingCommand response = remotingClient.invokeSync(namesrvAddr, request, timeoutMills);\n                            DataVersion nameServerDataVersion = null;\n                            Boolean changed = false;\n                            switch (response.getCode()) {\n                                case ResponseCode.SUCCESS: {\n                                    QueryDataVersionResponseHeader queryDataVersionResponseHeader =\n                                        (QueryDataVersionResponseHeader) response.decodeCommandCustomHeader(QueryDataVersionResponseHeader.class);\n                                    changed = queryDataVersionResponseHeader.getChanged();\n                                    byte[] body = response.getBody();\n                                    if (body != null) {\n                                        nameServerDataVersion = DataVersion.decode(body, DataVersion.class);\n                                        if (!topicConfigWrapper.getDataVersion().equals(nameServerDataVersion)) {\n                                            changed = true;\n                                        }\n                                    }\n                                    if (changed == null || changed) {\n                                        changedList.add(Boolean.TRUE);\n                                    }\n                                }\n                                default:\n                                    break;\n                            }\n                            LOGGER.warn(\"Query data version from name server {} OK, changed {}, broker {}, name server {}\", namesrvAddr, changed, topicConfigWrapper.getDataVersion(), nameServerDataVersion == null ? \"\" : nameServerDataVersion);\n                        } catch (Exception e) {\n                            changedList.add(Boolean.TRUE);\n                            LOGGER.error(\"Query data version from name server {} exception\", namesrvAddr, e);\n                        } finally {\n                            countDownLatch.countDown();\n                        }\n                    }\n                });\n\n            }\n            try {\n                countDownLatch.await(timeoutMills, TimeUnit.MILLISECONDS);\n            } catch (InterruptedException e) {\n                LOGGER.error(\"query dataversion from nameserver countDownLatch await Exception\", e);\n            }\n        }\n        return changedList;\n    }\n\n    public TopicConfigAndMappingSerializeWrapper getAllTopicConfig(\n        final String addr) throws RemotingConnectException, RemotingSendRequestException,\n        RemotingTimeoutException, InterruptedException, MQBrokerException {\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.GET_ALL_TOPIC_CONFIG, null);\n\n        RemotingCommand response = this.remotingClient.invokeSync(MixAll.brokerVIPChannel(true, addr), request, 3000);\n        assert response != null;\n        switch (response.getCode()) {\n            case ResponseCode.SUCCESS: {\n                return TopicConfigSerializeWrapper.decode(response.getBody(), TopicConfigAndMappingSerializeWrapper.class);\n            }\n            default:\n                break;\n        }\n\n        throw new MQBrokerException(response.getCode(), response.getRemark(), addr);\n    }\n\n    public TimerCheckpoint getTimerCheckPoint(\n        final String addr) throws RemotingConnectException, RemotingSendRequestException,\n        RemotingTimeoutException, InterruptedException, MQBrokerException {\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.GET_TIMER_CHECK_POINT, null);\n\n        RemotingCommand response = this.remotingClient.invokeSync(MixAll.brokerVIPChannel(true, addr), request, 3000);\n        assert response != null;\n        switch (response.getCode()) {\n            case ResponseCode.SUCCESS: {\n                return TimerCheckpoint.decode(ByteBuffer.wrap(response.getBody()));\n            }\n            default:\n                break;\n        }\n\n        throw new MQBrokerException(response.getCode(), response.getRemark(), addr);\n    }\n\n    public TimerMetrics.TimerMetricsSerializeWrapper getTimerMetrics(\n        final String addr) throws RemotingConnectException, RemotingSendRequestException,\n        RemotingTimeoutException, InterruptedException, MQBrokerException {\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.GET_TIMER_METRICS, null);\n\n        RemotingCommand response = this.remotingClient.invokeSync(MixAll.brokerVIPChannel(true, addr), request, 3000);\n        assert response != null;\n        switch (response.getCode()) {\n            case ResponseCode.SUCCESS: {\n                return TimerMetrics.TimerMetricsSerializeWrapper.decode(response.getBody(), TimerMetrics.TimerMetricsSerializeWrapper.class);\n            }\n            default:\n                break;\n        }\n\n        throw new MQBrokerException(response.getCode(), response.getRemark(), addr);\n    }\n\n    public ConsumerOffsetSerializeWrapper getAllConsumerOffset(\n        final String addr) throws InterruptedException, RemotingTimeoutException,\n        RemotingSendRequestException, RemotingConnectException, MQBrokerException {\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.GET_ALL_CONSUMER_OFFSET, null);\n        RemotingCommand response = this.remotingClient.invokeSync(addr, request, 3000);\n        assert response != null;\n        switch (response.getCode()) {\n            case ResponseCode.SUCCESS: {\n                return ConsumerOffsetSerializeWrapper.decode(response.getBody(), ConsumerOffsetSerializeWrapper.class);\n            }\n            default:\n                break;\n        }\n\n        throw new MQBrokerException(response.getCode(), response.getRemark(), addr);\n    }\n\n    public String getAllDelayOffset(\n        final String addr) throws InterruptedException, RemotingTimeoutException, RemotingSendRequestException,\n        RemotingConnectException, MQBrokerException, UnsupportedEncodingException {\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.GET_ALL_DELAY_OFFSET, null);\n        RemotingCommand response = this.remotingClient.invokeSync(addr, request, 3000);\n        assert response != null;\n        switch (response.getCode()) {\n            case ResponseCode.SUCCESS: {\n                return new String(response.getBody(), MixAll.DEFAULT_CHARSET);\n            }\n            default:\n                break;\n        }\n\n        throw new MQBrokerException(response.getCode(), response.getRemark(), addr);\n    }\n\n    public SubscriptionGroupWrapper getAllSubscriptionGroupConfig(\n        final String addr) throws InterruptedException, RemotingTimeoutException,\n        RemotingSendRequestException, RemotingConnectException, MQBrokerException {\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.GET_ALL_SUBSCRIPTIONGROUP_CONFIG, null);\n        RemotingCommand response = this.remotingClient.invokeSync(addr, request, 3000);\n        assert response != null;\n        switch (response.getCode()) {\n            case ResponseCode.SUCCESS: {\n                return SubscriptionGroupWrapper.decode(response.getBody(), SubscriptionGroupWrapper.class);\n            }\n            default:\n                break;\n        }\n\n        throw new MQBrokerException(response.getCode(), response.getRemark(), addr);\n    }\n\n    public void registerRPCHook(RPCHook rpcHook) {\n        remotingClient.registerRPCHook(rpcHook);\n    }\n\n    public void clearRPCHook() {\n        remotingClient.clearRPCHook();\n    }\n\n    public long getMaxOffset(final String addr, final String topic, final int queueId, final boolean committed,\n        final boolean isOnlyThisBroker)\n        throws RemotingException, MQBrokerException, InterruptedException {\n        GetMaxOffsetRequestHeader requestHeader = new GetMaxOffsetRequestHeader();\n        requestHeader.setTopic(topic);\n        requestHeader.setQueueId(queueId);\n        requestHeader.setCommitted(committed);\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.GET_MAX_OFFSET, requestHeader);\n\n        RemotingCommand response = this.remotingClient.invokeSync(addr, request, 3000);\n        assert response != null;\n        switch (response.getCode()) {\n            case ResponseCode.SUCCESS: {\n                GetMaxOffsetResponseHeader responseHeader = (GetMaxOffsetResponseHeader) response.decodeCommandCustomHeader(GetMaxOffsetResponseHeader.class);\n\n                return responseHeader.getOffset();\n            }\n            default:\n                break;\n        }\n\n        throw new MQBrokerException(response.getCode(), response.getRemark());\n    }\n\n    public long getMinOffset(final String addr, final String topic, final int queueId, final boolean isOnlyThisBroker)\n        throws RemotingException, MQBrokerException, InterruptedException {\n        GetMinOffsetRequestHeader requestHeader = new GetMinOffsetRequestHeader();\n        requestHeader.setTopic(topic);\n        requestHeader.setQueueId(queueId);\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.GET_MIN_OFFSET, requestHeader);\n\n        RemotingCommand response = this.remotingClient.invokeSync(addr, request, 3000);\n        assert response != null;\n        switch (response.getCode()) {\n            case ResponseCode.SUCCESS: {\n                GetMinOffsetResponseHeader responseHeader = (GetMinOffsetResponseHeader) response.decodeCommandCustomHeader(GetMinOffsetResponseHeader.class);\n\n                return responseHeader.getOffset();\n            }\n            default:\n                break;\n        }\n\n        throw new MQBrokerException(response.getCode(), response.getRemark());\n    }\n\n    public void lockBatchMQAsync(\n        final String addr,\n        final LockBatchRequestBody requestBody,\n        final long timeoutMillis,\n        final LockCallback callback) throws RemotingException, InterruptedException {\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.LOCK_BATCH_MQ, new LockBatchMqRequestHeader());\n\n        request.setBody(requestBody.encode());\n        this.remotingClient.invokeAsync(addr, request, timeoutMillis, new InvokeCallback() {\n            @Override\n            public void operationComplete(ResponseFuture responseFuture) {\n\n            }\n\n            @Override\n            public void operationSucceed(RemotingCommand response) {\n                if (callback == null) {\n                    return;\n                }\n                if (response.getCode() == ResponseCode.SUCCESS) {\n                    LockBatchResponseBody responseBody = LockBatchResponseBody.decode(response.getBody(),\n                        LockBatchResponseBody.class);\n                    Set<MessageQueue> messageQueues = responseBody.getLockOKMQSet();\n                    callback.onSuccess(messageQueues);\n                } else {\n                    callback.onException(new MQBrokerException(response.getCode(), response.getRemark()));\n                }\n            }\n\n            @Override\n            public void operationFail(Throwable throwable) {\n                if (callback == null) {\n                    return;\n                }\n                callback.onException(throwable);\n            }\n        });\n    }\n\n    public void unlockBatchMQAsync(\n        final String addr,\n        final UnlockBatchRequestBody requestBody,\n        final long timeoutMillis,\n        final UnlockCallback callback) throws RemotingException, InterruptedException {\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.UNLOCK_BATCH_MQ, new UnlockBatchMqRequestHeader());\n\n        request.setBody(requestBody.encode());\n\n        this.remotingClient.invokeAsync(addr, request, timeoutMillis, new InvokeCallback() {\n            @Override\n            public void operationComplete(ResponseFuture responseFuture) {\n\n            }\n\n            @Override\n            public void operationSucceed(RemotingCommand response) {\n                if (callback == null) {\n                    return;\n                }\n                if (response.getCode() == ResponseCode.SUCCESS) {\n                    callback.onSuccess();\n                } else {\n                    callback.onException(new MQBrokerException(response.getCode(), response.getRemark()));\n                }\n            }\n\n            @Override\n            public void operationFail(Throwable throwable) {\n                if (callback == null) {\n                    return;\n                }\n                callback.onException(throwable);\n            }\n        });\n    }\n\n    public RemotingClient getRemotingClient() {\n        return this.remotingClient;\n    }\n\n    public SendResult sendMessageToSpecificBroker(String brokerAddr, final String brokerName,\n        final MessageExt msg, String group,\n        long timeoutMillis) throws RemotingException, MQBrokerException, InterruptedException {\n\n        RemotingCommand request = buildSendMessageRequest(msg, group);\n        RemotingCommand response = this.remotingClient.invokeSync(brokerAddr, request, timeoutMillis);\n        return this.processSendResponse(brokerName, msg, response);\n    }\n\n    public CompletableFuture<SendResult> sendMessageToSpecificBrokerAsync(String brokerAddr, final String brokerName,\n        final MessageExt msg, String group,\n        long timeoutMillis) {\n        RemotingCommand request = buildSendMessageRequest(msg, group);\n\n        CompletableFuture<SendResult> cf = new CompletableFuture<>();\n        final String msgId = msg.getMsgId();\n        try {\n            this.remotingClient.invokeAsync(brokerAddr, request, timeoutMillis, new InvokeCallback() {\n                @Override\n                public void operationComplete(ResponseFuture responseFuture) {\n\n                }\n\n                @Override\n                public void operationSucceed(RemotingCommand response) {\n                    try {\n                        SendResult sendResult = processSendResponse(brokerName, msg, response);\n                        cf.complete(sendResult);\n                    } catch (MQBrokerException | RemotingCommandException e) {\n                        LOGGER.error(\"processSendResponse in sendMessageToSpecificBrokerAsync failed, msgId=\" + msgId, e);\n                        cf.completeExceptionally(e);\n                    }\n                }\n\n                @Override\n                public void operationFail(Throwable throwable) {\n                    cf.completeExceptionally(throwable);\n                }\n            });\n        } catch (Throwable t) {\n            LOGGER.error(\"invokeAsync failed in sendMessageToSpecificBrokerAsync, msgId=\" + msgId, t);\n            cf.completeExceptionally(t);\n        }\n        return cf;\n    }\n\n    private static RemotingCommand buildSendMessageRequest(MessageExt msg, String group) {\n        SendMessageRequestHeaderV2 requestHeaderV2 = buildSendMessageRequestHeaderV2(msg, group);\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.SEND_MESSAGE_V2, requestHeaderV2);\n\n        request.setBody(msg.getBody());\n        return request;\n    }\n\n    private static SendMessageRequestHeaderV2 buildSendMessageRequestHeaderV2(MessageExt msg, String group) {\n        SendMessageRequestHeader requestHeader = new SendMessageRequestHeader();\n        requestHeader.setProducerGroup(group);\n        requestHeader.setTopic(msg.getTopic());\n        requestHeader.setDefaultTopic(TopicValidator.AUTO_CREATE_TOPIC_KEY_TOPIC);\n        requestHeader.setDefaultTopicQueueNums(8);\n        requestHeader.setQueueId(msg.getQueueId());\n        requestHeader.setSysFlag(msg.getSysFlag());\n        requestHeader.setBornTimestamp(msg.getBornTimestamp());\n        requestHeader.setFlag(msg.getFlag());\n        requestHeader.setProperties(MessageDecoder.messageProperties2String(msg.getProperties()));\n        requestHeader.setReconsumeTimes(msg.getReconsumeTimes());\n        requestHeader.setBatch(false);\n\n        SendMessageRequestHeaderV2 requestHeaderV2 = SendMessageRequestHeaderV2.createSendMessageRequestHeaderV2(requestHeader);\n        return requestHeaderV2;\n    }\n\n    private SendResult processSendResponse(\n        final String brokerName,\n        final Message msg,\n        final RemotingCommand response\n    ) throws MQBrokerException, RemotingCommandException {\n        SendStatus sendStatus = null;\n        switch (response.getCode()) {\n            case ResponseCode.FLUSH_DISK_TIMEOUT:\n                sendStatus = SendStatus.FLUSH_DISK_TIMEOUT;\n                break;\n            case ResponseCode.FLUSH_SLAVE_TIMEOUT:\n                sendStatus = SendStatus.FLUSH_SLAVE_TIMEOUT;\n                break;\n            case ResponseCode.SLAVE_NOT_AVAILABLE:\n                sendStatus = SendStatus.SLAVE_NOT_AVAILABLE;\n                break;\n            case ResponseCode.SUCCESS: {\n                sendStatus = SendStatus.SEND_OK;\n                break;\n            }\n            default:\n                break;\n        }\n        if (sendStatus != null) {\n            SendMessageResponseHeader responseHeader =\n                (SendMessageResponseHeader) response.decodeCommandCustomHeader(SendMessageResponseHeader.class);\n\n            //If namespace not null , reset Topic without namespace.\n            String topic = msg.getTopic();\n\n            MessageQueue messageQueue = new MessageQueue(topic, brokerName, responseHeader.getQueueId());\n\n            String uniqMsgId = MessageClientIDSetter.getUniqID(msg);\n            if (msg instanceof MessageBatch) {\n                StringBuilder sb = new StringBuilder();\n                for (Message message : (MessageBatch) msg) {\n                    sb.append(sb.length() == 0 ? \"\" : \",\").append(MessageClientIDSetter.getUniqID(message));\n                }\n                uniqMsgId = sb.toString();\n            }\n            SendResult sendResult = new SendResult(sendStatus,\n                uniqMsgId,\n                responseHeader.getMsgId(), messageQueue, responseHeader.getQueueOffset());\n            sendResult.setTransactionId(responseHeader.getTransactionId());\n            String regionId = response.getExtFields().get(MessageConst.PROPERTY_MSG_REGION);\n            String traceOn = response.getExtFields().get(MessageConst.PROPERTY_TRACE_SWITCH);\n            if (regionId == null || regionId.isEmpty()) {\n                regionId = MixAll.DEFAULT_TRACE_REGION_ID;\n            }\n            if (traceOn != null && traceOn.equals(\"false\")) {\n                sendResult.setTraceOn(false);\n            } else {\n                sendResult.setTraceOn(true);\n            }\n            sendResult.setRegionId(regionId);\n            return sendResult;\n        }\n\n        throw new MQBrokerException(response.getCode(), response.getRemark());\n    }\n\n    public ExecutorService getBrokerOuterExecutor() {\n        return brokerOuterExecutor;\n    }\n\n    public TopicRouteData getTopicRouteInfoFromNameServer(final String topic, final long timeoutMillis)\n        throws RemotingException, MQBrokerException, InterruptedException {\n        return getTopicRouteInfoFromNameServer(topic, timeoutMillis, true);\n    }\n\n    public TopicRouteData getTopicRouteInfoFromNameServer(final String topic, final long timeoutMillis,\n        boolean allowTopicNotExist) throws MQBrokerException, InterruptedException, RemotingTimeoutException, RemotingSendRequestException, RemotingConnectException {\n        GetRouteInfoRequestHeader requestHeader = new GetRouteInfoRequestHeader();\n        requestHeader.setTopic(topic);\n\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.GET_ROUTEINFO_BY_TOPIC, requestHeader);\n\n        RemotingCommand response = this.remotingClient.invokeSync(null, request, timeoutMillis);\n        assert response != null;\n        switch (response.getCode()) {\n            case ResponseCode.TOPIC_NOT_EXIST: {\n                if (allowTopicNotExist) {\n                    LOGGER.warn(\"get Topic [{}] RouteInfoFromNameServer is not exist value\", topic);\n                }\n\n                break;\n            }\n            case ResponseCode.SUCCESS: {\n                byte[] body = response.getBody();\n                if (body != null) {\n                    return TopicRouteData.decode(body, TopicRouteData.class);\n                }\n            }\n            default:\n                break;\n        }\n\n        throw new MQBrokerException(response.getCode(), response.getRemark());\n    }\n\n    public ClusterInfo getBrokerClusterInfo() throws InterruptedException, RemotingTimeoutException, RemotingSendRequestException, RemotingConnectException, MQBrokerException {\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.GET_BROKER_CLUSTER_INFO, null);\n        RemotingCommand response = this.remotingClient.invokeSync(null, request, 3_000);\n        assert response != null;\n        switch (response.getCode()) {\n            case ResponseCode.SUCCESS: {\n                return ClusterInfo.decode(response.getBody(), ClusterInfo.class);\n            }\n            default:\n                break;\n        }\n\n        throw new MQBrokerException(response.getCode(), response.getRemark());\n    }\n\n    public void forwardRequest(String brokerAddr, RemotingCommand request, long timeoutMillis,\n        InvokeCallback invokeCallback) throws InterruptedException, RemotingSendRequestException, RemotingTimeoutException, RemotingTooMuchRequestException, RemotingConnectException {\n        this.remotingClient.invokeAsync(brokerAddr, request, timeoutMillis, invokeCallback);\n    }\n\n    public void refreshMetadata() throws Exception {\n        ClusterInfo brokerClusterInfo = getBrokerClusterInfo();\n        clientMetadata.refreshClusterInfo(brokerClusterInfo);\n    }\n\n    public ClientMetadata getClientMetadata() {\n        return clientMetadata;\n    }\n\n    public RpcClient getRpcClient() {\n        return rpcClient;\n    }\n\n    public MessageRequestModeSerializeWrapper getAllMessageRequestMode(\n        final String addr) throws RemotingSendRequestException, RemotingConnectException,\n        MQBrokerException, RemotingTimeoutException, InterruptedException {\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.GET_ALL_MESSAGE_REQUEST_MODE, null);\n        RemotingCommand response = this.remotingClient.invokeSync(addr, request, 3000);\n        assert response != null;\n        switch (response.getCode()) {\n            case ResponseCode.SUCCESS: {\n                return MessageRequestModeSerializeWrapper.decode(response.getBody(), MessageRequestModeSerializeWrapper.class);\n            }\n            default:\n                break;\n        }\n\n        throw new MQBrokerException(response.getCode(), response.getRemark(), addr);\n    }\n\n    public GetMetaDataResponseHeader getControllerMetaData(final String controllerAddress) throws Exception {\n        final RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.CONTROLLER_GET_METADATA_INFO, null);\n        final RemotingCommand response = this.remotingClient.invokeSync(controllerAddress, request, 3000);\n        assert response != null;\n        if (response.getCode() == SUCCESS) {\n            return (GetMetaDataResponseHeader) response.decodeCommandCustomHeader(GetMetaDataResponseHeader.class);\n        }\n        throw new MQBrokerException(response.getCode(), response.getRemark());\n    }\n\n    /**\n     * Alter syncStateSet\n     */\n    public SyncStateSet alterSyncStateSet(\n        final String controllerAddress,\n        final String brokerName,\n        final Long masterBrokerId, final int masterEpoch,\n        final Set<Long> newSyncStateSet, final int syncStateSetEpoch) throws Exception {\n\n        final AlterSyncStateSetRequestHeader requestHeader = new AlterSyncStateSetRequestHeader(brokerName, masterBrokerId, masterEpoch);\n        final RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.CONTROLLER_ALTER_SYNC_STATE_SET, requestHeader);\n        request.setBody(new SyncStateSet(newSyncStateSet, syncStateSetEpoch).encode());\n        final RemotingCommand response = this.remotingClient.invokeSync(controllerAddress, request, 3000);\n        assert response != null;\n        switch (response.getCode()) {\n            case SUCCESS: {\n                assert response.getBody() != null;\n                return RemotingSerializable.decode(response.getBody(), SyncStateSet.class);\n            }\n        }\n        throw new MQBrokerException(response.getCode(), response.getRemark());\n    }\n\n    /**\n     * Broker try to elect itself as a master in broker set\n     */\n    public Pair<ElectMasterResponseHeader, Set<Long>> brokerElect(String controllerAddress, String clusterName,\n        String brokerName,\n        Long brokerId) throws Exception {\n\n        final ElectMasterRequestHeader requestHeader = ElectMasterRequestHeader.ofBrokerTrigger(clusterName, brokerName, brokerId);\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.CONTROLLER_ELECT_MASTER, requestHeader);\n        RemotingCommand response = this.remotingClient.invokeSync(controllerAddress, request, 3000);\n        assert response != null;\n        switch (response.getCode()) {\n            // Only record success response.\n            case CONTROLLER_MASTER_STILL_EXIST:\n            case SUCCESS:\n                final ElectMasterResponseHeader responseHeader = (ElectMasterResponseHeader) response.decodeCommandCustomHeader(ElectMasterResponseHeader.class);\n                final ElectMasterResponseBody responseBody = RemotingSerializable.decode(response.getBody(), ElectMasterResponseBody.class);\n                return new Pair<>(responseHeader, responseBody.getSyncStateSet());\n        }\n\n        throw new MQBrokerException(response.getCode(), response.getRemark());\n    }\n\n    public GetNextBrokerIdResponseHeader getNextBrokerId(final String clusterName, final String brokerName,\n        final String controllerAddress) throws Exception {\n        final GetNextBrokerIdRequestHeader requestHeader = new GetNextBrokerIdRequestHeader(clusterName, brokerName);\n        final RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.CONTROLLER_GET_NEXT_BROKER_ID, requestHeader);\n        final RemotingCommand response = this.remotingClient.invokeSync(controllerAddress, request, 3000);\n        assert response != null;\n        if (response.getCode() == SUCCESS) {\n            return (GetNextBrokerIdResponseHeader) response.decodeCommandCustomHeader(GetNextBrokerIdResponseHeader.class);\n        }\n        throw new MQBrokerException(response.getCode(), response.getRemark());\n    }\n\n    public ApplyBrokerIdResponseHeader applyBrokerId(final String clusterName, final String brokerName,\n        final Long brokerId, final String registerCheckCode, final String controllerAddress) throws Exception {\n        final ApplyBrokerIdRequestHeader requestHeader = new ApplyBrokerIdRequestHeader(clusterName, brokerName, brokerId, registerCheckCode);\n        final RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.CONTROLLER_APPLY_BROKER_ID, requestHeader);\n        final RemotingCommand response = this.remotingClient.invokeSync(controllerAddress, request, 3000);\n        assert response != null;\n        if (response.getCode() == SUCCESS) {\n            return (ApplyBrokerIdResponseHeader) response.decodeCommandCustomHeader(ApplyBrokerIdResponseHeader.class);\n        }\n        throw new MQBrokerException(response.getCode(), response.getRemark());\n    }\n\n    public Pair<RegisterBrokerToControllerResponseHeader, Set<Long>> registerBrokerToController(\n        final String clusterName, final String brokerName, final Long brokerId, final String brokerAddress,\n        final String controllerAddress) throws Exception {\n        final RegisterBrokerToControllerRequestHeader requestHeader = new RegisterBrokerToControllerRequestHeader(clusterName, brokerName, brokerId, brokerAddress);\n        final RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.CONTROLLER_REGISTER_BROKER, requestHeader);\n        final RemotingCommand response = this.remotingClient.invokeSync(controllerAddress, request, 3000);\n        assert response != null;\n        if (response.getCode() == SUCCESS) {\n            RegisterBrokerToControllerResponseHeader responseHeader = (RegisterBrokerToControllerResponseHeader) response.decodeCommandCustomHeader(RegisterBrokerToControllerResponseHeader.class);\n            Set<Long> syncStateSet = RemotingSerializable.decode(response.getBody(), SyncStateSet.class).getSyncStateSet();\n            return new Pair<>(responseHeader, syncStateSet);\n        }\n        throw new MQBrokerException(response.getCode(), response.getRemark());\n    }\n\n    /**\n     * Get broker replica info\n     */\n    public Pair<GetReplicaInfoResponseHeader, SyncStateSet> getReplicaInfo(final String controllerAddress,\n        final String brokerName) throws Exception {\n        final GetReplicaInfoRequestHeader requestHeader = new GetReplicaInfoRequestHeader(brokerName);\n        final RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.CONTROLLER_GET_REPLICA_INFO, requestHeader);\n        final RemotingCommand response = this.remotingClient.invokeSync(controllerAddress, request, 3000);\n        assert response != null;\n        switch (response.getCode()) {\n            case SUCCESS: {\n                final GetReplicaInfoResponseHeader header = (GetReplicaInfoResponseHeader) response.decodeCommandCustomHeader(GetReplicaInfoResponseHeader.class);\n                assert response.getBody() != null;\n                final SyncStateSet stateSet = RemotingSerializable.decode(response.getBody(), SyncStateSet.class);\n                return new Pair<>(header, stateSet);\n            }\n        }\n        throw new MQBrokerException(response.getCode(), response.getRemark());\n    }\n\n    /**\n     * Send heartbeat to controller\n     */\n    public void sendHeartbeatToController(final String controllerAddress,\n        final String clusterName,\n        final String brokerAddr,\n        final String brokerName,\n        final Long brokerId,\n        final int sendHeartBeatTimeoutMills,\n        final boolean isInBrokerContainer,\n        final int epoch,\n        final long maxOffset,\n        final long confirmOffset,\n        final long controllerHeartBeatTimeoutMills,\n        final int electionPriority) {\n        if (StringUtils.isEmpty(controllerAddress)) {\n            return;\n        }\n\n        final BrokerHeartbeatRequestHeader requestHeader = new BrokerHeartbeatRequestHeader();\n        requestHeader.setClusterName(clusterName);\n        requestHeader.setBrokerAddr(brokerAddr);\n        requestHeader.setBrokerName(brokerName);\n        requestHeader.setEpoch(epoch);\n        requestHeader.setMaxOffset(maxOffset);\n        requestHeader.setConfirmOffset(confirmOffset);\n        requestHeader.setHeartbeatTimeoutMills(controllerHeartBeatTimeoutMills);\n        requestHeader.setElectionPriority(electionPriority);\n        requestHeader.setBrokerId(brokerId);\n        brokerOuterExecutor.execute(new AbstractBrokerRunnable(new BrokerIdentity(clusterName, brokerName, brokerId, isInBrokerContainer)) {\n            @Override\n            public void run0() {\n                RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.BROKER_HEARTBEAT, requestHeader);\n\n                try {\n                    BrokerOuterAPI.this.remotingClient.invokeOneway(controllerAddress, request, sendHeartBeatTimeoutMills);\n                } catch (Exception e) {\n                    LOGGER.error(\"Error happen when send heartbeat to controller {}\", controllerAddress, e);\n                }\n            }\n        });\n    }\n\n    public CompletableFuture<PullResult> pullMessageFromSpecificBrokerAsync(String brokerName, String brokerAddr,\n        String consumerGroup, String topic, int queueId, long offset,\n        int maxNums, long timeoutMillis) throws RemotingException, InterruptedException {\n        PullMessageRequestHeader requestHeader = new PullMessageRequestHeader();\n        requestHeader.setConsumerGroup(consumerGroup);\n        requestHeader.setTopic(topic);\n        requestHeader.setQueueId(queueId);\n        requestHeader.setQueueOffset(offset);\n        requestHeader.setMaxMsgNums(maxNums);\n        requestHeader.setSysFlag(PullSysFlag.buildSysFlag(false, false, true, false));\n        requestHeader.setCommitOffset(0L);\n        requestHeader.setSuspendTimeoutMillis(0L);\n        requestHeader.setSubscription(SubscriptionData.SUB_ALL);\n        requestHeader.setSubVersion(System.currentTimeMillis());\n        requestHeader.setMaxMsgBytes(Integer.MAX_VALUE);\n        requestHeader.setExpressionType(ExpressionType.TAG);\n        requestHeader.setBrokerName(brokerName);\n\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, requestHeader);\n        CompletableFuture<PullResult> pullResultFuture = new CompletableFuture<>();\n        this.remotingClient.invokeAsync(brokerAddr, request, timeoutMillis, new InvokeCallback() {\n            @Override\n            public void operationComplete(ResponseFuture responseFuture) {\n\n            }\n\n            @Override\n            public void operationSucceed(RemotingCommand response) {\n                try {\n                    PullResultExt pullResultExt = processPullResponse(response, brokerAddr);\n                    processPullResult(pullResultExt, brokerName, queueId);\n                    pullResultFuture.complete(pullResultExt);\n                } catch (Exception e) {\n                    pullResultFuture.complete(new PullResult(PullStatus.NO_MATCHED_MSG, -1, -1, -1, new ArrayList<>()));\n                }\n            }\n\n            @Override\n            public void operationFail(Throwable throwable) {\n                pullResultFuture.complete(new PullResult(PullStatus.NO_MATCHED_MSG, -1, -1, -1, new ArrayList<>()));\n            }\n        });\n        return pullResultFuture;\n    }\n\n    private PullResultExt processPullResponse(\n        final RemotingCommand response,\n        final String addr) throws MQBrokerException, RemotingCommandException {\n        PullStatus pullStatus = PullStatus.NO_NEW_MSG;\n        switch (response.getCode()) {\n            case ResponseCode.SUCCESS:\n                pullStatus = PullStatus.FOUND;\n                break;\n            case ResponseCode.PULL_NOT_FOUND:\n                pullStatus = PullStatus.NO_NEW_MSG;\n                break;\n            case ResponseCode.PULL_RETRY_IMMEDIATELY:\n                pullStatus = PullStatus.NO_MATCHED_MSG;\n                break;\n            case ResponseCode.PULL_OFFSET_MOVED:\n                pullStatus = PullStatus.OFFSET_ILLEGAL;\n                break;\n\n            default:\n                throw new MQBrokerException(response.getCode(), response.getRemark(), addr);\n        }\n\n        PullMessageResponseHeader responseHeader =\n            (PullMessageResponseHeader) response.decodeCommandCustomHeader(PullMessageResponseHeader.class);\n\n        return new PullResultExt(pullStatus, responseHeader.getNextBeginOffset(), responseHeader.getMinOffset(),\n            responseHeader.getMaxOffset(), null, responseHeader.getSuggestWhichBrokerId(), response.getBody(), responseHeader.getOffsetDelta());\n\n    }\n\n    private PullResult processPullResult(final PullResultExt pullResult, String brokerName, int queueId) {\n\n        if (PullStatus.FOUND == pullResult.getPullStatus()) {\n            ByteBuffer byteBuffer = ByteBuffer.wrap(pullResult.getMessageBinary());\n            List<MessageExt> msgList = MessageDecoder.decodesBatch(\n                byteBuffer,\n                true,\n                true,\n                true\n            );\n\n            // Currently batch messages are not supported\n            for (MessageExt msg : msgList) {\n                String traFlag = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);\n                if (Boolean.parseBoolean(traFlag)) {\n                    msg.setTransactionId(msg.getProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX));\n                }\n                MessageAccessor.putProperty(msg, MessageConst.PROPERTY_MIN_OFFSET,\n                    Long.toString(pullResult.getMinOffset()));\n                MessageAccessor.putProperty(msg, MessageConst.PROPERTY_MAX_OFFSET,\n                    Long.toString(pullResult.getMaxOffset()));\n                msg.setBrokerName(brokerName);\n                msg.setQueueId(queueId);\n                if (pullResult.getOffsetDelta() != null) {\n                    msg.setQueueOffset(pullResult.getOffsetDelta() + msg.getQueueOffset());\n                }\n            }\n\n            pullResult.setMsgFoundList(msgList);\n        }\n\n        pullResult.setMessageBinary(null);\n\n        return pullResult;\n    }\n\n}\n",
            "role": "user"
        },
        {
            "content": "//broker/src/main/java/org/apache/rocketmq/broker/failover/EscapeBridge.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.rocketmq.broker.failover;\n\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.TimeUnit;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.rocketmq.broker.BrokerController;\nimport org.apache.rocketmq.broker.transaction.queue.TransactionalMessageUtil;\nimport org.apache.rocketmq.client.consumer.PullStatus;\nimport org.apache.rocketmq.client.exception.MQBrokerException;\nimport org.apache.rocketmq.client.impl.producer.TopicPublishInfo;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.client.producer.SendStatus;\nimport org.apache.rocketmq.common.MixAll;\nimport org.apache.rocketmq.common.Pair;\nimport org.apache.rocketmq.common.ThreadFactoryImpl;\nimport org.apache.rocketmq.common.constant.LoggerName;\nimport org.apache.rocketmq.common.message.MessageConst;\nimport org.apache.rocketmq.common.message.MessageDecoder;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.common.message.MessageExtBrokerInner;\nimport org.apache.rocketmq.common.message.MessageQueue;\nimport org.apache.rocketmq.common.utils.ThreadUtils;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\nimport org.apache.rocketmq.remoting.exception.RemotingException;\nimport org.apache.rocketmq.store.GetMessageResult;\nimport org.apache.rocketmq.store.GetMessageStatus;\nimport org.apache.rocketmq.store.MessageStore;\nimport org.apache.rocketmq.store.PutMessageResult;\nimport org.apache.rocketmq.store.PutMessageStatus;\n\npublic class EscapeBridge {\n    protected static final Logger LOG = LoggerFactory.getLogger(LoggerName.BROKER_LOGGER_NAME);\n    private static final long SEND_TIMEOUT = 3000L;\n    private static final long DEFAULT_PULL_TIMEOUT_MILLIS = 1000 * 10L;\n    private final String innerProducerGroupName;\n    private final String innerConsumerGroupName;\n\n    private final BrokerController brokerController;\n\n    private ExecutorService defaultAsyncSenderExecutor;\n\n    public EscapeBridge(BrokerController brokerController) {\n        this.brokerController = brokerController;\n        this.innerProducerGroupName = \"InnerProducerGroup_\" + brokerController.getBrokerConfig().getBrokerName() + \"_\" + brokerController.getBrokerConfig().getBrokerId();\n        this.innerConsumerGroupName = \"InnerConsumerGroup_\" + brokerController.getBrokerConfig().getBrokerName() + \"_\" + brokerController.getBrokerConfig().getBrokerId();\n    }\n\n    public void start() throws Exception {\n        if (brokerController.getBrokerConfig().isEnableSlaveActingMaster() && brokerController.getBrokerConfig().isEnableRemoteEscape()) {\n            final BlockingQueue<Runnable> asyncSenderThreadPoolQueue = new LinkedBlockingQueue<>(50000);\n            this.defaultAsyncSenderExecutor = ThreadUtils.newThreadPoolExecutor(\n                Runtime.getRuntime().availableProcessors(),\n                Runtime.getRuntime().availableProcessors(),\n                1000 * 60,\n                TimeUnit.MILLISECONDS,\n                asyncSenderThreadPoolQueue,\n                new ThreadFactoryImpl(\"AsyncEscapeBridgeExecutor_\", this.brokerController.getBrokerIdentity())\n            );\n            LOG.info(\"init executor for escaping messages asynchronously success.\");\n        }\n    }\n\n    public void shutdown() {\n        if (null != this.defaultAsyncSenderExecutor) {\n            this.defaultAsyncSenderExecutor.shutdown();\n        }\n    }\n\n    public PutMessageResult putMessage(MessageExtBrokerInner messageExt) {\n        BrokerController masterBroker = this.brokerController.peekMasterBroker();\n        if (masterBroker != null) {\n            return masterBroker.getMessageStore().putMessage(messageExt);\n        } else if (this.brokerController.getBrokerConfig().isEnableSlaveActingMaster()\n            && this.brokerController.getBrokerConfig().isEnableRemoteEscape()) {\n\n            try {\n                messageExt.setWaitStoreMsgOK(false);\n                final SendResult sendResult = putMessageToRemoteBroker(messageExt);\n                return transformSendResult2PutResult(sendResult);\n            } catch (Exception e) {\n                LOG.error(\"sendMessageInFailover to remote failed\", e);\n                return new PutMessageResult(PutMessageStatus.PUT_TO_REMOTE_BROKER_FAIL, null, true);\n            }\n        } else {\n            LOG.warn(\"Put message failed, enableSlaveActingMaster={}, enableRemoteEscape={}.\",\n                this.brokerController.getBrokerConfig().isEnableSlaveActingMaster(), this.brokerController.getBrokerConfig().isEnableRemoteEscape());\n            return new PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, null);\n        }\n    }\n\n    private SendResult putMessageToRemoteBroker(MessageExtBrokerInner messageExt) {\n        final boolean isTransHalfMessage = TransactionalMessageUtil.buildHalfTopic().equals(messageExt.getTopic());\n        MessageExtBrokerInner messageToPut = messageExt;\n        if (isTransHalfMessage) {\n            messageToPut = TransactionalMessageUtil.buildTransactionalMessageFromHalfMessage(messageExt);\n        }\n        final TopicPublishInfo topicPublishInfo = this.brokerController.getTopicRouteInfoManager().tryToFindTopicPublishInfo(messageToPut.getTopic());\n        if (null == topicPublishInfo || !topicPublishInfo.ok()) {\n            LOG.warn(\"putMessageToRemoteBroker: no route info of topic {} when escaping message, msgId={}\",\n                messageToPut.getTopic(), messageToPut.getMsgId());\n            return null;\n        }\n\n        final MessageQueue mqSelected = topicPublishInfo.selectOneMessageQueue(this.brokerController.getBrokerConfig().getBrokerName());\n\n        messageToPut.setQueueId(mqSelected.getQueueId());\n\n        final String brokerNameToSend = mqSelected.getBrokerName();\n        final String brokerAddrToSend = this.brokerController.getTopicRouteInfoManager().findBrokerAddressInPublish(brokerNameToSend);\n\n        final long beginTimestamp = System.currentTimeMillis();\n        try {\n            final SendResult sendResult = this.brokerController.getBrokerOuterAPI().sendMessageToSpecificBroker(\n                brokerAddrToSend, brokerNameToSend,\n                messageToPut, this.getProducerGroup(messageToPut), SEND_TIMEOUT);\n            if (null != sendResult && SendStatus.SEND_OK.equals(sendResult.getSendStatus())) {\n                return sendResult;\n            } else {\n                LOG.error(\"Escaping failed! cost {}ms, Topic: {}, MsgId: {}, Broker: {}\",\n                    System.currentTimeMillis() - beginTimestamp, messageExt.getTopic(),\n                    messageExt.getMsgId(), brokerNameToSend);\n            }\n        } catch (RemotingException | MQBrokerException e) {\n            LOG.error(String.format(\"putMessageToRemoteBroker exception, MsgId: %s, RT: %sms, Broker: %s\",\n                messageToPut.getMsgId(), System.currentTimeMillis() - beginTimestamp, mqSelected), e);\n        } catch (InterruptedException e) {\n            LOG.error(String.format(\"putMessageToRemoteBroker interrupted, MsgId: %s, RT: %sms, Broker: %s\",\n                messageToPut.getMsgId(), System.currentTimeMillis() - beginTimestamp, mqSelected), e);\n            Thread.currentThread().interrupt();\n        }\n\n        return null;\n    }\n\n    public CompletableFuture<PutMessageResult> asyncPutMessage(MessageExtBrokerInner messageExt) {\n        BrokerController masterBroker = this.brokerController.peekMasterBroker();\n        if (masterBroker != null) {\n            return masterBroker.getMessageStore().asyncPutMessage(messageExt);\n        } else if (this.brokerController.getBrokerConfig().isEnableSlaveActingMaster()\n            && this.brokerController.getBrokerConfig().isEnableRemoteEscape()) {\n            try {\n                messageExt.setWaitStoreMsgOK(false);\n\n                final TopicPublishInfo topicPublishInfo = this.brokerController.getTopicRouteInfoManager().tryToFindTopicPublishInfo(messageExt.getTopic());\n                final String producerGroup = getProducerGroup(messageExt);\n\n                final MessageQueue mqSelected = topicPublishInfo.selectOneMessageQueue();\n                messageExt.setQueueId(mqSelected.getQueueId());\n\n                final String brokerNameToSend = mqSelected.getBrokerName();\n                final String brokerAddrToSend = this.brokerController.getTopicRouteInfoManager().findBrokerAddressInPublish(brokerNameToSend);\n                final CompletableFuture<SendResult> future = this.brokerController.getBrokerOuterAPI().sendMessageToSpecificBrokerAsync(brokerAddrToSend,\n                    brokerNameToSend, messageExt,\n                    producerGroup, SEND_TIMEOUT);\n\n                return future.exceptionally(throwable -> null)\n                    .thenApplyAsync(sendResult -> transformSendResult2PutResult(sendResult), this.defaultAsyncSenderExecutor)\n                    .exceptionally(throwable -> transformSendResult2PutResult(null));\n\n            } catch (Exception e) {\n                LOG.error(\"sendMessageInFailover to remote failed\", e);\n                return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.PUT_TO_REMOTE_BROKER_FAIL, null, true));\n            }\n        } else {\n            LOG.warn(\"Put message failed, enableSlaveActingMaster={}, enableRemoteEscape={}.\",\n                this.brokerController.getBrokerConfig().isEnableSlaveActingMaster(), this.brokerController.getBrokerConfig().isEnableRemoteEscape());\n            return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, null));\n        }\n    }\n\n\n    private String getProducerGroup(MessageExtBrokerInner messageExt) {\n        if (null == messageExt) {\n            return this.innerProducerGroupName;\n        }\n        String producerGroup = messageExt.getProperty(MessageConst.PROPERTY_PRODUCER_GROUP);\n        if (StringUtils.isEmpty(producerGroup)) {\n            producerGroup = this.innerProducerGroupName;\n        }\n        return producerGroup;\n    }\n\n\n    public PutMessageResult putMessageToSpecificQueue(MessageExtBrokerInner messageExt) {\n        BrokerController masterBroker = this.brokerController.peekMasterBroker();\n        if (masterBroker != null) {\n            return masterBroker.getMessageStore().putMessage(messageExt);\n        } else if (this.brokerController.getBrokerConfig().isEnableSlaveActingMaster()\n            && this.brokerController.getBrokerConfig().isEnableRemoteEscape()) {\n            try {\n                messageExt.setWaitStoreMsgOK(false);\n\n                final TopicPublishInfo topicPublishInfo = this.brokerController.getTopicRouteInfoManager().tryToFindTopicPublishInfo(messageExt.getTopic());\n                List<MessageQueue> mqs = topicPublishInfo.getMessageQueueList();\n\n                if (null == mqs || mqs.isEmpty()) {\n                    return new PutMessageResult(PutMessageStatus.PUT_TO_REMOTE_BROKER_FAIL, null, true);\n                }\n\n                String id = messageExt.getTopic() + messageExt.getStoreHost();\n                final int index = Math.floorMod(id.hashCode(), mqs.size());\n\n                MessageQueue mq = mqs.get(index);\n                messageExt.setQueueId(mq.getQueueId());\n\n                String brokerNameToSend = mq.getBrokerName();\n                String brokerAddrToSend = this.brokerController.getTopicRouteInfoManager().findBrokerAddressInPublish(brokerNameToSend);\n                final SendResult sendResult = this.brokerController.getBrokerOuterAPI().sendMessageToSpecificBroker(\n                    brokerAddrToSend, brokerNameToSend,\n                    messageExt, this.getProducerGroup(messageExt), SEND_TIMEOUT);\n\n                return transformSendResult2PutResult(sendResult);\n            } catch (Exception e) {\n                LOG.error(\"sendMessageInFailover to remote failed\", e);\n                return new PutMessageResult(PutMessageStatus.PUT_TO_REMOTE_BROKER_FAIL, null, true);\n            }\n        } else {\n            LOG.warn(\"Put message to specific queue failed, enableSlaveActingMaster={}, enableRemoteEscape={}.\",\n                this.brokerController.getBrokerConfig().isEnableSlaveActingMaster(), this.brokerController.getBrokerConfig().isEnableRemoteEscape());\n            return new PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, null);\n        }\n    }\n\n    private PutMessageResult transformSendResult2PutResult(SendResult sendResult) {\n        if (sendResult == null) {\n            return new PutMessageResult(PutMessageStatus.PUT_TO_REMOTE_BROKER_FAIL, null, true);\n        }\n        switch (sendResult.getSendStatus()) {\n            case SEND_OK:\n                return new PutMessageResult(PutMessageStatus.PUT_OK, null, true);\n            case SLAVE_NOT_AVAILABLE:\n                return new PutMessageResult(PutMessageStatus.SLAVE_NOT_AVAILABLE, null, true);\n            case FLUSH_DISK_TIMEOUT:\n                return new PutMessageResult(PutMessageStatus.FLUSH_DISK_TIMEOUT, null, true);\n            case FLUSH_SLAVE_TIMEOUT:\n                return new PutMessageResult(PutMessageStatus.FLUSH_SLAVE_TIMEOUT, null, true);\n            default:\n                return new PutMessageResult(PutMessageStatus.PUT_TO_REMOTE_BROKER_FAIL, null, true);\n        }\n    }\n\n    public Pair<GetMessageStatus, MessageExt> getMessage(String topic, long offset, int queueId, String brokerName, boolean deCompressBody) {\n        return getMessageAsync(topic, offset, queueId, brokerName, deCompressBody).join();\n    }\n\n    public CompletableFuture<Pair<GetMessageStatus, MessageExt>> getMessageAsync(String topic, long offset, int queueId, String brokerName, boolean deCompressBody) {\n        MessageStore messageStore = brokerController.getMessageStoreByBrokerName(brokerName);\n        if (messageStore != null) {\n            return messageStore.getMessageAsync(innerConsumerGroupName, topic, queueId, offset, 1, null)\n                .thenApply(result -> {\n                    if (result == null) {\n                        LOG.warn(\"getMessageResult is null , innerConsumerGroupName {}, topic {}, offset {}, queueId {}\", innerConsumerGroupName, topic, offset, queueId);\n                        return new Pair<>(GetMessageStatus.MESSAGE_WAS_REMOVING, null);\n                    }\n                    List<MessageExt> list = decodeMsgList(result, deCompressBody);\n                    if (list == null || list.isEmpty()) {\n                        LOG.warn(\"Can not get msg , topic {}, offset {}, queueId {}, result is {}\", topic, offset, queueId, result);\n                        return new Pair<>(result.getStatus(), null);\n                    }\n                    return new Pair<>(result.getStatus(), list.get(0));\n                });\n        } else {\n            return getMessageFromRemoteAsync(topic, offset, queueId, brokerName)\n                .thenApply(msg -> {\n                    if (msg == null) {\n                        return new Pair<>(GetMessageStatus.MESSAGE_WAS_REMOVING, null);\n                    }\n                    return new Pair<>(GetMessageStatus.FOUND, msg);\n                });\n        }\n    }\n\n    protected List<MessageExt> decodeMsgList(GetMessageResult getMessageResult, boolean deCompressBody) {\n        List<MessageExt> foundList = new ArrayList<>();\n        try {\n            List<ByteBuffer> messageBufferList = getMessageResult.getMessageBufferList();\n            if (messageBufferList != null) {\n                for (int i = 0; i < messageBufferList.size(); i++) {\n                    ByteBuffer bb = messageBufferList.get(i);\n                    if (bb == null) {\n                        LOG.error(\"bb is null {}\", getMessageResult);\n                        continue;\n                    }\n                    MessageExt msgExt = MessageDecoder.decode(bb, true, deCompressBody);\n                    if (msgExt == null) {\n                        LOG.error(\"decode msgExt is null {}\", getMessageResult);\n                        continue;\n                    }\n                    // use CQ offset, not offset in Message\n                    msgExt.setQueueOffset(getMessageResult.getMessageQueueOffset().get(i));\n                    foundList.add(msgExt);\n                }\n            }\n        } finally {\n            getMessageResult.release();\n        }\n\n        return foundList;\n    }\n\n    protected MessageExt getMessageFromRemote(String topic, long offset, int queueId, String brokerName) {\n        return getMessageFromRemoteAsync(topic, offset, queueId, brokerName).join();\n    }\n\n    protected CompletableFuture<MessageExt> getMessageFromRemoteAsync(String topic, long offset, int queueId, String brokerName) {\n        try {\n            String brokerAddr = this.brokerController.getTopicRouteInfoManager().findBrokerAddressInSubscribe(brokerName, MixAll.MASTER_ID, false);\n            if (null == brokerAddr) {\n                this.brokerController.getTopicRouteInfoManager().updateTopicRouteInfoFromNameServer(topic, true, false);\n                brokerAddr = this.brokerController.getTopicRouteInfoManager().findBrokerAddressInSubscribe(brokerName, MixAll.MASTER_ID, false);\n\n                if (null == brokerAddr) {\n                    LOG.warn(\"can't find broker address for topic {}\", topic);\n                    return CompletableFuture.completedFuture(null);\n                }\n            }\n\n            return this.brokerController.getBrokerOuterAPI().pullMessageFromSpecificBrokerAsync(brokerName,\n                brokerAddr, this.innerConsumerGroupName, topic, queueId, offset, 1, DEFAULT_PULL_TIMEOUT_MILLIS)\n                .thenApply(pullResult -> {\n                    if (pullResult.getPullStatus().equals(PullStatus.FOUND) && !pullResult.getMsgFoundList().isEmpty()) {\n                        return pullResult.getMsgFoundList().get(0);\n                    }\n                    return null;\n                });\n        } catch (Exception e) {\n            LOG.error(\"Get message from remote failed.\", e);\n        }\n\n        return CompletableFuture.completedFuture(null);\n    }\n}\n",
            "role": "user"
        },
        {
            "content": "//example/src/main/java/org/apache/rocketmq/example/broadcast/PushConsumer.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.rocketmq.example.broadcast;\n\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.remoting.protocol.heartbeat.MessageModel;\n\npublic class PushConsumer {\n\n    public static final String CONSUMER_GROUP = \"please_rename_unique_group_name_1\";\n    public static final String DEFAULT_NAMESRVADDR = \"127.0.0.1:9876\";\n    public static final String TOPIC = \"TopicTest\";\n\n    public static final String SUB_EXPRESSION = \"TagA || TagC || TagD\";\n\n    public static void main(String[] args) throws InterruptedException, MQClientException {\n\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);\n\n        // Uncomment the following line while debugging, namesrvAddr should be set to your local address\n//        consumer.setNamesrvAddr(DEFAULT_NAMESRVADDR);\n\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n\n        consumer.setMessageModel(MessageModel.BROADCASTING);\n\n        consumer.subscribe(TOPIC, SUB_EXPRESSION);\n\n        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> {\n            System.out.printf(\"%s Receive New Messages: %s %n\", Thread.currentThread().getName(), msgs);\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        });\n\n        consumer.start();\n        System.out.printf(\"Broadcast Consumer Started.%n\");\n    }\n}\n",
            "role": "user"
        },
        {
            "content": "//example/src/main/java/org/apache/rocketmq/example/namespace/PullConsumerWithNamespace.java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.rocketmq.example.namespace;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.rocketmq.client.consumer.DefaultMQPullConsumer;\nimport org.apache.rocketmq.client.consumer.PullResult;\nimport org.apache.rocketmq.common.message.MessageQueue;\n\npublic class PullConsumerWithNamespace {\n\n    public static final String NAMESPACE = \"InstanceTest\";\n    public static final String CONSUMER_GROUP = \"cidTest\";\n    public static final String DEFAULT_NAMESRVADDR = \"127.0.0.1:9876\";\n    public static final String TOPIC = \"NAMESPACE_TOPIC\";\n\n    private static final Map<MessageQueue, Long> OFFSET_TABLE = new HashMap<>();\n\n    public static void main(String[] args) throws Exception {\n        DefaultMQPullConsumer pullConsumer = new DefaultMQPullConsumer(CONSUMER_GROUP);\n        pullConsumer.setNamespaceV2(NAMESPACE);\n        pullConsumer.setNamesrvAddr(DEFAULT_NAMESRVADDR);\n        pullConsumer.start();\n\n        Set<MessageQueue> mqs = pullConsumer.fetchSubscribeMessageQueues(TOPIC);\n        for (MessageQueue mq : mqs) {\n            System.out.printf(\"Consume from the topic: %s, queue: %s%n\", mq.getTopic(), mq);\n            SINGLE_MQ:\n            while (true) {\n                try {\n                    PullResult pullResult =\n                        pullConsumer.pullBlockIfNotFound(mq, null, getMessageQueueOffset(mq), 32);\n                    System.out.printf(\"%s%n\", pullResult);\n\n                    putMessageQueueOffset(mq, pullResult.getNextBeginOffset());\n                    switch (pullResult.getPullStatus()) {\n                        case FOUND:\n                            dealWithPullResult(pullResult);\n                            break;\n                        case NO_MATCHED_MSG:\n                            break;\n                        case NO_NEW_MSG:\n                            break SINGLE_MQ;\n                        case OFFSET_ILLEGAL:\n                            break;\n                        default:\n                            break;\n                    }\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        pullConsumer.shutdown();\n    }\n\n    private static long getMessageQueueOffset(MessageQueue mq) {\n        Long offset = OFFSET_TABLE.get(mq);\n        if (offset != null) {\n            return offset;\n        }\n\n        return 0;\n    }\n\n    private static void dealWithPullResult(PullResult pullResult) {\n        if (null == pullResult || pullResult.getMsgFoundList().isEmpty()) {\n            return;\n        }\n        pullResult.getMsgFoundList().forEach(\n            msg -> System.out.printf(\"Topic is:%s, msgId is:%s%n\", msg.getTopic(), msg.getMsgId()));\n    }\n\n    private static void putMessageQueueOffset(MessageQueue mq, long offset) {\n        OFFSET_TABLE.put(mq, offset);\n    }\n}",
            "role": "user"
        }
    ],
    "model": "gpt-4-1106-preview",
    "response_format": {
        "type": "json_object"
    },
    "temperature": 0.9
}