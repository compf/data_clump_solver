"{
    "key":"public class DefaultMQPushConsumerImpl implements MQConsumerInner {\n\n    private static final Logger log = LoggerFactory.getLogger(DefaultMQPushConsumerImpl.class);\n\n    private final long consumerStartTimestamp = System.currentTimeMillis();\n\n    private final RPCHook rpcHook;\n\n    private final ArrayList<FilterMessageHook> filterMessageHookList = new ArrayList<>();\n\n    private volatile ServiceState serviceState = ServiceState.CREATE_JUST;\n\n    protected MQClientInstance mQClientFactory;\n\n    private PullAPIWrapper pullAPIWrapper;\n\n    private volatile boolean pause = false;\n\n    private boolean consumeOrderly = false;\n\n    private MessageListener messageListenerInner;\n\n    private OffsetStore offsetStore;\n\n    private ConsumeMessageService consumeMessageService;\n\n    private ConsumeMessageService consumeMessagePopService;\n\n    private long queueFlowControlTimes = 0;\n    private long queueMaxSpanFlowControlTimes = 0;\n\n    //10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h\n    private final int[] popDelayLevel = new int[] {10, 30, 60, 120, 180, 240, 300, 360, 420, 480, 540, 600, 1200, 1800, 3600, 7200};\n\n    private static final int MAX_POP_INVISIBLE_TIME = 300000;\n    private static final int MIN_POP_INVISIBLE_TIME = 5000;\n    private static final int ASYNC_TIMEOUT = 3000;\n\n    // only for test purpose, will be modified by reflection in unit test.\n    @SuppressWarnings(\"FieldMayBeFinal\")\n    private static boolean doNotUpdateTopicSubscribeInfoWhenSubscriptionChanged = false;\n\n    public DefaultMQPushConsumerImpl(DefaultMQPushConsumer defaultMQPushConsumer, RPCHook rpcHook) {\n        this.defaultMQPushConsumer = defaultMQPushConsumer;\n        this.rpcHook = rpcHook;\n        this.pullTimeDelayMillsWhenException = defaultMQPushConsumer.getPullTimeDelayMillsWhenException();\n    }\n\n    ...\n}",
    "reason":"size",
    "justification":"The `DefaultMQPushConsumerImpl` class has a large number of fields and methods, which makes it quite large in size. Refactoring could help improve maintainability and readability by breaking down the class into smaller, more focused components.",
    "suggestedName":"PushConsumerContext"
}"