messages:
[
	content:"
	
	I will provide you Java files that contain data clumps.
	Choose one data clump that you think is most important and should be refactored.
	
	A data clump exists if
	1) two methods (in the same or in different classes) have at least 3 common parameters
	    and one of those methods does not override the other,
	
	or  
	2) At least three fields in a class are common with the parameters of a method (in the same or in a different class),
	
	or
	3) Two different classes have at least three common fields
	
	
	Return the key of that data clump.
	Justify your response. 
	Use the following  output format in JSON:
	
	The "reason" attribute should be equal to as follows:
	        "size" -> if you choose the data clump because of its large number of parameters/fields
	        "occurrence" -> if you choose the data clump because it occurs very often and leads to much duplication
	        "affected_files" -> if you choose this data clump because many files are affected by this data clump
	        "domain" -> if you choose this data clump because the variables share a common domain so that extracting a class is a good idea
	        "other" -> if none of the options above fits
	
	### JSON
	{
	    "key":"<a portion of the source code, as submitted, that shows where the data clump is located",,
	    "reason":"<as explained above>,
	    "justification":"<Your justification which explains the 'reason' in more details>",
	    "suggestedName":"<A suitable name for an extracted class if the data clumps variables were to be extracted>"
	
	}
	
	### END JSON
		
",
	role:"
	user	
",
,
	content:"
	//src/argouml-app/src/org/argouml/ui/JasonsBigTheme.java
	/* $Id$
	 *****************************************************************************
	 * Copyright (c) 2009 Contributors - see below
	 * All rights reserved. This program and the accompanying materials
	 * are made available under the terms of the Eclipse Public License v1.0
	 * which accompanies this distribution, and is available at
	 * http://www.eclipse.org/legal/epl-v10.html
	 *
	 * Contributors:
	 *    tfmorris
	 *****************************************************************************
	 *
	 * Some portions of this file was previously release using the BSD License:
	 */
	
	// Copyright (c) 1996-2006 The Regents of the University of California. All
	// Rights Reserved. Permission to use, copy, modify, and distribute this
	// software and its documentation without fee, and without a written
	// agreement is hereby granted, provided that the above copyright notice
	// and this paragraph appear in all copies.  This software program and
	// documentation are copyrighted by The Regents of the University of
	// California. The software program and documentation are supplied "AS
	// IS", without any accompanying services from The Regents. The Regents
	// does not warrant that the operation of the program will be
	// uninterrupted or error-free. The end-user understands that the program
	// was developed for research purposes and is advised not to rely
	// exclusively on the program for any reason.  IN NO EVENT SHALL THE
	// UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
	// SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
	// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
	// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
	// SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
	// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
	// PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
	// CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
	// UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
	
	package org.argouml.ui;
	
	import java.awt.Font;
	import javax.swing.plaf.ColorUIResource;
	import javax.swing.plaf.FontUIResource;
	import javax.swing.plaf.metal.MetalTheme;
	
	/**
	 * This class defines a variation on the default Metal Theme.
	 */
	public class JasonsBigTheme extends MetalTheme {
	
	    private final ColorUIResource primary1 = new ColorUIResource(102, 102, 153);
	    private final ColorUIResource primary2 = new ColorUIResource(153, 153, 204);
	    private final ColorUIResource primary3 = new ColorUIResource(204, 204, 255);
	
	    private final ColorUIResource secondary1 =
		new ColorUIResource(102, 102, 102);
	    private final ColorUIResource secondary2 =
		new ColorUIResource(153, 153, 153);
	    private final ColorUIResource secondary3 =
		new ColorUIResource(204, 204, 204);
	
	    private final FontUIResource controlFont =
		new FontUIResource("SansSerif", Font.PLAIN, 14);
	    private final FontUIResource systemFont =
		new FontUIResource("Dialog", Font.PLAIN, 14);
	    private final FontUIResource windowTitleFont =
		new FontUIResource("SansSerif", Font.BOLD, 14);
	    private final FontUIResource userFont =
		new FontUIResource("SansSerif", Font.PLAIN, 14);
	    private final FontUIResource smallFont =
		new FontUIResource("Dialog", Font.PLAIN, 12);
	
	    /*
	     * @see javax.swing.plaf.metal.MetalTheme#getName()
	     */
	    public String getName() { return "Large Fonts"; }
	
	    // these are blue in Metal Default Theme
	    /*
	     * @see javax.swing.plaf.metal.MetalTheme#getPrimary1()
	     */
	    protected ColorUIResource getPrimary1() { return primary1; }
	
	    /*
	     * @see javax.swing.plaf.metal.MetalTheme#getPrimary2()
	     */
	    protected ColorUIResource getPrimary2() { return primary2; }
	
	    /*
	     * @see javax.swing.plaf.metal.MetalTheme#getPrimary3()
	     */
	    protected ColorUIResource getPrimary3() { return primary3; }
	
	    // these are gray in Metal Default Theme
	    /*
	     * @see javax.swing.plaf.metal.MetalTheme#getSecondary1()
	     */
	    protected ColorUIResource getSecondary1() { return secondary1; }
	
	    /*
	     * @see javax.swing.plaf.metal.MetalTheme#getSecondary2()
	     */
	    protected ColorUIResource getSecondary2() { return secondary2; }
	
	    /*
	     * @see javax.swing.plaf.metal.MetalTheme#getSecondary3()
	     */
	    protected ColorUIResource getSecondary3() { return secondary3; }
	
	    /*
	     * @see javax.swing.plaf.metal.MetalTheme#getControlTextFont()
	     */
	    public FontUIResource getControlTextFont() { return controlFont; }
	
	    /*
	     * @see javax.swing.plaf.metal.MetalTheme#getSystemTextFont()
	     */
	    public FontUIResource getSystemTextFont() { return systemFont; }
	
	    /*
	     * @see javax.swing.plaf.metal.MetalTheme#getUserTextFont()
	     */
	    public FontUIResource getUserTextFont() { return userFont; }
	
	    /*
	     * @see javax.swing.plaf.metal.MetalTheme#getMenuTextFont()
	     */
	    public FontUIResource getMenuTextFont() { return controlFont; }
	
	    /*
	     * @see javax.swing.plaf.metal.MetalTheme#getSubTextFont()
	     */
	    public FontUIResource getSubTextFont() { return smallFont; }
	
	    /*
	     * @see javax.swing.plaf.metal.MetalTheme#getWindowTitleFont()
	     */
	    public FontUIResource getWindowTitleFont() { return windowTitleFont; }
	}
		
",
	role:"
	user	
",
,
	content:"
	//src/argouml-app/src/org/argouml/ui/JasonsHugeTheme.java
	/* $Id$
	 *****************************************************************************
	 * Copyright (c) 2009 Contributors - see below
	 * All rights reserved. This program and the accompanying materials
	 * are made available under the terms of the Eclipse Public License v1.0
	 * which accompanies this distribution, and is available at
	 * http://www.eclipse.org/legal/epl-v10.html
	 *
	 * Contributors:
	 *    tfmorris
	 *****************************************************************************
	 *
	 * Some portions of this file was previously release using the BSD License:
	 */
	
	// Copyright (c) 1996-2006 The Regents of the University of California. All
	// Rights Reserved. Permission to use, copy, modify, and distribute this
	// software and its documentation without fee, and without a written
	// agreement is hereby granted, provided that the above copyright notice
	// and this paragraph appear in all copies.  This software program and
	// documentation are copyrighted by The Regents of the University of
	// California. The software program and documentation are supplied "AS
	// IS", without any accompanying services from The Regents. The Regents
	// does not warrant that the operation of the program will be
	// uninterrupted or error-free. The end-user understands that the program
	// was developed for research purposes and is advised not to rely
	// exclusively on the program for any reason.  IN NO EVENT SHALL THE
	// UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
	// SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
	// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
	// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
	// SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
	// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
	// PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
	// CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
	// UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
	
	package org.argouml.ui;
	
	import java.awt.Font;
	import javax.swing.plaf.ColorUIResource;
	import javax.swing.plaf.FontUIResource;
	import javax.swing.plaf.metal.MetalTheme;
	
	/**
	 * This class defines a variation on the default Metal Theme.
	 */
	public class JasonsHugeTheme extends MetalTheme {
	
	    private final ColorUIResource primary1 = new ColorUIResource(102, 102, 153);
	    private final ColorUIResource primary2 = new ColorUIResource(153, 153, 204);
	    private final ColorUIResource primary3 = new ColorUIResource(204, 204, 255);
	
	    private final ColorUIResource secondary1 =
		new ColorUIResource(102, 102, 102);
	    private final ColorUIResource secondary2 =
		new ColorUIResource(153, 153, 153);
	    private final ColorUIResource secondary3 =
		new ColorUIResource(204, 204, 204);
	
	    private final FontUIResource controlFont =
		new FontUIResource("SansSerif", Font.BOLD, 16);
	    private final FontUIResource systemFont =
		new FontUIResource("Dialog", Font.PLAIN, 16);
	    private final FontUIResource windowTitleFont =
		new FontUIResource("SansSerif", Font.BOLD, 16);
	    private final FontUIResource userFont =
		new FontUIResource("SansSerif", Font.PLAIN, 16);
	    private final FontUIResource smallFont =
		new FontUIResource("Dialog", Font.PLAIN, 14);
	
	    /*
	     * @see javax.swing.plaf.metal.MetalTheme#getName()
	     */
	    public String getName() { return "Very Large Fonts"; }
	
	    // these are blue in Metal Default Theme
	    /*
	     * @see javax.swing.plaf.metal.MetalTheme#getPrimary1()
	     */
	    protected ColorUIResource getPrimary1() { return primary1; }
	
	    /*
	     * @see javax.swing.plaf.metal.MetalTheme#getPrimary2()
	     */
	    protected ColorUIResource getPrimary2() { return primary2; }
	    /*
	     * @see javax.swing.plaf.metal.MetalTheme#getPrimary3()
	     */
	    protected ColorUIResource getPrimary3() { return primary3; }
	
	    // these are gray in Metal Default Theme
	    /*
	     * @see javax.swing.plaf.metal.MetalTheme#getSecondary1()
	     */
	    protected ColorUIResource getSecondary1() { return secondary1; }
	
	    /*
	     * @see javax.swing.plaf.metal.MetalTheme#getSecondary2()
	     */
	    protected ColorUIResource getSecondary2() { return secondary2; }
	
	    /*
	     * @see javax.swing.plaf.metal.MetalTheme#getSecondary3()
	     */
	    protected ColorUIResource getSecondary3() { return secondary3; }
	
	    /*
	     * @see javax.swing.plaf.metal.MetalTheme#getControlTextFont()
	     */
	    public FontUIResource getControlTextFont() { return controlFont; }
	
	    /*
	     * @see javax.swing.plaf.metal.MetalTheme#getSystemTextFont()
	     */
	    public FontUIResource getSystemTextFont() { return systemFont; }
	
	    /*
	     * @see javax.swing.plaf.metal.MetalTheme#getUserTextFont()
	     */
	    public FontUIResource getUserTextFont() { return userFont; }
	
	    /*
	     * @see javax.swing.plaf.metal.MetalTheme#getMenuTextFont()
	     */
	    public FontUIResource getMenuTextFont() { return controlFont; }
	
	    /*
	     * @see javax.swing.plaf.metal.MetalTheme#getSubTextFont()
	     */
	    public FontUIResource getSubTextFont() { return smallFont; }
	
	    /*
	     * @see javax.swing.plaf.metal.MetalTheme#getWindowTitleFont()
	     */
	    public FontUIResource getWindowTitleFont() { return windowTitleFont; }
	}
		
",
	role:"
	user	
",
,
	content:"
	//src/argouml-core-model/src/org/argouml/model/CoreFactory.java
	/* $Id$
	 *******************************************************************************
	 * Copyright (c) 2009,2010 Contributors - see below
	 * All rights reserved. This program and the accompanying materials
	 * are made available under the terms of the Eclipse Public License v1.0
	 * which accompanies this distribution, and is available at
	 * http://www.eclipse.org/legal/epl-v10.html
	 *
	 * Contributors:
	 *    Tom Morris
	 *    Thomas Neustupny
	 *******************************************************************************
	 *
	 * Some portions of this file was previously release using the BSD License:
	 */
	
	// Copyright (c) 2005-2007 The Regents of the University of California. All
	// Rights Reserved. Permission to use, copy, modify, and distribute this
	// software and its documentation without fee, and without a written
	// agreement is hereby granted, provided that the above copyright notice
	// and this paragraph appear in all copies. This software program and
	// documentation are copyrighted by The Regents of the University of
	// California. The software program and documentation are supplied "AS
	// IS", without any accompanying services from The Regents. The Regents
	// does not warrant that the operation of the program will be
	// uninterrupted or error-free. The end-user understands that the program
	// was developed for research purposes and is advised not to rely
	// exclusively on the program for any reason. IN NO EVENT SHALL THE
	// UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
	// SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
	// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
	// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
	// SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
	// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
	// PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
	// CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
	// UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
	
	package org.argouml.model;
	
	import java.util.List;
	
	
	/**
	 * The interface to the factory for the Core.
	 */
	public interface CoreFactory extends Factory {
	    
	    /**
	     * The name of the stereotype for a Realization.
	     */
	    public String REALIZE_STEREOTYPE = "realize"; //$NON-NLS-1$
	    
	    /**
	     * Create an empty but initialized instance of a UML Abstraction.
	     * 
	     * @return an initialized UML Abstraction instance.
	     * TODO: This needs an extra parameter to specify the model/extent where
	     * the new element should be created.
	     */
	    public Object createAbstraction();
	    
	    /**
	     * Build an empty but initialized instance of a UML Abstraction
	     * with a given name.
	     *
	     * @param name The name.
	     * @return an initialized UML Abstraction instance.
	     * @param supplier the supplier of the abstraction
	     * @param client the client of the abstraction
	     */
	    Object buildAbstraction(String name, Object supplier, Object client);
	
	    /**
	     * Create an empty but initialized instance of an Artifact
	     * 
	     * @since UML 1.4
	     * @return an initialized Artifact instance.
	     * TODO: This needs an extra parameter to specify the model/extent where
	     * the new element should be created.
	     */
	    public Object createArtifact();
	    
	    /**
	     * Create an empty but initialized instance of a UML Association.
	     * 
	     * @return an initialized UML Association instance.
	     * @deprecated for 0.26 by tfmorris. Use {@link #createAssociation(Object)}.
	     */
	    public Object createAssociation();
	    
	    /**
	     * Create an empty but initialized instance of a UML Association.
	     * 
	     * @param extent outer package (extent) in which to create new Association.
	     * @return an initialized UML Association instance.
	     */
	    public Object createAssociation(Object extent);
	    
	    /**
	     * Create an empty but initialized instance of a UML AssociationClass.
	     * 
	     * @return an initialized UML AssociationClass instance.
	     * TODO: This needs an extra parameter to specify the model/extent where
	     * the new element should be created.
	     */
	    public Object createAssociationClass();
	    
	    /**
	     * Create an empty but initialized instance of a UML AssociationEnd.
	     *
	     * @return an initialized UML AssociationEnd instance.
	     * TODO: This needs an extra parameter to specify the model/extent where
	     * the new element should be created.
	     */
	    Object createAssociationEnd();
	
	    /**
	     * Create an empty but initialized instance of a UML Attribute.
	     *
	     * @return an initialized UML Attribute instance.
	     * TODO: This needs an extra parameter to specify the model/extent where
	     * the new element should be created.
	     */
	    Object createAttribute();
	
	    /**
	     * Create an empty but initialized instance of a UML Binding.
	     *
	     * @return an initialized UML Binding instance.
	     * TODO: This needs an extra parameter to specify the model/extent where
	     * the new element should be created.
	     */
	    Object createBinding();
	
	    /**
	     * Create an empty but initialized instance of a UML Class.
	     *
	     * @return an initialized UML Class instance.
	     * TODO: This needs an extra parameter to specify the model/extent where
	     * the new element should be created.
	     */
	    Object createClass();
	
	    /**
	     * Create an empty but initialized instance of a UML Comment.
	     *
	     * @return an initialized UML Comment instance.
	     * TODO: This needs an extra parameter to specify the model/extent where
	     * the new element should be created.
	     */
	    Object createComment();
	
	    /**
	     * Create an empty but initialized instance of a UML Component.
	     *
	     * @return an initialized UML Component instance.
	     * TODO: This needs an extra parameter to specify the model/extent where
	     * the new element should be created.
	     */
	    Object createComponent();
	
	    /**
	     * Create an empty but initialized instance of a UML Constraint.
	     *
	     * @return an initialized UML Constraint instance.
	     * TODO: This needs an extra parameter to specify the model/extent where
	     * the new element should be created.
	     */
	    Object createConstraint();
	
	    /**
	     * Create an empty but initialized instance of a UML DataType.
	     *
	     * @return an initialized UML DataType instance.
	     * TODO: This needs an extra parameter to specify the model/extent where
	     * the new element should be created.
	     */
	    Object createDataType();
	    
	    /**
	    * Create an empty but initialized instance of a UML Dependency.
	    *
	    * @return an initialized UML Dependency instance.
	     * TODO: This needs an extra parameter to specify the model/extent where
	     * the new element should be created.
	    */
	    public Object createDependency();
	
	    /**
	     * Create an empty but initialized instance of a UML ElementResidence.
	     *
	     * @return an initialized UML ElementResidence instance.
	     * TODO: This needs an extra parameter to specify the model/extent where
	     * the new element should be created.
	     */
	    Object createElementResidence();
	    
	    /**
	     * @param me the modelelement
	     * @param component the component
	     * @return an initialized UML ElementResidence instance.
	     */
	    public Object buildElementResidence(Object me, Object component);
	    
	    /**
	     * Create an Enumeration.
	     * @return Object new Enumeration
	     * @since UML 1.4
	     * TODO: This needs an extra parameter to specify the model/extent where
	     * the new element should be created.
	     */
	    Object createEnumeration();
	
	    /**
	     * Create an EnumerationLiteral.
	     * @return Object new Enumeration
	     * @since UML 1.4
	     * TODO: This needs an extra parameter to specify the model/extent where
	     * the new element should be created.
	     */
	    Object createEnumerationLiteral();
	
	    /**
	     * Create an empty but initialized instance of a UML Flow.
	     *
	     * @return an initialized UML Flow instance.
	     * TODO: This needs an extra parameter to specify the model/extent where
	     * the new element should be created.
	     */
	    Object createFlow();
	
	    /**
	     * Create an empty but initialized instance of a UML Interface.
	     *
	     * @return an initialized UML Interface instance.
	     * TODO: This needs an extra parameter to specify the model/extent where
	     * the new element should be created.
	     */
	    Object createInterface();
	
	    /**
	     * Create an empty but initialized instance of a UML Method.
	     *
	     * @return an initialized UML Method instance.
	     * TODO: This needs an extra parameter to specify the model/extent where
	     * the new element should be created.
	     */
	    Object createMethod();
	
	    /**
	     * Create an empty but initialized instance of a UML Node.
	     *
	     * @return an initialized UML Node instance.
	     * TODO: This needs an extra parameter to specify the model/extent where
	     * the new element should be created.
	     */
	    Object createNode();
	
	    /**
	     * Create an empty but initialized instance of a UML Operation.
	     *
	     * @return an initialized UML Operation instance.
	     * TODO: This needs an extra parameter to specify the model/extent where
	     * the new element should be created.
	     */
	    Object createOperation();
	
	    /**
	     * Create an empty but initialized instance of a UML Parameter.
	     *
	     * @return an initialized UML Parameter instance.
	     * TODO: This needs an extra parameter to specify the model/extent where
	     * the new element should be created.
	     */
	    Object createParameter();
	
	    /**
	     * Create an empty but initialized instance of a UML Permission.
	     *
	     * @return an initialized UML Permission instance.
	     * TODO: This needs an extra parameter to specify the model/extent where
	     * the new element should be created.
	     * @deprecated for 0.27.3 by tfmorris.  Renamed in UML 2.x to PackageImport.
	     * Use {@link #createPackageImport()}.
	     */
	    @Deprecated
	    Object createPermission();
	    
	    /**
	     * Create an empty but initialized instance of a UML Permission.
	     *
	     * @return an initialized UML Permission instance.
	     * TODO: This needs an extra parameter to specify the model/extent where
	     * the new element should be created.
	     */
	    Object createPackageImport();
	    
	    /**
	     * Create a UML PrimitiveType.
	     * 
	     * @since UML 2.1.1
	     * @return an initialized UML Primitive instance.
	     * TODO: This needs an extra parameter to specify the model/extent where
	     * the new element should be created.
	     */
	    public Object createPrimitiveType();
	    
	
	    /**
	     * Create a UML TemplateArgument.
	     * 
	     * @since UML 1.4
	     * @return an initialized TemplateArgument instance.
	     * TODO: This needs an extra parameter to specify the model/extent where
	     * the new element should be created.
	     */
	    public Object createTemplateArgument();
	
	    /**
	     * Create an empty but initialized instance of a UML TemplateParameter.
	     *
	     * @return an initialized UML TemplateParameter instance.
	     * TODO: This needs an extra parameter to specify the model/extent where
	     * the new element should be created.
	     */
	    Object createTemplateParameter();
	
	    /**
	     * Create an empty but initialized instance of a UML Usage.
	     *
	     * @return an initialized UML Usage instance.
	     * TODO: This needs an extra parameter to specify the model/extent where
	     * the new element should be created.
	     */
	    Object createUsage();
	
	    /**
	     * Builds a binary associationrole on basis of two classifierroles,
	     * navigation and aggregation.
	     *
	     * @param fromClassifier   the first given classifier
	     * @param aggregationKind1 the first aggregationkind
	     * @param toClassifier     the second given classifier
	     * @param aggregationKind2 the second aggregationkind
	     * @param unidirectional true if unidirectional
	     * @return the newly build binary associationrole
	     * @deprecated for 0.27.3 by tfmorris.  Use 
	     * {@link #buildAssociation(Object, Object, Object, Object, boolean)}.
	     */
	    @Deprecated
	    Object buildAssociation(Object fromClassifier, Object aggregationKind1,
	            Object toClassifier, Object aggregationKind2,
	            Boolean unidirectional);
	
	
	    /**
	     * Builds a binary associationrole on basis of two classifierroles,
	     * navigation and aggregation.
	     *
	     * @param fromClassifier   the first given classifier
	     * @param aggregationKind1 the first aggregationkind
	     * @param toClassifier     the second given classifier
	     * @param aggregationKind2 the second aggregationkind
	     * @param unidirectional true if unidirectional
	     * @return the newly build binary associationrole
	     */
	    Object buildAssociation(Object fromClassifier, Object aggregationKind1,
	            Object toClassifier, Object aggregationKind2,
	            boolean unidirectional);
	
	    /**
	     * Builds a binary associations between two classifiers with
	     * default values for the association ends and the association
	     * itself.<p>
	     *
	     * @param classifier1 The first classifier to connect
	     * @param classifier2 The second classifier to connect
	     * @return Association
	     */
	    Object buildAssociation(Object classifier1, Object classifier2);
	
	    /**
	     * Builds a binary association with a direction, aggregation
	     * and a given name.
	     *
	     * @param c1 The first classifier to connect to
	     * @param nav1 The navigability of the Associaton end
	     * @param c2 The second classifier to connect to
	     * @param nav2 The navigability of the second Associaton end
	     * @param name the given name
	     * @return association
	     */
	    Object buildAssociation(Object c1, boolean nav1, Object c2, boolean nav2,
	            String name);
	
	    /**
	     * Builds an associationClass between classifier end1 and end2 with a
	     * default class.<p>
	     *
	     * @param end1 the first given classifier
	     * @param end2 the second given classifier
	     * @return AssociationClass
	     */
	    Object buildAssociationClass(Object end1, Object end2);
	
	    /**
	     * Builds a fully configurable association end. All variables for
	     * an associationend can be given as parameter.
	     * @param assoc The associaton this end will be part of
	     * @param name The name of the association end
	     * @param type The type (classifier) the end will connect. The end
	     * is a connection piece between an association and a classifier
	     * @param multi The multiplicity
	     * @param stereo The stereotype
	     * @param navigable The navigability. True if this association end
	     *                  can be 'passed' from the other classifier.
	     * @param order Ordering of the association
	     * @param aggregation the aggregationkind
	     * @param scope the scope kind
	     * @param changeable the changeablekind
	     * @param visibility the visibilitykind
	     * @return AssociationEnd
	     */
	    @Deprecated
	    Object buildAssociationEnd(
	        Object assoc,
	        String name,
	        Object type,
	        Object multi,
	        Object stereo,
	        boolean navigable,
	        Object order,
	        Object aggregation,
	        Object scope,
	        Object changeable,
	        Object visibility);
	
	    /**
	     * Builds a fully configurable association end. All variables for
	     * an associationend can be given as parameter.
	     * @param assoc The associaton this end will be part of
	     * @param name The name of the association end
	     * @param type The type (classifier) the end will connect. The end
	     * is a connection piece between an association and a classifier
	     * @param multiplicity array of two integers containing lower and upper bound
	     * @param stereo The stereotype
	     * @param navigable The navigability. True if this association end
	     *                  can be 'passed' from the other classifier.
	     * @param order Ordering of the association
	     * @param aggregation the aggregationkind
	     * @param scope the scope kind
	     * @param changeable the changeablekind
	     * @param visibility the visibilitykind
	     * @return AssociationEnd
	     */
	    Object buildAssociationEnd(
	        Object assoc,
	        String name,
	        Object type,
	        Integer[] multiplicity,
	        Object stereo,
	        boolean navigable,
	        Object order,
	        Object aggregation,
	        Object scope,
	        Object changeable,
	        Object visibility);
	    
	    /**
	     * Builds a simply configured association end.
	     *
	     * @param type the given classifier
	     * @param assoc the given association
	     * @return the newly build associationend
	     */
	    Object buildAssociationEnd(Object type, Object assoc);
	
	    /**
	     * Builds a default attribute.
	     *
	     * @param model The model the attribute belongs to.
	     * @param type The type of the attribute.
	     * @return The newly built attribute.
	     */
	    Object buildAttribute(Object model, Object type);
	
	    /**
	     * Builds a default attribute.
	     *
	     * @param type The type of the attribute.
	     * @return The newly built attribute.
	     */
	    Object buildAttribute2(Object type);
	    
	
	    /**
	     * Builds an attribute of the given type owned by a classifier.
	     *
	     * @param classifier the classifier which will own the new attribute
	     * @param type the type
	     * @return the newly built attribute
	     */
	    Object buildAttribute2(Object classifier, Object type);
	    
	    /**
	     * Builds a default implementation for a class. The class is not owned by
	     * any model element by default. Users should not forget to add ownership.
	     *
	     * @return newly created Class
	     * TODO: This needs an extra parameter to specify the model/extent where
	     * the new element should be created.
	     */
	    Object buildClass();
	
	    /**
	     * Builds a class with a given namespace.
	     *
	     * @param owner the namespace
	     * @return Class
	     * @see #buildClass()
	     */
	    Object buildClass(Object owner);
	
	    /**
	     * Builds a class with a given name.
	     *
	     * @param name the given name
	     * @return Class
	     * @see #buildClass()
	     * TODO: This needs an extra parameter to specify the model/extent where
	     * the new element should be created.
	     */
	    Object buildClass(String name);
	
	    /**
	     * Builds a class with a given name and namespace.
	     *
	     * @param name the given name
	     * @param owner the namespace
	     * @return Class
	     * @see #buildClass()
	     */
	    Object buildClass(String name, Object owner);
	
	    /**
	     * Builds a default implementation for an interface. The interface
	     * is not owned by any model element by default. Users should not
	     * forget to add ownership.
	     *
	     * @return Interface
	     * TODO: This needs an extra parameter to specify the model/extent where
	     * the new element should be created.
	     */
	    Object buildInterface();
	
	    /**
	     * Builds an interface with a given namespace.
	     *
	     * @param owner is the owner
	     * @return Interface
	     */
	    Object buildInterface(Object owner);
	
	    /**
	     * Builds an interface with a given name.
	     *
	     * @param name is the given name.
	     * @return Interface
	     * TODO: This needs an extra parameter to specify the model/extent where
	     * the new element should be created.
	     */
	    Object buildInterface(String name);
	
	    /**
	     * Builds an interface with a given name and namespace.
	     *
	     * @param name is the given name
	     * @param owner is the namespace
	     * @return Interface
	     */
	    Object buildInterface(String name, Object owner);
	
	    /**
	     * Builds a datatype with a given name and namespace.
	     *
	     * @param name is the name
	     * @param owner is the namespace
	     * @return an initialized UML DataType instance.
	     */
	    Object buildDataType(String name, Object owner);
	    
	    /**
	     * @param name is the name
	     * @param owner is the namespace
	     * @return an initialized UML Enumeration instance
	     * @since UML 1.4
	     */
	    Object buildEnumeration(String name, Object owner);
	    
	    /**
	     * @param name is the name
	     * @param enumeration is the enumeration of the literal
	     * @return an initialized UML EnumerationLiteral instance
	     * @since UML 1.4
	     */
	    Object buildEnumerationLiteral(String name, Object enumeration);
	
	    /**
	     * Builds a modelelement dependency between two modelelements.<p>
	     *
	     * @param clientObj is the client
	     * @param supplierObj is the supplier
	     * @return Dependency
	     */
	    Object buildDependency(Object clientObj, Object supplierObj);
	
	
	    /**
	     * Build an import Permission between a Namespace and a Package. All model
	     * elements in the supplier namespace will be added to the client namespace.
	     * The Permission will be placed in the client namespace.
	     * <p>
	     * UML 1.4 spec - "Import is a stereotyped permission dependency between two
	     * namespaces, denoting that the public contents of the target package are
	     * added to the namespace of the source package."
	     * <p>
	     * NOTE: For compatibility with UML 2.x, we adopt the slightly stricter
	     * requirement that the target namespace must be a Package.
	     * 
	     * @param client
	     *                is the client Namespace
	     * @param supplier
	     *                is the supplier Package
	     * @return Permission
	     */
	    Object buildPackageImport(Object client, Object supplier);
	
	
	    /**
	     * Build an access Permission between a Namespace and a Package. All model
	     * elements in the supplier namespace will be accessible from the client
	     * namespace, but they are not added to the client namespace. The Permission
	     * will be placed in the client namespace.
	     * <p>
	     * UML 1.4 spec - "Access is a stereotyped permission dependency between two
	     * namespaces, denoting that the public contents of the target namespace are
	     * accessible to the namespace of the source package."
	     * <p>
	     * NOTE: For compatibility with UML 2.x, we adopt the slightly stricter
	     * requirement that the target namespace must be a Package. In UML 2.x, this
	     * translates to a packageImport with non-public visibility.
	     * 
	     * @param client
	     *                is the client Namespace
	     * @param supplier
	     *                is the supplier Package
	     * @return Permission
	     */
	    Object buildPackageAccess(Object client, Object supplier);
	
	    
	    /**
	     * Builds a generalization between a parent and a child. Does not check if
	     * multiple inheritance is allowed for the current notation.
	     *
	     * @param child is the child
	     * @param parent is the parent
	     * @return Generalization
	     */
	    Object buildGeneralization(Object child, Object parent);
	
	
	    /**
	     * Builds a manifestation of an element for an artifact.
	     *
	     * @param utilizedElement is the packageable element
	     * @return manifestation
	     * TODO: This needs an extra parameter to specify the model/extent where
	     * the new element should be created.
	     */
	    Object buildManifestation(Object utilizedElement);
	
	
	    /**
	     * Builds a method with a given name.
	     *
	     * @param name is the given name
	     * @return method
	     * TODO: This needs an extra parameter to specify the model/extent where
	     * the new element should be created.
	     */
	    Object buildMethod(String name);
	
	
	    /**
	     * Builds an operation for a classifier.
	     *
	     * @param classifier is the given classifier
	     * @param returnType the type of the return parameter
	     * @return the operation
	     */
	    Object buildOperation(Object classifier, Object returnType);
	
	
	    /**
	     * Builds an operation with a given name for classifier.
	     * <p>
	     * NOTE: This is given a new method name so there won't be a name clash for
	     * the case where the old 3-param method was called with null arguments.
	     * <p>
	     * 
	     * @param cls
	     *            is the classifier that shall own the operation
	     * @param returnType
	     *            the type of the return parameter
	     * @param name
	     *            the given name for the operation
	     * @return the operation
	     */
	    Object buildOperation2(Object cls, Object returnType, String name);
	
	
	    /**
	     * Adds a parameter initialized to default values to a given event
	     * or behavioral feature or objectFlowState.
	     *
	     * @param o an event or behavioral feature or objectFlowState
	     * @param type the type of the parameter or null
	     * @return the parameter
	     */
	    Object buildParameter(Object o, Object type);
	    
	    /**
	     * Builds a realization between some supplier (for example an
	     * interface in Java) and a client who implements the realization.
	     *
	     * @param client is the client
	     * @param supplier is the supplier
	     * @param namespace the namespace to use if client and
	     * supplier are of different namespace
	     * @return Object the created abstraction
	     */
	    Object buildRealization(Object client, Object supplier, Object namespace);
	
	    /**
	     * Build a TemplateArgument which has the given element as its modelElement.
	     * <p>
	     * <em>NOTE:</em> Although it's not shown in the UML 1.4 spec, a
	     * TemplateArgument is a value (like MultiplicityRange), not a ModelElement
	     * and can not be reused in multiple instances. The UML diagrams don't show
	     * it as a composition, but it effectively is.
	     * 
	     * @param element
	     *            ModelElement to be used as argument
	     * @return newly created TemplateArgument
	     */
	    Object buildTemplateArgument(Object element);
	    
	    /**
	     * Build a TemplateArgument which has the given element as its modelElement.
	     * <p>
	     * <em>NOTE:</em> Although it's not shown in the UML 1.4 spec, a
	     * TemplateArgument is a value (like MultiplicityRange), not a ModelElement
	     * and can not be reused in multiple instances. The UML diagrams don't show
	     * it as a composition, but it effectively is.
	     * 
	     * @param binding Binding which will own this Template Argument
	     * @param argument
	     *            ModelElement to be used as argument
	     * @return newly created TemplateArgument
	     */
	    Object buildTemplateArgument(Object binding, Object argument);
	    
	    /**
	     * Build a TemplateParameter which has the given template and parameter and
	     * 
	     * @param template ModelElement which will be template
	     * @param parameter ModelElement which will be parameter. The only two two
	     *            things of significance are its type and name
	     * @param defaultElement an optional default Model Element which will be
	     *            used if not value is given in a Binding. Null if not used.
	     * 
	     * @param element ModelElement to be used as argument
	     * @return newly created TemplateParameter
	     */
	    Object buildTemplateParameter(Object template, Object parameter, 
	            Object defaultElement);
	    
	    /**
	     * Builds a usage between some client and a supplier. If client
	     * and supplier do not have the same model, an
	     * {@link IllegalArgumentException} is thrown.
	     *
	     * @param client is the client
	     * @param supplier is the supplier
	     * @return Usage
	     */
	    Object buildUsage(Object client, Object supplier);
	
	    /**
	     * Builds a comment inluding a reference to the given modelelement
	     * to comment.  If the element is null, the comment is still build
	     * since it is not mandatory to have an annotated element in the
	     * comment.<p>
	     *
	     * @param element is the model element
	     * @param model the namespace for the comment
	     * @return MComment
	     */
	    Object buildComment(Object element, Object model);
	
	    /**
	     * Builds a constraint that constraints the given modelelement.
	     * The namespace of the constraint will be the same as the
	     * namespace of the given modelelement.<p>
	     *
	     * @param constrElement The constrained element.
	     * @return Constraint
	     */
	    Object buildConstraint(Object constrElement);
	
	    /**
	     * Builds a constraint with a given name and boolean expression.<p>
	     *
	     * @param name is the given name
	     * @param bexpr boolean expression
	     * @return constraint
	     */
	    Object buildConstraint(String name, Object bexpr);
	    
	    /**
	     * Build binding between a supplier template element and its parameterized
	     * client using the given list or arguments to fill the template.
	     * 
	     * @param client
	     *            ModelElement to become client. A given ModelElement may only
	     *            participate as a client in a single Binding.
	     * @param supplier
	     *            template ModelElement to be parameterized
	     * @param arguments
	     *            list of argument used to fill the parameters. Number, order,
	     *            and type must match those of the TemplateParameters for the
	     *            supplier. A null may be passed to not create arguments at
	     *            build time.
	     * @return the newly created Binding
	     */
	    Object buildBinding(Object client, Object supplier, List arguments);
	
	    /**
	     * Copies a class, and it's features. This may also require other
	     * classifiers to be copied.
	     *
	     * @param source is the class to copy.
	     * @param ns is the namespace to put the copy in.
	     * @return a newly created class.
	     */
	    Object copyClass(Object source, Object ns);
	
	    /**
	     * Copies a feature from one classifier to another.
	     *
	     * @param source is the feature to copy.
	     * @param classifier is the classifier to put the copy in.
	     * @return a newly created feature.
	     */
	    Object copyFeature(Object source, Object classifier);
	
	    /**
	     * Copies a datatype, and it's features. This may also require other
	     * classifiers to be copied.
	     *
	     * @param source is the datatype to copy.
	     * @param ns is the namespace to put the copy in.
	     * @return a newly created data type.
	     */
	    Object copyDataType(Object source, Object ns);
	
	    /**
	     * Copies an interface, and it's features. This may also require other
	     * classifiers to be copied.
	     *
	     * @param source is the interface to copy.
	     * @param ns is the namespace to put the copy in.
	     * @return a newly created interface.
	     */
	    Object copyInterface(Object source, Object ns);
	
	    /**
	     * Additional support for generalization.
	     *
	     * @return A generalization.
	     * @deprecated for 0.26 by tfmorris.  Use 
	     * {@link #createGeneralization(Object)}.
	     */
	    Object createGeneralization();
	
	    /**
	     * Create a generalization in the given extent.
	     * 
	     * @param extent the extent in which the generalization should be created
	     * @return A generalization.
	     */
	    Object createGeneralization(Object extent);
	}
		
",
	role:"
	user	
",
,
	content:"
	//src/argouml-core-model-mdr/src/org/argouml/model/mdr/CoreFactoryMDRImpl.java
	/* $Id$
	 *****************************************************************************
	 * Copyright (c) 2009-2012 Contributors - see below
	 * All rights reserved. This program and the accompanying materials
	 * are made available under the terms of the Eclipse Public License v1.0
	 * which accompanies this distribution, and is available at
	 * http://www.eclipse.org/legal/epl-v10.html
	 *
	 * Contributors:
	 *    bobtarling
	 *    Thomas Neustupny
	 *    Tom Morris
	 *****************************************************************************
	 *
	 * Some portions of this file was previously release using the BSD License:
	 */
	
	// Copyright (c) 1996-2009 The Regents of the University of California. All
	// Rights Reserved. Permission to use, copy, modify, and distribute this
	// software and its documentation without fee, and without a written
	// agreement is hereby granted, provided that the above copyright notice
	// and this paragraph appear in all copies.  This software program and
	// documentation are copyrighted by The Regents of the University of
	// California. The software program and documentation are supplied "AS
	// IS", without any accompanying services from The Regents. The Regents
	// does not warrant that the operation of the program will be
	// uninterrupted or error-free. The end-user understands that the program
	// was developed for research purposes and is advised not to rely
	// exclusively on the program for any reason.  IN NO EVENT SHALL THE
	// UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
	// SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
	// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
	// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
	// SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
	// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
	// PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
	// CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
	// UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
	
	package org.argouml.model.mdr;
	
	import java.util.ArrayList;
	import java.util.Collection;
	import java.util.Iterator;
	import java.util.List;
	import java.util.logging.Level;
	import java.util.logging.Logger;
	
	import javax.jmi.reflect.InvalidObjectException;
	import javax.jmi.reflect.RefObject;
	
	import org.argouml.model.CoreFactory;
	import org.argouml.model.Model;
	import org.argouml.model.ModelCommand;
	import org.argouml.model.ModelManagementHelper;
	import org.argouml.model.NotImplementedException;
	import org.omg.uml.behavioralelements.activitygraphs.ObjectFlowState;
	import org.omg.uml.behavioralelements.commonbehavior.Reception;
	import org.omg.uml.behavioralelements.commonbehavior.Signal;
	import org.omg.uml.behavioralelements.statemachines.Event;
	import org.omg.uml.foundation.core.Abstraction;
	import org.omg.uml.foundation.core.Artifact;
	import org.omg.uml.foundation.core.AssociationClass;
	import org.omg.uml.foundation.core.AssociationEnd;
	import org.omg.uml.foundation.core.Attribute;
	import org.omg.uml.foundation.core.BehavioralFeature;
	import org.omg.uml.foundation.core.Binding;
	import org.omg.uml.foundation.core.Classifier;
	import org.omg.uml.foundation.core.Comment;
	import org.omg.uml.foundation.core.Component;
	import org.omg.uml.foundation.core.Constraint;
	import org.omg.uml.foundation.core.CorePackage;
	import org.omg.uml.foundation.core.DataType;
	import org.omg.uml.foundation.core.Dependency;
	import org.omg.uml.foundation.core.Element;
	import org.omg.uml.foundation.core.ElementResidence;
	import org.omg.uml.foundation.core.Enumeration;
	import org.omg.uml.foundation.core.EnumerationLiteral;
	import org.omg.uml.foundation.core.Feature;
	import org.omg.uml.foundation.core.Flow;
	import org.omg.uml.foundation.core.GeneralizableElement;
	import org.omg.uml.foundation.core.Generalization;
	import org.omg.uml.foundation.core.Interface;
	import org.omg.uml.foundation.core.Method;
	import org.omg.uml.foundation.core.ModelElement;
	import org.omg.uml.foundation.core.Namespace;
	import org.omg.uml.foundation.core.Node;
	import org.omg.uml.foundation.core.Operation;
	import org.omg.uml.foundation.core.Parameter;
	import org.omg.uml.foundation.core.Permission;
	import org.omg.uml.foundation.core.PresentationElement;
	import org.omg.uml.foundation.core.Primitive;
	import org.omg.uml.foundation.core.ProgrammingLanguageDataType;
	import org.omg.uml.foundation.core.Relationship;
	import org.omg.uml.foundation.core.Stereotype;
	import org.omg.uml.foundation.core.StructuralFeature;
	import org.omg.uml.foundation.core.TemplateArgument;
	import org.omg.uml.foundation.core.TemplateParameter;
	import org.omg.uml.foundation.core.UmlAssociation;
	import org.omg.uml.foundation.core.UmlClass;
	import org.omg.uml.foundation.core.Usage;
	import org.omg.uml.foundation.datatypes.AggregationKind;
	import org.omg.uml.foundation.datatypes.AggregationKindEnum;
	import org.omg.uml.foundation.datatypes.BooleanExpression;
	import org.omg.uml.foundation.datatypes.CallConcurrencyKindEnum;
	import org.omg.uml.foundation.datatypes.ChangeableKind;
	import org.omg.uml.foundation.datatypes.ChangeableKindEnum;
	import org.omg.uml.foundation.datatypes.Expression;
	import org.omg.uml.foundation.datatypes.Multiplicity;
	import org.omg.uml.foundation.datatypes.MultiplicityRange;
	import org.omg.uml.foundation.datatypes.OrderingKind;
	import org.omg.uml.foundation.datatypes.OrderingKindEnum;
	import org.omg.uml.foundation.datatypes.ParameterDirectionKindEnum;
	import org.omg.uml.foundation.datatypes.ProcedureExpression;
	import org.omg.uml.foundation.datatypes.ScopeKind;
	import org.omg.uml.foundation.datatypes.ScopeKindEnum;
	import org.omg.uml.foundation.datatypes.VisibilityKind;
	import org.omg.uml.foundation.datatypes.VisibilityKindEnum;
	import org.omg.uml.modelmanagement.UmlPackage;
	
	/**
	 * Factory to create UML classes for the UML Foundation::Core package.
	 * <p>
	 * Feature, StructuralFeature, and PresentationElement do not have a create
	 * method since they are called an "abstract metaclass" in the UML
	 * specifications.
	 * <p>
	 * @since ARGO0.19.5
	 * @author Ludovic Ma&icirc;tre
	 * @author Tom Morris
	 * <p>
	 * Derived from NSUML implementation by:
	 * @author Thierry Lach
	 * @author Jaap Branderhorst
	 */
	class CoreFactoryMDRImpl extends AbstractUmlModelFactoryMDR implements
	        CoreFactory {
	
	    private static final Logger LOG =
	        Logger.getLogger(CoreFactoryMDRImpl.class.getName());
	
	    /**
	     * The model implementation.
	     */
	    private MDRModelImplementation modelImpl;
	
	    /**
	     * Constructor.
	     *
	     * @param implementation
	     *            To get other helpers and factories.
	     */
	    CoreFactoryMDRImpl(MDRModelImplementation implementation) {
	        modelImpl = implementation;
	    }
	
	    private CorePackage getCorePackage() {
	        return modelImpl.getUmlPackage().getCore();
	    }
	
	    public Abstraction createAbstraction() {
	        Abstraction myAbstraction = getCorePackage().getAbstraction()
	                .createAbstraction();
	        super.initialize(myAbstraction);
	        return myAbstraction;
	    }
	
	
	    public Abstraction buildAbstraction(String name, Object supplier,
	            Object client) {
	        if (!(client instanceof Classifier)
	                || !(supplier instanceof Classifier)) {
	            throw new IllegalArgumentException(
	                    "The supplier and client of an abstraction"
	                            + "should be classifiers");
	        }
	        if (client.equals(supplier)) {
	            throw new IllegalArgumentException("The supplier and the client "
	                    + "must be different elements");
	        }
	        Abstraction abstraction = createAbstraction();
	        abstraction.setName(name);
	        abstraction.getClient().add((Classifier) client);
	        abstraction.getSupplier().add((Classifier) supplier);
	        return abstraction;
	    }
	
	
	    public Artifact createArtifact() {
	        Artifact artifact = getCorePackage().getArtifact().createArtifact();
	        super.initialize(artifact);
	        return artifact;
	    }
	
	
	    @Deprecated
	    public UmlAssociation createAssociation() {
	        return createAssociation(modelImpl.getUmlPackage());
	    }
	
	
	    public UmlAssociation createAssociation(Object extent) {
	        UmlAssociation assoc = ((org.omg.uml.UmlPackage) extent).getCore()
	                .getUmlAssociation().createUmlAssociation();
	        super.initialize(assoc);
	        return assoc;
	    }
	
	    public AssociationClass createAssociationClass() {
	        AssociationClass assoc = getCorePackage().getAssociationClass()
	                .createAssociationClass();
	        super.initialize(assoc);
	        return assoc;
	    }
	
	
	    public AssociationEnd createAssociationEnd() {
	        AssociationEnd assocEnd = getCorePackage().getAssociationEnd()
	                .createAssociationEnd();
	        super.initialize(assocEnd);
	        return assocEnd;
	    }
	
	
	    public Attribute createAttribute() {
	        Attribute myAttribute = getCorePackage().getAttribute().createAttribute();
	        super.initialize(myAttribute);
	        return myAttribute;
	    }
	
	
	    public Binding createBinding() {
	        Binding myBinding = getCorePackage().getBinding().createBinding();
	        super.initialize(myBinding);
	        return myBinding;
	    }
	
	
	    public UmlClass createClass() {
	        return createClass(modelImpl.getUmlPackage());
	    }
	
	    public UmlClass createClass(org.omg.uml.UmlPackage extent) {
	        UmlClass myClass = extent.getCore().getUmlClass().createUmlClass();
	        super.initialize(myClass);
	        return myClass;
	    }
	
	    public Comment createComment() {
	        Comment myComment = getCorePackage().getComment().createComment();
	        super.initialize(myComment);
	        return myComment;
	    }
	
	
	    public Component createComponent() {
	        Component myComponent = getCorePackage().getComponent().createComponent();
	        super.initialize(myComponent);
	        return myComponent;
	    }
	
	
	    public Constraint createConstraint() {
	        Constraint myConstraint = getCorePackage().getConstraint()
	                .createConstraint();
	        super.initialize(myConstraint);
	        return myConstraint;
	    }
	
	
	    public DataType createDataType() {
	        DataType dataType = getCorePackage().getDataType().createDataType();
	        super.initialize(dataType);
	        return dataType;
	    }
	
	
	    public Dependency createDependency() {
	        Dependency myDependency = getCorePackage().getDependency()
	                .createDependency();
	        super.initialize(myDependency);
	        return myDependency;
	    }
	
	
	    public ElementResidence createElementResidence() {
	        ElementResidence myElementResidence = getCorePackage().
	                getElementResidence().createElementResidence();
	        super.initialize(myElementResidence);
	        return myElementResidence;
	    }
	
	
	    public ElementResidence buildElementResidence(Object me, Object component) {
	        ElementResidence myElementResidence =
	            ((org.omg.uml.UmlPackage) ((ModelElement) me)
	                .refOutermostPackage()).getCore().getElementResidence()
	                .createElementResidence();
	        super.initialize(myElementResidence);
	        myElementResidence.setContainer((Component) component);
	        myElementResidence.setResident((ModelElement) me);
	        return myElementResidence;
	    }
	
	
	    public Enumeration createEnumeration() {
	        Enumeration myEnumeration = getCorePackage().getEnumeration()
	                .createEnumeration();
	        super.initialize(myEnumeration);
	        return myEnumeration;
	    }
	
	
	    public EnumerationLiteral createEnumerationLiteral() {
	        EnumerationLiteral myEnumerationLiteral = getCorePackage()
	                .getEnumerationLiteral().createEnumerationLiteral();
	        super.initialize(myEnumerationLiteral);
	        return myEnumerationLiteral;
	    }
	
	
	    public EnumerationLiteral buildEnumerationLiteral(String name,
	            Object enumeration) {
	        EnumerationLiteral el = createEnumerationLiteral();
	        el.setName(name);
	        el.setEnumeration((Enumeration) enumeration);
	        return el;
	    }
	
	
	    public Flow createFlow() {
	        Flow myFlow = getCorePackage().getFlow().createFlow();
	        super.initialize(myFlow);
	        return myFlow;
	    }
	
	    @Deprecated
	    public Generalization createGeneralization() {
	        return createGeneralization(modelImpl.getUmlPackage());
	    }
	
	    public Generalization createGeneralization(Object extent) {
	        Generalization myGeneralization = ((org.omg.uml.UmlPackage) extent)
	                .getCore().getGeneralization().createGeneralization();
	        super.initialize(myGeneralization);
	        return myGeneralization;
	    }
	
	    public Interface createInterface() {
	        Interface myInterface = getCorePackage()
	                .getInterface().createInterface();
	        super.initialize(myInterface);
	        return myInterface;
	    }
	
	
	    public Method createMethod() {
	        Method myMethod = getCorePackage().getMethod()
	                .createMethod();
	        super.initialize(myMethod);
	        return myMethod;
	    }
	
	
	    public Node createNode() {
	        Node myNode = getCorePackage().getNode().createNode();
	        super.initialize(myNode);
	        return myNode;
	    }
	
	
	    public Operation createOperation() {
	        Operation myOperation = getCorePackage()
	                .getOperation().createOperation();
	        super.initialize(myOperation);
	        return myOperation;
	    }
	
	
	    public Parameter createParameter() {
	        Parameter myParameter = getCorePackage()
	                .getParameter().createParameter();
	        super.initialize(myParameter);
	        return myParameter;
	    }
	
	
	    @Deprecated
	    public Permission createPermission() {
	        return createPackageImport();
	    }
	
	    public Permission createPackageImport() {
	        Permission myPermission = getCorePackage()
	                .getPermission().createPermission();
	        super.initialize(myPermission);
	        return myPermission;
	    }
	
	    public Primitive createPrimitiveType() {
	        Primitive obj = getCorePackage().getPrimitive().createPrimitive();
	        super.initialize(obj);
	        return obj;
	    }
	
	
	    public TemplateArgument createTemplateArgument() {
	        return createTemplateArgument(modelImpl.getUmlPackage());
	    }
	
	      private  TemplateArgument createTemplateArgument(
	              org.omg.uml.UmlPackage extent) {
	        TemplateArgument obj = extent.getCore().getTemplateArgument()
	                .createTemplateArgument();
	        super.initialize(obj);
	        return obj;
	    }
	
	
	    public TemplateParameter createTemplateParameter() {
	        return createTemplateParameter(modelImpl.getUmlPackage());
	    }
	
	    private TemplateParameter createTemplateParameter(
	            org.omg.uml.UmlPackage extent) {
	        TemplateParameter myTemplateParameter = extent.getCore()
	                .getTemplateParameter().createTemplateParameter();
	        super.initialize(myTemplateParameter);
	        return myTemplateParameter;
	    }
	
	
	    public Usage createUsage() {
	        Usage myUsage = getCorePackage().getUsage().createUsage();
	        super.initialize(myUsage);
	        return myUsage;
	    }
	
	    /**
	     * Builds a default binary association with two default association ends.
	     *
	     * @param c1
	     *            The first classifier to connect to
	     * @param nav1
	     *            The navigability of the Associaton end
	     * @param agg1
	     *            The aggregation type of the second Associaton end
	     * @param c2
	     *            The second classifier to connect to
	     * @param nav2
	     *            The navigability of the second Associaton end
	     * @param agg2
	     *            The aggregation type of the second Associaton end
	     * @return a newly created Association
	     * @throws IllegalArgumentException
	     *             if either Classifier is null
	     */
	    private UmlAssociation buildAssociation(Classifier c1, boolean nav1,
	            AggregationKind agg1, Classifier c2, boolean nav2,
	            AggregationKind agg2) {
	        if (c1 == null || c2 == null) {
	            throw new IllegalArgumentException("one of "
	                    + "the classifiers to be " + "connected is null");
	        }
	        Namespace ns1 = c1.getNamespace();
	        Namespace ns2 = c2.getNamespace();
	        if (ns1 == null || ns2 == null) {
	            throw new IllegalArgumentException("one of "
	                    + "the classifiers does not " + "belong to a namespace");
	        }
	
	        // We'll put the association in the namespace of whichever end
	        // is not navigable and is writeable.  If they both are, we'll use the
	        // namepace of c1.
	        Namespace ns = null;
	        if (nav2 && !modelImpl.getModelManagementHelper().isReadOnly(ns1)) {
	            ns = ns1;
	        } else if (nav1
	                && !modelImpl.getModelManagementHelper().isReadOnly(ns2)) {
	            ns = ns2;
	        } else {
	            throw new IllegalArgumentException(
	                    "At least one end must be navigable");
	        }
	        UmlAssociation assoc = createAssociation(ns.refOutermostPackage());
	        assoc.setName("");
	        assoc.setNamespace(ns);
	        buildAssociationEnd(assoc, null, c1, null, null,
	                nav1, null, agg1, null, null, null);
	        buildAssociationEnd(assoc, null, c2, null, null,
	                nav2, null, agg2, null, null, null);
	        return assoc;
	    }
	
	    @Deprecated
	    public UmlAssociation buildAssociation(Object fromClassifier,
	            Object aggregationKind1, Object toClassifier,
	            Object aggregationKind2, Boolean unidirectional) {
	
	        if (unidirectional == null) {
	            return buildAssociation(fromClassifier, aggregationKind1,
	                    toClassifier, aggregationKind2, false);
	        } else {
	            return buildAssociation(fromClassifier, aggregationKind1,
	                    toClassifier, aggregationKind2, unidirectional
	                            .booleanValue());
	        }
	    }
	
	    public UmlAssociation buildAssociation(Object fromClassifier,
	            Object aggregationKind1, Object toClassifier,
	            Object aggregationKind2, boolean unidirectional) {
	        if (fromClassifier == null || toClassifier == null) {
	            throw new IllegalArgumentException("one of "
	                    + "the classifiers to be " + "connected is null");
	        }
	        Classifier from = (Classifier) fromClassifier;
	        Classifier to = (Classifier) toClassifier;
	        AggregationKind agg1 = (AggregationKind) aggregationKind1;
	        AggregationKind agg2 = (AggregationKind) aggregationKind2;
	
	        Namespace ns = from.getNamespace();
	        if (ns == null || modelImpl.getModelManagementHelper().isReadOnly(ns)) {
	            ns = to.getNamespace();
	            if (ns == null
	                    || modelImpl.getModelManagementHelper().isReadOnly(ns)) {
	                throw new IllegalArgumentException(
	                        "At least one namespace must be non-null and writeable");
	            }
	        }
	
	        UmlAssociation assoc = createAssociation(ns.refOutermostPackage());
	        assoc.setName("");
	        assoc.setNamespace(ns);
	
	        final boolean nav1 = !unidirectional;
	        final boolean nav2 = true;
	
	        buildAssociationEnd(assoc, null, from, null, null, nav1, null, agg1,
	                null, null, null);
	        buildAssociationEnd(assoc, null, to, null, null, nav2, null, agg2,
	                null, null, null);
	        return assoc;
	    }
	
	
	    public UmlAssociation buildAssociation(Object classifier1,
	            Object classifier2) {
	        Classifier c1 = (Classifier) classifier1;
	        Classifier c2 = (Classifier) classifier2;
	        return buildAssociation(c1, true, AggregationKindEnum.AK_NONE, c2,
	                true, AggregationKindEnum.AK_NONE);
	    }
	
	
	    public UmlAssociation buildAssociation(Object c1, boolean nav1, Object c2,
	            boolean nav2, String name) {
	        UmlAssociation assoc = buildAssociation((Classifier) c1, nav1,
	                AggregationKindEnum.AK_NONE, (Classifier) c2, nav2,
	                AggregationKindEnum.AK_NONE);
	        if (assoc != null) {
	            assoc.setName(name);
	        }
	        return assoc;
	    }
	
	
	    public AssociationClass buildAssociationClass(Object end1, Object end2) {
	        if (end1 == null || end2 == null || !(end1 instanceof Classifier)
	                || !(end2 instanceof Classifier)) {
	            throw new IllegalArgumentException(
	                    "either one of the arguments was null");
	        }
	        final Classifier classifier1 = (Classifier) end1;
	        final Classifier classifier2 = (Classifier) end2;
	        AssociationClass assocClass = createAssociationClass();
	
	        assocClass.setNamespace(classifier1.getNamespace());
	        assocClass.setName("");
	        assocClass.setAbstract(false);
	        assocClass.setActive(false);
	        assocClass.setRoot(false);
	        assocClass.setLeaf(false);
	        assocClass.setSpecification(false);
	        assocClass.setVisibility(VisibilityKindEnum.VK_PUBLIC);
	
	        buildAssociationEnd(
	                assocClass, null, classifier1, null, null, true, null, null,
	                null, null, null);
	        buildAssociationEnd(
	                assocClass, null, classifier2, null, null, true, null, null,
	                null, null, null);
	        return assocClass;
	    }
	
	
	    public AssociationEnd buildAssociationEnd(Object assoc, String name,
	            Object type, Integer[] multiplicity, Object stereo, boolean navigable,
	            Object order, Object aggregation, Object scope, Object changeable,
	            Object visibility) {
	        if (aggregation != null
	                && aggregation.equals(AggregationKindEnum.AK_COMPOSITE)
	                && multiplicity != null
	                && (multiplicity[1] > 1 || multiplicity[1] == -1) ) {
	            throw new IllegalArgumentException("aggregation is composite "
	                    + "and multiplicity > 1");
	        }
	        AssociationEnd ae = buildAssociationEndInternal(assoc, name, type,
	                stereo, navigable, order, aggregation, scope, changeable,
	                visibility);
	        if (multiplicity != null) {
	            Multiplicity m = modelImpl.getDataTypesFactoryInternal()
	                    .createMultiplicityInternal(multiplicity[0],
	                            multiplicity[1]);
	            ae.setMultiplicity(m);
	        }
	        return ae;
	    }
	
	    @Deprecated
	    public AssociationEnd buildAssociationEnd(Object assoc, String name,
	            Object type, Object multi, Object stereo, boolean navigable,
	            Object order, Object aggregation, Object scope, Object changeable,
	            Object visibility) {
	        if (multi != null && !(multi instanceof Multiplicity)) {
	            throw new IllegalArgumentException("Multiplicity");
	        }
	        if (aggregation != null
	                && aggregation.equals(AggregationKindEnum.AK_COMPOSITE)
	                && multi != null
	                && compareMultiplicity(getMaxUpper((Multiplicity) multi), 1)
	                    > 0) {
	            throw new IllegalArgumentException("aggregation is composite "
	                    + "and multiplicity > 1");
	        }
	        AssociationEnd ae = buildAssociationEndInternal(assoc, name, type,
	                stereo, navigable, order, aggregation, scope, changeable,
	                visibility);
	        if (multi == null) {
	            ae.setMultiplicity(getMultiplicity11());
	        } else if (multi instanceof Multiplicity) {
	            ae.setMultiplicity((Multiplicity) multi);
	        } else if (multi instanceof String) {
	            Multiplicity m = modelImpl.getDataTypesFactoryInternal()
	                    .createMultiplicityInternal((String) multi);
	            ae.setMultiplicity(m);
	        }
	        return ae;
	    }
	
	    private AssociationEnd buildAssociationEndInternal (Object assoc, String name,
	            Object type, Object stereo, boolean navigable,
	            Object order, Object aggregation, Object scope, Object changeable,
	            Object visibility) {
	        // wellformednessrules and preconditions
	        if (assoc == null || !(assoc instanceof UmlAssociation) || type == null
	                || !(type instanceof Classifier)) {
	            throw new IllegalArgumentException("either type or association "
	                    + "are null");
	        }
	        if (stereo != null && !(stereo instanceof Stereotype)) {
	            throw new IllegalArgumentException("Stereotype");
	        }
	        if (order != null && !(order instanceof OrderingKind)) {
	            throw new IllegalArgumentException("OrderingKind");
	        }
	        if (aggregation != null && !(aggregation instanceof AggregationKind)) {
	            throw new IllegalArgumentException("AggregationKind");
	        }
	        if (scope != null && !(scope instanceof ScopeKind)) {
	            throw new IllegalArgumentException("ScopeKind");
	        }
	        if (changeable != null && !(changeable instanceof ChangeableKind)) {
	            throw new IllegalArgumentException("ChangeableKind");
	        }
	        if (visibility != null && !(visibility instanceof VisibilityKind)) {
	            throw new IllegalArgumentException("VisibilityKind");
	        }
	
	        AssociationEnd end = createAssociationEnd();
	        end.setAssociation((UmlAssociation) assoc);
	        end.setParticipant((Classifier) type);
	        end.setName(name);
	        // UML 1.4 WFR 2.5.3.1 #3 - no aggregation for N-ary associations
	        List<AssociationEnd> ends = ((UmlAssociation) assoc).getConnection();
	        if (ends.size() >= 3) {
	            for (AssociationEnd e : ends) {
	                e.setAggregation(AggregationKindEnum.AK_NONE);
	            }
	        }
	        if (stereo != null) {
	            end.getStereotype().clear();
	            end.getStereotype().add((Stereotype) stereo);
	        }
	        end.setNavigable(navigable);
	        if (order != null) {
	            end.setOrdering((OrderingKind) order);
	        } else {
	            end.setOrdering(OrderingKindEnum.OK_UNORDERED);
	        }
	        if (aggregation != null) {
	            end.setAggregation((AggregationKind) aggregation);
	        } else {
	            end.setAggregation(AggregationKindEnum.AK_NONE);
	        }
	        if (scope != null) {
	            end.setTargetScope((ScopeKind) scope);
	        } else {
	            end.setTargetScope(ScopeKindEnum.SK_INSTANCE);
	        }
	        if (changeable != null) {
	            end.setChangeability((ChangeableKind) changeable);
	        } else {
	            end.setChangeability(ChangeableKindEnum.CK_CHANGEABLE);
	        }
	        if (visibility != null) {
	            end.setVisibility((VisibilityKind) visibility);
	        } else {
	            end.setVisibility(VisibilityKindEnum.VK_PUBLIC);
	        }
	        return end;
	    }
	
	    private static final int MULT_UNLIMITED = -1;
	
	    /**
	     * Get the maximum value of a multiplicity
	     *
	     * @param m
	     *            the Multiplicity
	     * @return upper range
	     */
	    private int getMaxUpper(Multiplicity m) {
	        int max = 0;
	        for (MultiplicityRange mr : m.getRange()) {
	            int value = mr.getUpper();
	            if (value == MULT_UNLIMITED) {
	                max = value;
	            } else if (max != MULT_UNLIMITED && value > max) {
	                max = value;
	            }
	        }
	        return max;
	    }
	
	    /**
	     * Compare two multiplicities taking care of the value 'unlimited' (-1).
	     *
	     * @param mult1 first multiplicity
	     * @param mult2 second multiplicity
	     * @return 0 if equal, a positive integer (not necessarily 1) if mult1 is
	     *         greater than mult2 and a negative integer if mult2 is greater..
	     */
	    private static int compareMultiplicity(int mult1, int mult2) {
	        if (mult1 == MULT_UNLIMITED) {
	            if (mult2 == MULT_UNLIMITED) {
	                return 0; // equal
	            }
	            return 1; // greater
	        } else if (mult2 == MULT_UNLIMITED) {
	            return -1; // less than
	        }
	        return mult1 - mult2;
	    }
	
	    /**
	     * Get a 1..1 multiplicity
	     */
	    private Multiplicity getMultiplicity11() {
	        return modelImpl.getDataTypesFactoryInternal()
	                .createMultiplicityInternal(1, 1);
	    }
	
	
	    public AssociationEnd buildAssociationEnd(Object type, Object assoc) {
	        if (type == null || !(type instanceof Classifier) || assoc == null
	                || !(assoc instanceof UmlAssociation)) {
	            throw new IllegalArgumentException("one of the arguments is null");
	        }
	        return buildAssociationEnd(assoc, "", type, null, null, true, null,
	                null, null, null, VisibilityKindEnum.VK_PUBLIC);
	    }
	
	    public Attribute buildAttribute(Object model, Object theType) {
	        return buildAttribute2(theType);
	    }
	
	    public Attribute buildAttribute2(Object theType) {
	        Attribute attr = buildAttribute();
	        attr.setType((Classifier) theType);
	        return attr;
	    }
	
	    /**
	     * Build a new attribute with no type
	     * @return the new attribute
	     */
	    Attribute buildAttribute() {
	        Attribute attr = createAttribute();
	        attr.setMultiplicity(getMultiplicity11());
	        attr.setVisibility(VisibilityKindEnum.VK_PUBLIC);
	        attr.setOwnerScope(ScopeKindEnum.SK_INSTANCE);
	        attr.setChangeability(ChangeableKindEnum.CK_CHANGEABLE);
	        attr.setTargetScope(ScopeKindEnum.SK_INSTANCE);
	        return attr;
	    }
	
	
	    public Attribute buildAttribute2(Object handle, Object type) {
	        Attribute attr = buildAttribute2(type);
	        if (handle instanceof Classifier) {
	            Classifier cls = (Classifier) handle;
	            cls.getFeature().add(attr);
	        } else if (handle instanceof AssociationEnd) {
	            AssociationEnd assend = (AssociationEnd) handle;
	            assend.getQualifier().add(attr);
	        } else {
	            throw new IllegalArgumentException();
	        }
	        return attr;
	    }
	
	
	    public UmlClass buildClass() {
	        return buildClass((Object) null);
	    }
	
	
	    private static void initClass(UmlClass cl) {
	        cl.setName("");
	        cl.setAbstract(false);
	        cl.setActive(false);
	        cl.setRoot(false);
	        cl.setLeaf(false);
	        cl.setSpecification(false);
	        cl.setVisibility(VisibilityKindEnum.VK_PUBLIC);
	    }
	
	    public UmlClass buildClass(final Object owner) {
	        ModelCommand command = new ModelCommand() {
	            private UmlClass cl;
	            public UmlClass execute() {
	                if (owner == null) {
	                    cl = createClass();
	                } else {
	                    cl = createClass(getExtent(owner));
	                }
	                initClass(cl);
	                return cl;
	            }
	
	            public void undo() {
	                try {
	                    cl.refDelete();
	                } catch (InvalidObjectException e) {
	                    LOG.log(Level.WARNING, "Object already deleted " + cl);
	                }
	            }
	
	            public boolean isUndoable() {
	                return true;
	            }
	
	            public boolean isRedoable() {
	                return false;
	            }
	        };
	        UmlClass clazz = (UmlClass) org.argouml.model.Model.execute(command);
	        if (owner instanceof Namespace) {
	            modelImpl.getCoreHelper().setNamespace(clazz, owner);
	        }
	        return clazz;
	    }
	
	
	    private org.omg.uml.UmlPackage getExtent(Object element) {
	        return (org.omg.uml.UmlPackage) ((RefObject) element)
	                .refOutermostPackage();
	    }
	
	    public UmlClass buildClass(String name) {
	        UmlClass clazz = buildClass();
	        clazz.setName(name);
	        return clazz;
	    }
	
	
	    public UmlClass buildClass(String name, Object owner) {
	        UmlClass clazz = buildClass();
	        clazz.setName(name);
	        if (owner instanceof Namespace) {
	            modelImpl.getCoreHelper().setNamespace(clazz, owner);
	        }
	        return clazz;
	    }
	
	
	    public Interface buildInterface() {
	        Interface cl = createInterface();
	        cl.setName("");
	        cl.setAbstract(false);
	        cl.setRoot(false);
	        cl.setLeaf(false);
	        cl.setSpecification(false);
	        cl.setVisibility(VisibilityKindEnum.VK_PUBLIC);
	        return cl;
	    }
	
	
	    public Interface buildInterface(Object owner) {
	        Interface cl = buildInterface();
	        if (owner instanceof Namespace) {
	            cl.setNamespace((Namespace) owner);
	        }
	        return cl;
	    }
	
	
	    public Interface buildInterface(String name) {
	        Interface cl = buildInterface();
	        cl.setName(name);
	        return cl;
	    }
	
	
	    public Interface buildInterface(String name, Object owner) {
	        Interface cl = buildInterface();
	        cl.setName(name);
	        if (owner instanceof Namespace) {
	            cl.setNamespace((Namespace) owner);
	        }
	        return cl;
	    }
	
	
	    public DataType buildDataType(String name, Object owner) {
	        DataType dt = createDataType();
	        dt.setName(name);
	        if (owner instanceof Namespace) {
	            dt.setNamespace((Namespace) owner);
	        }
	        return dt;
	    }
	
	
	    public Enumeration buildEnumeration(String name, Object owner) {
	        Enumeration e = createEnumeration();
	        e.setName(name);
	        if (owner instanceof Namespace) {
	            e.setNamespace((Namespace) owner);
	        }
	        return e;
	    }
	
	
	    public Dependency buildDependency(Object clientObj, Object supplierObj) {
	
	        ModelElement client = (ModelElement) clientObj;
	        ModelElement supplier = (ModelElement) supplierObj;
	        if (client == null || supplier == null) {
	            throw new IllegalArgumentException("client or supplier is null "
	                    + "client = " + client + " supplier = " + supplier);
	        }
	        Dependency dep = createDependency();
	        dep.getSupplier().add(supplier);
	        dep.getClient().add(client);
	        if (client instanceof Namespace) {
	            dep.setNamespace((Namespace) client);
	        } else if (client.getNamespace() != null) {
	            dep.setNamespace(client.getNamespace());
	        }
	        return dep;
	    }
	
	
	    public Permission buildPackageImport(Object client, Object supplier) {
	        if (!(client instanceof Namespace)
	                || !(supplier instanceof UmlPackage)) {
	            throw new IllegalArgumentException("client is not a Namespace"
	                    + " or supplier is not a Package");
	        }
	        Permission per = buildPermissionInternal((ModelElement) client,
	                (UmlPackage) supplier);
	
	        // TODO: This should fetch the stereotype from our profile
	        modelImpl.getExtensionMechanismsFactory().buildStereotype(per,
	                ModelManagementHelper.IMPORT_STEREOTYPE,
	                per.getNamespace());
	        return per;
	    }
	
	
	    private Permission buildPermissionInternal(ModelElement client,
	            ModelElement supplier) {
	        Permission permission = createPackageImport();
	        permission.getSupplier().add(supplier);
	        permission.getClient().add(client);
	        if (client instanceof Namespace) {
	            permission.setNamespace((Namespace) client);
	        } else if (client.getNamespace() != null) {
	            permission.setNamespace(client.getNamespace());
	        }
	        return permission;
	    }
	
	
	    public Permission buildPackageAccess(Object client, Object supplier) {
	        if (!(client instanceof Namespace)
	                || !(supplier instanceof UmlPackage)) {
	            throw new IllegalArgumentException("client or "
	                    + "supplier is not a Namespace");
	        }
	        Permission per = buildPermissionInternal((ModelElement) client,
	                (UmlPackage) supplier);
	
	        // TODO: This should fetch the stereotype from our profile
	        modelImpl.getExtensionMechanismsFactory().buildStereotype(per,
	                ModelManagementHelper.ACCESS_STEREOTYPE,
	                per.getNamespace());
	        return per;
	    }
	
	
	    public Generalization buildGeneralization(Object child1, Object parent1) {
	        // TODO: This is a part implementation of well-formedness rule
	        // UML1.4.2 - 4.5.3.20 [3] Circular inheritance is not allowed.
	        // not self.allParents->includes(self)
	        if (!(child1 instanceof GeneralizableElement
	                && parent1 instanceof GeneralizableElement
	                && child1 != parent1)) {
	            throw new IllegalArgumentException(
	                    "Both items must be different generalizable elements");
	        }
	
	        GeneralizableElement child = (GeneralizableElement) child1;
	        GeneralizableElement parent = (GeneralizableElement) parent1;
	
	        // Check that the two elements aren't already linked the opposite way
	        // TODO: This is a part implementation of well-formedness rule
	        // UML1.4.2 - 4.5.3.20 [3] Circular inheritance is not allowed.
	        // not self.allParents->includes(self)
	        for (Generalization gen : parent.getGeneralization()) {
	            if (gen.getParent().equals(child)) {
	                throw new IllegalArgumentException("Generalization exists"
	                        + " in opposite direction");
	            }
	        }
	
	        // TODO: This is well-formedness rule from UML1.4.2
	        // 4.5.3.20 [2] No GeneralizableElement can have a parent
	        // Generalization to an element that is a leaf.
	        // self.parent->forAll(s | not s.isLeaf)
	        if (parent.isLeaf()) {
	            throw new IllegalArgumentException("parent is leaf");
	        }
	
	        // TODO: This is well-formedness rule from UML1.4.2
	        // 4.5.3.20 [1] A root cannot have any Generalizations.
	        // self.isRoot implies self.generalization->isEmpty
	        if (child.isRoot()) {
	            throw new IllegalArgumentException("child is root");
	        }
	
	        Namespace ns = child.getNamespace();
	        if ((ns == null || modelImpl.getModelManagementHelper().isReadOnly(ns))
	                && child instanceof Namespace) {
	            ns = (Namespace) child;
	        }
	        if (ns == null || modelImpl.getModelManagementHelper().isReadOnly(ns)) {
	            throw new IllegalArgumentException("No valid writeable namespace");
	        }
	        Generalization gen = createGeneralization(ns.refOutermostPackage());
	        gen.setParent(parent);
	        gen.setChild(child);
	        gen.setNamespace(ns);
	        return gen;
	    }
	
	    public Object buildManifestation(Object utilizedElement) {
	        throw new NotImplementedException( "UML 1.4 has no manifestations");
	    }
	
	    public Method buildMethod(String name) {
	        Method method = createMethod();
	        if (method != null) {
	            method.setName(name);
	        }
	        return method;
	    }
	
	
	    public Operation buildOperation(Object classifier, Object returnType) {
	        if (!(classifier instanceof Classifier)) {
	            throw new IllegalArgumentException("Handle is not a classifier");
	        }
	        Classifier cls = (Classifier) classifier;
	        Operation oper = createOperation();
	        oper.setOwner(cls);
	        oper.setVisibility(VisibilityKindEnum.VK_PUBLIC);
	        oper.setAbstract(false);
	        oper.setLeaf(false);
	        oper.setRoot(false);
	        oper.setQuery(false);
	        oper.setOwnerScope(ScopeKindEnum.SK_INSTANCE);
	        oper.setConcurrency(CallConcurrencyKindEnum.CCK_SEQUENTIAL);
	
	        Parameter returnParameter = buildParameter(oper, returnType);
	        returnParameter.setKind(ParameterDirectionKindEnum.PDK_RETURN);
	        returnParameter.setName("return");
	        return oper;
	    }
	
	
	    public Operation buildOperation2(Object cls, Object returnType,
	            String name) {
	        Operation oper = buildOperation(cls, returnType);
	        if (oper != null) {
	            oper.setName(name);
	        }
	        return oper;
	    }
	
	    /**
	     * Constructs a default parameter.
	     *
	     * @return The newly created parameter.
	     */
	    private Parameter buildParameter(Classifier type,
	            javax.jmi.reflect.RefObject ref) {
	        Parameter param = ((org.omg.uml.UmlPackage) ref.refOutermostPackage())
	                .getCore().getParameter().createParameter();
	        param.setType(type);
	        return param;
	    }
	
	
	    public Parameter buildParameter(Object o, Object type) {
	        if (o instanceof Event) {
	            Event event = (Event) o;
	            Parameter res = buildParameter((Classifier) type, event);
	            res.setKind(ParameterDirectionKindEnum.PDK_IN);
	            event.getParameter().add(res);
	            res.setName("arg" + event.getParameter().size());
	            return res;
	        } else if (o instanceof ObjectFlowState) {
	            ObjectFlowState ofs = (ObjectFlowState) o;
	            Parameter res = buildParameter((Classifier) type, ofs);
	            res.setKind(ParameterDirectionKindEnum.PDK_IN);
	            ofs.getParameter().add(res);
	            res.setName("arg" + ofs.getParameter().size());
	            return res;
	        } else if (o instanceof BehavioralFeature) {
	            BehavioralFeature oper = (BehavioralFeature) o;
	            Parameter res = buildParameter((Classifier) type, oper);
	            res.setKind(ParameterDirectionKindEnum.PDK_IN);
	            oper.getParameter().add(res);
	            res.setName("arg" + oper.getParameter().size());
	            return res;
	        } else if (o == null) {
	            throw new IllegalArgumentException(
	                    "A containing element must be supplied for the parameter");
	        } else {
	            throw new IllegalArgumentException(
	                    "Unsupported contining element for parameter "
	                    + o.getClass().getName());
	        }
	    }
	
	
	    public Abstraction buildRealization(Object clnt, Object spplr,
	            Object model) {
	        ModelElement client = (ModelElement) clnt;
	        ModelElement supplier = (ModelElement) spplr;
	        if (client == null || supplier == null || client.getNamespace() == null
	                || supplier.getNamespace() == null || client.equals(supplier)) {
	            throw new IllegalArgumentException("faulty arguments.");
	        }
	        Abstraction realization = createAbstraction();
	        Namespace nsc = client.getNamespace();
	        Namespace nss = supplier.getNamespace();
	        Namespace ns = null;
	        if (nsc.equals(nss)) {
	            ns = nsc;
	        } else {
	            ns = (Namespace) model;
	        }
	        realization.setNamespace(nsc);
	        modelImpl.getExtensionMechanismsFactory().buildStereotype(realization,
	                CoreFactory.REALIZE_STEREOTYPE, ns);
	        realization.getClient().add(client);
	        realization.getSupplier().add(supplier);
	        return realization;
	    }
	
	
	    public TemplateArgument buildTemplateArgument(Object element) {
	        TemplateArgument ta = createTemplateArgument();
	        ta.setModelElement((ModelElement) element);
	        return ta;
	    }
	
	    public TemplateArgument buildTemplateArgument(Object binding,
	            Object element) {
	        if (!(binding instanceof Binding && element instanceof ModelElement)) {
	            throw new IllegalArgumentException();
	        }
	        TemplateArgument ta = createTemplateArgument(getExtent(binding));
	        ta.setModelElement((ModelElement) element);
	        ta.setBinding((Binding) binding);
	        return ta;
	    }
	
	    public Object buildTemplateParameter(Object template, Object parameter,
	            Object defaultElement) {
	        if (!(template instanceof ModelElement)) {
	            throw new IllegalArgumentException(
	                    "Template must be a model element");
	        }
	        if (!(parameter instanceof ModelElement)) {
	            if (parameter == null) {
	                parameter = createClass(getExtent(template));
	            } else {
	            throw new IllegalArgumentException(
	                    "Parameter must be a model element");
	            }
	        }
	        if (defaultElement != null
	                && !(defaultElement instanceof ModelElement)) {
	            throw new IllegalArgumentException(
	                    "Default element must be a model element");
	        }
	
	        TemplateParameter templateParam =
	            createTemplateParameter(getExtent(template));
	        templateParam.setParameter((ModelElement) parameter);
	        if (defaultElement != null) {
	            templateParam.setDefaultElement((ModelElement) defaultElement);
	        }
	        templateParam.setTemplate((ModelElement) template);
	        return templateParam;
	    }
	
	
	    public Usage buildUsage(Object client, Object supplier) {
	        if (client == null || supplier == null) {
	            throw new IllegalArgumentException("In buildUsage null arguments.");
	        }
	        if (!(client instanceof ModelElement)) {
	            throw new IllegalArgumentException("client ModelElement");
	        }
	        if (!(supplier instanceof ModelElement)) {
	            throw new IllegalArgumentException("supplier ModelElement");
	        }
	        // TODO: UML 1.4 spec requires both client and supplier to be
	        // in the same model - tfm
	        Usage usage = createUsage();
	        usage.getSupplier().add((ModelElement) supplier);
	        usage.getClient().add((ModelElement) client);
	        if (((ModelElement) supplier).getNamespace() != null) {
	            usage.setNamespace(((ModelElement) supplier).getNamespace());
	        } else if (((ModelElement) client).getNamespace() != null) {
	            usage.setNamespace(((ModelElement) client).getNamespace());
	        }
	        // TODO: Add standard stereotype?  Set is open ended, but
	        // predefined names include: call, create, instantiate, send
	        return usage;
	    }
	
	
	    public Comment buildComment(Object element, Object model) {
	        if (model == null) {
	            throw new IllegalArgumentException("A namespace must be supplied.");
	        }
	        ModelElement elementToAnnotate = (ModelElement) element;
	        Comment comment = createComment();
	
	        Namespace commentsModel = null;
	        if (elementToAnnotate != null) {
	            comment.getAnnotatedElement().add(elementToAnnotate);
	            commentsModel = elementToAnnotate.getNamespace();
	        } else {
	            commentsModel = (Namespace) model;
	        }
	
	        comment.setNamespace(commentsModel);
	        return comment;
	    }
	
	
	    public Constraint buildConstraint(Object constrElement) {
	        ModelElement constrainedElement = (ModelElement) constrElement;
	        if (constrainedElement == null) {
	            throw new IllegalArgumentException("the constrained element is "
	                    + "mandatory and may not be " + "null.");
	        }
	        Constraint con = createConstraint();
	        con.getConstrainedElement().add(constrainedElement);
	        con.setNamespace(constrainedElement.getNamespace());
	        return con;
	    }
	
	
	    public Constraint buildConstraint(String name, Object bexpr) {
	        if (bexpr == null || !(bexpr instanceof BooleanExpression)) {
	            throw new IllegalArgumentException("invalid boolean expression.");
	        }
	        Constraint con = createConstraint();
	        if (name != null) {
	            con.setName(name);
	        }
	        con.setBody((BooleanExpression) bexpr);
	        return con;
	    }
	
	
	    public Binding buildBinding(Object client, Object supplier,
	            List arguments) {
	        Collection<Dependency> clientDeps = ((ModelElement) client)
	                .getClientDependency();
	        for (Dependency dep : clientDeps) {
	            if (dep instanceof Binding) {
	                throw new IllegalArgumentException(
	                        "client is already client of another Binding");
	            }
	        }
	
	        // Check arguments against parameters for type and number
	        // TODO: Perhaps move this to a critic instead? - tfm - 20070326
	        if (arguments != null) {
	            List<TemplateParameter> params =
	                ((ModelElement) supplier).getTemplateParameter();
	            if (params.size() != arguments.size()) {
	                throw new IllegalArgumentException(
	                        "number of arguments doesn't match number of params");
	            }
	            Iterator<TemplateArgument> ita = arguments.iterator();
	            for (TemplateParameter param : params) {
	                TemplateArgument ta = ita.next();
	                // TODO: Before allowing this, we should really check that
	                // TemplateParameter.defaultElement is defined
	                if (ta == null || ta.getModelElement() == null) {
	                    continue;
	                }
	                if (!(param.getParameter().getClass().equals(
	                        ta.getModelElement().getClass()))) {
	                    throw new IllegalArgumentException(
	                            "type of argument doesn't match type of parameter");
	                }
	            }
	        }
	
	        Binding binding = createBinding();
	        binding.getClient().add((ModelElement) client);
	        binding.getSupplier().add((ModelElement) supplier);
	        if (arguments != null) {
	            binding.getArgument().addAll(arguments);
	        }
	
	        return binding;
	    }
	
	
	    /**
	     * @param elem
	     *            the abstraction to be deleted
	     */
	    void deleteAbstraction(Object elem) {
	        if (!(elem instanceof Abstraction)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	    }
	
	    /**
	     * @param elem
	     *            the artifact to be deleted
	     */
	    void deleteArtifact(Object elem) {
	        if (!(elem instanceof Artifact)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	    }
	
	    /**
	     * @param elem
	     *            the association to be deleted
	     */
	    void deleteAssociation(Object elem) {
	        if (!(elem instanceof UmlAssociation)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	    }
	
	    /**
	     * @param elem
	     *            the a. to be deleted
	     */
	    void deleteAssociationClass(Object elem) {
	        if (!(elem instanceof AssociationClass)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	    }
	
	    /**
	     * Does a 'cascading delete' to all modelelements that are associated with
	     * this element that would be in an illegal state after deletion of the
	     * element. This method should not be called directly.
	     * <p>
	     *
	     * In the case of an AssociationEnd these are the following elements:
	     * <ul>
	     * <li>Binary Associations that lose one of the AssociationEnds by this
	     * deletion.
	     * <li>LinkEnds associated with this AssociationEnd.
	     * </ul>
	     *
	     *
	     * @param elem
	     * @see UmlFactoryMDRImpl#delete(Object)
	     */
	    void deleteAssociationEnd(Object elem) {
	        if (!(elem instanceof AssociationEnd)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	        AssociationEnd ae = (AssociationEnd) elem;
	        UmlAssociation assoc = ae.getAssociation();
	        if (assoc != null && assoc.getConnection() != null
	                && assoc.getConnection().size() == 2) { // binary association
	            modelImpl.getUmlFactory().delete(assoc);
	        }
	        // delete LinkEnds which have this as their associationEnd
	        modelImpl.getUmlHelper().deleteCollection(
	                ((org.omg.uml.UmlPackage) ae.refOutermostPackage())
	                        .getCommonBehavior().getAAssociationEndLinkEnd()
	                        .getLinkEnd(ae));
	    }
	
	    /**
	     * @param elem
	     *            the attribute to be deleted
	     */
	    void deleteAttribute(Object elem) {
	        if (!(elem instanceof Attribute)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	        // delete AttributeLinks where this is the Attribute
	        Attribute attr = (Attribute) elem;
	        modelImpl.getUmlHelper().deleteCollection(
	                ((org.omg.uml.UmlPackage) attr.refOutermostPackage())
	                        .getCommonBehavior().getAAttributeLinkAttribute()
	                        .getAttributeLink(attr));
	    }
	
	    /**
	     * @param elem the element to be deleted
	     */
	    void deleteBehavioralFeature(Object elem) {
	        if (!(elem instanceof BehavioralFeature)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	
	    }
	
	    /**
	     * @param elem
	     *            the element to be deleted
	     */
	    void deleteBinding(Object elem) {
	        if (!(elem instanceof Binding)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	        Binding binding = (Binding) elem;
	        modelImpl.getUmlHelper().deleteCollection(
	                ((org.omg.uml.UmlPackage) binding.refOutermostPackage())
	                        .getCore().getABindingArgument().getArgument(binding));
	    }
	
	    /**
	     * @param elem
	     *            the element to be deleted
	     */
	    void deleteClass(Object elem) {
	        if (!(elem instanceof UmlClass)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	    }
	
	    /**
	     * Does a 'cascading delete' to all modelelements that are associated with
	     * this element that would be in an illegal state after deletion of the
	     * element. Does not do an cascading delete for elements that are deleted by
	     * the MDR method remove. This method should not be called directly.
	     * <p>
	     *
	     * In the case of a classifier these are the following elements:
	     * <ul>
	     * <li>AssociationEnds that have this classifier as type
	     * </ul>
	     *
	     * @param elem
	     * @see UmlFactoryMDRImpl#delete(Object)
	     */
	    void deleteClassifier(Object elem) {
	        if (!(elem instanceof Classifier)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	        modelImpl.getUmlHelper().deleteCollection(
	                modelImpl.getFacade().getAssociationEnds(elem));
	        Classifier cls = (Classifier) elem;
	        // delete CreateActions which have this as their instantiation
	        modelImpl.getUmlHelper().deleteCollection(
	                ((org.omg.uml.UmlPackage) cls.refOutermostPackage())
	                        .getCommonBehavior().getACreateActionInstantiation()
	                        .getCreateAction(cls));
	        // TODO: ?delete Instances which have this as their classifier?
	        // or should we leave them since they contain so much state that the
	        // user would have to recreate??
	//        nsmodel.getUmlHelper().deleteCollection(
	//                nsmodel.getUmlPackage().getCommonBehavior()
	//                        .getAInstanceClassifier().getInstance(cls));
	        // TODO: ?delete ObjectFlowStates which have this as their type?
	//        nsmodel.getUmlHelper().deleteCollection(
	//                nsmodel.getUmlPackage().getActivityGraphs()
	//                        .getATypeObjectFlowState().getObjectFlowState(cls));
	        // TODO: ?delete ClassifierInStates which have this as their type?
	        modelImpl.getUmlHelper().deleteCollection(
	                ((org.omg.uml.UmlPackage) cls.refOutermostPackage())
	                        .getActivityGraphs().getATypeClassifierInState()
	                        .getClassifierInState(cls));
	    }
	
	    /**
	     * @param elem
	     *            the element to be deleted
	     */
	    void deleteComment(Object elem) {
	        if (!(elem instanceof Comment)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	    }
	
	    /**
	     * @param elem
	     *            the element to be deleted
	     */
	    void deleteComponent(Object elem) {
	        if (!(elem instanceof Component)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	
	    }
	
	    /**
	     * @param elem
	     *            the element to be deleted
	     */
	    void deleteConstraint(Object elem) {
	        if (!(elem instanceof Constraint)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	    }
	
	    /**
	     * @param elem
	     *            the element to be deleted
	     */
	    void deleteDataType(Object elem) {
	        if (!(elem instanceof DataType)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	    }
	
	    /**
	     * @param elem
	     *            the element to be deleted
	     */
	    void deleteDependency(Object elem) {
	        if (!(elem instanceof Dependency)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	    }
	
	    /**
	     * @param elem
	     *            the element to be deleted
	     */
	    void deleteElement(Object elem) {
	        if (!(elem instanceof Element)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	
	    }
	
	    /**
	     * @param elem
	     *            the element to be deleted
	     */
	    void deleteElementResidence(Object elem) {
	        if (!(elem instanceof ElementResidence)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	    }
	
	    /**
	     * @param elem
	     *            the element to be deleted
	     */
	    void deleteFeature(Object elem) {
	        if (!(elem instanceof Feature)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	    }
	
	    /**
	     * @param elem
	     *            the element to be deleted
	     */
	    void deleteFlow(Object elem) {
	        if (!(elem instanceof Flow)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	
	    }
	
	    /**
	     * @param elem
	     *            the element to be deleted
	     */
	    void deleteGeneralizableElement(Object elem) {
	        if (!(elem instanceof GeneralizableElement)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	
	        GeneralizableElement ge = (GeneralizableElement) elem;
	        modelImpl.getUmlHelper().deleteCollection(ge.getGeneralization());
	        modelImpl.getUmlHelper().deleteCollection(
	                ((org.omg.uml.UmlPackage) ge.refOutermostPackage()).getCore()
	                        .getAParentSpecialization().getSpecialization(ge));
	
	    }
	
	    /**
	     * @param elem the element to be deleted
	     */
	    void deleteGeneralization(Object elem) {
	        if (!(elem instanceof Generalization)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	    }
	
	    /**
	     * @param elem
	     *            the element to be deleted
	     */
	    void deleteInterface(Object elem) {
	        if (!(elem instanceof Interface)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	    }
	
	    /**
	     * @param elem
	     *            the element to be deleted
	     */
	    void deleteMethod(Object elem) {
	        if (!(elem instanceof Method)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	    }
	
	    /**
	     * Does a 'cascading delete' to all modelelements that are associated with
	     * this element that would be in an illegal state after deletion of the
	     * element. Does not do an cascading delete for elements that are deleted by
	     * MDR automatically. This method should not be called directly.
	     * <p>
	     *
	     * In the case of a modelelement these are the following elements:
	     * <ul>
	     * <li>Dependencies that have the modelelement as supplier or as a client
	     * and are binary. (that is, they only have one supplier and one client)
	     * <li>Behaviors, TemplateArguments, and ElementImports which require
	     * this ModelElement
	     * </ul>
	     *
	     * @param elem
	     * @see UmlFactoryMDRImpl#delete(Object)
	     */
	    void deleteModelElement(Object elem) {
	        if (!(elem instanceof ModelElement)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	
	        // Delete dependencies where this is the only client
	        Collection<Dependency> deps = org.argouml.model.Model.getFacade()
	                .getClientDependencies(elem);
	        for (Dependency dep : deps) {
	            if (dep.getClient().size() < 2
	                    && dep.getClient().contains(elem)) {
	                modelImpl.getUmlFactory().delete(dep);
	            }
	        }
	
	        // Delete dependencies where this is the only supplier
	        deps = org.argouml.model.Model.getFacade()
	                .getSupplierDependencies(elem);
	        for (Dependency dep : deps) {
	            if (dep.getSupplier().size() < 2
	                    && dep.getSupplier().contains(elem)) {
	                modelImpl.getUmlFactory().delete(dep);
	            }
	        }
	
	        /* Do not delete behaviors here!
	         * The behavior-context relation in the UML model
	         * is an aggregate, not composition. See issue 4281. */
	
	        ModelElement me = (ModelElement) elem;
	        modelImpl.getUmlHelper().deleteCollection(
	                ((org.omg.uml.UmlPackage) me.refOutermostPackage()).getCore()
	                        .getAModelElementTemplateArgument()
	                        .getTemplateArgument(me));
	        modelImpl.getUmlHelper().deleteCollection(
	                ((org.omg.uml.UmlPackage) me.refOutermostPackage())
	                        .getModelManagement()
	                        .getAImportedElementElementImport()
	                        .getElementImport(me));
	
	
	    }
	
	    /**
	     * A namespace deletes its owned elements.
	     *
	     * @param elem
	     *            is the namespace.
	     */
	    void deleteNamespace(Object elem) {
	        LOG.log(Level.FINE, "Deleting namespace {0}", elem);
	
	        if (!(elem instanceof Namespace)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	
	        List<ModelElement> ownedElements = new ArrayList<ModelElement>();
	        // TODO: This is a composite association, so these will get deleted
	        // automatically.  The only thing we need to do is check for any
	        // additional elements that need to be deleted as a result.
	        ownedElements.addAll(((Namespace) elem).getOwnedElement());
	        for (ModelElement element : ownedElements) {
	
	            LOG.log(Level.FINE, "Deleting ownedElement {0}", element);
	
	            modelImpl.getUmlFactory().delete(element);
	        }
	    }
	
	    /**
	     * @param elem
	     *            the element to be deleted
	     */
	    void deleteNode(Object elem) {
	        if (!(elem instanceof Node)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	
	    }
	
	    /**
	     * @param elem
	     *            the element to be deleted
	     */
	    void deleteOperation(Object elem) {
	        if (!(elem instanceof Operation)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	        Operation oper = (Operation) elem;
	        // delete CallActions which have this as their operation
	        modelImpl.getUmlHelper().deleteCollection(
	                ((org.omg.uml.UmlPackage) oper.refOutermostPackage())
	                        .getCommonBehavior().getACallActionOperation()
	                        .getCallAction(oper));
	        // delete CallEvents which have this as their operation
	        modelImpl.getUmlHelper().deleteCollection(
	                ((org.omg.uml.UmlPackage) oper.refOutermostPackage())
	                        .getStateMachines().getAOccurrenceOperation()
	                        .getOccurrence(oper));
	    }
	
	    /**
	     * @param elem
	     *            the element to be deleted
	     */
	    void deleteParameter(Object elem) {
	        if (!(elem instanceof Parameter)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	    }
	
	    /**
	     * @param elem
	     *            the element to be deleted
	     */
	    void deletePermission(Object elem) {
	        if (!(elem instanceof Permission)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	    }
	
	    /**
	     * @param elem
	     *            the element to be deleted
	     */
	    void deletePresentationElement(Object elem) {
	        if (!(elem instanceof PresentationElement)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	
	    }
	
	    /**
	     * @param elem
	     *            the element to be deleted
	     */
	    void deleteRelationship(Object elem) {
	        if (!(elem instanceof Relationship)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	    }
	
	    /**
	     * @param elem
	     *            the element to be deleted
	     */
	    void deleteStructuralFeature(Object elem) {
	        if (!(elem instanceof StructuralFeature)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	    }
	
	    /**
	     * @param elem
	     *            the element to be deleted
	     */
	    void deleteTemplateArgument(Object elem) {
	        if (!(elem instanceof TemplateArgument)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	    }
	
	    /**
	     * @param elem
	     *            the element to be deleted
	     */
	    void deleteTemplateParameter(Object elem) {
	        if (!(elem instanceof TemplateParameter)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	    }
	
	    /**
	     * @param elem
	     *            the element to be deleted
	     */
	    void deleteUsage(Object elem) {
	        if (!(elem instanceof Usage)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	    }
	
	    /**
	     * Delete an Enumeration.
	     * @param elem
	     *            the element to be deleted
	     * @since UML 1.4
	     */
	    void deleteEnumeration(Object elem) {
	        if (!(elem instanceof Enumeration)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	        // EnumerationLiterals should get deleted implicitly
	        // since they are associated by composition
	    }
	
	    /**
	     * Delete EnumerationLiteral.
	     * @param elem
	     *            the element to be deleted
	     * @since UML 1.4
	     */
	    void deleteEnumerationLiteral(Object elem) {
	        if (!(elem instanceof EnumerationLiteral)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	    }
	
	    /**
	     * Delete the given UML Primitive.
	     *
	     * @param elem the element to be deleted
	     * @since UML 1.4
	     */
	    void deletePrimitive(Object elem) {
	        if (!(elem instanceof Primitive)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	    }
	
	    /**
	     * Delete the given ProgrammingLanguageDataType.
	     *
	     * @param elem the element to be deleted
	     * @since UML 1.4
	     */
	    void deleteProgrammingLanguageDataType(Object elem) {
	        if (!(elem instanceof ProgrammingLanguageDataType)) {
	            throw new IllegalArgumentException("elem: " + elem);
	        }
	    }
	
	
	
	    /**
	     * Copies a class, and it's features. This may also require other
	     * classifiers to be copied.
	     *
	     * @param source
	     *            is the class to copy.
	     * @param ns
	     *            is the namespace to put the copy in.
	     * @return a newly created class.
	     */
	    public UmlClass copyClass(Object source, Object ns) {
	        if (!(source instanceof UmlClass && ns instanceof Namespace)) {
	            throw new IllegalArgumentException("source: " + source + ",ns: "
	                    + ns);
	        }
	
	        UmlClass c = createClass();
	        ((Namespace) ns).getOwnedElement().add(c);
	        doCopyClass(source, c);
	        return c;
	    }
	
	    /**
	     * Copies a feature from one classifier to another.
	     *
	     * @param source is the feature to copy.
	     * @param classifier is the classifier to put the copy in.
	     * @return a newly created feature.
	     */
	    public Feature copyFeature(Object source, Object classifier) {
	        if (!(source instanceof Feature && classifier instanceof Classifier)) {
	            throw new IllegalArgumentException("source: " + source
	                    + ",classifier: " + classifier);
	        }
	
	        Feature f = null;
	        if (source instanceof Attribute) {
	            Attribute attr = createAttribute();
	            doCopyAttribute((Attribute) source, attr);
	            f = attr;
	        } else if (source instanceof Operation) {
	            Operation oper = createOperation();
	            doCopyOperation((Operation) source, oper);
	            // TODO: build a return parameter
	            f = oper;
	        } else if (source instanceof Method) {
	            Method method = createMethod();
	            doCopyMethod((Method) source, method);
	            f = method;
	        } else if (source instanceof Reception) {
	            Reception reception = (Reception)
	                modelImpl.getCommonBehaviorFactory().createReception();
	            doCopyReception((Reception) source, reception);
	            f = reception;
	        } else {
	            throw new IllegalArgumentException("source: " + source);
	        }
	
	        f.setOwner((Classifier) classifier);
	        ((Classifier) classifier).getFeature().add(f);
	        return f;
	    }
	
	    /**
	     * Copies a datatype, and it's features. This may also require other
	     * classifiers to be copied.
	     *
	     * @param source
	     *            is the datatype to copy.
	     * @param ns
	     *            is the namespace to put the copy in.
	     * @return a newly created data type.
	     */
	    public DataType copyDataType(Object source, Object ns) {
	        if (!(source instanceof DataType)) {
	            throw new IllegalArgumentException();
	        }
	
	        if (!(ns instanceof Namespace)) {
	            throw new IllegalArgumentException();
	        }
	
	        DataType i = createDataType();
	        ((Namespace) ns).getOwnedElement().add(i);
	        doCopyDataType(source, i);
	        return i;
	    }
	
	    /**
	     * Copies an interface, and it's features. This may also require other
	     * classifiers to be copied.
	     *
	     * @param source
	     *            is the interface to copy.
	     * @param ns
	     *            is the namespace to put the copy in.
	     * @return a newly created interface.
	     */
	    public Interface copyInterface(Object source, Object ns) {
	        if (!(source instanceof Interface)) {
	            throw new IllegalArgumentException();
	        }
	
	        if (!(ns instanceof Namespace)) {
	            throw new IllegalArgumentException();
	        }
	
	        Interface i = createInterface();
	        ((Namespace) ns).getOwnedElement().add(i);
	        doCopyInterface(source, i);
	        return i;
	    }
	
	    /**
	     *
	     * @param from
	     *            The object which own the enumeration to copy
	     * @param to
	     *            The object to which copy the enumeration
	     */
	    public void copyEnumeration(Object from, Object to) {
	        doCopyModelElement(from, to);
	        List listFrom = ((Enumeration) from).getLiteral();
	        List listTo = ((Enumeration) to).getLiteral();
	        Object literalFrom;
	        Object literalTo;
	        for (int i = 0; i < listFrom.size(); i++) {
	            literalFrom = listFrom.get(i);
	            if (listTo.size() > i) {
	                literalTo = listTo.get(i);
	            } else {
	                literalTo = createEnumerationLiteral();
	                listTo.add(literalTo);
	            }
	            doCopyModelElement(literalFrom, literalTo);
	            ((EnumerationLiteral) literalTo).setEnumeration((Enumeration) to);
	        }
	    }
	
	    /**
	     * Used by the copy functions. Do not call this function directly.
	     */
	    private void doCopyElement(Object source, Object target) {
	        // Nothing more to do.
	    }
	
	    /**
	     * Used by the copy functions. Do not call this function directly.
	     *
	     * @param source
	     *            the source class
	     * @param target
	     *            the target class
	     */
	    public void doCopyClass(Object source, Object target) {
	        if (!(source instanceof UmlClass)) {
	            throw new IllegalArgumentException();
	        }
	
	        if (!(target instanceof UmlClass)) {
	            throw new IllegalArgumentException();
	        }
	
	        doCopyClassifier(source, target);
	
	        ((UmlClass) target).setActive(((UmlClass) source).isActive());
	    }
	
	    /*
	     * TODO: All the ToDos in the doCopyFoo methods below are inherited from the
	     * NSUML implementation and do not reflect new issues. One additional thing
	     * which does need to be dealt with is the copying of any attributes which
	     * have been added since this code was implemented for UML 1.3.
	     */
	    /**
	     * Used by the copy functions. Do not call this function directly.
	     * TODO: actions? instances? collaborations etc?
	     *
	     * @param source
	     *            the source classifier
	     * @param target
	     *            the target classifier
	     */
	    public void doCopyClassifier(Object source, Object target) {
	        if (!(source instanceof Classifier)) {
	            throw new IllegalArgumentException();
	        }
	
	        if (!(target instanceof Classifier)) {
	            throw new IllegalArgumentException();
	        }
	
	        // TODO: how to merge multiple inheritance? Necessary?
	        // This currently copies the common ancestors multiple times
	        doCopyNamespace(source, target);
	        doCopyGeneralizableElement(source, target);
	
	        // Copy all the Features
	        for (Feature f : ((Classifier) source).getFeature()) {
	            copyFeature(f, target);
	        }
	    }
	
	    /**
	     * Used by the copy functions. Do not call this function directly.
	     *
	     * @param source
	     *            the source datatype
	     * @param target
	     *            the target datatype
	     */
	    public void doCopyDataType(Object source, Object target) {
	        if (!(source instanceof DataType)) {
	            throw new IllegalArgumentException();
	        }
	
	        if (!(target instanceof DataType)) {
	            throw new IllegalArgumentException();
	        }
	
	        doCopyClassifier(source, target);
	    }
	
	    /**
	     * Used by the copy functions. Do not call this function directly.
	     * TODO: generalizations, specializations?
	     *
	     * @param source
	     *            the source generalizable element
	     * @param target
	     *            the target generalizable element
	     */
	    public void doCopyGeneralizableElement(Object source, Object target) {
	        if (!(source instanceof GeneralizableElement
	                && target instanceof GeneralizableElement)) {
	            throw new IllegalArgumentException("source: " + source
	                    + ",target: " + target);
	        }
	
	        doCopyModelElement(source, target);
	
	        GeneralizableElement targetGE = ((GeneralizableElement) target);
	        GeneralizableElement sourceGE = ((GeneralizableElement) source);
	        targetGE.setAbstract(sourceGE.isAbstract());
	        targetGE.setLeaf(sourceGE.isLeaf());
	        targetGE.setRoot(sourceGE.isRoot());
	    }
	
	    /**
	     * Used by the copy functions. Do not call this function directly.
	     *
	     * @param source
	     *            the source interface
	     * @param target
	     *            the target interface
	     */
	    public void doCopyInterface(Object source, Object target) {
	        if (!(source instanceof Interface)) {
	            throw new IllegalArgumentException();
	        }
	
	        if (!(target instanceof Interface)) {
	            throw new IllegalArgumentException();
	        }
	
	        doCopyClassifier(source, target);
	    }
	
	    /**
	     * Used by the copy functions. Do not call this function directly.
	     * TODO: template parameters, default type
	     * TODO: constraining elements
	     * TODO: flows, dependencies, comments, bindings, contexts ???
	     * TODO: contents, residences ???
	     *
	     * @param source
	     *            the source me
	     * @param target
	     *            the target me
	     */
	    public void doCopyModelElement(Object source, Object target) {
	        if (!(source instanceof ModelElement)) {
	            throw new IllegalArgumentException();
	        }
	
	        if (!(target instanceof ModelElement)) {
	            throw new IllegalArgumentException();
	        }
	
	        // Set the name so that superclasses can find the newly
	        // created element in the model, if necessary.
	        ModelElement targetME = ((ModelElement) target);
	        ModelElement sourceME = ((ModelElement) source);
	        targetME.setName(sourceME.getName());
	        doCopyElement(source, target);
	
	        targetME.setSpecification(sourceME.isSpecification());
	        targetME.setVisibility(sourceME.getVisibility());
	        modelImpl.getExtensionMechanismsFactory()
	                .copyTaggedValues(source, target);
	
	        if (!sourceME.getStereotype().isEmpty()) {
	            // Note that if we're copying this element then we
	            // must also be allowed to copy other necessary
	            // objects.
	            for (Stereotype s : sourceME.getStereotype()) {
	                targetME.getStereotype().add(s);
	            }
	        }
	    }
	
	    /**
	     * Used by the copy functions. Do not call this function directly.
	     *
	     * @param source
	     *            the source namespace
	     * @param target
	     *            the target namespace
	     */
	    public void doCopyNamespace(Object source, Object target) {
	        if (!(source instanceof Namespace)) {
	            throw new IllegalArgumentException();
	        }
	
	        if (!(target instanceof Namespace)) {
	            throw new IllegalArgumentException();
	        }
	
	        doCopyModelElement(source, target);
	        // Nothing more to do, don't copy owned elements.
	    }
	
	    /**
	     * Copy the meta-attributes of an Attribute to another.
	     *
	     * @param source the source attribute
	     * @param target the new attribute to be adapted
	     */
	    void doCopyAttribute(Attribute source, Attribute target) {
	        // TODO: Delete old multiplicity? Why is "copy" using hard coded value? - tfm
	        target.setMultiplicity(getMultiplicity11());
	        target.setChangeability(source.getChangeability());
	        target.setTargetScope(source.getTargetScope());
	        target.setType(source.getType());
	
	        doCopyFeature(source, target);
	    }
	
	    /**
	     * Copy the attributes of an Operation to another.
	     *
	     * @param source the source operation
	     * @param target the new operation to be modified
	     */
	    void doCopyOperation(Operation source, Operation target) {
	        target.setAbstract(source.isAbstract());
	        target.setLeaf(source.isLeaf());
	        target.setRoot(source.isRoot());
	        target.setConcurrency(source.getConcurrency());
	        target.setSpecification(source.getSpecification());
	
	        doCopyBehavioralFeature(source, target);
	    }
	
	    /**
	     * Copy the attributes of one Method to another.
	     *
	     * @param source the method to copy attributes from
	     * @param target the method to be adapted
	     */
	    void doCopyMethod(Method source, Method target) {
	        ProcedureExpression pe = source.getBody();
	        ProcedureExpression oldPe = target.getBody();
	        if (!equal(oldPe,pe)) {
	            target.setBody((ProcedureExpression)
	                    modelImpl.getDataTypesFactory().createProcedureExpression(
	                            pe.getLanguage(), pe.getBody()));
	            if (oldPe != null) {
	                Model.getUmlFactory().delete(oldPe);
	            }
	        }
	
	        doCopyBehavioralFeature(source, target);
	    }
	
	
	    private boolean equal(Expression expr1, Expression expr2) {
	        if (expr1 == null) {
	            if (expr2 == null) {
	                return true;
	            } else {
	                return false;
	            }
	        } else {
	            return expr1.equals(expr2);
	        }
	    }
	
	    /**
	     * Copy the attributes of one Reception to another.
	     *
	     * @param source the reception to copy attributes from
	     * @param target the reception to be adapted
	     */
	    void doCopyReception(Reception source, Reception target) {
	        target.setAbstract(source.isAbstract());
	        target.setLeaf(source.isLeaf());
	        target.setRoot(source.isRoot());
	        target.setSpecification(source.getSpecification());
	        target.setSignal(source.getSignal());
	
	        doCopyBehavioralFeature(source, target);
	    }
	
	
	    /**
	     * Copy the attributes of one BehavioralFeature to another.
	     *
	     * @param source the BehavioralFeature to copy from
	     * @param target the BehavioralFeature to b adapted
	     */
	    void doCopyBehavioralFeature(BehavioralFeature source,
	            BehavioralFeature target) {
	        target.setQuery(source.isQuery());
	        // copy raised signals:
	        Collection<Signal> raisedSignals = ((org.omg.uml.UmlPackage) source
	                .refOutermostPackage()).getCommonBehavior()
	                .getAContextRaisedSignal().getRaisedSignal(source);
	        for (Signal signal : raisedSignals) {
	            ((org.omg.uml.UmlPackage) source.refOutermostPackage())
	                    .getCommonBehavior().getAContextRaisedSignal().add(target,
	                            signal);
	        }
	
	        doCopyFeature(source, target);
	    }
	
	    /**
	     * Copy the attributes of one Feature to another.
	     *
	     * @param source the Feature to copy from
	     * @param target the Feature to copy to
	     */
	    void doCopyFeature(Feature source, Feature target) {
	        target.setVisibility(source.getVisibility());
	        target.setOwnerScope(source.getOwnerScope());
	
	        doCopyModelElement(source, target);
	    }
	
	}
		
",
	role:"
	user	
",
,
	content:"
	//src/argouml-core-model-euml/src/org/argouml/model/euml/CoreFactoryEUMLImpl.java
	// $Id$
	/*******************************************************************************
	 * Copyright (c) 2007,2010 Tom Morris and other contributors
	 * All rights reserved. This program and the accompanying materials
	 * are made available under the terms of the Eclipse Public License v1.0
	 * which accompanies this distribution, and is available at
	 * http://www.eclipse.org/legal/epl-v10.html
	 *
	 * Contributors:
	 *    Tom Morris - initial implementation
	 *    Bogdan Pistol - undo support & large piece of initial implementation
	 *    bobtarling
	 *    Thomas Neustupny
	 *****************************************************************************/
	
	package org.argouml.model.euml;
	
	import java.util.List;
	
	import org.argouml.model.AbstractModelFactory;
	import org.argouml.model.CoreFactory;
	import org.argouml.model.NotImplementedException;
	import org.eclipse.emf.edit.domain.EditingDomain;
	import org.eclipse.uml2.uml.Abstraction;
	import org.eclipse.uml2.uml.AggregationKind;
	import org.eclipse.uml2.uml.Artifact;
	import org.eclipse.uml2.uml.Association;
	import org.eclipse.uml2.uml.AssociationClass;
	import org.eclipse.uml2.uml.BehavioralFeature;
	import org.eclipse.uml2.uml.BehavioredClassifier;
	import org.eclipse.uml2.uml.Classifier;
	import org.eclipse.uml2.uml.Comment;
	import org.eclipse.uml2.uml.Component;
	import org.eclipse.uml2.uml.ComponentRealization;
	import org.eclipse.uml2.uml.Constraint;
	import org.eclipse.uml2.uml.DataType;
	import org.eclipse.uml2.uml.Dependency;
	import org.eclipse.uml2.uml.Element;
	import org.eclipse.uml2.uml.Enumeration;
	import org.eclipse.uml2.uml.EnumerationLiteral;
	import org.eclipse.uml2.uml.Generalization;
	import org.eclipse.uml2.uml.Interface;
	import org.eclipse.uml2.uml.InterfaceRealization;
	import org.eclipse.uml2.uml.Manifestation;
	import org.eclipse.uml2.uml.MultiplicityElement;
	import org.eclipse.uml2.uml.NamedElement;
	import org.eclipse.uml2.uml.Namespace;
	import org.eclipse.uml2.uml.Node;
	import org.eclipse.uml2.uml.OpaqueBehavior;
	import org.eclipse.uml2.uml.Operation;
	import org.eclipse.uml2.uml.PackageImport;
	import org.eclipse.uml2.uml.PackageableElement;
	import org.eclipse.uml2.uml.Parameter;
	import org.eclipse.uml2.uml.PrimitiveType;
	import org.eclipse.uml2.uml.Property;
	import org.eclipse.uml2.uml.Stereotype;
	import org.eclipse.uml2.uml.TemplateBinding;
	import org.eclipse.uml2.uml.TemplateParameter;
	import org.eclipse.uml2.uml.TemplateParameterSubstitution;
	import org.eclipse.uml2.uml.TemplateSignature;
	import org.eclipse.uml2.uml.TemplateableElement;
	import org.eclipse.uml2.uml.Type;
	import org.eclipse.uml2.uml.UMLFactory;
	import org.eclipse.uml2.uml.Usage;
	import org.eclipse.uml2.uml.ValueSpecification;
	import org.eclipse.uml2.uml.VisibilityKind;
	
	/**
	 * The implementation of the CoreFactory for EUML2.
	 */
	class CoreFactoryEUMLImpl implements CoreFactory, AbstractModelFactory {
	
	    /**
	     * The model implementation.
	     */
	    private final EUMLModelImplementation modelImpl;
	
	    private final EditingDomain editingDomain;
	
	    /**
	     * Constructor.
	     * 
	     * @param implementation
	     *                The ModelImplementation.
	     */
	    public CoreFactoryEUMLImpl(EUMLModelImplementation implementation) {
	        modelImpl = implementation;
	        editingDomain = implementation.getEditingDomain();
	    }
	
	    public Abstraction buildAbstraction(final String name,
	            final Object supplier, final Object client) {
	        if (!(client instanceof NamedElement)
	                || !(supplier instanceof NamedElement)) {
	            throw new IllegalArgumentException(
	                    "The client and the supplier " + //$NON-NLS-1$
	                    "must be NamedElements."); //$NON-NLS-1$
	        }
	        if (((NamedElement) client).getNearestPackage() == null) {
	            throw new NullPointerException(
	                    "The containing package of the client " + //$NON-NLS-1$
	                    "must be non-null."); //$NON-NLS-1$
	        }
	        RunnableClass run = new RunnableClass() {
	            public void run() {
	                Abstraction abstraction = createAbstraction();
	                if (name != null) {
	                    abstraction.setName(name);
	                }
	                abstraction.getSuppliers().add((NamedElement) supplier);
	                abstraction.getClients().add((NamedElement) client);
	                ((NamedElement) client).getNearestPackage()
	                        .getPackagedElements().add(abstraction);
	                getParams().add(abstraction);
	            }
	        };
	        ChangeCommand cmd = new ChangeCommand(
	                modelImpl, run,
	                "Create the abstraction # between " + //$NON-NLS-1$
	                "the client # and the supplier #"); //$NON-NLS-1$
	        editingDomain.getCommandStack().execute(cmd);
	        cmd.setObjects(run.getParams().get(0), client, supplier);
	
	        return (Abstraction) run.getParams().get(0);
	    }
	
	    private Association buildAssociation(final Object type1,
	            final Boolean navigability1, final Object aggregationKind1,
	            final Object type2, final Boolean navigability2,
	            final Object aggregationKind2, final String associationName) {
	        if (!(type1 instanceof Type) || !(type2 instanceof Type)) {
	            throw new IllegalArgumentException(
	                    "The types must be instances of Type."); //$NON-NLS-1$
	        }
	        if ((aggregationKind1 != null 
	                    && !(aggregationKind1 instanceof AggregationKind))
	                || (aggregationKind2 != null 
	                        && !(aggregationKind2 instanceof AggregationKind))) {
	            throw new IllegalArgumentException(
	                    "The aggregations of the association ends" + //$NON-NLS-1$
	                    " must be instances of AggregationKind."); //$NON-NLS-1$
	        }
	        if (((Type) type1).getNearestPackage() == null) {
	            throw new NullPointerException(
	                    "The containing package of the type1" + //$NON-NLS-1$
	                    " must be non-null."); //$NON-NLS-1$
	        }
	        RunnableClass run = new RunnableClass() {
	            public void run() {
	                Association association = createAssociation();
	                Property property1 = buildAssociationEndInternal(association,
	                        null, (Type) type1, null, null, navigability1, null,
	                        (AggregationKind) aggregationKind1, null, null);
	                Property property2 = buildAssociationEndInternal(association,
	                        null, (Type) type2, null, null, navigability2, null,
	                        (AggregationKind) aggregationKind2, null, null);
	                if (associationName != null) {
	                    association.setName(associationName);
	                }
	                association.getOwnedEnds().add(property1);
	                association.getOwnedEnds().add(property2);
	                // The code below will make navigable ends owned by 
	                // the classifier at the opposite end, but let's just
	                // make them owned by the association for simplicity 
	                // (don't assume everything will be like this though!)
	                // Bob says - see page 42 and 43 of UML2.2 superstructure
	                // for info on property ownership. Default will be 
	                // association ownership but we need a way for the 
	                // user to change to classifier ownership at a
	                // later time.
	//                if (UMLUtil.getOwnedAttributes((Type) type2) == null) {
	//                    association.getOwnedEnds().add(property1);
	//                } else {
	//                    UMLUtil.getOwnedAttributes((Type) type2).add(property1);
	//                }
	//                if (UMLUtil.getOwnedAttributes((Type) type1) == null) {
	//                    association.getOwnedEnds().add(property2);
	//                } else {
	//                    UMLUtil.getOwnedAttributes((Type) type1).add(property2);
	//                }
	                //
	                ((Type) type1).getNearestPackage().getPackagedElements().add(
	                        association);
	                getParams().add(association);
	            }
	        };
	        ChangeCommand cmd = new ChangeCommand(
	                modelImpl, run, "Create the association # between # and #");
	        editingDomain.getCommandStack().execute(cmd);
	        cmd.setObjects(run.getParams().get(0), type1, type2);
	
	        return (Association) run.getParams().get(0);
	    }
	
	    @Deprecated
	    public Association buildAssociation(Object fromClassifier,
	            Object aggregationKind1, Object toClassifier,
	            Object aggregationKind2, Boolean unidirectional) {
	        if (unidirectional != null) {
	            return buildAssociation(
	                    fromClassifier, !unidirectional, 
	                    aggregationKind1, toClassifier,
	                    true, aggregationKind2, null);
	        } else {
	            return buildAssociation(
	                    fromClassifier, null, aggregationKind1, toClassifier, null,
	                    aggregationKind2, null);
	        }
	    }
	    
	
	    public Object buildAssociation(Object fromClassifier,
	            Object aggregationKind1, Object toClassifier,
	            Object aggregationKind2, boolean unidirectional) {
	        return buildAssociation(
	                fromClassifier, true, aggregationKind1, toClassifier,
	                !unidirectional, aggregationKind2, null); 
	    }
	
	
	    public Association buildAssociation(Object classifier1, 
	            Object classifier2) {
	        return buildAssociation(
	                classifier1, null, null, classifier2, null, null, null);
	    }
	
	    public Association buildAssociation(Object c1, boolean nav1, Object c2,
	            boolean nav2, String name) {
	        return buildAssociation(c1, nav1, null, c2, nav2, null, name);
	    }
	
	    public AssociationClass buildAssociationClass(final Object end1,
	            final Object end2) {
	        if (!(end1 instanceof Type) || !(end2 instanceof Type)) {
	            throw new IllegalArgumentException(
	                    "end1 and end2 must be instances of Type"); //$NON-NLS-1$
	        }
	        if (((Type) end1).getNearestPackage() == null) {
	            throw new NullPointerException(
	                    "The containing package of " + //$NON-NLS-1$
	                    "the end1 must be non-null."); //$NON-NLS-1$
	        }
	        RunnableClass run = new RunnableClass() {
	            public void run() {
	                AssociationClass associationClass = createAssociationClass();
	                Property property1 = createAssociationEnd();
	                Property property2 = createAssociationEnd();
	                property1.setType((Type) end2);
	                property2.setType((Type) end1);
	                property1.setAssociation(associationClass);
	                property2.setAssociation(associationClass);
	                ((Type) end1).getNearestPackage().getPackagedElements().add(
	                        associationClass);
	                if (UMLUtil.getOwnedAttributes((Type) end1) == null) {
	                    associationClass.getOwnedAttributes().add(property1);
	                } else {
	                    UMLUtil.getOwnedAttributes((Type) end1).add(property1);
	                }
	                if (UMLUtil.getOwnedAttributes((Type) end2) == null) {
	                    associationClass.getOwnedAttributes().add(property2);
	                } else {
	                    UMLUtil.getOwnedAttributes((Type) end2).add(property2);
	                }
	                getParams().add(associationClass);
	            }
	        };
	        ChangeCommand cmd = new ChangeCommand(
	                modelImpl, run,
	                "Create the association class # between # and #");
	        editingDomain.getCommandStack().execute(cmd);
	        cmd.setObjects(run.getParams().get(0), end1, end2);
	
	        return (AssociationClass) run.getParams().get(0);
	    }
	
	    private Property buildAssociationEnd(final Object assoc, final String name,
	            final Object type, final Object multi, final Object stereo,
	            final Boolean navigable, final Object order,
	            final Object aggregation, final Object scope,
	            final Object changeable, final Object visibility) {
	        // The attribute 'targetScope' of an AssociationEnd in UML1.x is no
	        // longer supported in UML2.x
	        if (!(assoc instanceof Association)) {
	            throw new IllegalArgumentException(
	                    "The assoc must be instance of Association."); //$NON-NLS-1$
	        }
	        if (!(type instanceof Type)) {
	            throw new IllegalArgumentException(
	                    "The type of the property " + //$NON-NLS-1$
	                    "must be instance of Type."); //$NON-NLS-1$
	        }
	        if (aggregation != null && !(aggregation instanceof AggregationKind)) {
	            throw new IllegalArgumentException(
	                    "The aggregation of the property " + //$NON-NLS-1$
	                    "must be instance of AggregationKind."); //$NON-NLS-1$
	        }
	        if (visibility != null && !(visibility instanceof VisibilityKind)) {
	            throw new IllegalArgumentException(
	                    "The visibility of the property must" + //$NON-NLS-1$
	                    " be instance of VisibilityKind."); //$NON-NLS-1$
	        }
	        if (!(multi instanceof MultiplicityElement)) {
	            throw new IllegalArgumentException(
	                    "The multilicity of the property must" + //$NON-NLS-1$
	                    " be instance of MultiplicityElement."); //$NON-NLS-1$
	        }
	        MultiplicityElement m = (MultiplicityElement) multi;
	        final int lower = m.getLower();
	        final int upper = m.getUpper();
	        if ((order != null && !(order instanceof Boolean))
	                || (changeable != null && !(changeable instanceof Boolean))) {
	            throw new IllegalArgumentException(
	                    "The isOrdered, isReadOnly attributes of " + //$NON-NLS-1$
	                    "the property must be instances of Boolean."); //$NON-NLS-1$
	        }
	        if (stereo != null && !(stereo instanceof Stereotype)) {
	            throw new IllegalArgumentException(
	                    "stereo must be instance of Stereotype."); //$NON-NLS-1$
	        }
	        RunnableClass run = new RunnableClass() {
	            public void run() {
	                Property property = buildAssociationEndInternal(
	                        (Association) assoc, name, (Type) type,
	                        new Integer[] {lower, upper}, (Stereotype) stereo,
	                        navigable, (Boolean) order,
	                        (AggregationKind) aggregation,
	                        (Boolean) changeable, (VisibilityKind) visibility);
	                getParams().add(property);
	            }
	        };
	        modelImpl.getModelEventPump().getRootContainer().setHoldEvents(true);
	        ChangeCommand cmd = new ChangeCommand(
	                modelImpl, run,
	                "Create the association end # of the association #");
	        editingDomain.getCommandStack().execute(cmd);
	        if (run.getParams().isEmpty()) {
	            editingDomain.getCommandStack().undo();
	            editingDomain.getCommandStack().flush();
	            modelImpl.getModelEventPump().getRootContainer().clearHeldEvents();
	            modelImpl.getModelEventPump().getRootContainer().setHoldEvents(
	                    false);
	            throw new UnsupportedOperationException(
	                    "This stereotype cannot be applied " + //$NON-NLS-1$
	                    "to the association end."); //$NON-NLS-1$
	        }
	        cmd.setObjects(run.getParams().get(0), assoc);
	        modelImpl.getModelEventPump().getRootContainer().setHoldEvents(false);
	
	        return (Property) run.getParams().get(0);
	    }
	
	    private Property buildAssociationEndInternal(final Association assoc,
	            final String name, final Type type,
	            final Integer[] multi, final Stereotype stereo,
	            final Boolean navigable, final Boolean order,
	            final AggregationKind aggregation, // final Object scope,
	            final Object changeable, final VisibilityKind visibility) {
	        // The attribute 'targetScope' of an AssociationEnd in UML1.x is no
	        // longer supported in UML2.x
	
	        Property property = createAssociationEnd();
	        property.setType((Type) type);
	        property.setAssociation((Association) assoc);
	        if (name != null) {
	            property.setName(name);
	        }
	        if (navigable != null) {
	            property.setIsNavigable(navigable);
	            if (!(Boolean) navigable) {
	                ((Association) assoc).getOwnedEnds().add(property);
	            }
	        }
	        if (aggregation != null) {
	            property.setAggregation((AggregationKind) aggregation);
	        }
	        if (visibility != null) {
	            property.setVisibility((VisibilityKind) visibility);
	        }
	        if (multi != null) {
	            if (multi[0] != null) {
	                property.setLower(multi[0]);
	            }
	            if (multi[1] != null) {
	                property.setUpper(multi[1]);
	            }
	        }
	        if (order != null) {
	            property.setIsOrdered((Boolean) order);
	        }
	        if (changeable != null) {
	            property.setIsReadOnly((Boolean) changeable);
	        }
	        if (stereo != null) {
	            if (property.isStereotypeApplicable((Stereotype) stereo)) {
	                property.applyStereotype((Stereotype) stereo);
	            } 
	        }
	        return property;
	    }
	    
	    @Deprecated
	    public Property buildAssociationEnd(Object assoc, String name, Object type,
	            Object multi, Object stereo, boolean navigable, Object order,
	            Object aggregation, Object scope, Object changeable,
	            Object visibility) {
	        throw new NotImplementedException();
	    }
	
	    public Property buildAssociationEnd(Object assoc, String name, Object type,
	            Integer[] multi, Object stereo, boolean navigable, Object order,
	            Object aggregation, Object scope, Object changeable,
	            Object visibility) {
	        return buildAssociationEndInternal((Association) assoc, name,
	                (Type) type, multi, (Stereotype) stereo, (Boolean) navigable,
	                (Boolean) order, (AggregationKind) aggregation,
	                changeable, (VisibilityKind) visibility);
	    }
	        
	    public Property buildAssociationEnd(Object type, Object assoc) {
	        return buildAssociationEnd(
	                assoc, null, type, null, null, null, null, null, null, null,
	                null);
	    }
	
	    public Property buildAttribute(Object model, Object type) {
	        return buildAttribute2(type);
	    }
	
	    public Property buildAttribute2(Object type) {
	        if (!(type instanceof Type)) {
	            throw new IllegalArgumentException(
	                    "The type of the attribute must" + //$NON-NLS-1$
	                    " be instance of Type."); //$NON-NLS-1$
	        }
	        Property property = createAttribute();
	        property.setType((Type) type);
	        return property;
	    }
	
	
	    public Property buildAttribute2(final Object handle, final Object type) {
	        if (!(handle instanceof Type)) {
	            throw new IllegalArgumentException(
	                    "handle must be instance of Type."); //$NON-NLS-1$
	        }
	        if (type != null && !(type instanceof Type)) {
	            throw new IllegalArgumentException(
	                    "type must be instance of Type."); //$NON-NLS-1$
	        }
	        if (UMLUtil.getOwnedAttributes((Type) handle) == null) {
	            throw new UnsupportedOperationException(
	                    "The type " + handle.getClass()  //$NON-NLS-1$
	                    + " does not support owning attributes."); //$NON-NLS-1$
	        }
	        RunnableClass run = new RunnableClass() {
	            public void run() {
	                Property property = createAttribute();
	                UMLUtil.getOwnedAttributes((Type) handle).add(property);
	                if (type != null) {
	                    property.setType((Type) type);
	                }
	                property.setName("newAttr");
	                getParams().add(property);
	            }
	        };
	        ChangeCommand cmd = new ChangeCommand(
	                modelImpl, run, "Create the attribute # of the type #");
	        editingDomain.getCommandStack().execute(cmd);
	        cmd.setObjects(run.getParams().get(0), handle);
	
	        return (Property) run.getParams().get(0);
	    }
	
	    /**
	     * Removed from UML2.x, use buildTemplateBinding instead.
	     */
	    @Deprecated
	    public Object buildBinding(Object client, Object supplier, List arguments) {
	        return buildTemplateBinding(client, supplier, arguments);
	    }
	
	    public TemplateBinding buildTemplateBinding(final Object client,
	            final Object supplier, final List arguments) {
	        // TODO: Is it appropriate the TemplateableElement as the client and a
	        // list of TemplateParameterSubstitution as the list of parameters?
	        if (!(client instanceof TemplateableElement)) {
	            throw new IllegalArgumentException(
	                    "The supplier must be instance of " + //$NON-NLS-1$
	                    "TemplateableElement."); //$NON-NLS-1$
	        }
	        if (!(supplier instanceof TemplateSignature)) {
	            throw new IllegalArgumentException(
	                    "The supplier must be instance of " + //$NON-NLS-1$
	                    "TemplateSignature."); //$NON-NLS-1$
	        }
	        if (arguments != null) {
	            for (Object o : arguments) {
	                if (!(o instanceof TemplateParameterSubstitution)) {
	                    throw new IllegalArgumentException(
	                            "The list of arguments must be instances" + //$NON-NLS-1$
	                            " of TemplateParameterSubstitutions."); //$NON-NLS-1$
	                }
	            }
	        }
	        RunnableClass run = new RunnableClass() {
	            public void run() {
	                TemplateBinding templateBinding = createTemplateBinding();
	                templateBinding.setBoundElement((TemplateableElement) client);
	                templateBinding.setSignature((TemplateSignature) supplier);
	                if (arguments != null) {
	                    for (Object o : arguments) {
	                        templateBinding.getParameterSubstitutions().add(
	                                (TemplateParameterSubstitution) o);
	                    }
	                }
	                getParams().add(templateBinding);
	            }
	        };
	        ChangeCommand cmd = new ChangeCommand(
	                modelImpl, run,
	                "Create the template binding # between "
	                        + "the client # and the supplier #");
	        editingDomain.getCommandStack().execute(cmd);
	        cmd.setObjects(run.getParams().get(0), client, supplier);
	
	        return (TemplateBinding) run.getParams().get(0);
	    }
	
	    public org.eclipse.uml2.uml.Class buildClass() {
	        return createClass();
	    }
	
	    public org.eclipse.uml2.uml.Class buildClass(Object owner) {
	        return buildClass(null, owner);
	    }
	
	    public org.eclipse.uml2.uml.Class buildClass(String name) {
	        org.eclipse.uml2.uml.Class clazz = createClass();
	        if (name != null) {
	            clazz.setName(name);
	        }
	        return clazz;
	    }
	
	    public org.eclipse.uml2.uml.Class buildClass(final String name,
	            final Object owner) {
	        if (!(owner instanceof org.eclipse.uml2.uml.Package)
	                && !(owner instanceof org.eclipse.uml2.uml.Class)
	                && !(owner instanceof Interface)) {
	            throw new IllegalArgumentException(
	                    "The owner must be instance of Package" + //$NON-NLS-1$
	                    " or UML2 Class or Interface."); //$NON-NLS-1$
	        }
	        RunnableClass run = new RunnableClass() {
	            public void run() {
	                org.eclipse.uml2.uml.Class clazz = createClass();
	                if (name != null) {
	                    clazz.setName(name);
	                }
	                if (owner instanceof org.eclipse.uml2.uml.Package) {
	                    clazz.setPackage((org.eclipse.uml2.uml.Package) owner);
	                } else if (owner instanceof org.eclipse.uml2.uml.Class) {
	                    ((org.eclipse.uml2.uml.Class) owner).getNestedClassifiers()
	                            .add(clazz);
	                } else if (owner instanceof Interface) {
	                    ((Interface) owner).getNestedClassifiers().add(clazz);
	                }
	                getParams().add(clazz);
	            }
	        };
	        ChangeCommand cmd = new ChangeCommand(
	                modelImpl, run, "Create the class # of the owner #");
	        editingDomain.getCommandStack().execute(cmd);
	        cmd.setObjects(run.getParams().get(0), owner);
	
	        return (org.eclipse.uml2.uml.Class) run.getParams().get(0);
	    }
	
	    public Comment buildComment(final Object element, final Object model) {
	        if (!(model instanceof Namespace)) {
	            throw new IllegalArgumentException(
	                    "A namespace must be supplied."); //$NON-NLS-1$
	        }
	        if (element != null && !(element instanceof Element)) {
	            throw new IllegalArgumentException(
	                    "The annotated element must be instance of Element."); //$NON-NLS-1$
	        }
	        RunnableClass run = new RunnableClass() {
	            public void run() {
	                Comment comment = createComment();
	                if (element != null) {
	                    comment.getAnnotatedElements().add((Element) element);
	                }
	                ((Namespace) model).getOwnedComments().add(comment);
	                getParams().add(comment);
	            }
	        };
	        ChangeCommand cmd;
	        if (element == null) {
	            cmd = new ChangeCommand(modelImpl, run, "Create the comment #");
	        } else {
	            cmd = new ChangeCommand(
	                    modelImpl, run,
	                    "Create the comment # attached to the element #");
	        }
	        editingDomain.getCommandStack().execute(cmd);
	        if (element == null) {
	            cmd.setObjects(run.getParams().get(0));
	        } else {
	            cmd.setObjects(run.getParams().get(0), element);
	        }
	
	        return (Comment) run.getParams().get(0);
	    }
	
	    public Constraint buildConstraint(final Object constrElement) {
	        if (!(constrElement instanceof Element)) {
	            throw new IllegalArgumentException(
	                    "The constrained element must be instance of Element."); //$NON-NLS-1$
	        }
	        if (((Element) constrElement).getNearestPackage() == null) {
	            throw new NullPointerException(
	                    "The containing package of the constrained" //$NON-NLS-1$
	                            + " element must be non-null."); //$NON-NLS-1$
	        }
	        RunnableClass run = new RunnableClass() {
	            public void run() {
	                Constraint constraint = createConstraint();
	                constraint.getConstrainedElements()
	                        .add((Element) constrElement);
	                getParams().add(constraint);
	            }
	        };
	        ChangeCommand cmd = new ChangeCommand(
	                modelImpl, run,
	                "Create the constraint # that constrains the element #");
	        editingDomain.getCommandStack().execute(cmd);
	        cmd.setObjects(run.getParams().get(0), constrElement);
	
	        return (Constraint) run.getParams().get(0);
	    }
	
	    public Constraint buildConstraint(String name, Object bexpr) {
	        // TODO: BooleanExpresion is removed from UML2.x, is it OK to use
	        // ValueSpecification?
	        if (!(bexpr instanceof ValueSpecification)) {
	            throw new IllegalArgumentException(
	                    "The 'bexpr' value specification must be " //$NON-NLS-1$
	                            + "instance of ValueSpecification"); //$NON-NLS-1$
	        }
	        Constraint constraint = createConstraint();
	        if (name != null) {
	            constraint.setName(name);
	        }
	        constraint.setSpecification((ValueSpecification) bexpr);
	        return constraint;
	    }
	
	    public DataType buildDataType(final String name, final Object owner) {
	        if (!(owner instanceof org.eclipse.uml2.uml.Package)
	                && !(owner instanceof org.eclipse.uml2.uml.Class)
	                && !(owner instanceof Interface)) {
	            throw new IllegalArgumentException(
	                    "The owner must be instance of Package" //$NON-NLS-1$
	                            + " or UML2 Class or Interface."); //$NON-NLS-1$
	        }
	        RunnableClass run = new RunnableClass() {
	            public void run() {
	                DataType dataType = createDataType();
	                if (name != null) {
	                    dataType.setName(name);
	                }
	                if (owner instanceof org.eclipse.uml2.uml.Package) {
	                    dataType.setPackage((org.eclipse.uml2.uml.Package) owner);
	                } else if (owner instanceof org.eclipse.uml2.uml.Class) {
	                    ((org.eclipse.uml2.uml.Class) owner).getNestedClassifiers()
	                            .add(dataType);
	                } else if (owner instanceof Interface) {
	                    ((Interface) owner).getNestedClassifiers().add(dataType);
	                }
	                getParams().add(dataType);
	            }
	        };
	        ChangeCommand cmd = new ChangeCommand(
	                modelImpl, run, "Create the data type # owned by #");
	        editingDomain.getCommandStack().execute(cmd);
	        cmd.setObjects(run.getParams().get(0), owner);
	
	        return (DataType) run.getParams().get(0);
	    }
	
	    public Dependency buildDependency(final Object clientObj,
	            final Object supplierObj) {
	        if (!(clientObj instanceof NamedElement)
	                || !(supplierObj instanceof NamedElement)) {
	            throw new IllegalArgumentException(
	                    "The client and the supplier must be" //$NON-NLS-1$
	                            + " instances of NamedElement."); //$NON-NLS-1$
	        }
	        if (((NamedElement) clientObj).getNearestPackage() == null) {
	            throw new NullPointerException(
	                    "The containing package of the client must be non-null."); //$NON-NLS-1$
	        }
	        RunnableClass run = new RunnableClass() {
	            public void run() {
	                Dependency dependency = createDependency();
	                dependency.getClients().add((NamedElement) clientObj);
	                dependency.getSuppliers().add((NamedElement) supplierObj);
	                ((NamedElement) clientObj).getNearestPackage()
	                        .getPackagedElements().add(dependency);
	                getParams().add(dependency);
	            }
	        };
	        ChangeCommand cmd = new ChangeCommand(
	                modelImpl, run, "Create the dependency # between the"
	                        + " client # and the supplier #");
	        editingDomain.getCommandStack().execute(cmd);
	        cmd.setObjects(run.getParams().get(0), clientObj, supplierObj);
	
	        return (Dependency) run.getParams().get(0);
	    }
	
	    public Dependency buildComponentRealization(final Object clientObj,
	            final Object supplierObj) {
	        if (!(clientObj instanceof NamedElement)
	                || !(supplierObj instanceof NamedElement)) {
	            throw new IllegalArgumentException(
	                    "The client and the supplier must be" //$NON-NLS-1$
	                            + " instances of NamedElement."); //$NON-NLS-1$
	        }
	        if (((NamedElement) clientObj).getNearestPackage() == null) {
	            throw new NullPointerException(
	                    "The containing package of the client must be non-null."); //$NON-NLS-1$
	        }
	        RunnableClass run = new RunnableClass() {
	            public void run() {
	                ComponentRealization dependency =
	                    UMLFactory.eINSTANCE.createComponentRealization();
	                dependency.getClients().add((NamedElement) clientObj);
	                dependency.getSuppliers().add((NamedElement) supplierObj);
	                ((NamedElement) clientObj).getNearestPackage()
	                        .getPackagedElements().add(dependency);
	                getParams().add(dependency);
	            }
	        };
	        ChangeCommand cmd = new ChangeCommand(
	                modelImpl, run, "Create the component realization # between the"
	                        + " client # and the supplier #");
	        editingDomain.getCommandStack().execute(cmd);
	        cmd.setObjects(run.getParams().get(0), clientObj, supplierObj);
	
	        return (ComponentRealization) run.getParams().get(0);
	    }
	    
	    public Object buildElementResidence(Object me, Object component) {
	        // TODO: Is this removed from UML2 ?
	        throw new NotImplementedException();
	    }
	
	    public Enumeration buildEnumeration(final String name, final Object owner) {
	        if (!(owner instanceof org.eclipse.uml2.uml.Package)
	                && !(owner instanceof org.eclipse.uml2.uml.Class)
	                && !(owner instanceof Interface)) {
	            throw new IllegalArgumentException(
	                    "The owner must be instance of Package or UML2 Class or Interface."); //$NON-NLS-1$
	        }
	        RunnableClass run = new RunnableClass() {
	            public void run() {
	                Enumeration enumeration = createEnumeration();
	                if (name != null) {
	                    enumeration.setName(name);
	                }
	                if (owner instanceof org.eclipse.uml2.uml.Package) {
	                    enumeration.setPackage(
	                            (org.eclipse.uml2.uml.Package) owner);
	                } else if (owner instanceof org.eclipse.uml2.uml.Class) {
	                    ((org.eclipse.uml2.uml.Class) owner).getNestedClassifiers()
	                            .add(enumeration);
	                } else if (owner instanceof Interface) {
	                    ((Interface) owner).getNestedClassifiers().add(enumeration);
	                }
	                getParams().add(enumeration);
	            }
	        };
	        ChangeCommand cmd = new ChangeCommand(
	                modelImpl, run, "Create the enumeration # owned by #");
	        editingDomain.getCommandStack().execute(cmd);
	        cmd.setObjects(run.getParams().get(0), owner);
	
	        return (Enumeration) run.getParams().get(0);
	    }
	
	    public EnumerationLiteral buildEnumerationLiteral(final String name,
	            final Object enumeration) {
	        if (!(enumeration instanceof Enumeration)) {
	            throw new IllegalArgumentException(
	                    "The enumeration must be instance of Enumeration."); //$NON-NLS-1$
	        }
	        RunnableClass run = new RunnableClass() {
	            public void run() {
	                EnumerationLiteral enumerationLiteral = 
	                    createEnumerationLiteral();
	                if (name != null) {
	                    enumerationLiteral.setName(name);
	                }
	                enumerationLiteral.setEnumeration((Enumeration) enumeration);
	                getParams().add(enumerationLiteral);
	            }
	        };
	        ChangeCommand cmd = new ChangeCommand(
	                modelImpl, run, "Create the enumeration literal # owned by #");
	        editingDomain.getCommandStack().execute(cmd);
	        cmd.setObjects(run.getParams().get(0), enumeration);
	
	        return (EnumerationLiteral) run.getParams().get(0);
	    }
	
	
	    public Generalization buildGeneralization(final Object child,
	            final Object parent) {
	        if (!(child instanceof Classifier) || !(parent instanceof Classifier)) {
	            throw new IllegalArgumentException(
	                    "The general (the parent) and the specific (the child) must be instances of Classifier."); //$NON-NLS-1$
	        }
	        RunnableClass run = new RunnableClass() {
	            public void run() {
	                Generalization generalization = createGeneralization();
	                generalization.setGeneral((Classifier) parent);
	                generalization.setSpecific((Classifier) child);
	                getParams().add(generalization);
	            }
	        };
	        ChangeCommand cmd = new ChangeCommand(
	                modelImpl, run,
	                "Create the generalization # between # (general) and # (specific)");
	        editingDomain.getCommandStack().execute(cmd);
	        cmd.setObjects(run.getParams().get(0), parent, child);
	
	        return (Generalization) run.getParams().get(0);
	    }
	
	    public Interface buildInterface() {
	        return createInterface();
	    }
	
	    public Interface buildInterface(Object owner) {
	        return buildInterface(null, owner);
	    }
	
	    public Interface buildInterface(String name) {
	        Interface interfaze = createInterface();
	        if (name != null) {
	            interfaze.setName(name);
	        }
	        return interfaze;
	    }
	
	    public Interface buildInterface(final String name, final Object owner) {
	        if (!(owner instanceof org.eclipse.uml2.uml.Package)
	                && !(owner instanceof org.eclipse.uml2.uml.Class)
	                && !(owner instanceof Interface)) {
	            throw new IllegalArgumentException(
	                    "The owner must be instance of Package" + //$NON-NLS-1$
	                    " or UML2 Class or Interface."); //$NON-NLS-1$
	        }
	        RunnableClass run = new RunnableClass() {
	            public void run() {
	                Interface interfaze = createInterface();
	                if (owner instanceof org.eclipse.uml2.uml.Package) {
	                    interfaze.setPackage((org.eclipse.uml2.uml.Package) owner);
	                } else if (owner instanceof org.eclipse.uml2.uml.Class) {
	                    ((org.eclipse.uml2.uml.Class) owner).getNestedClassifiers()
	                            .add(interfaze);
	                } else if (owner instanceof Interface) {
	                    ((Interface) owner).getNestedClassifiers().add(interfaze);
	                }
	                if (name != null) {
	                    interfaze.setName(name);
	                }
	                getParams().add(interfaze);
	            }
	        };
	        ChangeCommand cmd = new ChangeCommand(
	                modelImpl, run, "Create the interface # owned by #");
	        editingDomain.getCommandStack().execute(cmd);
	        cmd.setObjects(run.getParams().get(0), owner);
	
	        return (Interface) run.getParams().get(0);
	    }
	
	    public Object buildManifestation(Object utilizedElement) {
	        if (!(utilizedElement instanceof PackageableElement)) {
	            throw new IllegalArgumentException(
	                    "The utilized element must be an instance of PackageableElement."); //$NON-NLS-1$
	        }
	        Manifestation m = UMLFactory.eINSTANCE.createManifestation();
	        m.setName(((PackageableElement) utilizedElement).getName() + " manifestation");
	        m.setUtilizedElement((PackageableElement) utilizedElement);
	        return m;
	    }
	
	    public Object buildMethod(String name) {
	        // in UML2, we model a method as a Behavior (initially OpaqueBehavior)
	        OpaqueBehavior method = UMLFactory.eINSTANCE.createOpaqueBehavior();
	        method.setName(name);
	        return method;
	    }
	
	    public Operation buildOperation(Object classifier, Object returnType) {
	        return buildOperation2(classifier, returnType, null);
	    }
	
	
	    public Operation buildOperation2(final Object cls, final Object returnType,
	            final String name) {
	        if ((returnType != null && !(returnType instanceof Type))
	                || !(cls instanceof Type)) {
	            throw new IllegalArgumentException(
	                    "cls and returnType must be instances of Type."); //$NON-NLS-1$
	        }
	        if (UMLUtil.getOwnedOperations((Type) cls) == null) {
	            throw new UnsupportedOperationException(
	                    "The type " + cls.getClass()  //$NON-NLS-1$
	                    + " does not support owning operations."); //$NON-NLS-1$
	        }
	        RunnableClass run = new RunnableClass() {
	            public void run() {
	                Operation operation = createOperation();
	                UMLUtil.getOwnedOperations((Type) cls).add(operation);
	                operation.createReturnResult("return", (Type) returnType);
	                if (name != null) {
	                    operation.setName(name);
	                } else {
	                    // TODO: Remove?  Can't be localized
	                    operation.setName("newOperation");
	                }
	                getParams().add(operation);
	            }
	        };
	        ChangeCommand cmd = new ChangeCommand(
	                modelImpl, run, "Create the operation # owned by #");
	        editingDomain.getCommandStack().execute(cmd);
	        cmd.setObjects(run.getParams().get(0), cls);
	
	        return (Operation) run.getParams().get(0);
	    }
	
	
	    public Parameter buildParameter(final Object o, final Object type) {
	        // TODO: In UML2.x Event has no parameters. The Event metaclass in
	        // UML1.x corresponds to the Trigger metaclass in UML2.x (see UML
	        // Superstructure page 456).
	        if (!(o instanceof BehavioralFeature)) {
	            throw new IllegalArgumentException(
	                    "The parameter must be attached to a BehavioralFeature."); //$NON-NLS-1$
	        }
	        if (!(type instanceof Type)) {
	            throw new IllegalArgumentException(
	                    "The type of the parameter must be instance of Type."); //$NON-NLS-1$
	        }
	        RunnableClass run = new RunnableClass() {
	            public void run() {
	                Parameter param = createParameter();
	                param.setType((Type) type);
	                // TODO: Remove?  Can't be localized
	                param.setName("arg"
	                        + ((BehavioralFeature) o).getOwnedParameters().size());
	                ((BehavioralFeature) o).getOwnedParameters().add(param);
	                getParams().add(param);
	            }
	        };
	        ChangeCommand cmd = new ChangeCommand(
	                modelImpl, run, "Create the parameter # owned by #");
	        editingDomain.getCommandStack().execute(cmd);
	        cmd.setObjects(run.getParams().get(0), o);
	
	        return (Parameter) run.getParams().get(0);
	    }
	
	
	    public PackageImport buildPackageAccess(Object client, Object supplier) {
	        return buildPackageImport(
	                client, supplier, VisibilityKind.PRIVATE_LITERAL);
	    }
	
	    public PackageImport buildPackageImport(Object client, Object supplier) {
	        return buildPackageImport(client, supplier, null);
	    }
	
	    private PackageImport buildPackageImport(final Object client,
	            final Object supplier, final VisibilityKind visibility) {
	        if (!(client instanceof Namespace)) {
	            throw new IllegalArgumentException(
	                    "The client must be instance of Namespace."); //$NON-NLS-1$
	        }
	        if (!(supplier instanceof org.eclipse.uml2.uml.Package)) {
	            throw new IllegalArgumentException(
	                    "The supplier must be instance of Package."); //$NON-NLS-1$
	        }
	        RunnableClass run = new RunnableClass() {
	            public void run() {
	                PackageImport packageImport = createPackageImport();
	                packageImport.setImportedPackage((org.eclipse.uml2.uml.Package) supplier);
	                packageImport.setImportingNamespace((Namespace) client);
	                if (visibility != null) {
	                    packageImport.setVisibility(visibility);
	                }
	                getParams().add(packageImport);
	            }
	        };
	        ChangeCommand cmd = new ChangeCommand(
	                modelImpl, run,
	                "Create the package import # between the client # and the supplier #");
	        editingDomain.getCommandStack().execute(cmd);
	        cmd.setObjects(run.getParams().get(0), client, supplier);
	
	        return (PackageImport) run.getParams().get(0);
	    }
	
	    public InterfaceRealization buildRealization(final Object client,
	            final Object supplier, Object namespace) {
	        // The interface realization will be created in the client namespace
	        // (client is a namespace)
	        if (!(client instanceof BehavioredClassifier)) {
	            throw new IllegalArgumentException(
	                    "The client must be instance of BehavioredClassifier"); //$NON-NLS-1$
	        }
	        if (!(supplier instanceof Interface)) {
	            throw new IllegalArgumentException(
	                    "The supplier must be an Interface"); //$NON-NLS-1$
	        }
	        RunnableClass run = new RunnableClass() {
	            public void run() {
	                InterfaceRealization realization = 
	                    UMLFactory.eINSTANCE.createInterfaceRealization();
	                realization.setImplementingClassifier(
	                        (BehavioredClassifier) client);
	                realization.setContract((Interface) supplier);
	                ((BehavioredClassifier) client).getInterfaceRealizations()
	                        .add(realization);
	                getParams().add(realization);
	            }
	        };
	        ChangeCommand cmd = new ChangeCommand(
	                modelImpl, run,
	                "Create the interface realization # between" //$NON-NLS-1$
	                        + " the client # and the supplier #"); //$NON-NLS-1$
	        editingDomain.getCommandStack().execute(cmd);
	        cmd.setObjects(run.getParams().get(0), client, supplier);
	
	        return (InterfaceRealization) run.getParams().get(0);
	    }
	
	    public Object buildTemplateArgument(Object element) {
	        // TODO: Is this removed from UML2 ?
	        throw new NotImplementedException();
	    }
	
	    public Usage buildUsage(final Object client, final Object supplier) {
	        if (!(client instanceof NamedElement)
	                || !(supplier instanceof NamedElement)) {
	            throw new IllegalArgumentException(
	                    "The client and the supplier must be NamedElements."); //$NON-NLS-1$
	        }
	        if (((NamedElement) client).getNearestPackage() == null) {
	            throw new NullPointerException(
	                    "The client is not contained in a package."); //$NON-NLS-1$
	        }
	        RunnableClass run = new RunnableClass() {
	            public void run() {
	                Usage usage = createUsage();
	                usage.getClients().add((NamedElement) client);
	                usage.getSuppliers().add((NamedElement) supplier);
	                ((NamedElement) client).getNearestPackage()
	                        .getPackagedElements().add(usage);
	                getParams().add(usage);
	            }
	        };
	        ChangeCommand cmd = new ChangeCommand(
	                modelImpl, run,
	                "Create the usage # between the client # and the supplier #");
	        editingDomain.getCommandStack().execute(cmd);
	        cmd.setObjects(run.getParams().get(0), client, supplier);
	
	        return (Usage) run.getParams().get(0);
	    }
	
	    public Object copyClass(Object source, Object ns) {
	        return modelImpl.getCopyHelper().copy(source, ns);
	    }
	
	    public Object copyDataType(Object source, Object ns) {
	        return modelImpl.getCopyHelper().copy(source, ns);
	    }
	
	    public Object copyFeature(Object source, Object classifier) {
	        return modelImpl.getCopyHelper().copy(source, classifier);
	    }
	
	    public Object copyInterface(Object source, Object ns) {
	        return modelImpl.getCopyHelper().copy(source, ns);
	    }
	
	    public Abstraction createAbstraction() {
	        return UMLFactory.eINSTANCE.createAbstraction();
	    }
	
	    public Artifact createArtifact() {
	        return UMLFactory.eINSTANCE.createArtifact();
	    }
	
	    @Deprecated
	    public Association createAssociation() {
	        return createAssociation(null);
	    }
	
	    public Association createAssociation(Object extent) {
	        RunnableClass run = new RunnableClass() {
	            public void run() {
	                getParams().add(UMLFactory.eINSTANCE.createAssociation());
	            }
	        };
	        ChangeCommand cmd = new ChangeCommand(
	                modelImpl, run,
	                "Create an association");
	        editingDomain.getCommandStack().execute(cmd);
	//        cmd.setObjects(run.getParams().get(0));
	        return (Association) run.getParams().get(0);
	    }
	    
	    public AssociationClass createAssociationClass() {
	        return UMLFactory.eINSTANCE.createAssociationClass();
	    }
	
	    public Property createAssociationEnd() {
	        return UMLFactory.eINSTANCE.createProperty();
	    }
	
	    public Property createAttribute() {
	        return UMLFactory.eINSTANCE.createProperty();
	    }
	
	    /**
	     * Removed from UML2.x, use createTemplateBinding instead.
	     */
	    @Deprecated
	    public TemplateBinding createBinding() {
	        return createTemplateBinding();
	    }
	
	    public TemplateBinding createTemplateBinding() {
	        return UMLFactory.eINSTANCE.createTemplateBinding();
	    }
	
	    public org.eclipse.uml2.uml.Class createClass() {
	        return UMLFactory.eINSTANCE.createClass();
	    }
	
	    public Comment createComment() {
	        return UMLFactory.eINSTANCE.createComment();
	    }
	
	    public Component createComponent() {
	        return UMLFactory.eINSTANCE.createComponent();
	    }
	
	    public Constraint createConstraint() {
	        return UMLFactory.eINSTANCE.createConstraint();
	    }
	
	    public DataType createDataType() {
	        return UMLFactory.eINSTANCE.createDataType();
	    }
	
	    public Dependency createDependency() {
	        return UMLFactory.eINSTANCE.createDependency();
	    }
	
	    public Object createElementResidence() {
	        // TODO: Is this removed from UML2 ?
	        throw new NotImplementedException();
	    }
	
	    public Enumeration createEnumeration() {
	        return UMLFactory.eINSTANCE.createEnumeration();
	    }
	
	    public EnumerationLiteral createEnumerationLiteral() {
	        return UMLFactory.eINSTANCE.createEnumerationLiteral();
	    }
	
	    public Object createFlow() {
	        // TODO: Is this removed from UML2 ?
	        throw new NotImplementedException();
	    }
	
	    @Deprecated
	    public Generalization createGeneralization() {
	        return createGeneralization(null);
	    }
	
	    public Generalization createGeneralization(Object extent) {
	        // Extent ignored for eUML2 implementation (required for NetBeans MDR)
	        return UMLFactory.eINSTANCE.createGeneralization();
	    }
	    
	    public Interface createInterface() {
	        return UMLFactory.eINSTANCE.createInterface();
	    }
	
	    public Object createMethod() {
	        // TODO: Is this removed from UML2 ?
	        throw new NotImplementedException();
	    }
	
	    public Node createNode() {
	        return UMLFactory.eINSTANCE.createNode();
	    }
	
	    public Operation createOperation() {
	        return UMLFactory.eINSTANCE.createOperation();
	    }
	
	    public Parameter createParameter() {
	        return UMLFactory.eINSTANCE.createParameter();
	    }
	
	    /**
	     * Removed from UML2.x, use createPackageImport instead.
	     */
	    @Deprecated
	    public PackageImport createPermission() {
	        return createPackageImport();
	    }
	
	    public PackageImport createPackageImport() {
	        return UMLFactory.eINSTANCE.createPackageImport();
	    }
	
	    public PrimitiveType createPrimitiveType() {
	        return UMLFactory.eINSTANCE.createPrimitiveType();
	    }
	
	    public Object createTemplateArgument() {
	        // TODO: Is this removed from UML2 ?
	        throw new NotImplementedException();
	    }
	
	    public TemplateParameter createTemplateParameter() {
	        return UMLFactory.eINSTANCE.createTemplateParameter();
	    }
	
	    public Usage createUsage() {
	        return UMLFactory.eINSTANCE.createUsage();
	    }
	
	    public Object buildTemplateArgument(Object binding, Object argument) {
	        // TODO: Auto-generated method stub
	        throw new NotYetImplementedException();
	        
	    }
	
	    public Object buildTemplateParameter(Object template, Object parameter,
	            Object defaultElement) {
	        // TODO: Auto-generated method stub
	        throw new NotYetImplementedException();
	        
	    }
	
	    public Object createTemplateArgument(Object extent) {
	        // TODO: Auto-generated method stub
	        throw new NotYetImplementedException();
	        
	    }
	
	    public Object createTemplateParameter(Object extent) {
	        // TODO: Auto-generated method stub
	        throw new NotYetImplementedException();
	        
	    }
	
	}
		
",
	role:"
	user	
",
,
	content:"
	//src/argouml-core-diagrams-sequence2/src/org/argouml/sequence2/diagram/FigLifeLine.java
	/* $Id$
	 *******************************************************************************
	 * Copyright (c) 2010 Contributors - see below
	 * All rights reserved. This program and the accompanying materials
	 * are made available under the terms of the Eclipse Public License v1.0
	 * which accompanies this distribution, and is available at
	 * http://www.eclipse.org/legal/epl-v10.html
	 *
	 * Contributors:
	 *    Bob Tarling
	 *    Christian L\u00f3pez Esp\u00ednola
	 *******************************************************************************
	 *
	 * Some portions of this file were previously release using the BSD License:
	 */
	
	// $Id$
	// Copyright (c) 2007-2009 The Regents of the University of California. All
	// Rights Reserved. Permission to use, copy, modify, and distribute this
	// software and its documentation without fee, and without a written
	// agreement is hereby granted, provided that the above copyright notice
	// and this paragraph appear in all copies. This software program and
	// documentation are copyrighted by The Regents of the University of
	// California. The software program and documentation are supplied "AS
	// IS", without any accompanying services from The Regents. The Regents
	// does not warrant that the operation of the program will be
	// uninterrupted or error-free. The end-user understands that the program
	// was developed for research purposes and is advised not to rely
	// exclusively on the program for any reason. IN NO EVENT SHALL THE
	// UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
	// SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
	// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
	// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
	// SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
	// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
	// PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
	// CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
	// UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
	
	package org.argouml.sequence2.diagram;
	
	import java.awt.Rectangle;
	import java.util.Collections;
	import java.util.LinkedList;
	import java.util.List;
	
	import org.argouml.uml.diagram.DiagramSettings;
	import org.argouml.uml.diagram.ui.ArgoFigGroup;
	import org.tigris.gef.presentation.FigLine;
	import org.tigris.gef.presentation.FigRect;
	
	
	/**
	 * This fig is the LifeLine of a ClassifierRole.
	 * @author penyaskito
	 */
	class FigLifeLine extends ArgoFigGroup {
	
	    private static final long serialVersionUID = 466925040550356L;
	
	    private FigLine lineFig;
	    private FigRect rectFig;
	    
	    private List<FigActivation> activations;
	    private List<FigActivation> stackedActivations;
	    
	    static final int WIDTH = 150;
	    static final int HEIGHT = 500;
	
	    FigLifeLine(Object owner, Rectangle bounds, DiagramSettings settings) {
	        super(owner, settings);
	        initialize(bounds.x, bounds.y);
	    }
	    
	    private void initialize(int x, int y) {
	        activations = new LinkedList<FigActivation>();
	        stackedActivations = new LinkedList<FigActivation>();
	        
	        rectFig = new FigRect(x, y, WIDTH, HEIGHT); 
	        rectFig.setFilled(false);
	        rectFig.setLineWidth(0);
	        lineFig = new FigLine(x + WIDTH / 2, y, 
	                x + WIDTH / 2, y + HEIGHT, LINE_COLOR);
	        lineFig.setDashed(true);
	        lineFig.setLineWidth(LINE_WIDTH);
	        
	        addFig(rectFig);
	        addFig(lineFig);
	    }
	    
	    // TODO: Does this still need to be synchronized? If so then explain why.
	    synchronized void createActivations(final List<FigMessage> messages) {
	        clearActivations();
	        Collections.sort(messages, new FigMessageComparator());
	        
	        activations = createStandardActivations(messages);
	        stackedActivations = createStackedActivations(messages);
	        
	        addActivations(activations);
	        addActivations(stackedActivations);
	
	        // TODO: Do we need this?
	        calcBounds();
	    }
	    
	    /**
	     * Add the given list of activation Figs to the lifeline. The fill colour
	     * is forced to the lifeline colour in the process.
	     * @param activationFigs
	     */
	    private void addActivations(
	            final List<FigActivation> activationFigs) {
	        for (final FigActivation figAct : activationFigs) {
	            figAct.setFillColor(getFillColor());
	            addFig(figAct);
	        }
	    }
	    
	    private List<FigActivation> createStandardActivations(
	                final List<FigMessage> figMessages) {        
	        
	        final List<FigActivation> newActivations =
	            new LinkedList<FigActivation>();
	        
	        // Check here if there are no incoming call actions
	        // if not then create an activation at the top of the lifeline
	        FigActivation currentActivation = null;
	        if (!hasIncomingCallActionFirst(figMessages)) {
	            currentActivation = createActivationFig(
	                    getOwner(),
	                    lineFig.getX(),
	                    lineFig.getY(), 
	                    lineFig.getWidth(), 
	                    lineFig.getHeight(),
	                    getSettings(),
	                    null);
	        }
	        
	        // This counts the number of repeated call/returns that take place
	        // after the first activation. This shouldn't be required once
	        // we handle stacked activations better and once issue 5692 and 5693
	        // are sorted.
	        int activationsCount = 0;
	        //
	        
	        for (FigMessage figMessage : figMessages) {
	            int ySender = 0;
	            
	            if (!figMessage.isSelfMessage()) {
	                if (isIncoming(figMessage)) {
	                    if (currentActivation == null) {
	                        if (figMessage.isSynchCallMessage()) {
	                            // if we are the dest and is a call action, create the 
	                            // activation, but don't add it until the height is set.
	                            ySender = figMessage.getFinalY();
	                            currentActivation = createActivationFig(
	                                    getOwner(), 
	                                    lineFig.getX(), 
	                                    ySender, 
	                                    0, 
	                                    0,
	                                    getSettings(),
	                                    figMessage);
	                            activationsCount++;
	                        } else if (figMessage.isCreateMessage()) {
	                            // if we are the destination of a create action,
	                            // create the entire activation
	                            currentActivation = createActivationFig(
	                                    getOwner(),
	                                    lineFig.getX(),
	                                    lineFig.getY(),
	                                    0,
	                                    0,
	                                    getSettings(),
	                                    figMessage);
	                            activationsCount++;
	                        }
	                    } else {
	                        if (figMessage.isSynchCallMessage()
	                                && isSameClassifierRoles(
	                                        currentActivation.getActivatingMessage(),
	                                        figMessage)) {
	                            activationsCount++;
	                        } else if (figMessage.isDeleteMessage()) {
	                            // if we are the target of a destroy action
	                            // the figlifeline ends here and we add the activation
	                            ySender = figMessage.getFinalY();
	                            currentActivation.setHeight(
	                                    ySender - currentActivation.getY());
	                            currentActivation.setDestroy(true);
	                            lineFig.setHeight(ySender - getY());
	                            newActivations.add(currentActivation);
	                            currentActivation = null;
	                        }
	                    }
	                }
	                
	                if (isOutgoing(figMessage) && currentActivation != null
	                    && currentActivation.isActivatorEnd(figMessage)
	                            && --activationsCount == 0) {
	                        // if we are the source of a return action
	                        // the activation ends here.
	                        ySender = figMessage.getStartY();
	                        currentActivation.setHeight(
	                                ySender - currentActivation.getY());
	                        newActivations.add(currentActivation);
	                        currentActivation = null;
	                }
	            }
	        }
	        
	        // If we have a currentAct object that means have reached the end
	        // of the lifeline with a call or a create not returned.
	        // Add the activation to the list after setting its height to end
	        // at the end of the lifeline.
	        if (currentActivation != null) {
	            currentActivation.setHeight(
	                    getHeight() - (currentActivation.getY() - getY()));
	            newActivations.add(currentActivation);
	        }
	        
	        return newActivations;
	    }
	    
	    private boolean isSameClassifierRoles(
	            final FigMessage mess1,
	            final FigMessage mess2) {
	        return mess1 != null
	                && mess1.getDestFigNode() == mess2.getDestFigNode()
	                && mess1.getSourceFigNode() == mess2.getSourceFigNode();
	    }
	    
	    /**
	     * Return true if the given message fig is pointing in to this lifeline.
	     * @param messageFig
	     * @return true if the message is incoming
	     */
	    private boolean isIncoming(FigMessage messageFig) {
	        return (messageFig.getDestFigNode().getOwner() == getOwner());
	    }
	    
	    /**
	     * Return true if the given message fig is pointing out from this lifeline.
	     * @param messageFig
	     * @return true if the message is outgoing
	     */
	    private boolean isOutgoing(FigMessage messageFig) {
	        return (messageFig.getSourceFigNode().getOwner() == getOwner());
	    }
	    
	    private FigActivation createActivationFig(
	            final Object owner, 
	            final int x, 
	            final int y, 
	            final int w, 
	            final int h,
	            final DiagramSettings settings,
	            final FigMessage messageFig) {
	        return new FigActivation(
	                owner,
	                new Rectangle(x, y, w, h),
	                settings,
	                messageFig);
	    }
	    
	    private List<FigActivation> createStackedActivations(
	            final List<FigMessage> figMessages) {
	        
	        final List<FigActivation> newActivations =
	            new LinkedList<FigActivation>();
	        
	        FigActivation currentAct = null;
	        
	        for (FigMessage figMessage : figMessages) {
	            int ySender = 0;
	            // if we are the dest and is a call action, create the 
	            // activation, but don't add it until the height is set.
	            if (figMessage.isSelfMessage()) {
	                if (figMessage.isSynchCallMessage()) {
	                    ySender = figMessage.getFinalY();
	                    currentAct = new FigActivation(figMessage.getOwner(),
	                            new Rectangle(lineFig.getX()
	                                    + FigActivation.DEFAULT_WIDTH / 2, ySender,
	                                    0, 0), getSettings(), figMessage, false);
	                } else if (currentAct != null
	                        && figMessage.isReplyMessage()) {
	                    ySender = figMessage.getStartY();
	                    currentAct.setHeight(ySender - currentAct.getY());
	                    newActivations.add(currentAct);
	                    currentAct = null;
	                }
	            }
	        }
	        return newActivations;
	    }
	
	
	    private boolean hasIncomingCallActionFirst(
	                final List<FigMessage> figMessages) {
	        final FigClassifierRole cr =
	            (FigClassifierRole) getGroup();
	        if (figMessages.isEmpty()) {
	            return false;
	        }
	        FigMessage figMessage = figMessages.get(0);
	        if (cr.equals(figMessage.getDestFigNode())
	                && !cr.equals(figMessage.getSourceFigNode())
	                && figMessage.isSynchCallMessage()) {
	            return true;
	        }
	        return false;
	    }
	    
	    private void clearActivations() {
	        for (FigActivation oldActivation : activations) {
	            removeFig(oldActivation);    
	        }
	        for (FigActivation oldActivation : stackedActivations) {
	            removeFig(oldActivation);    
	        }
	        activations.clear();
	        stackedActivations.clear();
	    }
	    
	    @Override
	    public void setFilled(boolean filled) {
	        // we do nothing. No call to the parent
	    }
	    
	    @Override
	    // TODO: synchronized is required here as there can be some 
	    // concurrent modification problems when drawing a call message and
	    // having that automatically draw the reply. Maybe fixing the TODO
	    // below will resolve this and the synch can go.
	    protected synchronized void setBoundsImpl(int x, int y, int w, int h) {
	        final Rectangle oldBounds = getBounds();
	        
	        rectFig.setBounds(x, y, w, h);
	        lineFig.setBounds(x + w / 2, y, w, h);
	        
	        final int yDiff = oldBounds.y - y;
	    
	        // we don't recalculate activations, just move them
	        for (FigActivation act : activations) {
	            // TODO: why do we need to remove then add the Fig?
	            removeFig(act);
	            act.setLocation(
	                    lineFig.getX() - FigActivation.DEFAULT_WIDTH / 2,
	                    act.getY() - yDiff);
	            if (activations.size() == 1 
	                    && act.getHeight() == oldBounds.height) {
	                act.setHeight(getHeight());
	            }
	            addFig(act);
	        }
	        damage();
	        _x = x;
	        _y = y;
	        _w = w;
	        _h = h;
	        firePropChange("bounds", oldBounds, getBounds());
	    }
	    
	    public void setLineWidth(int w) {
	        lineFig.setLineWidth(w);
	    }
	}
		
",
	role:"
	user	
",
,
	content:"
	//src/argouml-core-diagrams-activity2/src/org/argouml/activity2/diagram/FigBaseNode.java
	/* $Id$
	 *****************************************************************************
	 * Copyright (c) 2010-2011 Contributors - see below
	 * All rights reserved. This program and the accompanying materials
	 * are made available under the terms of the Eclipse Public License v1.0
	 * which accompanies this distribution, and is available at
	 * http://www.eclipse.org/legal/epl-v10.html
	 *
	 * Contributors:
	 *    Bob Tarling
	 *****************************************************************************
	 */
	
	package org.argouml.activity2.diagram;
	
	import java.awt.Dimension;
	import java.awt.Rectangle;
	
	import org.argouml.uml.diagram.DiagramSettings;
	import org.tigris.gef.presentation.FigGroup;
	import org.tigris.gef.presentation.FigNode;
	
	/**
	 * The Fig for all node diagram elements. All specialist diagram elements
	 * decorate this to get specialist behaviour 
	 * @author Bob Tarling
	 */
	class FigBaseNode extends FigNode implements DiagramNode {
	
	    private FigBasePresentation displayState;
	    private final DiagramSettings settings;
	    private DiagramElement nameDiagramElement;
	    
	    /**
	     * Constructor a new FigBaseNode
	     * 
	     * @param owner the owning UML element
	     * @param bounds rectangle describing bounds
	     * @param settings rendering settings
	     */
	    FigBaseNode(final Object owner, final Rectangle bounds,
	            final DiagramSettings settings) {
	        super(owner);
	        setBounds(bounds);
	        this.settings = settings;
	    }
	    
	    void setDisplayState(FigBasePresentation displayState) {
	        this.displayState = displayState;
	        displayState.setOwner(getOwner());
	        addFig(displayState);
	    }
	    
	    @Override
	    public boolean isDragConnectable() {
	        return false;
	    }
	    
	    @Override
	    public Dimension getMinimumSize() {
	        return displayState.getMinimumSize();
	    }
	
	    public void setNameDiagramElement(DiagramElement name) {
	    }
	
	    // TODO: Move an empty implementation to FigGroup in GEF
	    protected void positionChildren() {
	        Rectangle myBounds = getBounds();
	        if (displayState != null) {
	            displayState.setBounds(myBounds);
	        }
	//      calcBounds();
	        updateEdges();
	    }
	    
	    @Override
	    protected void setBoundsImpl(
	            final int x,
	            final int y,
	            final int w,
	            final int h) {
	
	        _x = x;
	        _y = y;
	        _w = w;
	        _h = h;
	        
	        positionChildren();
	    }
	
	    /**
	     * This is called to rearrange the contents of the Fig when a childs
	     * minimum size means it will no longer fit. If this group also has
	     * a parent and it will no longer fit that parent then control is
	     * delegated to that parent.
	     */
	    public void calcBounds() {
	        if (getGroup() != null) {
	            ((FigGroup) getGroup()).calcBounds();
	        } else {
	            final Dimension min = getMinimumSize();
	            int maxw = Math.max(getWidth(), min.width);
	            int maxh = Math.max(getHeight(), min.height);
	            setBounds(_x, _y, maxw, maxh);
	        }
	    }
	}
		
",
	role:"
	user	
",
,
	content:"
	//src/argouml-core-model/src/org/argouml/model/CoreHelper.java
	/* $Id$
	 *******************************************************************************
	 * Copyright (c) 2009-2012 Contributors - see below
	 * All rights reserved. This program and the accompanying materials
	 * are made available under the terms of the Eclipse Public License v1.0
	 * which accompanies this distribution, and is available at
	 * http://www.eclipse.org/legal/epl-v10.html
	 *
	 * Contributors:
	 *    Thomas Neustupny
	 *    Michiel van der Wulp
	 *    Tom Morris
	 *******************************************************************************
	 *
	 * Some portions of this file was previously release using the BSD License:
	 */
	
	// Copyright (c) 2005-2008 The Regents of the University of California. All
	// Rights Reserved. Permission to use, copy, modify, and distribute this
	// software and its documentation without fee, and without a written
	// agreement is hereby granted, provided that the above copyright notice
	// and this paragraph appear in all copies. This software program and
	// documentation are copyrighted by The Regents of the University of
	// California. The software program and documentation are supplied "AS
	// IS", without any accompanying services from The Regents. The Regents
	// does not warrant that the operation of the program will be
	// uninterrupted or error-free. The end-user understands that the program
	// was developed for research purposes and is advised not to rely
	// exclusively on the program for any reason. IN NO EVENT SHALL THE
	// UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
	// SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
	// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
	// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
	// SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
	// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
	// PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
	// CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
	// UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
	
	package org.argouml.model;
	
	import java.util.Collection;
	import java.util.List;
	
	/**
	 * The interface for the helper for Core.<p>
	 */
	public interface CoreHelper {
	    /**
	     * Determine if a meta type is a subtype of another.
	     * @param type The parent metatype.
	     * @param subType The metatype to test for being a subtype.
	     * @return true is subType is a sub-type of type.
	     */
	    boolean isSubType(Object type, Object subType);
	
	    /**
	     * Return all elements of which this GeneralizableElement is a direct or
	     * indirect subtype.
	     * <p>
	     * Note: This follows the Generalizations in UML, so the results do
	     * <em>not</em> include Interfaces which are connected to Classes by
	     * Realizations.
	     * 
	     * @param element
	     *                the GeneralizableElement you want to have the parents for
	     * @return a collection of the parents, each of which is a
	     *         GeneralizableElement.
	     */
	    Collection getAllSupertypes(Object element);
	
	    /**
	     * Return the immediate supertypes of a GeneralizableElement.
	     * 
	     * @param generalizableElement
	     *            the element you want to have the parents for
	     * @return a collection of the parents, each of which is a
	     *         GeneralizableElement.
	     */
	    Collection getSupertypes(Object generalizableElement);
	
	    /**
	     * Return all utilized element of the manifestations of a given artifact.
	     *
	     * @param artifact the artifact you want to have the utilized elements for
	     * @return a collection of the manifestations
	     */
	    Collection getUtilizedElements(Object artifact);
	
	    /**
	     * Return all AssociationEnds of a given Classifier plus all 
	     * AssociationEnds of all of the Classifier's supertypes.
	     * <p>
	     * Note: Until 0.24 this was documented as returning the <em>opposite</em>
	     * ends, but the implementation has returned the near ends since at least
	     * beginning of the MDR implementation (0.18).
	     * 
	     * @param classifier
	     *                the classifier for which to get the association ends
	     * @return a collection of the AssociationEnds
	     */
	    Collection getAssociateEndsInh(Object classifier);
	
	    /**
	     * Remove a Feature from a Classifier.
	     *
	     * @param cls the classifier
	     * @param feature the feature to be removed
	     */
	    void removeFeature(Object cls, Object feature);
	
	    /**
	     * Remove an EnumerationLiteral from an Enumeration.
	     *
	     * @param enumeration the enumeration
	     * @param literal the literal to be removed
	     */
	    void removeLiteral(Object enumeration, Object literal);
	
	    /**
	     * Replace all operations of the given classifier
	     * by the given list of operations.
	     *
	     * @param classifier the given classifier
	     * @param operations the new operations
	     */
	    void setOperations(Object classifier, List operations);
	
	    /**
	     * Replace all attributes of the given classifier
	     * by the given collection of attributes.
	     * @param classifier the classifier
	     * @param attributes an ordered list of new attributes
	     */
	    void setAttributes(Object classifier, List attributes);
	    
	    /**
	     * Return all attributes of a given Classifier,
	     * including inherited.
	     *
	     * @param classifier the classifier you want to have the attributes for
	     * @return a collection of the attributes
	     */
	    Collection getAttributesInh(Object classifier);
	
	    /**
	     * Return all operations of a given Classifier,
	     * including inherited.
	     *
	     * @param classifier the classifier you want to have the operations for
	     * @return a collection of the operations
	     */
	    Collection getOperationsInh(Object classifier);
	    
	    /**
	     * Return the collection of all direct parents. <p>
	     * 
	     * This function is additional operation number 1 for 
	     * a GeneralizableElement from the UML1.4 standard.
	     * 
	     * @param generalizableElement the given element
	     * @return a collection of GeneralizableElement
	     */
	    Collection getParents(Object generalizableElement);
	
	    /**
	     * Return all return parameters for a BehavioralFeature 
	     * (Operation, Reception,...).
	     *
	     * @param bf is the behavioral feature.
	     * @return List of parameters of with direction kind of Return.
	     */
	    List getReturnParameters(Object bf);
	
	    /**
	     * Return the Operation which is the specification for a Method.<p>
	     * 
	     * There is also a method in the Facade interface with the same name which
	     * may be what you want if you are looking for the specification of
	     * something other than a Method.
	     * 
	     * @see Facade#getSpecification(Object)
	     * 
	     * @param object
	     *            the method you want the realized operation of.
	     * @return an operation, or null.
	     */
	    Object getSpecification(Object object);
	
	    /**
	     * Return all Classifiers of which this class is a
	     * direct supertype.
	     *
	     * @param cls  the class you want to have the children for
	     * @return a collection of the children, each of which is a
	     *         GeneralizableElement.
	     */
	    Collection getSubtypes(Object cls);
	
	    /**
	     * Return all behavioralfeatures found in this element and its
	     * children.<p>
	     *
	     * @param element is the element
	     * @return Collection
	     */
	    Collection getAllBehavioralFeatures(Object element);
	
	    /**
	     * Return all behavioral features of a Classifier.
	     * @param classifier The classifier
	     * @return the list with all behavioral features of the classifier
	     */
	    List getBehavioralFeatures(Object classifier);
	
	    /**
	     * Return all interfaces found in this namespace and in its children.
	     *
	     * @param ns the given namespace
	     * @return Collection with all interfaces found
	     */
	    Collection getAllInterfaces(Object ns);
	
	    /**
	     * Return all classes found in this namespace and in its children.<p>
	     *
	     * @param ns is the namespace.
	     * @return Collection
	     */
	    Collection getAllClasses(Object ns);
	
	    /**
	     * Return all interfaces the given class realizes.<p>
	     *
	     * @param cls the classifier
	     * @return Collection
	     */
	    Collection getRealizedInterfaces(Object cls);
	
	    /**
	     * Return all classes that the given GeneralizableElement extends.
	     *
	     * @param element is the GeneralizableElement
	     * @return Collection
	     */
	    Collection getExtendedClassifiers(Object element);
	
	    /**
	     * Gets the generalization between two GeneralizableElements.
	     * Returns null if there is none.<p>
	     *
	     * @param achild is the child GeneralizableElement.
	     * @param aparent is the parent GeneralizableElement.
	     * @return Generalization
	     */
	    Object getGeneralization(Object achild, Object aparent);
	
	    /**
	     * Gets the body of a comment.
	     *
	     * @param comment the comment
	     * @return the body of the comment
	     */
	    String getBody(Object comment);
	
	    /**
	     * Return all flows connecting from a source ModelElement to a target
	     * ModelElement.<p>
	     *
	     * @param source is the source model element.
	     * @param target is the target model element.
	     * @return Collection
	     */
	    Collection getFlows(Object source, Object target);
	
	    /**
	     * Return all elements that extend a Class.
	     *
	     * @param element is the class (a GeneralizableElement)
	     * @return Collection
	     */
	    Collection getExtendingElements(Object element);
	
	    /**
	     * Return all classifiers that extend a Classifier.
	     *
	     * @param classifier is the classifier.
	     * @return Collection
	     */
	    Collection getExtendingClassifiers(Object classifier);
	
	    /**
	     * Return all components found in this namespace and in its children.
	     *
	     * @param ns is the namespace.
	     * @return Collection
	     */
	    Collection getAllComponents(Object ns);
	
	    /**
	     * Return all components found in this namespace and in its children.
	     *
	     * @param ns is the namespace
	     * @return Collection
	     */
	    Collection getAllDataTypes(Object ns);
	
	    /**
	     * Return all components found in this namespace and in its children.<p>
	     *
	     * @param ns is the namespace
	     * @return Collection
	     */
	    Collection getAllNodes(Object ns);
	
	    /**
	     * Gets all classifiers that are associated to the given
	     * classifier (have an association relationship with the
	     * classifier).<p>
	     *
	     * @param aclassifier an Classifier
	     * @return Collection
	     */
	    Collection getAssociatedClassifiers(Object aclassifier);
	
	    /**
	     * Gets the associations between the classifiers from and to. Returns an
	     * empty collection if no Associations are found.
	     *
	     * @param from a classifier
	     * @param to a classifier
	     * @return a Collection with Associations
	     */
	    Collection getAssociations(Object from, Object to);
	
	    /**
	     * Return all classifiers found in this namespace and in its children.
	     *
	     * @param namespace the given namespace
	     * @return Collection the collection of all classifiers
	     *                    found in the namespace
	     */
	    Collection getAllClassifiers(Object namespace);
	
	    /**
	     * Return all associations for a Classifier.<p>
	     *
	     * @param oclassifier the given classifier
	     * @return Collection all associations for the given classifier
	     */
	    Collection getAssociations(Object oclassifier);
	
	    /**
	     * Returns the associationend between a classifier and
	     * an associaton.<p>
	     *
	     * @param type is the classifier
	     * @param assoc is the association
	     * @return An AssociationEnd.
	     */
	    Object getAssociationEnd(Object type, Object assoc);
	
	
	    /**
	     * Return all Attributes of a Classifier and of its parents.
	     *
	     * @param classifier is the classifier
	     * @return Collection
	     */
	    Collection getAllAttributes(Object classifier);
	    
	    /**
	     * Return a Set containing all ModelElements visible 
	     * outside of the Namespace. 
	     * This is an "Additional Operation" from the UML spec.
	     * 
	     * @param ns the given namespace
	     * @return the collection with ModelElements
	     */
	    Collection getAllVisibleElements(Object ns);
	
	    /**
	     * Return the source of a relation or Link. The source of a relation is
	     * defined as the ModelElement that propagates this relation. If
	     * there are more then 1 sources, only the first is returned. If
	     * there is no source, null is returned. Examples of sources
	     * include classifiers that are types to associationends, usecases
	     * that are bases to extend and include relations and so on. A
	     * source is always the start from the arrow in the fig, the
	     * destination the end.<p>
	     * 
	     * TODO: move this method to a generic ModelHelper
	     *
	     * @param relationship is the relation
	     * @return Object
	     */
	    Object getSource(Object relationship);
	
	    /**
	     * Returns the destination of a relation or link. The destination of a
	     * relation is defined as the ModelElement that receives this
	     * relation.  If there are more then 1 destinations, only the
	     * first is returned.  If there is no destination, null is
	     * returned.  Examples of sources include classifiers that are
	     * types to associationends, usecases that are bases to extend and
	     * include relations and so on.  In the case of an association,
	     * the destination is defined as the type of the second element in
	     * the connections list.<p>
	     * 
	     * TODO: move this method to a generic ModelHelper
	     *
	     * @param relationship is the relation
	     * @return object
	     */
	    Object getDestination(Object relationship);
	
	    /**
	     * Return the dependencies between a supplier ModelElement and
	     * a client ModelElement.  Does not return the inverse
	     * relationship (dependency 'from client to supplier').<p>
	     *
	     * @param supplier a ModelElement
	     * @param client a ModelElement
	     * @return Collection
	     */
	    Collection getDependencies(Object supplier, Object client);
	
	
	    /**
	     * Return the packageImport (Permission with
	     * <code>&lt;&lt;import&gt;&gt;</code> or
	     * <code>&lt;&lt;access&gt;&gt;</code> stereotype in UML 1.4) between a
	     * supplier Package and a client Namespace, if any.
	     * 
	     * @param supplier a Package
	     * @param client a Namespace
	     * @return the import or null
	     */
	    Object getPackageImport(Object supplier, Object client);
	
	
	    /**
	     * Return all packageImports (Permissions with
	     * <code>&lt;&lt;import&gt;&gt;</code> or
	     * <code>&lt;&lt;access&gt;&gt;</code> stereotype in UML 1.4) that this
	     * Namespace is a client of.
	     * 
	     * @param client a Namespace
	     * @return Collection of imports
	     */
	    Collection getPackageImports(Object client);
	    
	    /**
	     * Return all relationships between the source and destination
	     * ModelElement and vice versa.<p>
	     *
	     * @param source is the source model element
	     * @param dest is the destination model element
	     * @return Collection
	     */
	    Collection getRelationships(Object source, Object dest);
	
	    /**
	     * Return true if the given ModelElement may be owned by the given
	     * namespace.<p>
	     * Simply returns false if the parameters are not the expected 
	     * UML elements - any Object is accepted.
	     *
	     * @param element a ModelElement
	     * @param namespace a Namespace
	     * @return boolean
	     */
	    boolean isValidNamespace(Object element, Object namespace);
	
	    /**
	     * Return the first namespace which two namespaces share. That is: it
	     * returns the first namespace that owns the given namespaces
	     * themselves or an owner of the given namespaces.<p>
	     *
	     * @param ns1 is the first name space
	     * @param ns2 is the second name space
	     * @return The Namespace.
	     */
	    Object getFirstSharedNamespace(Object ns1, Object ns2);
	
	    /**
	     * Return all possible namespaces that are valid owners of the given
	     * ModelElement as determined by the method isValidNamespace.
	     * 
	     * @param modelElement
	     *            is the model element
	     * @param model
	     *            the model to search
	     * @return Collection
	     */
	    Collection getAllPossibleNamespaces(Object modelElement, Object model);
	
	    /**
	     * Return all children of a given GeneralizableElement on all levels (the
	     * complete subtree excluding the GeneralizableElement itself).
	     * 
	     * @param element
	     *            is the GeneralizableElement
	     * @return Collection
	     * @throws IllegalStateException
	     *             if there is a circular reference.
	     */
	    Collection getChildren(Object element);
	
	    /**
	     * Return all interfaces that are realized by the given class or
	     * by its superclasses. It's possible that interfaces occur twice
	     * in the collection returned. In that case there is a double
	     * reference to that interface.
	     *
	     * @param element is the given class
	     * @return Collection
	     */
	    Collection getAllRealizedInterfaces(Object element);
	
	    /**
	     * Determine whether an Association has at least one AssociationEnd
	     * of AggregationKind Composite.
	     * @param  association the association to be investigated
	     * @return true if one of the association ends of the given association
	     *         is of the composite kind
	     */
	    boolean hasCompositeEnd(Object association);
	
	    /**
	     * @param associationEnd is the association end
	     * @param kindType the AggregationKind as a string in lower case,
	     *                 eg: composite.
	     * @return true if the aggregation kinds are the same.
	     */
	    boolean equalsAggregationKind(Object associationEnd, String kindType);
	
	    /**
	     * Remove the given ModelElement from a given comment.
	     *
	     * @param handle Comment
	     * @param me ModelElement
	     */
	    void removeAnnotatedElement(Object handle, Object me);
	
	    /**
	     * Remove a dependency from a ModelElement.
	     *
	     * @param handle is the model element
	     * @param dep is the dependency
	     */
	    void removeClientDependency(Object handle, Object dep);
	
	    /**
	     * Remove the given constraint from a given ModelElement.
	     *
	     * @param handle ModelElement
	     * @param cons Constraint
	     */
	    void removeConstraint(Object handle, Object cons);
	
	    /**
	     * Remove an owned model element from a namespace.
	     *
	     * @param handle is the name space
	     * @param value is the model element
	     */
	    void removeOwnedElement(Object handle, Object value);
	
	    /**
	     * Remove a Parameter from an Operation.
	     *
	     * @param handle The operation.
	     * @param parameter The parameter.
	     */
	    void removeParameter(Object handle, Object parameter);
	
	    /**
	     * Remove a Qualifier from a AssociationEnd.
	     * 
	     * @param handle the AssociationEnd
	     * @param qualifier the Qualifier attribute to be removed
	     */
	    void removeQualifier(Object handle, Object qualifier);
	
	    /**
	     * Remove a source flow from a ModelElement.
	     *
	     * @param handle The model element.
	     * @param flow The flow.
	     */
	    void removeSourceFlow(Object handle, Object flow);
	
	    /**
	     * Add a supplier dependency to a ModelElement.
	     *
	     * @param supplier the supplier
	     * @param dependency the dependency
	     */
	    void removeSupplierDependency(Object supplier, Object dependency);
	
	    /**
	     * Add a target flow to a ModelElement.
	     *
	     * @param handle The model element.
	     * @param flow The flow to add.
	     */
	    void removeTargetFlow(Object handle, Object flow);
	
	    /**
	     * Remove a TemplateArgument from a Binding.
	     *
	     * @param binding The Binding.
	     * @param argument The argument.
	     */
	    void removeTemplateArgument(Object binding, Object argument);
	    
	    /**
	     * Remove a TemplateParameter from a ModelElement.
	     *
	     * @param handle The element.
	     * @param parameter The parameter.
	     */
	    void removeTemplateParameter(Object handle, Object parameter);
	    
	    /**
	     * Add an annotated element to a comment.
	     *
	     * @param comment The comment to which the element is annotated
	     * @param annotatedElement The element to annotate
	     */
	    void addAnnotatedElement(Object comment, Object annotatedElement);
	
	    /**
	     * Add a client model element to a Dependency.
	     *
	     * @param dependency the Dependency.
	     * @param element The model element.
	     */
	    void addClient(Object dependency, Object element);
	
	    /**
	     * Add a client Dependency to a ModelElement.
	     *
	     * @param handle the ModelElement
	     * @param dependency the dependency
	     */
	    void addClientDependency(Object handle, Object dependency);
	
	    /**
	     * Add a new comment to a ModelElement.
	     *
	     * @param element the element to which the comment is to be added
	     * @param comment the comment for the model element
	     */
	    void addComment(Object element, Object comment);
	
	    /**
	     * Add an End to a connection.
	     *
	     * @param handle Association or Link
	     * @param connection AssociationEnd or LinkEnd
	     */
	    void addConnection(Object handle, Object connection);
	
	    /**
	     * Add an End to a connection.
	     *
	     * @param handle Association or Link
	     * @param position the 0-based position at which
	     *          to insert the AssociationEnd or LinkEnd
	     * @param connection AssociationEnd or LinkEnd
	     */
	    void addConnection(Object handle, int position, Object connection);
	
	    /**
	     * Add a constraint to a ModelElement.
	     *
	     * @param handle model element
	     * @param mc constraint
	     */
	    void addConstraint(Object handle, Object mc);
	
	    /**
	     * @param handle Component
	     * @param node Node
	     */
	    void addDeploymentLocation(Object handle, Object node);
	
	    /**
	     * Add a feature to a Classifier.
	     *
	     * @param handle classifier
	     * @param index position
	     * @param f feature
	     */
	    void addFeature(Object handle, int index, Object f);
	
	    /**
	     * Add an EnumerationLiteral to an Enumeration at the specified position.
	     * 
	     * @param handle the enumeration
	     * @param index the position
	     * @param literal the EnumerationLiteral to be added
	     */
	    void addLiteral(Object handle, int index, Object literal);
	
	    /**
	     * Add a feature to a Classifier.
	     *
	     * @param handle classifier
	     * @param f feature
	     */
	    void addFeature(Object handle, Object f);
	
	    /**
	     * Add the given Link to the given Link or Association.
	     *
	     * @param handle the Link or Association
	     * @param link Link
	     */
	    void addLink(Object handle, Object link);
	
	    /**
	     * Add a manifestation to an artifact.
	     *
	     * @param handle is the artifact
	     * @param manifestation is the manifestation
	     */
	    void addManifestation(Object handle, Object manifestation);
	
	    /**
	     * Add a method to an Operation and copy the values of the Operation's
	     * visibility and scope attributes to the Method.
	     *
	     * @param handle is the operation
	     * @param method is the method
	     */
	    void addMethod(Object handle, Object method);
	
	    /**
	     * Add a ModelElement to a Namespace.
	     *
	     * @param handle namespace
	     * @param me model element
	     */
	    void addOwnedElement(Object handle, Object me);
	
	    /**
	     * Add a Parameter to the given object at given location.
	     *
	     * @param handle The object that will get the Parameter:
	     *               Event, BehavioralFeature.
	     * @param index the location
	     * @param parameter Object that will be added
	     */
	    void addParameter(Object handle, int index, Object parameter);
	
	    /**
	     * Add a Parameter to the given object.
	     *
	     * @param handle The object that will get the Parameter:
	     *               ObjectFlowState, Event, BehavioralFeature, Classifier.
	     * @param parameter Object that will be added
	     */
	    void addParameter(Object handle, Object parameter);
	
	    /**
	     * @param handle the Association End
	     * @param position the 0-based position at which
	     *          to insert the Qualifier
	     * @param qualifier the Qualifier attribute
	     */
	    void addQualifier(Object handle, int position, Object qualifier);
	
	    /**
	     * Add a raised Signal to a Message.
	     *
	     * @param handle the Message or Operation
	     * @param sig the Signal that is raised
	     */
	    void addRaisedSignal(Object handle, Object sig);
	    
	    /**
	     * Add a raised exception to a Operation.
	     *
	     * @param handle the Operation
	     * @param exception the raised exception.
	     */
	    void addRaisedException(Object handle, Object exception);
	
	    /**
	     * Add a source flow to a ModelElement.
	     *
	     * @param handle The model element.
	     * @param flow The flow.
	     */
	    void addSourceFlow(Object handle, Object flow);
	
	    /**
	     * Add a supplier to a Dependency.
	     *
	     * @param handle the Dependency to which to add the supplier
	     * @param element supplier model element
	     */
	    void addSupplier(Object handle, Object element);
	
	    /**
	     * Add a supplier dependency to a ModelElement.
	     *
	     * @param supplier the supplier
	     * @param dependency the dependency
	     */
	    void addSupplierDependency(Object supplier, Object dependency);
	
	
	    /**
	     * Add a target flow to a ModelElement.
	     *
	     * @param handle The model element.
	     * @param flow The flow to add.
	     */
	    void addTargetFlow(Object handle, Object flow);
	
	    /**
	     * Add a TemplateArgument to the given object at given location.
	     *
	     * @param handle The object that will get the TemplateParameter
	     * @param index the location
	     * @param argument Object that will be added
	     */
	    void addTemplateArgument(Object handle, int index, Object argument);
	
	    /**
	     * Add a TemplateArgument to the given object.
	     *
	     * @param handle The object that will get the TemplateArgument
	     * @param argument Object that will be added
	     */
	    void addTemplateArgument(Object handle, Object argument);
	    
	    /**
	     * Add a TemplateParameter to the given object at given location.
	     *
	     * @param handle The object that will get the TemplateParameter
	     * @param index the location
	     * @param parameter Object that will be added
	     */
	    void addTemplateParameter(Object handle, int index, Object parameter);
	
	    /**
	     * Add a TemplateTParameter to the given object.
	     *
	     * @param handle The object that will get the TemplateParameter
	     * @param parameter Object that will be added
	     */
	    void addTemplateParameter(Object handle, Object parameter);
	    
	    /**
	     * Set the isAbstract attribute of a GeneralizableElement.
	     *
	     * @param handle the GeneralizableElement
	     * @param isAbstract is true if it should be abstract
	     */
	    void setAbstract(Object handle, boolean isAbstract);
	
	    /**
	     * Set the isActive attribute of a UML Class.
	     *
	     * @param handle Class
	     * @param isActive boolean
	     */
	    void setActive(Object handle, boolean isActive);
	
	    /**
	     * Set the aggregation attribute of an AssociationEnd.
	     * This is implementation dependent regarding whether the UML version
	     * considers aggregation on the container or aggregated item
	     * 
	     * @param handle
	     *            the AssociationEnd
	     * @param aggregationKind
	     *            an {@link AggregationKind} of Aggregate, Composite, or None
	     *            returned from {@link Model#getAggregationKind()}.
	     */
	    void setAggregation(Object handle, Object aggregationKind);
	
	    /**
	     * Set the aggregation attribute of an AssociationEnd.
	     * This assumes UML1 style where the aggregation is held on the
	     * containing part of the association rather than the aggregate.
	     * 
	     * @param handle
	     *            the AssociationEnd
	     * @param aggregationKind
	     *            an {@link AggregationKind} of Aggregate, Composite, or None
	     *            returned from {@link Model#getAggregationKind()}.
	     */
	    void setAggregation1(Object handle, Object aggregationKind);
	
	
	    /**
	     * Set the aggregation attribute of an AssociationEnd.
	     * This assumes UML2 style where the aggregation is held on the
	     * aggregate part of the association rather than the container.
	     * 
	     * @param handle
	     *            the AssociationEnd
	     * @param aggregationKind
	     *            an {@link AggregationKind} of Aggregate, Composite, or None
	     *            returned from {@link Model#getAggregationKind()}.
	     */
	    void setAggregation2(Object handle, Object aggregationKind);
	    
	    
	    /**
	     * Set the list of annotated elements for the given comment.
	     *
	     * @param handle the given comment
	     * @param elems the collection of annotated ModelElements
	     */
	    void setAnnotatedElements(Object handle, Collection elems);
	
	    /**
	     * Set the association of a ModelElement.
	     *
	     * @param handle the model element to set association
	     * @param association is the association
	     */
	    void setAssociation(Object handle, Object association);
	
	    /**
	     * Set the isLeaf attribute of a GeneralizableElement.
	     *
	     * @param handle the GeneralizableElement
	     * @param isLeaf is true if it is a leaf, ie it has no subtypes.
	     */
	    void setLeaf(Object handle, boolean isLeaf);
	
	    /**
	     * Set the raised signals of a BehavioralFeature.
	     *
	     * @param handle the behavioural feature
	     * @param raisedSignals the raised signals
	     */
	    void setRaisedSignals(Object handle, Collection raisedSignals);
	
	    /**
	     * Sets a body of a given Method or Constraint.
	     *
	     * @param handle The method or constraint.
	     * @param expr The body of the expression.
	     *             If it is a method, this must be a ProcedureExpression.
	     *             If it is a Constraint, this must be a BooleanExpression.
	     */
	    void setBody(Object handle, Object expr);
	
	    /**
	     * Set the Changeability of a StructuralFeature or AssociationEnd.
	     * 
	     * @param handle
	     *            StructuralFeature or AssociationEnd
	     * @param ck
	     *            a {@link ChangeableKind} of Changeable, Frozen or AddOnly
	     *            returned from {@link Model#getChangeableKind()}.
	     * @deprecated for 0.25.4 by tfmorris. Use
	     *             {@link #setReadOnly(Object, boolean)}. NOTE: The UML 1.x
	     *             enum of AddOnly has no equivalent in UML 2.x.
	     */
	    @Deprecated
	    void setChangeability(Object handle, Object ck);
	
	    /**
	     * Set the isReadOnly (UML 2.x) or changeable (UML 1.x) attribute of a
	     * StructuralFeature or AssociationEnd.
	     * 
	     * @param handle
	     *            is the feature
	     * @param isReadOnly
	     *            true for ReadOnly (Frozen in UML 1.x).
	     * 
	     */
	    void setReadOnly(Object handle, boolean isReadOnly);
	    
	    /**
	     * Set the child for a generalization.
	     *
	     * @param handle Generalization
	     * @param child GeneralizableElement
	     */
	    void setChild(Object handle, Object child);
	
	    /**
	     * Set the concurrency of an Operation.
	     * 
	     * @param handle
	     *            the Operation
	     * @param concurrencyKind
	     *            a {@link ConcurrencyKind} of Concurrent, Guarded, or
	     *            Sequential returned from {@link Model#getConcurrencyKind()}.
	     *            null is allowed
	     */
	    void setConcurrency(Object handle, Object concurrencyKind);
	
	    /**
	     * Sets the list of connections of the given association or link.
	     *
	     * @param handle the given association or link
	     * @param ends the list of association-ends or link-ends
	     */
	    void setConnections(Object handle, Collection ends);
	
	    /**
	     * Sets the default ModelEelement of a TemplateParameter.
	     *
	     * @param handle is the TemplateParameter
	     * @param element is the default ModelElement or null
	     */
	    void setDefaultElement(Object handle, Object element);
	    
	    /**
	     * Set the defaultValue of a Parameter.
	     *
	     * @param handle is the Parameter
	     * @param expression the Expression to be used as the default value
	     */
	    void setDefaultValue(Object handle, Object expression);
	
	    /**
	     * Set the discriminator of a Generalization.
	     * 
	     * @param handle a Generalization
	     * @param discriminator the String representing the discriminator
	     */
	    void setDiscriminator(Object handle, String discriminator);
	
	    /**
	     * Set the Feature of a Classifier at the given position.
	     *
	     * @param classifier The classifier to set.
	     * @param index The position. Start with 0.
	     * @param feature The feature to set.
	     */
	    void setFeature(Object classifier, int index, Object feature);
	
	    /**
	     * Sets the features of a Classifier.
	     * 
	     * @param classifier
	     *            the Classifier to set features to
	     * @param features
	     *            the list of features. <em>NOTE:</em> although the API allows
	     *            any type of Collection, the list of features is ordered, so
	     *            only a List should be passed here. Other types of collections
	     *            will be converted to a List in their natural order (which may
	     *            not be the desired order.
	     */
	    void setFeatures(Object classifier, Collection features);
	
	    /**
	     * Set the Container of the given ElementResidence
	     * to the given Component.
	     *
	     * @param handle the ElementResidence
	     * @param component the Component
	     */
	    void setContainer(Object handle, Object component);
	
	    /**
	     * Set the initialValue of an Attribute.
	     *
	     * @param attribute attribute that we set the initial value of
	     * @param expression that is the value to set. Can be <code>null</code>.
	     */
	    void setInitialValue(Object attribute, Object expression);
	
	    /**
	     * Set the kind of a Parameter or the Pseudostate.
	     * 
	     * @param handle
	     *            is the Parameter or Pseudostate
	     * @param kind
	     *            a direction kind returned from
	     *            {@link Model#getDirectionKind()} or a pseudostate kind
	     *            returned from {@link Model#getPseudostateKind()}.
	     */
	    void setKind(Object handle, Object kind);
	
	    /**
	     * Set the container that owns the handle.<p>
	     * 
	     * <em>Warning: the implementation does not support setting the owner
	     * of actions.</em>
	     * Use setState1 etc. on action for that goal.<p>
	     * Use a more specific method such as setOwner, setContainer, etc if
	     * at all possible, rather than this method.
	     *
	     * @param handle
	     *            The ModelElement that must be added to the container
	     * @param container
	     *            The owning ModelElement
	     * @exception IllegalArgumentException
	     *                when the handle or container is null or if the handle
	     *                cannot be added to the container.
	     */
	    void setModelElementContainer(Object handle, Object container);
	
	    /**
	     * Set the multiplicity of a ModelElement.
	     *
	     * @param handle model element
	     * @param arg multiplicity as string OR multiplicity object,
	     *            null is a valid value (unspecified)
	     * @deprecated for 0.31.6 by tfmorris.  Use {@link #setMultiplicity(Object, String)}.
	     */
	    @Deprecated
	    void setMultiplicity(Object handle, Object arg);
	
	    /**
	     * Set the multiplicity of an Element.
	     *
	     * @param handle model element
	     * @param arg multiplicity as string
	     *            null is a valid value (unspecified)
	     */
	    void setMultiplicity(Object handle, String arg);
	    
	    /**
	     * Set the multiplicity of a ModelElement.
	     *
	     * @param handle model element
	     * @param lower the lower range of the multiplicity
	     * @param upper the upper range of the multiplicity
	     */
	    void setMultiplicity(Object handle, int lower, int upper);
	
	    /**
	     * Set the name of a ModelElement.
	     *
	     * @param handle is the model element
	     * @param name to set
	     */
	    void setName(Object handle, String name);
	
	    /**
	     * Set the body of a comment.<p>
	     *
	     * <em>NOTE:</em> For UML 1.3, this actually set Comment.name, but for UML
	     * 1.4 it sets Comment.body.
	     * <em>This is a behavior change in the API.</em><p>
	     *
	     * @param handle
	     *            the Comment element
	     * @param body
	     *            the string
	     */
	    void setBody(Object handle, String body);
	
	    /**
	     * Set the namespace of a ModelElement.
	     *
	     * @param handle is the model element
	     * @param ns is the namespace. Can be <code>null</code>.
	     */
	    void setNamespace(Object handle, Object ns);
	
	    /**
	     * Set the navigability of an AssociationEnd.
	     *
	     * @param handle is the association end
	     * @param flag is the navigability flag
	     */
	    void setNavigable(Object handle, boolean flag);
	
	    /**
	     * Set the OrderingKind of a given AssociationEnd.
	     * 
	     * @param handle
	     *            AssociationEnd
	     * @param ordering
	     *            an {@link OrderingKind} returned from
	     *            {@link Model#getOrderingKind()}.
	     */
	    void setOrdering(Object handle, Object ordering);
	
	    /**
	     * Set the owner of a Feature or a TagDefinition.
	     *
	     * @param handle Feature or TagDefinition
	     * @param owner Classifier or null
	     */
	    void setOwner(Object handle, Object owner);
	
	    /**
	     * Set the isStatic (UML 2.x) or ownerScope (UML 1.x) attribute of a
	     * feature.  As a special backward compatibility bridge, if passed
	     * a UML 1.4 AssociationEnd, it will set the targetScope instead of 
	     * the ownerScope (since AssociationEnds don't have an ownerScope).
	     * 
	     * @param element
	     *            feature or association end
	     * @param isStatic
	     *            true if static (Classifier scope in UML 1.x). False is
	     *            equivalent to the UML 1.x ScopeKind of 'Instance'.
	     * @since 0.25.4
	     */
	    void setStatic(Object element, boolean isStatic);
	
	    /**
	     * Set the parameter of a TemplateParameter.
	     * 
	     * @param handle the TemplateParameter
	     * @param parameter the dummy ModelElement to be used as the parameter
	     */
	    void setParameter(Object handle, Object parameter);
	
	    /**
	     * Set the parameters of a classifier, event, objectflowstate or
	     * behavioralfeature.
	     * 
	     * @param handle
	     *            the classifier, event, objectflowstate or behavioralfeature
	     * @param parameters
	     *            is a Collection of parameters
	     */
	    void setParameters(Object handle, Collection parameters);
	
	    /**
	     * Set the parent of a generalization.
	     *
	     * @param handle generalization
	     * @param parent GeneralizableElement (parent)
	     */
	    void setParent(Object handle, Object parent);
	
	    /**
	     * Set the powerType of a Generalization.
	     * 
	     * @param handle
	     *            Generalization
	     * @param powerType
	     *            the Classifier to set as the powerType or null to clear the
	     *            powerType.
	     */
	    void setPowertype(Object handle, Object powerType);
	
	    /**
	     * Set the qualifier attributes of an AssociationEnd.
	     *
	     * @param handle the association end
	     * @param qualifiers List of Attributes to be set as qualifiers
	     */
	    void setQualifiers(Object handle, List qualifiers);
	
	    /**
	     * Sets the isQuery attribute of a BehavioralFeature.
	     *
	     * @param handle is the behavioral feature
	     * @param isQuery new value for the isQuery attribute
	     */
	    void setQuery(Object handle, boolean isQuery);
	
	    /**
	     * Sets the ModelElement of a ElementResidence.
	     * 
	     * @param handle ElementResidence
	     * @param resident ModelElement or null
	     */
	    void setResident(Object handle, Object resident);
	
	    /**
	     * Sets the residents of a NodeInstance or ComponentInstance.
	     *
	     * @param handle the NodeInstance or ComponentInstance
	     * @param residents collection of 
	     *          ComponentInstances (in case the handle is a NodeInstance)
	     *          or Instances (in case the handle is a ComponentInstance)
	     */
	    void setResidents(Object handle, Collection residents);
	
	    /**
	     * Set the isRoot attribute of a GeneralizableElement.
	     *
	     * @param handle model element
	     * @param isRoot is true if it is a root ie it has no supertypes
	     */
	    void setRoot(Object handle, boolean isRoot);
	
	    /**
	     * @param handle Flow
	     * @param specifications the collection of ModelEvents (sourceFlow)
	     */
	    void setSources(Object handle, Collection specifications);
	
	    /**
	     * Set the isSpecification attribute for the ElementOwnership of a
	     * ModelElement.
	     * 
	     * @param handle
	     *            ModelElement
	     * @param isSpecification
	     *            true of the element is specification
	     */
	    void setSpecification(Object handle, boolean isSpecification);
	
	    /**
	     * Set the specification (i.e. the Operation) of a Method.
	     * 
	     * @param method the method
	     * @param specification the operation
	     */
	    void setSpecification(Object method, Object specification);
	
	    /**
	     * Set the specification of an Operation.
	     * 
	     * @param operation the operation
	     * @param specification the operation
	     */
	    void setSpecification(Object operation, String specification);
	    
	    /**
	     * Set the specifications of an AssociationEnd.
	     *
	     * @param handle the association end
	     * @param specifications collection
	     */
	    void setSpecifications(Object handle, Collection specifications);
	
	    /**
	     * Add a stereotype to a ModelElement.
	     *
	     * @param modelElement model element
	     * @param stereo stereotype
	     */
	    void addStereotype(Object modelElement, Object stereo);
	
	    /**
	     * Add a collection of stereotype to a ModelElement.
	     *
	     * @param modelElement model element
	     * @param stereos stereotype
	     */
	    void addAllStereotypes(Object modelElement, Collection stereos);
	
	    /**
	     * Remove a stereotype from a ModelElement.
	     *
	     * @param handle model element
	     * @param stereo stereotype
	     */
	    void removeStereotype(Object handle, Object stereo);
	
	    /**
	     * Remove all stereotypes from a given ModelElement.
	     *
	     * @param handle model element
	     */
	    void clearStereotypes(Object handle);
	
	    /**
	     * Set a tagged value of a ModelElement.
	     * 
	     * @param handle is the model element
	     * @param tag is the tag name (a string)
	     * @param value is the value
	     * @deprecated by tfmorris for 0.23.3. Use
	     *             {@link ExtensionMechanismsHelper#setType(Object, Object)} and
	     *          {@link ExtensionMechanismsHelper#setValueOfTag(Object, String)}.
	     */
	    @Deprecated
	    void setTaggedValue(Object handle, String tag, String value);
	
	
	    /**
	     * Set the targetScope of an AssociationEnd or StructuralFeature.
	     * 
	     * @param handle the model element
	     * @param targetScope a {@link ScopeKind} of Instance or Classifier returned
	     *                from {@link Model#getScopeKind()}.
	     * @deprecated for 0.25.4 by tfmorris. Target Scope has been removed from
	     *             the UML 2.x spec so this should not be used.
	     */
	    @Deprecated
	    void setTargetScope(Object handle, Object targetScope);
	
	    /**
	     * Set the type of a ModelElement.
	     * 
	     * @param handle
	     *            a ModelElement which is one of: Parameter, AssociationEnd,
	     *            StructuralFeature, ClassifierInState, or ObjectFlowState.
	     * @param type
	     *            a Classifier representing the type
	     */
	    void setType(Object handle, Object type);
	
	    /**
	     * Set the visibility of a ModelElement, 
	     * ElementResidence, ElementImport.
	     *
	     * @param handle element
	     * @param visibility is the visibility
	     */
	    void setVisibility(Object handle, Object visibility);
	
	    /**
	     * Remove a deployment location.
	     *
	     * @param handle Component from which to remove deploymentLocation
	     * @param node Node to be removed
	     */
	    void removeDeploymentLocation(Object handle, Object node);
	
	    /**
	     * Remove a connection between an Association & AssociationEnd
	     * or between a Link & LinkEnd.
	     *
	     * @param handle Association or Link
	     * @param connection AssociationEnd or LinkEnd
	     */
	    void removeConnection(Object handle, Object connection);
	
	    /**
	     * Add an ElementResidence.
	     *
	     * @param handle ModelElement
	     * @param residence ElementResidence to add
	     */
	    void addElementResidence(Object handle, Object residence);
	
	    /**
	     * Remove an ElementResidence.
	     *
	     * @param handle ModelElement
	     * @param residence ElementResidence to remove
	     */
	    void removeElementResidence(Object handle, Object residence);
	
	    /**
	     * Set the (ordered) list of literals of an Enumeration.
	     * @param enumeration Enumeration to add EnumerationLiterals too
	     * @param literals A list of EnumerationLiterals
	     */
	    void setEnumerationLiterals(Object enumeration, List literals);
	    
	    /**
	     * Returns names of all metatypes in metamodel.
	     * 
	     * TODO: This method rightly belongs in a separate interface dealing
	     * with instances of MOF types as opposed to UML types like all the
	     * rest of the methods here do.
	     * 
	     * @return Collection containing Strings with names of all metatypes
	     */
	    Collection<String> getAllMetatypeNames();
	
	    /**
	     * Returns names of all metamodel value elements including datatypes,
	     * enumerations, and primitive types.
	     * 
	     * TODO: This method rightly belongs in a separate interface dealing
	     * with instances of MOF types as opposed to UML types like all the
	     * rest of the methods here do.
	     * 
	     * @return Collection containing Strings with names of all metatypes
	     */
	    Collection<String> getAllMetaDatatypeNames();
	}
		
",
	role:"
	user	
",
,
	content:"
	//src/argouml-core-model/src/org/argouml/model/AbstractCoreHelperDecorator.java
	/* $Id$
	 *******************************************************************************
	 * Copyright (c) 2009-2010 Contributors - see below
	 * All rights reserved. This program and the accompanying materials
	 * are made available under the terms of the Eclipse Public License v1.0
	 * which accompanies this distribution, and is available at
	 * http://www.eclipse.org/legal/epl-v10.html
	 *
	 * Contributors:
	 *    tfmorris
	 *    Thomas Neustupny
	 *    Michiel van der Wulp
	 *******************************************************************************
	 *
	 * Some portions of this file was previously release using the BSD License:
	 */
	
	// Copyright (c) 2005-2008 The Regents of the University of California. All
	// Rights Reserved. Permission to use, copy, modify, and distribute this
	// software and its documentation without fee, and without a written
	// agreement is hereby granted, provided that the above copyright notice
	// and this paragraph appear in all copies. This software program and
	// documentation are copyrighted by The Regents of the University of
	// California. The software program and documentation are supplied "AS
	// IS", without any accompanying services from The Regents. The Regents
	// does not warrant that the operation of the program will be
	// uninterrupted or error-free. The end-user understands that the program
	// was developed for research purposes and is advised not to rely
	// exclusively on the program for any reason. IN NO EVENT SHALL THE
	// UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
	// SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
	// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
	// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
	// SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
	// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
	// PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
	// CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
	// UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
	
	package org.argouml.model;
	
	import java.util.Collection;
	import java.util.List;
	
	/**
	 * An abstract Decorator for the {@link CoreHelper}.
	 *
	 * @author Bob Tarling
	 */
	@SuppressWarnings("deprecation")
	public abstract class AbstractCoreHelperDecorator implements CoreHelper {
	
	    /**
	     * The delegate.
	     */
	    private CoreHelper impl;
	
	    /**
	     * Construct a new AbstractCoreHelperDecorator.
	     *
	     * @param component The component to decorate.
	     */
	    protected AbstractCoreHelperDecorator(CoreHelper component) {
	        impl = component;
	    }
	
	    /**
	     * The component we are decorating.
	     *
	     * @return Returns the component.
	     */
	    protected CoreHelper getComponent() {
	        return impl;
	    }
	
	    /*
	     * @see org.argouml.model.CoreHelper#clearStereotypes(java.lang.Object)
	     * 
	     * All methods below similarly override methods in CoreHelper.
	     */
	    public void clearStereotypes(Object modelElement) {
	        impl.clearStereotypes(modelElement);
	    }
	
	    public boolean isSubType(Object type, Object subType) {
	        return impl.isSubType(type, subType);
	    }
	
	    public Collection getAllSupertypes(Object cls1) {
	        return impl.getAllSupertypes(cls1);
	    }
	
	    public Collection getSupertypes(Object generalizableElement) {
	        return impl.getSupertypes(generalizableElement);
	    }
	
	    public Collection getUtilizedElements(Object artifact) {
	        return impl.getUtilizedElements(artifact);
	    }
	
	    public Collection getAssociateEndsInh(Object classifier1) {
	        return impl.getAssociateEndsInh(classifier1);
	    }
	
	    public void removeFeature(Object cls, Object feature) {
	        impl.removeFeature(cls, feature);
	    }
	
	    public void removeLiteral(Object enu, Object literal) {
	        impl.removeLiteral(enu, literal);
	    }
	
	    public void setOperations(Object classifier, List operations) {
	        impl.setOperations(classifier, operations);
	    }
	
	    public void setAttributes(Object classifier, List attributes) {
	        impl.setAttributes(classifier, attributes);
	    }
	    
	    public Collection getAttributesInh(Object classifier) {
	        return impl.getAttributesInh(classifier);
	    }
	
	    public Collection getOperationsInh(Object classifier) {
	        return impl.getOperationsInh(classifier);
	    }
	
	    public Collection getParents(Object generalizableElement) {
	        return impl.getParents(generalizableElement);
	    }
	
	    public List getReturnParameters(Object bf) {
	        return impl.getReturnParameters(bf);
	    }
	
	    public Object getSpecification(Object object) {
	        return impl.getSpecification(object);
	    }
	
	    public Collection getSubtypes(Object cls) {
	        return impl.getSubtypes(cls);
	    }
	
	    public Collection getAllBehavioralFeatures(Object element) {
	        return impl.getAllBehavioralFeatures(element);
	    }
	
	    public List getBehavioralFeatures(Object clazz) {
	        return impl.getBehavioralFeatures(clazz);
	    }
	
	    public Collection getAllInterfaces(Object ns) {
	        return impl.getAllInterfaces(ns);
	    }
	
	    public Collection getAllClasses(Object ns) {
	        return impl.getAllClasses(ns);
	    }
	
	    public Collection getRealizedInterfaces(Object cls) {
	        return impl.getRealizedInterfaces(cls);
	    }
	
	    public Collection getExtendedClassifiers(Object clazz) {
	        return impl.getExtendedClassifiers(clazz);
	    }
	
	    public Object getGeneralization(Object child, Object parent) {
	        return impl.getGeneralization(child, parent);
	    }
	
	    public String getBody(Object comment) {
	        return impl.getBody(comment);
	    }
	
	    public Collection getFlows(Object source, Object target) {
	        return impl.getFlows(source, target);
	    }
	
	    public Collection getExtendingElements(Object clazz) {
	        return impl.getExtendingElements(clazz);
	    }
	
	    public Collection getExtendingClassifiers(Object clazz) {
	        return impl.getExtendingClassifiers(clazz);
	    }
	
	    public Collection getAllComponents(Object ns) {
	        return impl.getAllComponents(ns);
	    }
	
	    public Collection getAllDataTypes(Object ns) {
	        return impl.getAllDataTypes(ns);
	    }
	
	    public Collection getAllNodes(Object ns) {
	        return impl.getAllNodes(ns);
	    }
	
	    public Collection getAssociatedClassifiers(Object classifier) {
	        return impl.getAssociatedClassifiers(classifier);
	    }
	
	    public Collection getAssociations(Object from, Object to) {
	        return impl.getAssociations(from, to);
	    }
	
	    public Collection getAllClassifiers(Object namespace) {
	        return impl.getAllClassifiers(namespace);
	    }
	
	    public Collection getAssociations(Object classifier) {
	        return impl.getAssociations(classifier);
	    }
	
	    public Object getAssociationEnd(Object type, Object assoc) {
	        return impl.getAssociationEnd(type, assoc);
	    }
	
	    public Collection getAllAttributes(Object clazz) {
	        return impl.getAllAttributes(clazz);
	    }
	
	    public Collection getAllVisibleElements(Object ns) {
	        return impl.getAllVisibleElements(ns);
	    }
	
	    public Object getSource(Object relationship) {
	        return impl.getSource(relationship);
	    }
	
	    public Object getDestination(Object relationship) {
	        return impl.getDestination(relationship);
	    }
	
	    public Collection getDependencies(Object supplier, Object client) {
	        return impl.getDependencies(supplier, client);
	    }
	
	    public Object getPackageImport(Object supplier, Object client) {
	        return impl.getPackageImport(supplier, client);
	    }
	
	    public Collection getPackageImports(Object client) {
	        return impl.getPackageImports(client);
	    }
	    
	    public Collection getRelationships(Object source, Object dest) {
	        return impl.getRelationships(source, dest);
	    }
	
	    public boolean isValidNamespace(Object mObj, Object nsObj) {
	        return impl.isValidNamespace(mObj, nsObj);
	    }
	
	    public Object getFirstSharedNamespace(Object ns1, Object ns2) {
	        return impl.getFirstSharedNamespace(ns1, ns2);
	    }
	
	    public Collection getAllPossibleNamespaces(Object modelElement,
						       Object model) {
	        return impl.getAllPossibleNamespaces(modelElement, model);
	    }
	
	    public Collection getChildren(Object o) {
	        return impl.getChildren(o);
	    }
	
	    public Collection getAllRealizedInterfaces(Object o) {
	        return impl.getAllRealizedInterfaces(o);
	    }
	
	    public boolean hasCompositeEnd(Object association) {
	        return impl.hasCompositeEnd(association);
	    }
	
	    public boolean equalsAggregationKind(Object associationEnd,
						 String kindType) {
	        return impl.equalsAggregationKind(associationEnd, kindType);
	    }
	
	    public void removeAnnotatedElement(Object handle, Object me) {
	        impl.removeAnnotatedElement(handle, me);
	    }
	
	    public void removeClientDependency(Object handle, Object dep) {
	        impl.removeClientDependency(handle, dep);
	    }
	
	    public void removeConstraint(Object handle, Object cons) {
	        impl.removeConstraint(handle, cons);
	    }
	
	    public void removeOwnedElement(Object handle, Object value) {
	        impl.removeOwnedElement(handle, value);
	    }
	
	    public void removeParameter(Object handle, Object parameter) {
	        impl.removeParameter(handle, parameter);
	    }
	
	    public void removeQualifier(Object handle, Object parameter) {
	        impl.removeQualifier(handle, parameter);
	    }
	
	    public void removeSourceFlow(Object handle, Object flow) {
	        impl.removeSourceFlow(handle, flow);
	    }
	
	    public void removeSupplierDependency(Object supplier, Object dependency) {
	        impl.removeSupplierDependency(supplier, dependency);
	    }
	
	    public void removeStereotype(Object modelElement, Object stereotype) {
	        impl.removeStereotype(modelElement, stereotype);
	    }
	
	    public void removeTargetFlow(Object handle, Object flow) {
	        impl.removeTargetFlow(handle, flow);
	    }
	
	    public void removeTemplateArgument(Object handle, Object argument) {
	        impl.removeTemplateArgument(handle, argument);
	    }
	    
	    public void removeTemplateParameter(Object handle, Object parameter) {
	        impl.removeTemplateParameter(handle, parameter);
	    }
	
	    public void addAnnotatedElement(Object comment, Object annotatedElement) {
	        impl.addAnnotatedElement(comment, annotatedElement);
	    }
	
	    public void addClient(Object handle, Object element) {
	        impl.addClient(handle, element);
	    }
	
	    public void addClientDependency(Object handle, Object dependency) {
	        impl.addClientDependency(handle, dependency);
	    }
	
	    public void addComment(Object element, Object comment) {
	        impl.addComment(element, comment);
	    }
	
	    public void addConnection(Object handle, Object connection) {
	        impl.addConnection(handle, connection);
	    }
	
	    public void addConnection(Object handle, int position, Object connection) {
	        impl.addConnection(handle, position, connection);
	    }
	
	    public void addConstraint(Object handle, Object mc) {
	        impl.addConstraint(handle, mc);
	    }
	
	    public void addDeploymentLocation(Object handle, Object node) {
	        impl.addDeploymentLocation(handle, node);
	    }
	
	    public void addFeature(Object handle, int index, Object f) {
	        impl.addFeature(handle, index, f);
	    }
	
	    public void addFeature(Object handle, Object f) {
	        impl.addFeature(handle, f);
	    }
	
	    public void addLiteral(Object handle, int index, Object literal) {
	        impl.addLiteral(handle, index, literal);
	    }
	
	    public void addLink(Object handle, Object link) {
	        impl.addLink(handle, link);
	    }
	
	    public void addManifestation(Object handle, Object m) {
	        impl.addManifestation(handle, m);
	    }
	
	    public void addMethod(Object handle, Object m) {
	        impl.addMethod(handle, m);
	    }
	
	    public void addOwnedElement(Object handle, Object me) {
	        impl.addOwnedElement(handle, me);
	    }
	
	    public void addParameter(Object handle, int index, Object parameter) {
	        impl.addParameter(handle, index, parameter);
	    }
	
	    public void addParameter(Object handle, Object parameter) {
	        impl.addParameter(handle, parameter);
	    }
	
	    public void addQualifier(Object handle, int index, Object qualifier) {
	        impl.addQualifier(handle, index, qualifier);
	    }
	
	    public void addRaisedSignal(Object handle, Object sig) {
	        impl.addRaisedSignal(handle, sig);
	    }
	
	    public void addSourceFlow(Object handle, Object flow) {
	        impl.addSourceFlow(handle, flow);
	    }
	
	    public void addAllStereotypes(Object modelElement, Collection stereotypes) {
	        impl.addStereotype(modelElement, stereotypes);
	    }
	
	    public void addStereotype(Object modelElement, Object stereotype) {
	        impl.addStereotype(modelElement, stereotype);
	    }
	
	    public void addSupplier(Object handle, Object element) {
	        impl.addSupplier(handle, element);
	    }
	
	    public void addSupplierDependency(Object supplier, Object dependency) {
	        impl.addSupplierDependency(supplier, dependency);
	    }
	
	    public void addTargetFlow(Object handle, Object flow) {
	        impl.addTargetFlow(handle, flow);
	    }
	
	    public void addTemplateArgument(Object handle, int index, Object argument) {
	        impl.addTemplateArgument(handle, index, argument);
	    }
	
	    public void addTemplateArgument(Object handle, Object argument) {
	        impl.addTemplateArgument(handle, argument);
	    }
	
	    public void addTemplateParameter(Object handle, int index, 
	            Object parameter) {
	        impl.addTemplateParameter(handle, index, parameter);
	    }
	
	    public void addTemplateParameter(Object handle, Object parameter) {
	        impl.addTemplateParameter(handle, parameter);
	    }
	
	    public void setAnnotatedElements(Object handle, Collection elems) {
	        impl.setAnnotatedElements(handle, elems);
	    }
	
	    public void setAssociation(Object handle, Object association) {
	        impl.setAssociation(handle, association);
	    }
	
	    public void setRaisedSignals(Object handle, Collection raisedSignals) {
	        impl.setRaisedSignals(handle, raisedSignals);
	    }
	
	    public void setBody(Object handle, Object expr) {
	        impl.setBody(handle, expr);
	    }
	
	    public void setChild(Object handle, Object child) {
	        impl.setChild(handle, child);
	    }
	
	    public void setConnections(Object handle, Collection elems) {
	        impl.setConnections(handle, elems);
	    }
	
	    public void setDefaultElement(Object handle, Object element) {
	        impl.setDefaultElement(handle, element);
	    }
	    
	    public void setDefaultValue(Object handle, Object expr) {
	        impl.setDefaultValue(handle, expr);
	    }
	
	    public void setDiscriminator(Object handle, String discriminator) {
	        impl.setDiscriminator(handle, discriminator);
	    }
	
	    public void setFeature(Object elem, int i, Object feature) {
	        impl.setFeature(elem, i, feature);
	    }
	
	    public void setFeatures(Object handle, Collection features) {
	        impl.setFeatures(handle, features);
	    }
	
	    public void setContainer(Object handle, Object component) {
	        impl.setContainer(handle, component);
	    }
	
	    public void setInitialValue(Object at, Object expr) {
	        impl.setInitialValue(at, expr);
	    }
	
	    public void setModelElementContainer(Object handle, Object container) {
	        impl.setModelElementContainer(handle, container);
	    }
	
	    public void setNamespace(Object handle, Object ns) {
	        impl.setNamespace(handle, ns);
	    }
	
	    public void setOwner(Object handle, Object owner) {
	        impl.setOwner(handle, owner);
	    }
	
	    public void setStatic(Object handle, boolean isStatic) {
	        impl.setStatic(handle, isStatic);
	    }
	    
	    public void setParameter(Object handle, Object parameter) {
	        impl.setParameter(handle, parameter);
	    }
	
	    public void setParameters(Object handle, Collection parameters) {
	        impl.setParameters(handle, parameters);
	    }
	
	    public void setParent(Object handle, Object parent) {
	        impl.setParent(handle, parent);
	    }
	
	    public void setQualifiers(Object handle, List elems) {
	        impl.setQualifiers(handle, elems);
	    }
	
	    public void setResident(Object handle, Object resident) {
	        impl.setResident(handle, resident);
	    }
	
	    public void setResidents(Object handle, Collection residents) {
	        impl.setResidents(handle, residents);
	    }
	
	    public void setSources(Object handle, Collection specifications) {
	        impl.setSources(handle, specifications);
	    }
	
	    public void setSpecifications(Object handle, Collection specifications) {
	        impl.setSpecifications(handle, specifications);
	    }
	
	    @Deprecated
	    public void setTaggedValue(Object handle, String tag, String value) {
	        impl.setTaggedValue(handle, tag, value);
	    }
	
	    public void setType(Object handle, Object type) {
	        impl.setType(handle, type);
	    }
	
	    public void removeDeploymentLocation(Object handle, Object node) {
	        impl.removeDeploymentLocation(handle, node);
	    }
	
	    public void setAbstract(Object handle, boolean flag) {
	        impl.setAbstract(handle, flag);
	    }
	
	    public void setActive(Object handle, boolean active) {
	        impl.setActive(handle, active);
	    }
	
	    public void setAggregation(Object handle, Object aggregationKind) {
	        impl.setAggregation(handle, aggregationKind);
	    }
	
	    public void setLeaf(Object handle, boolean flag) {
	        impl.setLeaf(handle, flag);
	    }
	
	    @Deprecated
	    public void setChangeability(Object handle, Object ck) {
	        impl.setChangeability(handle, ck);
	    }
	    
	    public void setReadOnly(Object handle, boolean isReadOnly) {
	        impl.setReadOnly(handle, isReadOnly);
	    }
	    
	    public void setConcurrency(Object handle, Object concurrencyKind) {
	        impl.setConcurrency(handle, concurrencyKind);
	    }
	
	    public void setKind(Object handle, Object kind) {
	        impl.setKind(handle, kind);
	    }
	
	    @Deprecated
	    public void setMultiplicity(Object handle, Object arg) {
	        impl.setMultiplicity(handle, arg);
	    }
	
	    public void setMultiplicity(Object handle, String arg) {
	        impl.setMultiplicity(handle, arg);
	    }
	
	    public void setMultiplicity(Object handle, int lower, int upper) {
	        impl.setMultiplicity(handle, lower, upper);
	    }
	    
	    public void setName(Object handle, String name) {
	        impl.setName(handle, name);
	    }
	
	    public void setBody(Object handle, String body) {
	        impl.setBody(handle, body);
	    }
	
	    public void setNavigable(Object handle, boolean flag) {
	        impl.setNavigable(handle, flag);
	    }
	
	    public void setOrdering(Object handle, Object ok) {
	        impl.setOrdering(handle, ok);
	    }
	
	    public void setPowertype(Object handle, Object pt) {
	        impl.setPowertype(handle, pt);
	    }
	
	    public void setQuery(Object handle, boolean flag) {
	        impl.setQuery(handle, flag);
	    }
	
	    public void setRoot(Object handle, boolean flag) {
	        impl.setRoot(handle, flag);
	    }
	
	    public void setSpecification(Object handle, boolean specification) {
	        impl.setSpecification(handle, specification);
	    }
	
	    @Deprecated
	    public void setTargetScope(Object handle, Object scopeKind) {
	        impl.setTargetScope(handle, scopeKind);
	    }
	
	    public void setVisibility(Object handle, Object visibility) {
	        impl.setVisibility(handle, visibility);
	    }
	
	    public void removeConnection(Object handle, Object connection) {
	        impl.removeConnection(handle, connection);
	    }
	
	    public void addElementResidence(Object handle, Object residence) {
	        impl.addElementResidence(handle, residence);
	    }
	
	    public void removeElementResidence(Object handle, Object residence) {
	        impl.removeElementResidence(handle, residence);
	    }
	
	    public void setEnumerationLiterals(Object enumeration, List literals) {
	        impl.setEnumerationLiterals(enumeration, literals);
	    }
	
	    public Collection getAllMetatypeNames() {
	        return impl.getAllMetatypeNames();
	    }
	
	    public Collection getAllMetaDatatypeNames() {
	        return impl.getAllMetaDatatypeNames();
	    }
	}
		
",
	role:"
	user	
",
,
	content:"
	//src/argouml-core-umlpropertypanels/src/org/argouml/core/propertypanels/ui/SwingUIFactory.java
	/* $Id$
	 *******************************************************************************
	 * Copyright (c) 2009-2012 Contributors - see below
	 * All rights reserved. This program and the accompanying materials
	 * are made available under the terms of the Eclipse Public License v1.0
	 * which accompanies this distribution, and is available at
	 * http://www.eclipse.org/legal/epl-v10.html
	 *
	 * Contributors:
	 *    Bob Tarling - Post GSOC improvements
	 *    Christian Lpez Espnola
	 *    Thomas Neustupny
	 *******************************************************************************
	 *
	 * Some portions of this file was previously release using the BSD License:
	 */
	// Copyright (c) 2008 The Regents of the University of California. All
	// Rights Reserved. Permission to use, copy, modify, and distribute this
	// software and its documentation without fee, and without a written
	// agreement is hereby granted, provided that the above copyright notice
	// and this paragraph appear in all copies. This software program and
	// documentation are copyrighted by The Regents of the University of
	// California. The software program and documentation are supplied "AS
	// IS", without any accompanying services from The Regents. The Regents
	// does not warrant that the operation of the program will be
	// uninterrupted or error-free. The end-user understands that the program
	// was developed for research purposes and is advised not to rely
	// exclusively on the program for any reason. IN NO EVENT SHALL THE
	// UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
	// SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
	// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
	// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
	// SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
	// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
	// PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
	// CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
	// UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
	
	package org.argouml.core.propertypanels.ui;
	
	import java.util.Collection;
	import java.util.logging.Level;
	import java.util.logging.Logger;
	
	import javax.swing.BoxLayout;
	import javax.swing.JComboBox;
	import javax.swing.JComponent;
	import javax.swing.JLabel;
	import javax.swing.JPanel;
	import javax.swing.JScrollPane;
	import javax.swing.JTextArea;
	import javax.swing.JTextField;
	import javax.swing.JToolBar;
	import javax.swing.border.TitledBorder;
	
	import org.argouml.application.helpers.ResourceLoaderWrapper;
	import org.argouml.core.propertypanels.model.CheckBoxData;
	import org.argouml.core.propertypanels.model.ControlData;
	import org.argouml.core.propertypanels.model.GetterSetterManager;
	import org.argouml.core.propertypanels.model.PanelData;
	import org.argouml.i18n.Translator;
	import org.argouml.model.Model;
	import org.argouml.ui.ActionCreateContainedModelElement;
	import org.argouml.uml.ui.ActionDeleteModelElements;
	import org.argouml.uml.ui.foundation.extension_mechanisms.ActionNewStereotype;
	import org.tigris.toolbar.ToolBarFactory;
	
	/**
	 * Creates the XML Property panels
	 */
	class SwingUIFactory {
	
	    private static final Logger LOG =
	        Logger.getLogger(SwingUIFactory.class.getName());
	
	    public SwingUIFactory() {
	    }
	
	    /**
	     * @param target The model element selected
	     * @return A Panel to be added to the main panel
	     * @throws Exception If something goes wrong
	     * @see org.argouml.core.propertypanels.panel.UIFactory#createGUI(java.lang.Object)
	     */
	    public void createGUI (
	            final Object target,
	            final JPanel panel) throws Exception {
	        PanelData panelData =
	            XMLPropPanelFactory.getInstance().getPropertyPanelsData(
	              	target.getClass());
	
	        if (panelData == null) {
	            panel.add(new JLabel(
	        	    "There is no panel configured for " + target.getClass()));
	            LOG.log(Level.SEVERE, "No panel found for " + target.getClass());
	            return;
	        }
	
	        createLabel(target, panelData, panel);
	
	        for (ControlData prop : panelData.getProperties()) {
	            try {
	        	createControl (target, panel, prop);
	            } catch (Exception e) {
	                String message = "Exception caught building control "
	                    + prop.getControlType()
	                    + " for property " + prop.getPropertyName()
	                    + " on panel for " + target;
	                LOG.log(Level.SEVERE, message, e);
	                try {
	                    panel.add(new JLabel(message));
	                } catch (Exception ex) {
	                    throw e;
	                }
	            }
	        }
	    }
	
	    /**
	     * Create a control on the given panel for the correct type and target
	     * @param target
	     * @param panel
	     * @param prop
	     * @throws Exception
	     */
	    private void createControl(
	            final Object target,
	            final JPanel panel,
	            final ControlData prop) throws Exception {
	        if ("text".equals(prop.getControlType())) {
	            buildTextboxPanel(panel, target, prop);
	        } else if ("combo".equals(prop.getControlType())) {
	            buildComboPanel(panel, target, prop);
	        } else if ("checkgroup".equals(prop.getControlType())) {
	            buildCheckGroup(panel, target, prop);
	        } else if ("optionbox".equals(prop.getControlType())) {
	            buildOptionBox(panel, target, prop);
	        } else if ("singlerow".equals(prop.getControlType())) {
	            buildSingleRow(panel, target, prop);
	        } else if ("list".equals(prop.getControlType())) {
	            buildList(panel, target, prop);
	        } else if ("textarea".equals(prop.getControlType())) {
	            buildTextArea(panel, target, prop);
	        } else if ("separator".equals(prop.getControlType())) {
	            panel.add(LabelledLayout.getSeparator());
	        }
	    }
	
	    /**
	     * Create the label with icon and description for the panel.
	     * @param target
	     * @param panel
	     */
	    private void createLabel(
	            final Object target,
	            final PanelData panelData,
	            final JPanel panel) {
	        final String metaTypeName = Model.getMetaTypes().getName(target);
	        final ToolBarFactory tbf = new ToolBarFactory(new Object[0]);
	        tbf.setRollover(true);
	        final JToolBar tb = tbf.createToolBar();
	        final String label;
	
	        if (Model.getFacade().isAPseudostate(target)) {
	        	// TODO: We need some way of driving this from panel xml rather
	        	// than hard coded test
	        	Object pseudostateKind = Model.getFacade().getKind(target);
	        	label = Model.getFacade().getName(pseudostateKind);
	        } else {
	            label = metaTypeName;
	        }
	    	tb.add(new JLabel(label, ResourceLoaderWrapper.lookupIconResource(label), JLabel.LEFT));
	        if (!Model.getModelManagementHelper().isReadOnly(target)) {
	            tb.add(new NavigateUpAction(target));
	
	            if (panelData.isSiblingNavigation()) {
	                tb.add(new NavigatePreviousAction(target));
	                tb.add(new NavigateNextAction(target));
	            }
	
	            tb.add(new ActionDeleteModelElements());
	            // We only have this here until we have stereotypes
	            // list on property panel
	            tb.add(new ActionNewStereotype());
	
	            addCreateButtons(target, tb, panelData.getNewChildElements());
	
	            final Object parent =
	        	Model.getFacade().getModelElementContainer(target);
	            addCreateButtons(parent, tb, panelData.getNewSiblingElements());
	        }
	        panel.add(tb);
	    }
	
	    /**
	     * Create the actions to create new model elements and add the buttons to
	     * perform those actions to the given toolbar.
	     * @param container The model element that will contain the newly created elements
	     * @param tb The toolbar to contain the buttons.
	     * @param metaTypes The list of model element types for which
	     * actions/buttons are required
	     */
	    private void addCreateButtons(
		    final Object container,
		    final JToolBar tb,
		    final Collection<Class<?>> metaTypes) {
	        if (container != null) {
	            for (Class<?> metaType : metaTypes) {
	                if (Model.getUmlFactory().isContainmentValid(
	            	    metaType, container)) {
	                    tb.add(new ActionCreateContainedModelElement(
	                    	metaType, container));
	                }
	            }
	        }
	    }
	
	    private void buildTextArea(
	            final JPanel panel,
	            final Object target,
	            final ControlData prop) {
	
	        // TODO: Why do we need this as well as control? Why is it
	        // instantiated when its not always needed.
	        JPanel p = new JPanel();
	
	        JComponent control = null;
	
	        final String propertyName = prop.getPropertyName();
	        final Class<?> type = prop.getType();
	
	        final TitledBorder border = new TitledBorder(propertyName);
	        p.setBorder(border);
	
	        if ("initialValue".equals(propertyName)) {
	            if (Model.getFacade().getUmlVersion().charAt(0) == '1') {
	                UMLExpressionModel model =
	                    new UMLInitialValueExpressionModel(target);
	                p  = new UMLExpressionPanel(model, propertyName);
	            } else {
	        	UMLValueSpecificationModel model =
	                    new UMLValueSpecificationModel(target, "initialValue");
	                //p  = new UMLValueSpecificationPanel(model, propertyName);
	        	p  = new UMLValueSpecificationPanelOptional(model, propertyName);
	            }
	            control = p;
	        } else if ("defaultValue".equals(propertyName)) {
	            UMLExpressionModel model =
	                new UMLDefaultValueExpressionModel(target);
	            p  = new UMLExpressionPanel(model, propertyName);
	            control = p;
	        } else if ("specification".equals(propertyName)) {
	            UMLPlainTextDocument document =
	                new UMLOperationSpecificationDocument(propertyName, target);
	            UMLTextArea osta = new UMLTextArea(document);
	            osta.setRows(3);
	            control = new JScrollPane(osta);
	        } else if ("body".equals(propertyName) && type == String.class) {
	            UMLPlainTextDocument document = new UMLCommentBodyDocument(propertyName, target);
	            UMLTextArea text = new UMLTextArea(document);
	            text.setLineWrap(true);
	            text.setRows(5);
	            control = new JScrollPane(text);
	        } else if ("condition".equals(propertyName)) {
	            UMLExpressionModel conditionModel =
	                new UMLConditionExpressionModel(target);
	            JTextArea conditionArea =
	                new UMLExpressionBodyField(conditionModel, true);
	            conditionArea.setRows(5);
	            control = new JScrollPane(conditionArea);
	        } else if ("script".equals(propertyName)) {
	            UMLExpressionModel scriptModel =
	                new UMLScriptExpressionModel(target);
	            p  = new UMLExpressionPanel(scriptModel, prop.getPropertyName());
	            control = p;
	        } else if ("recurrence".equals(propertyName)) {
	            UMLExpressionModel recurrenceModel =
	                new UMLRecurrenceExpressionModel(target);
	            p  = new UMLExpressionPanel(recurrenceModel, propertyName);
	            control = p;
	        } else if ("expression".equals(propertyName)) {
	            UMLExpressionModel model = new UMLExpressionExpressionModel(target);
	            p = new UMLExpressionPanel(model, propertyName);
	            control = p;
	        } else if ("changeExpression".equals(propertyName)) {
	            UMLExpressionModel model = new UMLChangeExpressionModel(target);
	            p = new UMLExpressionPanel(model, propertyName);
	            control = p;
	        } else if ("when".equals(propertyName)) {
	            UMLExpressionModel model = new UMLTimeExpressionModel(target);
	            p = new UMLExpressionPanel(model, propertyName);
	            control = p;
	        }
	
	        if (control != null) {
	            if (control == p) {
	                // if the control is a panel, add it
	                addControl(panel, null, control, target);
	            } else {
	                // if not, it is a control and must be labeled...
	                addControl(panel, Translator.localize(prop.getLabel()),
	                		control, target);
	            }
	        } else {
	            final GetterSetterManager getterSetter =
	            	GetterSetterManager.getGetterSetter(prop.getType());
	
	            if (getterSetter.contains(propertyName)) {
	                ExpressionModel model =
	                	new ExpressionModel(propertyName, prop.getTypes().get(0), target, getterSetter);
	                final JTextField languageField =
	                    new ExpressionLanguageField(model);
	                addControl(
	                        panel,
	                        Translator.localize("label.language"),
	                        languageField, target);
	                control = new JScrollPane(new ExpressionBodyField(model));
	                addControl(panel, null, control, target);
	            }
	        }
	    }
	
	    private void buildSingleRow(JPanel panel, Object target,
	            ControlData prop) {
	
	        final SingleListFactory factory = new SingleListFactory();
	        final JComponent pane =
	            factory.createComponent(target, prop.getPropertyName(), prop.getTypes());
	
	        if (pane != null) {
	            addControl(panel, Translator.localize(prop.getLabel()), pane, target);
	        }
	    }
	
	    private void buildList(
	            final JPanel panel, Object target,
	            final ControlData prop) {
	
	        final ListFactory factory = new ListFactory();
	        final JComponent list =
	            factory.createComponent(target, prop.getPropertyName(), prop.getTypes());
	
	        if (list != null) {
	            addControl(panel, Translator.localize(prop.getLabel()), list, target);
	        }
	    }
	
	    /**
	     * @param target The target of the panel
	     * @param prop The XML data that contains the information
	     *        of the options.
	     * @return a radio button panel with the options
	     */
	    private void buildOptionBox(JPanel panel, Object target,
	            ControlData prop) {
	
	        final String propertyName = prop.getPropertyName();
	
	        // TODO: consider a conditional feature in the xml panel def for this:
	        if (Model.getFacade().getUmlVersion().charAt(0) != '1') {
	            if ("aggregation".equals(propertyName) &&
	        	    !Model.getFacade().isAAssociationEnd(target)) {
	        	// only association end has an aggregation option box
	        	return;
	            }
	        }
	
	        final GetterSetterManager getterSetter = GetterSetterManager.getGetterSetter(prop.getType());
	
	        if (getterSetter.contains(propertyName)) {
	            JPanel control = new RadioButtonPanel(
	                    target,
	                    propertyName,
	                    true,
	                    getterSetter);
	            addControl(panel, null, control, target);
	        }
	    }
	
	    /**
	     * @param target The target of the checkbox group
	     * @param prop The XML data that contains the information
	     *        of the checkboxes.
	     * @return a panel that contains the checkboxes
	     */
	    private void buildCheckGroup(
		    final JPanel panel,
		    final Object target,
	            final ControlData prop) {
	        JPanel p = new JPanel();
	        p.setLayout(new BoxLayout(p, BoxLayout.X_AXIS));
	        TitledBorder border = new TitledBorder(prop.getPropertyName());
	        p.setBorder(border);
	
	        if ("modifiers".equals(prop.getPropertyName())) {
	            for (CheckBoxData data : prop.getCheckboxes()) {
	                buildCheckBox(p, target, data);
	            }
	        }
	        addControl(panel, null, p, target);
	    }
	
	    private void buildCheckBox(
	            final JPanel panel,
	            final Object target,
	            final CheckBoxData prop) {
	
	        final String propertyName = prop.getPropertyName();
	
	        final GetterSetterManager getterSetter =
	            GetterSetterManager.getGetterSetter(prop.getType());
	
	        final String label = Translator.localize(prop.getLabel());
	
	        if (getterSetter.contains(propertyName)) {
	        	final CheckBox cb =
	        		new CheckBox(label, target, propertyName, getterSetter);
	        	if (Model.getModelManagementHelper().isReadOnly(target)) {
	        		cb.setEnabled(false);
	        	}
	
	            panel.add(cb);
	        }
	    }
	
	    /**
	     * @param panel The panel where the controls will be added.
	     * @param target The target of the panel
	     * @param prop The XML data that contains the information
	     *        of the combo.
	     * @return a combo panel
	     */
	    private void buildComboPanel(
	            final JPanel panel,
	            final Object target,
	            final ControlData prop) {
	
	        JComponent comp = null;
	
	        final String propertyName = prop.getPropertyName();
	        if ("namespace".equals(prop.getPropertyName())) {
	            final UMLComboBoxModel model =
	                new UMLModelElementNamespaceComboBoxModel(propertyName, target);
	            final UMLComboBox combo = new UMLSearchableComboBox(
	                    model,
	                    model.getAction(), true);
	            comp = new UMLComboBoxNavigator(
	                    Translator.localize(
	                    "label.namespace.navigate.tooltip"),
	                    combo);
	        } else if ("type".equals(prop.getPropertyName())) {
	            final UMLComboBoxModel model;
	            if (Model.getFacade().isATemplateParameter(target)) {
	                model = new UMLStructuralFeatureTypeComboBoxModel(
	                        propertyName,
	                        Model.getFacade().getParameter(target));
	            } else {
	                model = new UMLStructuralFeatureTypeComboBoxModel(
	                        propertyName,
	                        target);
	            }
	            comp = new UMLComboBox(model);
	        } else if ("base".equals(prop.getPropertyName())) {
	            if (Model.getFacade().isAAssociationRole(target)) {
	                final UMLComboBoxModel model =
	                    new UMLAssociationRoleBaseComboBoxModel(propertyName, target);
	                final UMLComboBox combo = new UMLSearchableComboBox(
	                        model,
	                        model.getAction(), true);
	                comp = new UMLComboBoxNavigator(Translator.localize(
	                        "label.association.navigate.tooltip"),
	                        combo);
	            } else {
	                //
	            }
	        } else if ("powertype".equals(prop.getPropertyName())) {
	            final UMLComboBoxModel model =
	                new UMLGeneralizationPowertypeComboBoxModel(propertyName, target);
	            final UMLComboBox combo = new UMLComboBox(
	                    model);
	            comp = combo;
	        } else if ("multiplicity".equals(prop.getPropertyName())) {
	            final UMLMultiplicityPanel mPanel = new UMLMultiplicityPanel(propertyName, target);
	            comp = mPanel;
	        } else if ("activator".equals(prop.getPropertyName())) {
	            final UMLComboBoxModel model =
	                new UMLMessageActivatorComboBoxModel(propertyName, target);
	            final JComboBox combo =
	                new UMLMessageActivatorComboBox(model, model.getAction());
	            comp = combo;
	        } else if ("operation".equals(prop.getPropertyName())) {
	            if (Model.getFacade().isACallEvent(target)) {
	                UMLComboBoxModel model =
	                    new UMLCallEventOperationComboBoxModel(propertyName, target);
	                UMLComboBox combo = new UMLComboBox(model);
	                comp = new UMLComboBoxNavigator(Translator.localize(
	                        "label.operation.navigate.tooltip"),
	                        combo);
	            } else {
	                final UMLComboBoxModel model =
	                    new UMLCallActionOperationComboBoxModel(propertyName, target);
	                UMLComboBox combo =
	                    new UMLComboBox(model);
	                comp = new UMLComboBoxNavigator(Translator.localize(
	                	"label.operation.navigate.tooltip"),
	                        combo);
	            }
	        } else if ("classifier".equals(prop.getPropertyName())) {
	            final UMLComboBoxModel model =
	                new UMLComponentInstanceClassifierComboBoxModel(propertyName, target);
	            UMLComboBox combo = new UMLComboBox(model);
	            comp = new UMLComboBoxNavigator(Translator.localize(
	                            "label.component-instance.navigate.tooltip"),
	                            combo);
	        } else if ("representedClassifier".equals(prop.getPropertyName())) {
	            final UMLComboBoxModel model =
	                new UMLCollaborationRepresentedClassifierComboBoxModel(propertyName, target);
	            UMLComboBox combo = new UMLComboBox(model);
	            comp = new UMLComboBoxNavigator(Translator.localize(
	                            "label.represented-classifier.navigate.tooltip"),
	                            combo);
	        } else if ("representedOperation".equals(prop.getPropertyName())) {
	            final UMLComboBoxModel model =
	                new UMLCollaborationRepresentedOperationComboBoxModel(propertyName, target);
	            UMLComboBox combo = new UMLComboBox(model);
	            comp = new UMLComboBoxNavigator(Translator.localize(
	                            "label.represented-operation.navigate.tooltip"),
	                    combo);
	        } else if ("context".equals(prop.getPropertyName())) {
	            final UMLComboBoxModel model;
	            if (Model.getFacade().isAActivityGraph(target)) {
	                model =
	                    new UMLActivityGraphContextComboBoxModel(propertyName, target);
	            } else {
	                model =
	                    new UMLStateMachineContextComboBoxModel(propertyName, target);
	            }
	            UMLComboBox combo = new UMLComboBox(model);
	            comp = new UMLComboBoxNavigator(Translator.localize(
	                            "label.context.navigate.tooltip"),
	                    combo);
	
	        } else if ("association".equals(prop.getPropertyName())) {
	            final UMLComboBoxModel model =
	                new UMLLinkAssociationComboBoxModel(propertyName, target);
	            comp =  new UMLComboBoxNavigator(Translator.localize(
	                        "label.association.navigate.tooltip"),
	                    new UMLSearchableComboBox(model,
	                            model.getAction(), true));
	        } else if ("participant".equals(prop.getPropertyName())) {
	            final UMLComboBoxModel model =
	                new UMLAssociationEndTypeComboBoxModel(propertyName, target);
	            comp = new UMLComboBox(model,
	                    true);
	        } else if ("submachine".equals(prop.getPropertyName())) {
	            final UMLComboBoxModel model =
	                new UMLSubmachineStateComboBoxModel(propertyName, target);
	            final UMLComboBox submachineBox = new UMLComboBox(model);
	            comp = new UMLComboBoxNavigator(Translator.localize(
	                            "tooltip.nav-submachine"), submachineBox);
	        } else if ("referenceState".equals(prop.getPropertyName())) {
	            final UMLComboBoxModel model =
	                new UMLStubStateComboBoxModel(propertyName, target);
	            final UMLComboBox referencestateBox =
	                new UMLComboBox(model);
	            comp = new UMLComboBoxNavigator(Translator.localize(
	                    "tooltip.nav-stubstate"), referencestateBox);
	        } else if ("tagType".equals(prop.getPropertyName())) {
	            UMLComboBoxModel model = new UMLMetaClassComboBoxModel(propertyName, target);
	            final UMLComboBox typeComboBox = new UMLComboBox(model);
	            comp = new UMLComboBoxNavigator(
	                   Translator.localize("label.type.navigate.tooltip"),
	                   typeComboBox);
	            // TODO: Why is this disabled always?
	            comp.setEnabled(false);
	        } else if ("parameter".equals(prop.getPropertyName())) {
	            final UMLComboBoxModel model =
	                new UMLTemplateParameterParameterComboBoxModel(target);
	            final UMLComboBox combo = new UMLComboBox(model);
	            comp = new UMLComboBoxNavigator(
	                    Translator.localize("label.type.navigate.tooltip"),
	                    combo);
	        } else if ("defaultElement".equals(prop.getPropertyName())) {
	            final UMLComboBoxModel model =
	                new UMLTemplateParameterDefaultElementComboBoxModel(propertyName, target);
	            final UMLComboBox combo = new UMLComboBox(model);
	            comp = new UMLComboBoxNavigator(
	                    Translator.localize("label.type.navigate.tooltip"),
	                    combo);
	        } else if ("signal".equals(prop.getPropertyName())) {
	            final UMLComboBoxModel model =
	                new UMLSignalComboBoxModel(propertyName, target);
	            final UMLComboBox combo = new UMLComboBox(model);
	            comp = new UMLComboBoxNavigator(
	                    Translator.localize("label.type.navigate.tooltip"),
	                    combo);
	        } else if ("trigger".equals(prop.getPropertyName())) {
	            final UMLComboBoxModel model =
	                new UMLTransitionTriggerComboBoxModel(propertyName, target);
	            final UMLComboBox combo = new UMLComboBox(model);
	            comp = new UMLComboBoxNavigator(
	                    Translator.localize("label.type.navigate.tooltip"),
	                    combo);
	        } else if ("specification".equals(prop.getPropertyName())) {
	            final UMLComboBoxModel model =
	                new UMLMethodSpecificationComboBoxModel(propertyName, target);
	            final UMLComboBox combo = new UMLComboBox(model);
	            comp = new UMLComboBoxNavigator(
	                    Translator.localize("label.type.navigate.tooltip"),
	                    combo);
	        }
	
	        if (comp != null) {
	            addControl(panel, Translator.localize(prop.getLabel()),
	            		comp, target);
	        }
	    }
	
	    /**
	     * @param panel a panel with a labelled text field
	     * @param target The target of the panel
	     * @param prop The XML data that contains the information
	     *        of the options.
	     */
	    private void buildTextboxPanel(JPanel panel, Object target,
	            ControlData prop) {
	
	        UMLPlainTextDocument document = null;
	        if ("name".equals(prop.getPropertyName())) {
	            if (Model.getFacade().isATemplateParameter(target)) {
	                target = Model.getFacade().getParameter(target);
	            }
	            document = new UMLModelElementNameDocument(
	        	    prop.getPropertyName(), target);
	        } else if ("discriminator".equals(prop.getPropertyName())) {
	            document = new UMLDiscriminatorNameDocument(
	        	    prop.getPropertyName(), target);
	        } else if ("location".equals(prop.getPropertyName())) {
	            document = new UMLExtensionPointLocationDocument(
	        	    prop.getPropertyName(), target);
	        } else if ("bound".equals(prop.getPropertyName())) {
	            document =new UMLSynchStateBoundDocument(
	        	    prop.getPropertyName(), target);
	        }
	
	        if (document != null) {
	            JTextField tfield = new UMLTextField(document);
	            addControl(panel, Translator.localize(prop.getLabel()),
	            		tfield, target);
	        }
	    }
	
	    private void addControl(
	    		final JPanel panel,
	    		final String text,
	    		final JComponent component,
	    		final Object target) {
	    	if (Model.getModelManagementHelper().isReadOnly(target)) {
	    		component.setEnabled(false);
	    	}
	
	        LabelledComponent lc = new LabelledComponent(text, component);
	        panel.add(lc);
	    }
	}
		
",
	role:"
	user	
",
,
	content:"
	//src/argouml-core-model/src/org/argouml/model/ModelEventPump.java
	/* $Id$
	 *******************************************************************************
	 * Copyright (c) 2009 Contributors - see below
	 * All rights reserved. This program and the accompanying materials
	 * are made available under the terms of the Eclipse Public License v1.0
	 * which accompanies this distribution, and is available at
	 * http://www.eclipse.org/legal/epl-v10.html
	 *
	 * Contributors:
	 *    tfmorris
	 *******************************************************************************
	 *
	 * Some portions of this file was previously release using the BSD License:
	 */
	
	// Copyright (c) 2004-2007 The Regents of the University of California. All
	// Rights Reserved. Permission to use, copy, modify, and distribute this
	// software and its documentation without fee, and without a written
	// agreement is hereby granted, provided that the above copyright notice
	// and this paragraph appear in all copies.  This software program and
	// documentation are copyrighted by The Regents of the University of
	// California. The software program and documentation are supplied "AS
	// IS", without any accompanying services from The Regents. The Regents
	// does not warrant that the operation of the program will be
	// uninterrupted or error-free. The end-user understands that the program
	// was developed for research purposes and is advised not to rely
	// exclusively on the program for any reason.  IN NO EVENT SHALL THE
	// UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
	// SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
	// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
	// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
	// SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
	// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
	// PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
	// CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
	// UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
	
	package org.argouml.model;
	
	import java.beans.PropertyChangeListener;
	import java.util.List;
	
	
	/**
	 * This is the interface for registering interest in events sent from
	 * the model component.<p>
	 *
	 * Neither the registration or unregistration, nor the events themselves
	 * contain any reference to the model implementation.  Instead they
	 * use the {@link java.beans.PropertyChangeListener},
	 * {@link java.beans.PropertyChangeEvent} to
	 * deliver events.<p>
	 *
	 * The reference to the listener is a WeakReference so you don't need to
	 * call removeWHATEVERListener, you can just forget about your listener
	 * and it is eventually finalized and removed. This also means that you
	 * will have to keep a reference to your listener while it is active.
	 * Since the garbage collecting mechanism is not really deterministic
	 * a forgotten about listener might still receive events. Unless it can
	 * handle them in a harmless way, this approach should not be used.
	 *
	 * TODO: (Is this still true or does it refer to the NSUML
	 * implementation? - tfm 20051109)
	 * (This is part of the contract that is established between the Model
	 * subsystem and its users. If that is not fulfilled by the current
	 * implementation, then the current implementation is incorrect.
	 * Linus 20060411).<p>
	 *
	 * TODO: What event names?
	 * The event names generated are {@link String}s and their values and
	 * meanings are not really well documented. In general they are the
	 * name of an an association end or attribute in the UML metamodel.<p>
	 *
	 * Here are some highlights:<ul>
	 * <li>"remove" - event sent when the element is removed.
	 * </ul>
	 *
	 * @author Linus Tolke
	 */
	public interface ModelEventPump {
	    // Operations that work on elements:
	
	    /**
	     * Adds a listener to modelevents that are fired by some given modelelement
	     * and that have any of the names in eventNames.<p>
	     *
	     * @param listener The listener to add
	     * @param modelelement The modelelement the listener should be added too
	     * @param propertyNames The array of property names the listener wishes to
	     * receive events for
	     */
	    void addModelEventListener(UmlChangeListener listener,
	                               Object modelelement,
	                               String[] propertyNames);
	
	    /**
	     * Adds a listener to modelevents that are fired by some given modelelement
	     * and that have the name in eventName.<p>
	     *
	     * @param listener The listener to add
	     * @param modelelement The modelelement the listener should be added too
	     * @param propertyName The property name the listener wishes to
	     * receive events for
	     */
	    void addModelEventListener(UmlChangeListener listener,
	                               Object modelelement,
	                               String propertyName);
	
	    /**
	     * Adds a listener to modelevents that are fired by some given modelelement
	     * and that have any of the names in eventNames.<p>
	     *
	     * @param listener The listener to add
	     * @param modelelement The modelelement the listener should be added too
	     * @param propertyNames The array of property names the listener wishes to
	     * receive events for
	     */
	    void addModelEventListener(PropertyChangeListener listener,
	            		       Object modelelement,
				       String[] propertyNames);
	
	    /**
	     * Adds a listener to modelevents that are fired by some given modelelement
	     * and that have the name in eventName.<p>
	     *
	     * @param listener The listener to add
	     * @param modelelement The modelelement the listener should be added too
	     * @param propertyName The property name the listener wishes to
	     * receive events for
	     */
	    void addModelEventListener(PropertyChangeListener listener,
				       Object modelelement,
				       String propertyName);
	
	    /**
	     * Adds a listener to all events fired by some modelelement.
	     *
	     * @param listener is the listener to add
	     * @param modelelement is the model element
	     */
	    void addModelEventListener(PropertyChangeListener listener,
	            		       Object modelelement);
	
	    /**
	     * Removes a listener that listens to modelevents with name
	     * eventNames that are fired by the given modelelement.<p>
	     *
	     * @param listener The listener to remove
	     * @param modelelement The modelelement that fires the events the
	     * listener is listening to.
	     * @param propertyNames The property names the listener no longer wishes to
	     * receive events for
	     */
	    void removeModelEventListener(UmlChangeListener listener,
	                                  Object modelelement,
	                                  String[] propertyNames);
	
	    /**
	     * Removes a listener that listens to modelevents with name
	     * eventName that are fired by the given modelelement.<p>
	     *
	     * @param listener The listener to remove.
	     * @param modelelement The modelelement that fires the events the
	     * listener is listening to.
	     * @param propertyName The property name the listener no longer wishes to
	     * receive events for
	     */
	    void removeModelEventListener(UmlChangeListener listener,
	                                  Object modelelement,
	                                  String propertyName);
	
	    /**
	     * Removes a listener that listens to modelevents with name
	     * eventNames that are fired by the given modelelement.<p>
	     *
	     * @param listener The listener to remove
	     * @param modelelement The modelelement that fires the events the
	     * listener is listening to.
	     * @param propertyNames The property names the listener no longer wishes to
	     * receive events for
	     */
	    void removeModelEventListener(PropertyChangeListener listener,
					  Object modelelement,
					  String[] propertyNames);
	
	    /**
	     * Removes a listener that listens to modelevents with name
	     * eventName that are fired by the given modelelement.<p>
	     *
	     * @param listener The listener to remove.
	     * @param modelelement The modelelement that fires the events the
	     * listener is listening to.
	     * @param propertyName The property name the listener no longer wishes to
	     * receive events for
	     */
	    void removeModelEventListener(PropertyChangeListener listener,
					  Object modelelement,
					  String propertyName);
	
	    /**
	     * Removes a listener that listens to all events fired by the
	     * given modelelement.<p>
	     *
	     * @param listener is the listener
	     * @param modelelement is the model element
	     */
	    void removeModelEventListener(PropertyChangeListener listener,
					  Object modelelement);
	
	    // Operations that work on classes of objects:
	
	    /**
	     * Adds a listener that listens to all events that are named eventNames and
	     * that occur to instances of the given modelClass.
	     * <p>
	     * 
	     * @param listener
	     *            is the listener to add.
	     * @param modelClass
	     *            is the given model class
	     * @param propertyNames
	     *            The property names the listener wishes to receive events for.
	     *            If null or an empty array, all events will be returned.
	     * @throws IllegalArgumentException
	     *             if one of the arguments is null or if the modelClass is not a
	     *             valid metamodel class.
	     * @throws IllegalStateException
	     *             if the listener is already registred.
	     */
	    void addClassModelEventListener(PropertyChangeListener listener,
					    Object modelClass,
					    String[] propertyNames);
	
	    /**
	     * Adds a listener that listens to the event that is named eventName and
	     * that occur to instances of the given modelClass.  If you want to be 
	     * notified of changes on all properties, use 
	     * {@link #addClassModelEventListener(PropertyChangeListener, Object, String[])}
	     * with a null third argument.
	     * <p>
	     * 
	     * @param listener
	     *            is the listener to add.
	     * @param modelClass
	     *            is the given model class
	     * @param propertyName
	     *            The property name the listener wishes to receive events for.
	     * @throws IllegalArgumentException
	     *             if one of the arguments is null or if the modelClass is not a
	     *             valid metamodel class.
	     * @throws IllegalStateException
	     *             if the listener is already registered.
	     */
	    void addClassModelEventListener(PropertyChangeListener listener,
					    Object modelClass,
					    String propertyName);
	
	    /**
	     * Removes a listener that listens to all modelevents fired by instances of
	     * modelClass and that have the original name eventNames.
	     *
	     * @param listener The listener to remove
	     * @param modelClass The class the listener does not want to listen to
	     * instances anymore
	     * @param propertyNames The property names the listener no longer wishes to
	     * receive events for
	     */
	    void removeClassModelEventListener(PropertyChangeListener listener,
					       Object modelClass,
					       String[] propertyNames);
	
	    /**
	     * Removes a listener that listens to all modelevents fired by instances of
	     * modelClass and that have the name eventName.
	     *
	     * @param listener The listener to remove
	     * @param modelClass The class the listener does not want to listen to
	     * instances anymore.
	     * @param propertyName The property name the listener no longer wishes to
	     * receive events for
	     */
	    void removeClassModelEventListener(PropertyChangeListener listener,
					       Object modelClass,
					       String propertyName);
	
	    /**
	     * Start the ModelEventPump firing events.
	     */
	    void startPumpingEvents();
	
	    /**
	     * Stop the ModelEventPump firing events.
	     */
	    void stopPumpingEvents();
	
	    /**
	     * Flush events from the ModelEventPump. Blocks until all events have been
	     * delivered.
	     * <p>
	     * <em>NOTE: </em> This may not be called from a 
	     * {@link PropertyChangeListener#propertyChange(java.beans.PropertyChangeEvent)}
	     * method which has been invoked by the ModelEventPump.
	     */
	    void flushModelEvents();
	    
	    /**
	     * Get debug info for the event pump. Information returned is implementation
	     * specific. List returned contains either Strings or Lists. Lists may be
	     * nested arbitrarily deeply forming a tree of information. If a node
	     * contains children, the first entry in the list is expected to be a String
	     * with subsequent entries representing children.
	     * 
	     * @return List of Strings or other Lists.
	     */
	    @SuppressWarnings("unchecked")
	    public List getDebugInfo();
	}
		
",
	role:"
	user	
",
,
	content:"
	//src/argouml-core-model/src/org/argouml/model/ExtensionMechanismsHelper.java
	/* $Id$
	 *******************************************************************************
	 * Copyright (c) 2009 Contributors - see below
	 * All rights reserved. This program and the accompanying materials
	 * are made available under the terms of the Eclipse Public License v1.0
	 * which accompanies this distribution, and is available at
	 * http://www.eclipse.org/legal/epl-v10.html
	 *
	 * Contributors:
	 *    Thomas Neustupny
	 *******************************************************************************
	 *
	 * Some portions of this file was previously release using the BSD License:
	 */
	
	// Copyright (c) 2005-2008 The Regents of the University of California. All
	// Rights Reserved. Permission to use, copy, modify, and distribute this
	// software and its documentation without fee, and without a written
	// agreement is hereby granted, provided that the above copyright notice
	// and this paragraph appear in all copies. This software program and
	// documentation are copyrighted by The Regents of the University of
	// California. The software program and documentation are supplied "AS
	// IS", without any accompanying services from The Regents. The Regents
	// does not warrant that the operation of the program will be
	// uninterrupted or error-free. The end-user understands that the program
	// was developed for research purposes and is advised not to rely
	// exclusively on the program for any reason. IN NO EVENT SHALL THE
	// UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
	// SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
	// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
	// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
	// SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
	// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
	// PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
	// CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
	// UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
	
	package org.argouml.model;
	
	import java.util.Collection;
	
	
	/**
	 * The interface for the helper of the ExtensionMechanisms.
	 */
	public interface ExtensionMechanismsHelper {
	    /**
	     * Returns all stereotypes in a given namespace, 
	     * and all those in any sub-namespace of the given namespace.
	     *
	     * @param ns is the namespace.
	     * @return a Collection with the stereotypes.
	     */
	    Collection getStereotypes(Object ns);
	
	    /**
	     * Finds a stereotype in a given namespace, 
	     * and all those in any sub-namespace of the given namespace.
	     * Returns null if no such stereotype is found.
	     * <p>
	     * TODO: What if stereo.getName() or stereo.getBaseClass() is null?
	     * Then you know immediately that none will be found, but is that the
	     * correct answer?
	     * Currently, null is returned in these cases. <p>
	     * 
	     * TODO: This function should not take a stereotype object as parameter,
	     * but a name and a baseclass. <p>
	     * TODO: Currently only works for stereotypes with only one baseclass. <p>
	     * TODO: Currently only works for stereotypes where the baseclass is 
	     * equal to the given one - inheritance does not work.
	     * 
	     * @return the stereotype found or null.
	     * @param ns is the namespace.
	     * @param stereo is the stereotype.
	     */
	    Object getStereotype(Object ns, Object stereo);
	
	    /**
	     * Searches for a stereotype just like the given stereotype in all
	     * given models (and their sub-namespaces).
	     * The given stereotype can not have its namespace set yet;
	     * otherwise it will be returned itself!
	     *
	     * TODO: This function should not take a stereotype object as parameter,
	     * but a name and a baseclass. <p>
	     * TODO: Currently only works for stereotypes with only one baseclass. <p>
	     * TODO: Should it only search for stereotypes owned by the Model object? 
	     *
	     * @param models a collection of models
	     * @param stereo is the given stereotype
	     * @return Stereotype
	     */
	    Object getStereotype(Collection models, Object stereo);
	
	    /**
	     * @param m the ModelElement
	     * @return the name of the metatype (i.e UML type) of this Element
	     * @deprecated for 0.27.3 by tfmorris. Use {@link MetaTypes#getName(Object)}
	     */
	    @Deprecated
	    String getMetaModelName(Object m);
	
	    /**
	     * Returns all possible stereotypes for some
	     * modelelement. Possible stereotypes are those stereotypes that
	     * are owned by the same namespace the modelelement is owned by
	     * and that have a baseclass that is the same as the
	     * metamodelelement name of the modelelement.
	     *
	     * @param modelElement is the model element
	     * @param models the models to search in
	     * @return Collection
	     */
	    Collection getAllPossibleStereotypes(Collection models,
	            				 Object modelElement);
	
	
	    /**
	     * Returns <code>true</code> if the given stereotype has a baseclass that
	     * equals the baseclass of the given ModelElement or one of the superclasses
	     * of the given ModelElement.
	     * 
	     * @param theModelElement
	     *                is the model element
	     * @param theStereotype
	     *                is the stereotype
	     * @return boolean
	     */
	    boolean isValidStereotype(Object theModelElement, Object theStereotype);
	
	    /**
	     * Get all stereotypes from all Models in the list. <p>
	     *
	     * Finds also all stereotypes owned by any sub-namespaces of the Model.
	     * 
	     * @return the collection of stereotypes in all models
	     *         in the current project
	     * @param models the models to search
	     */
	    Collection getStereotypes(Collection models);
	
	    /**
	     * Get commonly used tagged value types. <p>
	     * While in early UML 1.x versions only String was provided, in UML 2.x
	     * tagged values are stereotype properties with any possible type. However
	     * even in UML 2.x only primitive types are used in most cases. The client
	     * of the model subsystem should be able to handle at least the returned
	     * types, but is still free to provide support for any type.
	     * 
	     * @return a collection of types
	     */
	    Collection getCommonTaggedValueTypes();
	
	    /**
	     * Sets the stereotype of some modelelement. The method also
	     * copies a stereotype that is not a part of the current model to
	     * the current model.<p>
	     *
	     * @param modelElement is the model element
	     * @param stereotype is the stereotype
	     */
	    void addCopyStereotype(Object modelElement, Object stereotype);
	
	    /**
	     * Tests if a stereotype has a given name and given base class.
	     * While comparing the baseclass, inheritance is not considered.
	     *
	     * @param object is the stereotype.
	     * @param name is the name of the stereotype.
	     * @param base is a string representing the base class of the stereotype.
	     * @return true if object is a stereotype with the desired characteristics.
	     */
	    boolean isStereotype(Object object, String name, String base);
	
	    /**
	     * Tests if a stereotype is or inherits from a stereotype with some
	     * name and base class.
	     *
	     * @param object is the stereotype.
	     * @param name is the name of the stereotype.
	     * @param base is the base class of the stereotype.
	     * @return true if object is a (descendant of a) stereotype with the
	     *	desired characteristics.
	     */
	    boolean isStereotypeInh(Object object, String name, String base);
	
	    /**
	     * Add an extended element to a stereotype.
	     *
	     * @param handle Stereotype
	     * @param extendedElement ExtensionPoint
	     */
	    void addExtendedElement(Object handle, Object extendedElement);
	
	    /**
	     * Add a baseclass to some stereotype.
	     *
	     * @param handle the stereotype
	     * @param baseClass the baseclass to add
	     */
	    void addBaseClass(Object handle, Object baseClass);
	
	    /**
	     * Remove baseclass from some stereotype.
	     *
	     * @param handle the stereotype
	     * @param baseClass the baseclass to remove
	     */
	    void removeBaseClass(Object handle, Object baseClass);
	
	    /**
	     * Set the icon for a stereotype.
	     *
	     * @param handle Stereotype
	     * @param icon String
	     */
	    void setIcon(Object handle, Object icon);
	
	
	    /**
	     * Set the tagType of a TaggedDefinition.  This controls the range of legal
	     * values for the associated TaggedValues.  
	     * 
	     * @param handle the taggedValue
	     * @param tagType A string containing the name of the type for values that
	     *                may be assigned to this tag. This can either be the name
	     *                of a datatype (e.g. "String", "Integer" or "Boolean") or
	     *                the name of a metaclass for more complex types of tagged
	     *                values.
	     */
	    void setTagType(Object handle, String tagType);
	    
	    /**
	     * Set the type of a taggedvalue.
	     * 
	     * @param handle the taggedValue
	     * @param type the tagDefinition
	     */
	    void setType(Object handle, Object type);
	
	    /**
	     * Sets the dataValues of the given TaggedValue to a single String value.
	     * Provided for backward compatibility with UML 1.3. new uses should use
	     * setDataValues.
	     * 
	     * @param handle
	     *                is the tagged value
	     * @param value
	     *                is the value
	     * @deprecated for 0.25.5 by tfmorris. Use
	     *             {@link #setDataValues(Object, String[])}.
	     */
	    @Deprecated
	    void setValueOfTag(Object handle, String value);
	
	    /**
	     * Sets the dataValues of the given TaggedValue. UML1 only.
	     *
	     * @param handle is the tagged value
	     * @param values an array of String values
	     */
	    void setDataValues(Object handle, String[] values);
	    
	    //additional support for tagged values
	
	    /**
	     * Add a tagged value.
	     *
	     * @param handle The model element to add to.
	     * @param taggedValue The tagged value to add.
	     */
	    void addTaggedValue(Object handle, Object taggedValue);
	
	    /**
	     * Apply a profile to a model or another profile.
	     * 
	     * @param handle The model or profile.
	     * @param profile The to be applied profile.
	     */
	    public void applyProfile(Object handle, Object profile);
	
	    /**
	     * Remove a tagged value.
	     *
	     * @param handle The model element to remove from.
	     * @param taggedValue The tagged value to remove.
	     */
	    void removeTaggedValue(Object handle, Object taggedValue);
	
	    /**
	     * Set the list of tagged values for a model element. UML1 only.
	     *
	     * @param handle The model element to set for.
	     * @param taggedValues A Collection of tagged values.
	     */
	    void setTaggedValue(Object handle, Collection taggedValues);
	
	    /**
	     * Set tagged value (bound to a stereotype) for a model element.
	     * The value might be an List, depending on the multiplicity of the
	     * property.
	     *
	     * @param handle The model element to set for.
	     * @param property The property of the applied stereotype.
	     * @param value Single value or a List value to set to.
	     */
	    void setTaggedValue(Object handle, Object property, Object value);
	
	    /**
	     * Unapply a profile to a model or another profile.
	     * 
	     * @param handle The model or profile.
	     * @param profile The to be unapplied profile.
	     */
	    public void unapplyProfile(Object handle, Object profile);
	
	    /**
	     * Returns <code>true</code> if the given ModelElement has a Stereotype
	     * with the given name.
	     * 
	     * @param element the given ModelElement
	     * @param name the given name
	     * @return true if there is such a stereotype
	     */
	    boolean hasStereotype(Object element, String name);
	
	    /**
	     * Make a profile applicable. Usually a profile edited in a UML design
	     * environment like ArgoUML is not directly applicable, but needs to be
	     * shifted to the metamodel level, so that it can serve as an extension
	     * to the UML metamodel.
	     * 
	     * @param handle the profile before made applicable to a model
	     * @return the profile made applicable to a model
	     */
	    Object makeProfileApplicable(Object handle);
	}
		
",
	role:"
	user	
",
,
	content:"
	//src/argouml-core-model/src/org/argouml/model/AbstractExtensionMechanismsHelperDecorator.java
	/* $Id$
	 *******************************************************************************
	 * Copyright (c) 2009 Contributors - see below
	 * All rights reserved. This program and the accompanying materials
	 * are made available under the terms of the Eclipse Public License v1.0
	 * which accompanies this distribution, and is available at
	 * http://www.eclipse.org/legal/epl-v10.html
	 *
	 * Contributors:
	 *    Thomas Neustupny
	 *******************************************************************************
	 *
	 * Some portions of this file was previously release using the BSD License:
	 */
	
	// Copyright (c) 1996-2007 The Regents of the University of California. All
	// Rights Reserved. Permission to use, copy, modify, and distribute this
	// software and its documentation without fee, and without a written
	// agreement is hereby granted, provided that the above copyright notice
	// and this paragraph appear in all copies. This software program and
	// documentation are copyrighted by The Regents of the University of
	// California. The software program and documentation are supplied "AS
	// IS", without any accompanying services from The Regents. The Regents
	// does not warrant that the operation of the program will be
	// uninterrupted or error-free. The end-user understands that the program
	// was developed for research purposes and is advised not to rely
	// exclusively on the program for any reason. IN NO EVENT SHALL THE
	// UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
	// SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
	// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
	// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
	// SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
	// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
	// PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
	// CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
	// UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
	
	package org.argouml.model;
	
	import java.util.Collection;
	
	/**
	 * An abstract Decorator for the {@link ExtensionMechanismsHelper}.
	 *
	 * @author Bob Tarling
	 */
	public abstract class AbstractExtensionMechanismsHelperDecorator
		implements ExtensionMechanismsHelper {
	
	    /**
	     * The component.
	     */
	    private ExtensionMechanismsHelper impl;
	
	    /**
	     * @param component The component to decorate.
	     */
	    protected AbstractExtensionMechanismsHelperDecorator(
	            ExtensionMechanismsHelper component) {
	        impl = component;
	    }
	
	    /**
	     * The component we are decorating.
	     *
	     * @return Returns the component.
	     */
	    protected ExtensionMechanismsHelper getComponent() {
	        return impl;
	    }
	
	    /*
	     * @see org.argouml.model.ExtensionMechanismsHelper#getStereotypes(java.lang.Object)
	     */
	    public Collection getStereotypes(Object ns) {
	        return impl.getStereotypes(ns);
	    }
	
	    public Object getStereotype(Object ns, Object stereo) {
	        return impl.getStereotype(ns, stereo);
	    }
	
	    public Object getStereotype(Collection models, Object stereo) {
	        return impl.getStereotype(models, stereo);
	    }
	
	    public String getMetaModelName(Object m) {
	        return impl.getMetaModelName(m);
	    }
	
	    public Collection getAllPossibleStereotypes(Collection models,
	            Object modelElement) {
	        return impl.getAllPossibleStereotypes(models, modelElement);
	    }
	
	
	    public boolean isValidStereotype(Object theModelElement,
	            Object theStereotype) {
	        return impl.isValidStereotype(theModelElement, theStereotype);
	    }
	
	    public Collection getStereotypes(Collection models) {
	        return impl.getStereotypes(models);
	    }
	
	    public Collection getCommonTaggedValueTypes() {
	        return impl.getCommonTaggedValueTypes();
	    }
	
	    public void addCopyStereotype(Object modelElement, Object stereotype) {
	        impl.addCopyStereotype(modelElement, stereotype);
	    }
	
	    public boolean isStereotype(Object object, String name, String base) {
	        return impl.isStereotype(object, name, base);
	    }
	
	    public boolean isStereotypeInh(Object object, String name, String base) {
	        return impl.isStereotypeInh(object, name, base);
	    }
	
	    public void addExtendedElement(Object handle, Object extendedElement) {
	        impl.addExtendedElement(handle, extendedElement);
	    }
	
	    public void addBaseClass(Object handle, Object baseClass) {
	        impl.addBaseClass(handle, baseClass);
	    }
	
	    public void removeBaseClass(Object handle, Object baseClass) {
	        impl.removeBaseClass(handle, baseClass);
	    }
	
	    public void setIcon(Object handle, Object icon) {
	        impl.setIcon(handle, icon);
	    }
	
	    public void setTagType(Object handle, String tagType) {
	        impl.setType(handle, tagType);
	    }
	    
	    public void setType(Object handle, Object type) {
	        impl.setType(handle, type);
	    }
	
	    @Deprecated
	    public void setValueOfTag(Object handle, String value) {
	        impl.setValueOfTag(handle, value);
	    }
	
	    public void setDataValues(Object handle, String[] values) {
	        impl.setDataValues(handle, values);
	    }
	    
	    public void addTaggedValue(Object handle, Object taggedValue) {
	        impl.addTaggedValue(handle, taggedValue);
	    }
	
	    public void removeTaggedValue(Object handle, Object taggedValue) {
	        impl.removeTaggedValue(handle, taggedValue);
	    }
	
	    public void setTaggedValue(Object handle, Collection taggedValues) {
	        impl.setTaggedValue(handle, taggedValues);
	    }
	
	    public void setTaggedValue(Object handle, Object property, Object value) {
	        impl.setTaggedValue(handle, property, value);
	    }
	
	    public boolean hasStereotype(Object handle, String name) {
	        return impl.hasStereotype(handle, name);
	    }
	    
	    public Object makeProfileApplicable(Object handle) {
	        return impl.makeProfileApplicable(handle);
	    }
	
	    public void applyProfile(Object handle, Object profile) {
	        impl.applyProfile(handle, profile);
	    }
	
	    public void unapplyProfile(Object handle, Object profile) {
	        impl.unapplyProfile(handle, profile);
	    }
	}
		
",
	role:"
	user	
",
,
	content:"
	//src/argouml-app/src/org/argouml/uml/diagram/collaboration/ui/CollabDiagramRenderer.java
	/* $Id$
	 *****************************************************************************
	 * Copyright (c) 2009-2012 Contributors - see below
	 * All rights reserved. This program and the accompanying materials
	 * are made available under the terms of the Eclipse Public License v1.0
	 * which accompanies this distribution, and is available at
	 * http://www.eclipse.org/legal/epl-v10.html
	 *
	 * Contributors:
	 *    Bob Tarling
	 *****************************************************************************
	 *
	 * Some portions of this file was previously release using the BSD License:
	 */
	
	// Copyright (c) 1996-2008 The Regents of the University of California. All
	// Rights Reserved. Permission to use, copy, modify, and distribute this
	// software and its documentation without fee, and without a written
	// agreement is hereby granted, provided that the above copyright notice
	// and this paragraph appear in all copies.  This software program and
	// documentation are copyrighted by The Regents of the University of
	// California. The software program and documentation are supplied "AS
	// IS", without any accompanying services from The Regents. The Regents
	// does not warrant that the operation of the program will be
	// uninterrupted or error-free. The end-user understands that the program
	// was developed for research purposes and is advised not to rely
	// exclusively on the program for any reason.  IN NO EVENT SHALL THE
	// UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
	// SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
	// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
	// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
	// SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
	// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
	// PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
	// CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
	// UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
	
	package org.argouml.uml.diagram.collaboration.ui;
	
	import java.util.Map;
	import java.util.logging.Level;
	import java.util.logging.Logger;
	
	import org.argouml.model.Model;
	import org.argouml.uml.CommentEdge;
	import org.argouml.uml.diagram.ArgoDiagram;
	import org.argouml.uml.diagram.DiagramEdgeSettings;
	import org.argouml.uml.diagram.DiagramSettings;
	import org.argouml.uml.diagram.UmlDiagramRenderer;
	import org.argouml.uml.diagram.static_structure.ui.FigEdgeNote;
	import org.argouml.uml.diagram.ui.FigDependency;
	import org.argouml.uml.diagram.ui.FigGeneralization;
	import org.argouml.uml.diagram.ui.UMLDiagram;
	import org.tigris.gef.base.Diagram;
	import org.tigris.gef.base.Layer;
	import org.tigris.gef.base.LayerPerspective;
	import org.tigris.gef.graph.GraphModel;
	import org.tigris.gef.presentation.FigEdge;
	import org.tigris.gef.presentation.FigNode;
	
	/**
	 * This class defines a renderer object for UML Collaboration Diagrams.
	 * In a collaboration Diagram the following UML objects are displayed with the
	 * following Figs:<p>
	 *
	 * <pre>
	 *   UML Object       ---  Fig
	 *   ---------------------------------------
	 *   MClassifierRole  ---  FigClassifierRole
	 *   MMessage         ---  FigMessage
	 *   MComment         ---  FigComment
	 * </pre>
	 *
	 * Provides {@link #getFigNodeFor} to implement the
	 * {@link org.tigris.gef.graph.GraphNodeRenderer} interface and
	 * {@link #getFigEdgeFor} to implement the
	 * {@link org.tigris.gef.graph.GraphEdgeRenderer} interface.<p>
	 *
	 * <em>Note</em>. Should be implemented as a singleton - we don't really
	 * need a separate instance for each use case diagram.<p>
	 *
	 *
	 * @author agauthie
	 */
	public class CollabDiagramRenderer extends UmlDiagramRenderer {
	    /**
	     * Logger.
	     */
	    private static final Logger LOG =
	        Logger.getLogger(CollabDiagramRenderer.class.getName());
	
	    /*
	     * @see org.tigris.gef.graph.GraphNodeRenderer#getFigNodeFor(
	     *         org.tigris.gef.graph.GraphModel, org.tigris.gef.base.Layer,
	     *         java.lang.Object, java.util.Map)
	     */
	    public FigNode getFigNodeFor(GraphModel gm, Layer lay,
					 Object node, Map styleAttributes) {
	
	        FigNode figNode = null;
	
	        assert node != null;
	
	        // Although not generally true for GEF, for Argo we know that the layer
	        // is a LayerPerspective which knows the associated diagram
	        Diagram diag = ((LayerPerspective) lay).getDiagram();
	        if (diag instanceof UMLDiagram
	                && ((UMLDiagram) diag).doesAccept(node)) {
	            figNode = (FigNode) ((UMLDiagram) diag).drop(node, null);
	        } else {
	            LOG.log(Level.SEVERE, "TODO: CollabDiagramRenderer getFigNodeFor");
	            throw new IllegalArgumentException(
	                    "Node is not a recognised type. Received "
	                    + node.getClass().getName());
	        }
	
	        lay.add(figNode);
	        return figNode;
	    }
	
	    /**
	     * Return a Fig that can be used to represent the given edge,
	     * Generally the same code as for the ClassDiagram, since its
	     * very related to it.
	     *
	     * {@inheritDoc}
	     */
	    public FigEdge getFigEdgeFor(GraphModel gm, Layer lay,
					 Object edge, Map styleAttributes) {
	        LOG.log(Level.FINE, "making figedge for {0}", edge);
	
	        if (edge == null) {
	            throw new IllegalArgumentException("A model edge must be supplied");
	        }
	
	        assert lay instanceof LayerPerspective;
	        ArgoDiagram diag = (ArgoDiagram) ((LayerPerspective) lay).getDiagram();
	        DiagramSettings settings = diag.getDiagramSettings();
	
	        FigEdge newEdge = null;
	        if (Model.getFacade().isAAssociationRole(edge)
	                || Model.getFacade().isAConnector(edge)) {
	            Object[] associationEnds =
	                Model.getFacade().getConnections(edge).toArray();
	            newEdge = new FigAssociationRole(
	                    new DiagramEdgeSettings(
	                            edge,
	                            associationEnds[0],
	                            associationEnds[1]),
	                            settings);
	            FigNode sourceFig =
	                getFigNodeForAssociationEnd(diag, associationEnds[0]);
	            FigNode destFig =
	                getFigNodeForAssociationEnd(diag, associationEnds[1]);
	            newEdge.setSourceFigNode(sourceFig);
	            newEdge.setSourcePortFig(sourceFig);
	            newEdge.setDestFigNode(destFig);
	            newEdge.setDestPortFig(destFig);
	        } else if (Model.getFacade().isAGeneralization(edge)) {
	            newEdge = new FigGeneralization(edge, settings);
	        } else if (Model.getFacade().isADependency(edge)) {
	            newEdge = new FigDependency(edge , settings);
	        } else if (edge instanceof CommentEdge) {
	            newEdge = new FigEdgeNote(edge, settings); // TODO -> settings
	        }
	
	        addEdge(lay, newEdge, edge);
	        return newEdge;
	    }
	
	    protected FigNode getFigNodeForAssociationEnd(
	            final ArgoDiagram diagram,
	            final Object associationEnd) {
	        final Object element;
	        if (Model.getFacade().getUmlVersion().startsWith("1")) {
	            element =
	                Model.getFacade().getClassifier(associationEnd);
	        } else {
	            element =
	                Model.getFacade().getLifeline(associationEnd);
	        }
	        return getNodePresentationFor(diagram.getLayer(), element);
	    }
	}
		
",
	role:"
	user	
",
,
	content:"
	//src/argouml-core-model/src/org/argouml/model/CollaborationsFactory.java
	/* $Id$
	 *******************************************************************************
	 * Copyright (c) 2009 Contributors - see below
	 * All rights reserved. This program and the accompanying materials
	 * are made available under the terms of the Eclipse Public License v1.0
	 * which accompanies this distribution, and is available at
	 * http://www.eclipse.org/legal/epl-v10.html
	 *
	 * Contributors:
	 *    tfmorris
	 *******************************************************************************
	 *
	 * Some portions of this file was previously release using the BSD License:
	 */
	
	// Copyright (c) 2005-2006 The Regents of the University of California. All
	// Rights Reserved. Permission to use, copy, modify, and distribute this
	// software and its documentation without fee, and without a written
	// agreement is hereby granted, provided that the above copyright notice
	// and this paragraph appear in all copies. This software program and
	// documentation are copyrighted by The Regents of the University of
	// California. The software program and documentation are supplied "AS
	// IS", without any accompanying services from The Regents. The Regents
	// does not warrant that the operation of the program will be
	// uninterrupted or error-free. The end-user understands that the program
	// was developed for research purposes and is advised not to rely
	// exclusively on the program for any reason. IN NO EVENT SHALL THE
	// UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
	// SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
	// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
	// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
	// SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
	// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
	// PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
	// CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
	// UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
	
	package org.argouml.model;
	
	/**
	 * The interface for the factory of Collaboration.
	 */
	public interface CollaborationsFactory extends Factory {
	    /**
	     * Create an empty but initialized instance of a UML AssociationEndRole.
	     *
	     * @return an initialized UML AssociationEndRole instance.
	     */
	    Object createAssociationEndRole();
	
	    /**
	     * Create an empty but initialized instance of a UML AssociationRole.
	     *
	     * @return an initialized UML AssociationRole instance.
	     */
	    Object createAssociationRole();
	
	    /**
	     * Create an empty but initialized instance of a UML ClassifierRole.
	     *
	     * @return an initialized UML ClassifierRole instance.
	     */
	    Object createClassifierRole();
	
	    /**
	     * Create an empty but initialized instance of a UML ClassifierRole.
	     *
	     * @return an initialized UML ClassifierRole instance.
	     */
	    Object createLifeline();
	    
	    /**
	     * Create an empty but initialized instance of a UML Collaboration.
	     *
	     * @return an initialized UML Collaboration instance.
	     */
	    Object createCollaboration();
	
	    /**
	     * Create an empty but initialized instance of a CollaborationInstanceSet.
	     *
	     * @since UML 1.4
	     * @return an initialized CollaborationInstanceSet instance.
	     */
	    Object createCollaborationInstanceSet();
	
	    /**
	     * Create an empty but initialized instance of a UML Interaction.
	     *
	     * @return an initialized UML Interaction instance.
	     */
	    Object createInteraction();
	
	    /**
	     * Create an empty but initialized instance of an InteractionInstanceSet.
	     * 
	     * @since UML 1.4
	     * @return an initialized InteractionInstanceSet instance.
	     */
	    Object createInteractionInstanceSet();
	
	    /**
	     * Create an empty but initialized instance of a UML Message.
	     *
	     * @return an initialized UML Message instance.
	     */
	    Object createMessage();
	
	    /**
	     * Creates a classifierrole and adds it to the given collaboration.
	     *
	     * @param collaboration the given collaboration
	     * @return the created classifier role
	     */
	    Object buildClassifierRole(Object collaboration);
	
	    /**
	     * Builds a default collaboration not attached to a classifier.
	     *
	     * @param handle the namespace for the collaboration
	     * @return the created collaboration
	     */
	    Object buildCollaboration(Object handle);
	
	    /**
	     * Builds a collaboration that is owned by a certain namespace and
	     * represents the given represented element.
	     *
	     * @param namespace the namespace for the collaboration
	     * @param representedElement the represented element
	     * @return the created collaboration
	     */
	    Object buildCollaboration(Object namespace,
	            Object representedElement);
	
	    /**
	     * Builds an interaction belonging to some collaboration.
	     *
	     * @param handle the collaboration that will be the context
	     * for the new interaction
	     * @return the newly build interaction
	     */
	    Object buildInteraction(Object handle);
	
	    /**
	     * Builds an associationendrole based on some classifierrole.
	     *
	     * @param atype the classifierrole
	     * @return the associationendrole
	     */
	    Object buildAssociationEndRole(Object atype);
	
	    /**
	     * Builds a binary associationrole on basis of two classifierroles.
	     *
	     * @param from the first classifierrole
	     * @param to the second classifierrole
	     * @return the newly build associationrole
	     */
	    Object buildAssociationRole(Object from, Object to);
	
	    /**
	     * Builds a binary associationrole on basis of two classifierroles,
	     * navigation and aggregation.
	     *
	     * @param from   the first classifierrole
	     * @param agg1   the first aggregationkind
	     * @param to     the second classifierrole
	     * @param agg2   the second aggregationkind
	     * @param unidirectional true if unidirectional
	     * @return the newly build assoc. role
	     * @deprecated for 0.27.3 by tfmorris.  Use 
	     * {@link #buildAssociationRole(Object, Object, Object, Object, boolean)}.
	     */
	    @Deprecated
	    Object buildAssociationRole(Object from,
	            Object agg1, Object to, Object agg2,
	            Boolean unidirectional);
	
	
	    /**
	     * Builds a binary associationrole on basis of two classifierroles,
	     * navigation and aggregation.
	     *
	     * @param from   the first classifierrole
	     * @param agg1   the first aggregationkind
	     * @param to     the second classifierrole
	     * @param agg2   the second aggregationkind
	     * @param unidirectional true if unidirectional
	     * @return the newly build assoc. role
	     */
	    Object buildAssociationRole(Object from,
	            Object agg1, Object to, Object agg2,
	            boolean unidirectional);
	    
	    /**
	     * Builds an associationrole based on a given link. The link must
	     * have a source and a destination instance that both have a
	     * classifierrole as classifier.  The classifierroles must have
	     * the same collaboration as owner. This collaboration will be the
	     * new owner of the associationrole.
	     *
	     * @param link a UML Link
	     * @return the newly created association role (an Object)
	     */
	    Object buildAssociationRole(Object link);
	    
	    /**
	     * Creates a lifeline and adds it to the given interaction.
	     *
	     * @param interaction the given interaction
	     * @return the created lifeline
	     */
	    Object buildLifeline(Object interaction);
	
	
	    /**
	     * Builds a message within some collaboration or interaction.
	     *
	     * @param acollab a collaboration or interaction
	     * @param arole an associationrole
	     * @return the newly build message
	     */
	    Object buildMessage(Object acollab, Object arole);
	
	    /**
	     * Builds an activator for some message.
	     *
	     * @param owner the owner
	     * @param interaction the interaction
	     * @return the newly build message
	     */
	    Object buildActivator(Object owner, Object interaction);
	}
		
",
	role:"
	user	
",
,
	content:"
	//src/argouml-app/src/org/argouml/ui/TreeModelSupport.java
	/* $Id$
	 *****************************************************************************
	 * Copyright (c) 2009 Contributors - see below
	 * All rights reserved. This program and the accompanying materials
	 * are made available under the terms of the Eclipse Public License v1.0
	 * which accompanies this distribution, and is available at
	 * http://www.eclipse.org/legal/epl-v10.html
	 *
	 * Contributors:
	 *    tfmorris
	 *****************************************************************************
	 *
	 * Some portions of this file was previously release using the BSD License:
	 */
	
	// Copyright (c) 1996-2008 The Regents of the University of California. All
	// Rights Reserved. Permission to use, copy, modify, and distribute this
	// software and its documentation without fee, and without a written
	// agreement is hereby granted, provided that the above copyright notice
	// and this paragraph appear in all copies.  This software program and
	// documentation are copyrighted by The Regents of the University of
	// California. The software program and documentation are supplied "AS
	// IS", without any accompanying services from The Regents. The Regents
	// does not warrant that the operation of the program will be
	// uninterrupted or error-free. The end-user understands that the program
	// was developed for research purposes and is advised not to rely
	// exclusively on the program for any reason.  IN NO EVENT SHALL THE
	// UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
	// SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
	// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
	// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
	// SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
	// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
	// PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
	// CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
	// UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
	
	package org.argouml.ui;
	
	import javax.swing.event.EventListenerList;
	import javax.swing.event.TreeModelEvent;
	import javax.swing.event.TreeModelListener;
	
	/**
	 * Helper class for tree models that provides tree event handling.<p>
	 *
	 * @author  alexb
	 * @since 0.13.5, Created on 15 April 2003
	 */
	public class TreeModelSupport extends PerspectiveSupport {
	
	    /** tree model listener list. */
	    private EventListenerList listenerList = new EventListenerList();
	
	    /**
	     * The constructor.
	     *
	     * @param name the name that will be localized
	     */
	    public TreeModelSupport(String name) {
	        super(name);
	    }
	
	    // ---------------- listener management ----------------
	
	    /**
	     * Add a TreeModelListener to the list of listeners.
	     *
	     * @param l the listener to be added
	     */
	    public void addTreeModelListener(TreeModelListener l) {
	        listenerList.add(TreeModelListener.class, l);
	    }
	
	    /**
	     * Remove a TreeModelListener from the list of listeners..
	     *
	     * @param l the listener to be removed
	     */
	    public void removeTreeModelListener(TreeModelListener l) {
	        listenerList.remove(TreeModelListener.class, l);
	    }
	
	    // --------------- tree nodes -------------------------
	
	    /**
	     * Notify all listeners that a node (or a set of siblings) has changed in
	     * some way. The node(s) have not changed locations in the tree or altered
	     * their children arrays, but other attributes have changed and may affect
	     * presentation. 
	     * <p>
	     * To indicate the root has changed, childIndices and children will be null.
	     * <p>
	     * <em>NOTE:</em> This is a Swing method which must be invoked on the
	     * Swing/AWT event thread.
	     * 
	     * @param source the Object responsible for generating the event (typically
	     *                the creator of the event object passes this for its value)
	     * @param path an array of Object identifying the path to the parent of the
	     *                modified item(s), where the first element of the array is
	     *                the Object stored at the root node and the last element is
	     *                the Object stored at the parent node
	     * @param childIndices an array of int that specifies the index values of
	     *                the removed items. The indices must be in sorted order,
	     *                from lowest to highest
	     * @param children an array of Object containing the inserted, removed, or
	     *                changed objects
	     * @see TreeModelListener#treeNodesChanged(TreeModelEvent)
	     */
	    protected void fireTreeNodesChanged(
						final Object source,
						final Object[] path,
						final int[] childIndices,
						final Object[] children) {
	
	        // Guaranteed to return a non-null array
	        Object[] listeners = listenerList.getListenerList();
	        TreeModelEvent e = null;
	        // Process the listeners last to first, notifying
	        // those that are interested in this event
	        for (int i = listeners.length - 2; i >= 0; i -= 2) {
	            if (listeners[i] == TreeModelListener.class) {
	                // Lazily create the event:
	                if (e == null) {
	                    e =
	                        new TreeModelEvent(
						   source,
						   path,
						   childIndices,
						   children);
	                }
	                ((TreeModelListener) listeners[i + 1]).treeNodesChanged(e);
	            }
	        }
	    }
	
	    /**
	     * Notify all listeners a node has been inserted.  The event instance
	     * is lazily created using the parameters passed into
	     * the fire method.
	     * <p>
	     * <em>NOTE:</em> This is a Swing method which must be invoked on the
	     * Swing/AWT event thread.
	     * 
	     * @param source the Object responsible for generating the event (typically
	     *                the creator of the event object passes this for its value)
	     * @param path an array of Object identifying the path to the parent of the
	     *                modified item(s), where the first element of the array is
	     *                the Object stored at the root node and the last element is
	     *                the Object stored at the parent node
	     * @param childIndices an array of int that specifies the index values of
	     *                the removed items. The indices must be in sorted order,
	     *                from lowest to highest
	     * @param children an array of Object containing the inserted, removed, or
	     *                changed objects
	     * @see TreeModelListener#treeNodesChanged(TreeModelEvent)
	     */
	    protected void fireTreeNodesInserted(
						 Object source,
						 Object[] path,
						 int[] childIndices,
						 Object[] children) {
	
	        // Guaranteed to return a non-null array
	        Object[] listeners = listenerList.getListenerList();
	        TreeModelEvent e = null;
	        // Process the listeners last to first, notifying
	        // those that are interested in this event
	        for (int i = listeners.length - 2; i >= 0; i -= 2) {
	            if (listeners[i] == TreeModelListener.class) {
	                // Lazily create the event:
	                if (e == null) {
	                    e =
	                        new TreeModelEvent(
						   source,
						   path,
						   childIndices,
						   children);
	                }
	                ((TreeModelListener) listeners[i + 1]).treeNodesInserted(e);
	            }
	        }
	    }
	
	    /**
	     * Notify all listeners that nodes have been removed from the tree. Note
	     * that if a subtree is removed from the tree, this method may only be
	     * invoked once for the root of the removed subtree, not once for each
	     * individual set of siblings removed.
	     * <p>
	     * <em>NOTE:</em> This is a Swing method which must be invoked on the
	     * Swing/AWT event thread.
	     * 
	     * @param source the Object responsible for generating the event (typically
	     *                the creator of the event object passes this for its value)
	     * @param path an array of Object identifying the path to the parent of the
	     *                modified item(s), where the first element of the array is
	     *                the Object stored at the root node and the last element is
	     *                the Object stored at the parent node
	     * @param childIndices an array of int that specifies the index values of
	     *                the removed items. The indices must be in sorted order,
	     *                from lowest to highest
	     * @param children an array of Object containing the inserted, removed, or
	     *                changed objects
	     * @see TreeModelListener#treeNodesChanged(TreeModelEvent)
	     * @see EventListenerList
	     */
	    protected void fireTreeNodesRemoved(
						Object source,
						Object[] path,
						int[] childIndices,
						Object[] children) {
	
	        // Guaranteed to return a non-null array
	        Object[] listeners = listenerList.getListenerList();
	        TreeModelEvent e = null;
	        // Process the listeners last to first, notifying
	        // those that are interested in this event
	        for (int i = listeners.length - 2; i >= 0; i -= 2) {
	            if (listeners[i] == TreeModelListener.class) {
	                // Lazily create the event:
	                if (e == null) {
	                    e =
	                        new TreeModelEvent(
						   source,
						   path,
						   childIndices,
						   children);
	                }
	                ((TreeModelListener) listeners[i + 1]).treeNodesRemoved(e);
	            }
	        }
	    }
	
	    // ------------- tree structure -----------------
	
	    /**
	     * Notify all listeners that the tree has drastically changed
	     * structure from a given node down. If the path returned by e.getPath() is
	     * of length one and the first element does not identify the current root
	     * node the first element should become the new root of the tree.
	     * <p>
	     * <em>NOTE:</em> This is a Swing method which must be invoked on the 
	     * Swing/AWT event thread.
	     * 
	     * @param path an array of Object identifying the path to the parent of the
	     *                modified item(s), where the first element of the array is
	     *                the Object stored at the root node and the last element is
	     *                the Object stored at the parent node
	     * @see TreeModelListener#treeStructureChanged(TreeModelEvent)
	     */
	    protected void fireTreeStructureChanged(Object[] path) {
	        fireTreeStructureChanged(this, path);
	    }
	
	    /**
	     * Notify all listeners that the tree has drastically changed
	     * structure from a given node down. If the path returned by e.getPath() is
	     * of length one and the first element does not identify the current root
	     * node the first element should become the new root of the tree.
	     * <p>
	     * <em>NOTE:</em> This is a Swing method which must be invoked on the 
	     * Swing/AWT event thread.
	     * 
	     * @param source the Object responsible for generating the event (typically
	     *                the creator of the event object passes this for its value)
	     * @param path an array of Object identifying the path to the parent of the
	     *                modified item(s), where the first element of the array is
	     *                the Object stored at the root node and the last element is
	     *                the Object stored at the parent node
	     * @see TreeModelListener#treeStructureChanged(TreeModelEvent)
	     */
	    protected void fireTreeStructureChanged(Object source, Object[] path) {
	        fireTreeStructureChanged(source, path, null, null);
	    }
	
	    /**
	     * Notify all listeners that the tree has drastically changed structure from
	     * a given node down. If the path returned by e.getPath() is of length one
	     * and the first element does not identify the current root node the first
	     * element should become the new root of the tree.
	     * <p>
	     * <em>NOTE:</em> This is a Swing method which must be invoked on the
	     * Swing/AWT event thread.
	     * 
	     * @param source the Object responsible for generating the event (typically
	     *                the creator of the event object passes this for its value)
	     * @param path an array of Object identifying the path to the parent of the
	     *                modified item(s), where the first element of the array is
	     *                the Object stored at the root node and the last element is
	     *                the Object stored at the parent node
	     * @param childIndices an array of int that specifies the index values of
	     *                the removed items. The indices must be in sorted order,
	     *                from lowest to highest
	     * @param children an array of Object containing the inserted, removed, or
	     *                changed objects
	     * @see TreeModelListener#treeStructureChanged(TreeModelEvent)
	     */
	    public void fireTreeStructureChanged(
						 Object source,
						 Object[] path,
						 int[] childIndices,
						 Object[] children) {
	
	        // Guaranteed to return a non-null array
	        Object[] listeners = listenerList.getListenerList();
	        TreeModelEvent e = null;
	        // Process the listeners last to first, notifying
	        // those that are interested in this event
	        for (int i = listeners.length - 2; i >= 0; i -= 2) {
	            if (listeners[i] == TreeModelListener.class) {
	                // Lazily create the event:
	                if (e == null) {
	                    e =
	                        new TreeModelEvent(
						   source,
						   path,
						   childIndices,
						   children);
	                }
	                ((TreeModelListener) listeners[i + 1]).treeStructureChanged(e);
	            }
	        }
	    }
	
	}
		
",
	role:"
	user	
",
,

],
model:"
gpt-4-1106-preview
",
response_format:
{
	type:"
	json_object	
",

}
temperature:"0.1",
