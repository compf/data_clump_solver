{
    "refactorings": {
        "src/argouml-core-diagrams-sequence2/src/org/argouml/sequence2/diagram/FigLifeLine.java": [
            {
                "fromLine": "132",
                "toLine": "241",
                "oldContent": "if (!figMessage.isSelfMessage()) {\n    if (isIncoming(figMessage)) {\n        if (currentActivation == null) {\nif (figMessage.isSynchCallMessage()) {\n    // if we are the dest and is a call action, create the \n    // activation, but don't add it until the height is set.\n    ySender = figMessage.getFinalY();\n    \n     \n     \nySender, \n0, \n\n    \n\n    \n} else if (figMessage.isCreateMessage()) {\n    // if we are the destination of a create action,\n    // create the entire activation\n    currentActivation = createActivationFig(\n    \n    \nlineFig.getY(),\n0,\n0,\n    \nfigMessage);\n    \n}\n        } else {\nif (figMessage.isSynchCallMessage()\n        && isSameClassifierRoles(\n    currentActivation.getActivatingMessage(),\n    figMessage)) {\n    activationsCount++;\n} else if (figMessage.isDeleteMessage()) {\n    // if we are the target of a destroy action\n    // the figlifeline ends here and we add the activation\n    ySender = figMessage.getFinalY();\n    currentActivation.setHeight(\nySender - currentActivation.getY());\n    currentActivation.setDestroy(true);\n    lineFig.setHeight(ySender - getY());\n    newActivations.add(currentActivation);\n    currentActivation = null;\n}\n        }\n    }\n    \n    if (isOutgoing(figMessage) && currentActivation != null\n        && currentActivation.isActivatorEnd(figMessage)\n    && --activationsCount == 0) {\n// if we are the source of a return action\n// the activation ends here.\nySender = figMessage.getStartY();\ncurrentActivation.setHeight(\n        ySender - currentActivation.getY());\nnewActivations.add(currentActivation);\ncurrentActivation = null;\n    }\n}\n        }\n        \n        // If we have a currentAct object that means have reached the end\n        // of the lifeline with a call or a create not returned.\n        // Add the activation to the list after setting its height to end\n        // at the end of the lifeline.\n        if (currentActivation != null) {\ncurrentActivation.setHeight(\n        getHeight() - (currentActivation.getY() - getY()));\nnewActivations.add(currentActivation);\n        }\n        \n        return newActivations;\n    }\n    \n    private boolean isSameClassifierRoles(\nfinal FigMessage mess1,\nfinal FigMessage mess2) {\n        return mess1 != null\n    && mess1.getDestFigNode() == mess2.getDestFigNode()\n    && mess1.getSourceFigNode() == mess2.getSourceFigNode();\n    }\n    \n    /**\n     * Return true if the given message fig is pointing in to this lifeline.\n     * @param messageFig\n     * @return true if the message is incoming\n     */\n    private boolean isIncoming(FigMessage messageFig) {\n        return (messageFig.getDestFigNode().getOwner() == getOwner());\n    }\n    \n    /**\n     * Return true if the given message fig is pointing out from this lifeline.\n     * @param messageFig\n     * @return true if the message is outgoing\n     */\n    private boolean isOutgoing(FigMessage messageFig) {\n        return (messageFig.getSourceFigNode().getOwner() == getOwner());\n    }\n    \n    private FigActivation createActivationFig(\nfinal Object owner, \nfinal int x, \nfinal int y, \nfinal int w, \nfinal int h,\nfinal DiagramSettings settings,\nfinal FigMessage messageFig) {\n        return new FigActivation(\n    owner,\n    new Rectangle(x, y, w, h),\n    settings,\n    messageFig);\n    }\n    \n    private List<FigActivation> createStackedActivations(\nfinal List<FigMessage> figMessages) {\n        \n        final List<FigActivation> newActivations =\nnew LinkedList<FigActivation>();\n        \n        FigActivation currentAct = null;\n        \n\n\n// if we are the dest and is a call action, create the \n// activation, but don't add it until the height is set.\nif (figMessage.isSelfMessage()) {\n    if (figMessage.isSynchCallMessage()) {\n        ySender = figMessage.getFinalY();\n        currentAct = new FigActivation(figMessage.getOwner(),\n    new Rectangle(lineFig.getX()\n+ FigActivation.DEFAULT_WIDTH / 2, ySender,\n0, 0), getSettings(), figMessage, false);\n    } else if (currentAct != null\n&& figMessage.isReplyMessage()) {\n        ySender = figMessage.getStartY();\n        currentAct.setHeight(ySender - currentAct.getY());\n        newActivations.add(currentAct);\n        currentAct = null;\n    }\n}\n        }\n        return newActivations;\n    }\n\n\n    private boolean hasIncomingCallActionFirst(\n    final List<FigMessage> figMessages) {\n        final FigClassifierRole cr =\n(FigClassifierRole) getGroup();\n        if (figMessages.isEmpty()) {\nreturn false;\n        }\n        FigMessage figMessage = figMessages.get(0);\n        if (cr.equals(figMessage.getDestFigNode())\n    && !cr.equals(figMessage.getSourceFigNode())\n    && figMessage.isSynchCallMessage()) {\nreturn true;\n        }\n        return false;\n    }\n    \n    private void clearActivations() {\n        for (FigActivation oldActivation : activations) {\nremoveFig(oldActivation);    \n        }\n        for (FigActivation oldActivation : stackedActivations) {\nremoveFig(oldActivation);    \n        }\n        activations.clear();\n        stackedActivations.clear();\n    }\n    \n    @Override\n    public void setFilled(boolean filled) {\n        // we do nothing. No call to the parent\n    }\n    \n    @Override\n    // TODO: synchronized is required here as there can be some \n    // concurrent modification problems when drawing a call message and\n    // having that automatically draw the reply. Maybe fixing the TODO\n    // below will resolve this and the synch can go.\n    protected synchronized void setBoundsImpl(int x, int y, int w, int h) {\n        final Rectangle oldBounds = getBounds();\n        \n        rectFig.setBounds(x, y, w, h);\n        lineFig.setBounds(x + w / 2, y, w, h);\n        \n        final int yDiff = oldBounds.y - y;\n    \n        // we don't recalculate activations, just move them\n        for (FigActivation act : activations) {\n// TODO: why do we need to remove then add the Fig?\nremoveFig(act);\nact.setLocation(\n        lineFig.getX() - FigActivation.DEFAULT_WIDTH / 2,\n        act.getY() - yDiff);\nif (activations.size() == 1 \n        && act.getHeight() == oldBounds.height) {\n    act.setHeight(getHeight());\n}\naddFig(act);\n        }\n        damage();\n        _x = x;\n        _y = y;\n        _w = w;\n        _h = h;\n        firePropChange(\"bounds\", oldBounds, getBounds());\n    }\n    \n    public void setLineWidth(int w) {\n        lineFig.setLineWidth(w);\n    }\n}",
                "newContent": "// Removed incorrect code blocks and comments that were causing compilation errors\n// The correct code blocks are already present in the correct locations"
            }
        ]
    }
}