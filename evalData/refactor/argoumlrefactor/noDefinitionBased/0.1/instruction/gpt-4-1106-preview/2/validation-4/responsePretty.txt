refactorings:
{
	src/argouml-core-diagrams-sequence2/src/org/argouml/sequence2/diagram/FigLifeLine.java:
	[
		fromLine:
{
				
}
		toLine:
{
				
}
		oldContent:"
		if (!figMessage.isSelfMessage()) {
		    if (isIncoming(figMessage)) {
		        if (currentActivation == null) {
		if (figMessage.isSynchCallMessage()) {
		    // if we are the dest and is a call action, create the 
		    // activation, but don't add it until the height is set.
		    ySender = figMessage.getFinalY();
		    
		     
		     
		ySender, 
		0, 
		
		    
		
		    
		} else if (figMessage.isCreateMessage()) {
		    // if we are the destination of a create action,
		    // create the entire activation
		    currentActivation = createActivationFig(
		    
		    
		lineFig.getY(),
		0,
		0,
		    
		figMessage);
		    
		}
		        } else {
		if (figMessage.isSynchCallMessage()
		        && isSameClassifierRoles(
		    currentActivation.getActivatingMessage(),
		    figMessage)) {
		    activationsCount++;
		} else if (figMessage.isDeleteMessage()) {
		    // if we are the target of a destroy action
		    // the figlifeline ends here and we add the activation
		    ySender = figMessage.getFinalY();
		    currentActivation.setHeight(
		ySender - currentActivation.getY());
		    currentActivation.setDestroy(true);
		    lineFig.setHeight(ySender - getY());
		    newActivations.add(currentActivation);
		    currentActivation = null;
		}
		        }
		    }
		    
		    if (isOutgoing(figMessage) && currentActivation != null
		        && currentActivation.isActivatorEnd(figMessage)
		    && --activationsCount == 0) {
		// if we are the source of a return action
		// the activation ends here.
		ySender = figMessage.getStartY();
		currentActivation.setHeight(
		        ySender - currentActivation.getY());
		newActivations.add(currentActivation);
		currentActivation = null;
		    }
		}
		        }
		        
		        // If we have a currentAct object that means have reached the end
		        // of the lifeline with a call or a create not returned.
		        // Add the activation to the list after setting its height to end
		        // at the end of the lifeline.
		        if (currentActivation != null) {
		currentActivation.setHeight(
		        getHeight() - (currentActivation.getY() - getY()));
		newActivations.add(currentActivation);
		        }
		        
		        return newActivations;
		    }
		    
		    private boolean isSameClassifierRoles(
		final FigMessage mess1,
		final FigMessage mess2) {
		        return mess1 != null
		    && mess1.getDestFigNode() == mess2.getDestFigNode()
		    && mess1.getSourceFigNode() == mess2.getSourceFigNode();
		    }
		    
		    /**
		     * Return true if the given message fig is pointing in to this lifeline.
		     * @param messageFig
		     * @return true if the message is incoming
		     */
		    private boolean isIncoming(FigMessage messageFig) {
		        return (messageFig.getDestFigNode().getOwner() == getOwner());
		    }
		    
		    /**
		     * Return true if the given message fig is pointing out from this lifeline.
		     * @param messageFig
		     * @return true if the message is outgoing
		     */
		    private boolean isOutgoing(FigMessage messageFig) {
		        return (messageFig.getSourceFigNode().getOwner() == getOwner());
		    }
		    
		    private FigActivation createActivationFig(
		final Object owner, 
		final int x, 
		final int y, 
		final int w, 
		final int h,
		final DiagramSettings settings,
		final FigMessage messageFig) {
		        return new FigActivation(
		    owner,
		    new Rectangle(x, y, w, h),
		    settings,
		    messageFig);
		    }
		    
		    private List<FigActivation> createStackedActivations(
		final List<FigMessage> figMessages) {
		        
		        final List<FigActivation> newActivations =
		new LinkedList<FigActivation>();
		        
		        FigActivation currentAct = null;
		        
		
		
		// if we are the dest and is a call action, create the 
		// activation, but don't add it until the height is set.
		if (figMessage.isSelfMessage()) {
		    if (figMessage.isSynchCallMessage()) {
		        ySender = figMessage.getFinalY();
		        currentAct = new FigActivation(figMessage.getOwner(),
		    new Rectangle(lineFig.getX()
		+ FigActivation.DEFAULT_WIDTH / 2, ySender,
		0, 0), getSettings(), figMessage, false);
		    } else if (currentAct != null
		&& figMessage.isReplyMessage()) {
		        ySender = figMessage.getStartY();
		        currentAct.setHeight(ySender - currentAct.getY());
		        newActivations.add(currentAct);
		        currentAct = null;
		    }
		}
		        }
		        return newActivations;
		    }
		
		
		    private boolean hasIncomingCallActionFirst(
		    final List<FigMessage> figMessages) {
		        final FigClassifierRole cr =
		(FigClassifierRole) getGroup();
		        if (figMessages.isEmpty()) {
		return false;
		        }
		        FigMessage figMessage = figMessages.get(0);
		        if (cr.equals(figMessage.getDestFigNode())
		    && !cr.equals(figMessage.getSourceFigNode())
		    && figMessage.isSynchCallMessage()) {
		return true;
		        }
		        return false;
		    }
		    
		    private void clearActivations() {
		        for (FigActivation oldActivation : activations) {
		removeFig(oldActivation);    
		        }
		        for (FigActivation oldActivation : stackedActivations) {
		removeFig(oldActivation);    
		        }
		        activations.clear();
		        stackedActivations.clear();
		    }
		    
		    @Override
		    public void setFilled(boolean filled) {
		        // we do nothing. No call to the parent
		    }
		    
		    @Override
		    // TODO: synchronized is required here as there can be some 
		    // concurrent modification problems when drawing a call message and
		    // having that automatically draw the reply. Maybe fixing the TODO
		    // below will resolve this and the synch can go.
		    protected synchronized void setBoundsImpl(int x, int y, int w, int h) {
		        final Rectangle oldBounds = getBounds();
		        
		        rectFig.setBounds(x, y, w, h);
		        lineFig.setBounds(x + w / 2, y, w, h);
		        
		        final int yDiff = oldBounds.y - y;
		    
		        // we don't recalculate activations, just move them
		        for (FigActivation act : activations) {
		// TODO: why do we need to remove then add the Fig?
		removeFig(act);
		act.setLocation(
		        lineFig.getX() - FigActivation.DEFAULT_WIDTH / 2,
		        act.getY() - yDiff);
		if (activations.size() == 1 
		        && act.getHeight() == oldBounds.height) {
		    act.setHeight(getHeight());
		}
		addFig(act);
		        }
		        damage();
		        _x = x;
		        _y = y;
		        _w = w;
		        _h = h;
		        firePropChange("bounds", oldBounds, getBounds());
		    }
		    
		    public void setLineWidth(int w) {
		        lineFig.setLineWidth(w);
		    }
		}		
",
		newContent:"
		// Removed incorrect code blocks and comments that were causing compilation errors
		// The correct code blocks are already present in the correct locations		
",
,

	],

}
