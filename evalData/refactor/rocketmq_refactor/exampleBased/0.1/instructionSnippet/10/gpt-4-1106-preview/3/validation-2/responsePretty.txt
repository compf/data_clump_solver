refactorings:
{
	/root/data_clump_solver/cloned_projects/rocketmq_refactor/store/src/main/java/org/apache/rocketmq/store/DefaultMessageStore.java:
	[
		fromLine:"		148",
		toLine:"		168",
		oldContent:"
		    private CompactionService compactionService;
		
		    private final StoreStatsService storeStatsService;
		
		    private final TransientStorePool transientStorePool;
		
		    protected final RunningFlags runningFlags = new RunningFlags();
		    private final SystemClock systemClock = new SystemClock();
		
		    private final ScheduledExecutorService scheduledExecutorService;
		    private final BrokerStatsManager brokerStatsManager;
		    private final MessageArrivingListener messageArrivingListener;
		    private final BrokerConfig brokerConfig;
		
		    private volatile boolean shutdown = true;
		    protected boolean notifyMessageArriveInBatch = false;
		
		    private StoreCheckpoint storeCheckpoint;
		    private TimerMessageStore timerMessageStore;
		
		    private final LinkedList<CommitLogDispatcher> dispatcherList;		
",
		newContent:"
		    private CompactionService compactionService;
		
		    private final StoreStatsService storeStatsService;
		
		    private final TransientStorePool transientStorePool;
		
		    protected final RunningFlags runningFlags = new RunningFlags();
		    private final SystemClock systemClock = new SystemClock();
		
		    private final ScheduledExecutorService scheduledExecutorService;
		    // private final BrokerStatsManager brokerStatsManager; // Removed as part of refactoring
		    private final MessageArrivingListener messageArrivingListener;
		    private final BrokerConfig brokerConfig;
		
		    private volatile boolean shutdown = true;
		    protected boolean notifyMessageArriveInBatch = false;
		
		    private StoreCheckpoint storeCheckpoint;
		    private TimerMessageStore timerMessageStore;
		
		    private final LinkedList<CommitLogDispatcher> dispatcherList;		
",
,
		fromLine:"		205",
		toLine:"		225",
		oldContent:"
		    private final DispatchRequestOrderlyQueue dispatchRequestOrderlyQueue = new DispatchRequestOrderlyQueue(dispatchRequestOrderlyQueueSize);
		
		    private long stateMachineVersion = 0L;
		
		    // this is a unmodifiableMap
		    private ConcurrentMap<String, TopicConfig> topicConfigTable;
		
		    private final ScheduledExecutorService scheduledCleanQueueExecutorService =
		        ThreadUtils.newSingleThreadScheduledExecutor(new ThreadFactoryImpl("StoreCleanQueueScheduledThread"));
		
		    public DefaultMessageStore(final MessageStoreConfig messageStoreConfig, final BrokerStatsManager brokerStatsManager,
		        final MessageArrivingListener messageArrivingListener, final BrokerConfig brokerConfig, final ConcurrentMap<String, TopicConfig> topicConfigTable) throws IOException {
		        this.messageArrivingListener = messageArrivingListener;
		        this.brokerConfig = brokerConfig;
		        this.messageStoreConfig = messageStoreConfig;
		        this.aliveReplicasNum = messageStoreConfig.getTotalReplicas();
		        this.brokerStatsManager = brokerStatsManager;
		        this.topicConfigTable = topicConfigTable;
		        this.allocateMappedFileService = new AllocateMappedFileService(this);
		        if (messageStoreConfig.isEnableDLegerCommitLog()) {
		            this.commitLog = new DLedgerCommitLog(this);		
",
		newContent:"
		    private final DispatchRequestOrderlyQueue dispatchRequestOrderlyQueue = new DispatchRequestOrderlyQueue(dispatchRequestOrderlyQueueSize);
		
		    private long stateMachineVersion = 0L;
		
		    // this is a unmodifiableMap
		    private ConcurrentMap<String, TopicConfig> topicConfigTable;
		
		    private final ScheduledExecutorService scheduledCleanQueueExecutorService =
		        ThreadUtils.newSingleThreadScheduledExecutor(new ThreadFactoryImpl("StoreCleanQueueScheduledThread"));
		
		    // Constructor modified to remove BrokerStatsManager
		    public DefaultMessageStore(final MessageStoreConfig messageStoreConfig,
		        final MessageArrivingListener messageArrivingListener, final BrokerConfig brokerConfig, final ConcurrentMap<String, TopicConfig> topicConfigTable) throws IOException {
		        this.messageArrivingListener = messageArrivingListener;
		        this.brokerConfig = brokerConfig;
		        this.messageStoreConfig = messageStoreConfig;
		        this.aliveReplicasNum = messageStoreConfig.getTotalReplicas();
		        // this.brokerStatsManager = brokerStatsManager; // Removed as part of refactoring
		        this.topicConfigTable = topicConfigTable;
		        this.allocateMappedFileService = new AllocateMappedFileService(this);
		        if (messageStoreConfig.isEnableDLegerCommitLog()) {
		            this.commitLog = new DLedgerCommitLog(this);		
",
,
		fromLine:"		1996",
		toLine:"		2016",
		oldContent:"
		
		    @Override
		    public long getStateMachineVersion() {
		        return stateMachineVersion;
		    }
		
		    public void setStateMachineVersion(long stateMachineVersion) {
		        this.stateMachineVersion = stateMachineVersion;
		    }
		
		    public BrokerStatsManager getBrokerStatsManager() {
		        return brokerStatsManager;
		    }
		
		    public BrokerConfig getBrokerConfig() {
		        return brokerConfig;
		    }
		
		    public int remainTransientStoreBufferNumbs() {
		        if (this.isTransientStorePoolEnable()) {
		            return this.transientStorePool.availableBufferNums();		
",
		newContent:"
		
		    @Override
		    public long getStateMachineVersion() {
		        return stateMachineVersion;
		    }
		
		    public void setStateMachineVersion(long stateMachineVersion) {
		        this.stateMachineVersion = stateMachineVersion;
		    }
		
		    // The following method has been removed as part of the refactoring process.
		    // public BrokerStatsManager getBrokerStatsManager() {
		    //     return brokerStatsManager;
		    // }
		
		    public BrokerConfig getBrokerConfig() {
		        return brokerConfig;
		    }
		
		    public int remainTransientStoreBufferNumbs() {
		        if (this.isTransientStorePoolEnable()) {
		            return this.transientStorePool.availableBufferNums();		
",
,

	],
	/root/data_clump_solver/cloned_projects/rocketmq_refactor/store/src/main/java/org/apache/rocketmq/store/timer/TimerMessageStore.java:
	[
		fromLine:"		149",
		toLine:"		174",
		oldContent:"
		    protected long lastTimeOfCheckMetrics = System.currentTimeMillis();
		    protected AtomicInteger frequency = new AtomicInteger(0);
		
		    private volatile BrokerRole lastBrokerRole = BrokerRole.SLAVE;
		    //the dequeue is an asynchronous process, use this flag to track if the status has changed
		    private boolean dequeueStatusChangeFlag = false;
		    private long shouldStartTime;
		
		    // True if current store is master or current brokerId is equal to the minimum brokerId of the replica group in slaveActingMaster mode.
		    protected volatile boolean shouldRunningDequeue;
		    private final BrokerStatsManager brokerStatsManager;
		    private Function<MessageExtBrokerInner, PutMessageResult> escapeBridgeHook;
		
		    public TimerMessageStore(final MessageStore messageStore, final MessageStoreConfig storeConfig,
		        TimerCheckpoint timerCheckpoint, TimerMetrics timerMetrics,
		        final BrokerStatsManager brokerStatsManager) throws IOException {
		
		        this.messageStore = messageStore;
		        this.storeConfig = storeConfig;
		        this.commitLogFileSize = storeConfig.getMappedFileSizeCommitLog();
		        this.timerLogFileSize = storeConfig.getMappedFileSizeTimerLog();
		        this.precisionMs = storeConfig.getTimerPrecisionMs();
		
		        // TimerWheel contains the fixed number of slots regardless of precision.
		        this.slotsTotal = TIMER_WHEEL_TTL_DAY * DAY_SECS;
		        this.timerWheel = new TimerWheel(		
",
		newContent:"
		    protected long lastTimeOfCheckMetrics = System.currentTimeMillis();
		    protected AtomicInteger frequency = new AtomicInteger(0);
		
		    private volatile BrokerRole lastBrokerRole = BrokerRole.SLAVE;
		    //the dequeue is an asynchronous process, use this flag to track if the status has changed
		    private boolean dequeueStatusChangeFlag = false;
		    private long shouldStartTime;
		
		    // True if current store is master or current brokerId is equal to the minimum brokerId of the replica group in slaveActingMaster mode.
		    protected volatile boolean shouldRunningDequeue;
		    // private final BrokerStatsManager brokerStatsManager; // Removed as part of refactoring
		    private Function<MessageExtBrokerInner, PutMessageResult> escapeBridgeHook;
		
		    // Constructor modified to remove BrokerStatsManager
		    public TimerMessageStore(final MessageStore messageStore, final MessageStoreConfig storeConfig,
		        TimerCheckpoint timerCheckpoint, TimerMetrics timerMetrics) throws IOException {
		
		        this.messageStore = messageStore;
		        this.storeConfig = storeConfig;
		        this.commitLogFileSize = storeConfig.getMappedFileSizeCommitLog();
		        this.timerLogFileSize = storeConfig.getMappedFileSizeTimerLog();
		        this.precisionMs = storeConfig.getTimerPrecisionMs();
		
		        // TimerWheel contains the fixed number of slots regardless of precision.
		        this.slotsTotal = TIMER_WHEEL_TTL_DAY * DAY_SECS;
		        this.timerWheel = new TimerWheel(		
",
,

	],
	/root/data_clump_solver/cloned_projects/rocketmq_refactor/store/src/main/java/org/apache/rocketmq/store/MessageStore.java:
	[
		fromLine:"		595",
		toLine:"		615",
		oldContent:"
		     * @param queueId Queue ID.
		     * @return Consume queue.
		     */
		    ConsumeQueueInterface findConsumeQueue(String topic, int queueId);
		
		    /**
		     * Get BrokerStatsManager of the messageStore.
		     *
		     * @return BrokerStatsManager.
		     */
		    BrokerStatsManager getBrokerStatsManager();
		
		    /**
		     * Will be triggered when a new message is appended to commit log.
		     *
		     * @param msg           the msg that is appended to commit log
		     * @param result        append message result
		     * @param commitLogFile commit log file
		     */
		    void onCommitLogAppend(MessageExtBrokerInner msg, AppendMessageResult result, MappedFile commitLogFile);
				
",
		newContent:"
		     * @param queueId Queue ID.
		     * @return Consume queue.
		     */
		    ConsumeQueueInterface findConsumeQueue(String topic, int queueId);
		
		    /**
		     * The following method has been removed as part of the refactoring process.
		     *
		     * // Get BrokerStatsManager of the messageStore.
		     * // @return BrokerStatsManager.
		     * // BrokerStatsManager getBrokerStatsManager();
		     *
		     * Will be triggered when a new message is appended to commit log.
		     *
		     * @param msg           the msg that is appended to commit log
		     * @param result        append message result
		     * @param commitLogFile commit log file
		     */
		    void onCommitLogAppend(MessageExtBrokerInner msg, AppendMessageResult result, MappedFile commitLogFile);
				
",
,

	],
	/root/data_clump_solver/cloned_projects/rocketmq_refactor/store/src/main/java/org/apache/rocketmq/store/RocksDBMessageStore.java:
	[
		fromLine:"		16",
		toLine:"		52",
		oldContent:"
		 */
		package org.apache.rocketmq.store;
		
		import java.io.IOException;
		import java.util.concurrent.ConcurrentHashMap;
		import java.util.concurrent.ConcurrentMap;
		import java.util.function.Supplier;
		
		import io.opentelemetry.api.common.AttributesBuilder;
		import io.opentelemetry.api.metrics.Meter;
		import org.apache.rocketmq.common.BrokerConfig;
		import org.apache.rocketmq.common.TopicConfig;
		import org.apache.rocketmq.common.UtilAll;
		import org.apache.rocketmq.store.config.MessageStoreConfig;
		import org.apache.rocketmq.store.config.StorePathConfigHelper;
		import org.apache.rocketmq.store.metrics.DefaultStoreMetricsManager;
		import org.apache.rocketmq.store.metrics.RocksDBStoreMetricsManager;
		import org.apache.rocketmq.store.queue.ConsumeQueueInterface;
		import org.apache.rocketmq.store.queue.ConsumeQueueStoreInterface;
		import org.apache.rocketmq.store.queue.RocksDBConsumeQueue;
		import org.apache.rocketmq.store.queue.RocksDBConsumeQueueStore;
		import org.apache.rocketmq.store.stats.BrokerStatsManager;
		import org.rocksdb.RocksDBException;
		
		public class RocksDBMessageStore extends DefaultMessageStore {
		
		    public RocksDBMessageStore(final MessageStoreConfig messageStoreConfig, final BrokerStatsManager brokerStatsManager,
		        final MessageArrivingListener messageArrivingListener, final BrokerConfig brokerConfig, final ConcurrentMap<String, TopicConfig> topicConfigTable) throws
		        IOException {
		        super(messageStoreConfig, brokerStatsManager, messageArrivingListener, brokerConfig, topicConfigTable);
		        notifyMessageArriveInBatch = true;
		    }
		
		    @Override
		    public ConsumeQueueStoreInterface createConsumeQueueStore() {
		        return new RocksDBConsumeQueueStore(this);
		    }		
",
		newContent:"
		 */
		package org.apache.rocketmq.store;
		
		import java.io.IOException;
		import java.util.concurrent.ConcurrentHashMap;
		import java.util.concurrent.ConcurrentMap;
		import java.util.function.Supplier;
		
		import io.opentelemetry.api.common.AttributesBuilder;
		import io.opentelemetry.api.metrics.Meter;
		import org.apache.rocketmq.common.BrokerConfig;
		import org.apache.rocketmq.common.TopicConfig;
		import org.apache.rocketmq.common.UtilAll;
		import org.apache.rocketmq.store.config.MessageStoreConfig;
		import org.apache.rocketmq.store.config.StorePathConfigHelper;
		import org.apache.rocketmq.store.metrics.DefaultStoreMetricsManager;
		import org.apache.rocketmq.store.metrics.RocksDBStoreMetricsManager;
		import org.apache.rocketmq.store.queue.ConsumeQueueInterface;
		import org.apache.rocketmq.store.queue.ConsumeQueueStoreInterface;
		import org.apache.rocketmq.store.queue.RocksDBConsumeQueue;
		import org.apache.rocketmq.store.queue.RocksDBConsumeQueueStore;
		// import org.apache.rocketmq.store.stats.BrokerStatsManager; // Removed as part of refactoring
		import org.rocksdb.RocksDBException;
		
		public class RocksDBMessageStore extends DefaultMessageStore {
		
		    // Constructor modified to remove BrokerStatsManager
		    public RocksDBMessageStore(final MessageStoreConfig messageStoreConfig,
		        final MessageArrivingListener messageArrivingListener, final BrokerConfig brokerConfig, final ConcurrentMap<String, TopicConfig> topicConfigTable) throws
		        IOException {
		        super(messageStoreConfig, messageArrivingListener, brokerConfig, topicConfigTable);
		        notifyMessageArriveInBatch = true;
		    }
		
		    @Override
		    public ConsumeQueueStoreInterface createConsumeQueueStore() {
		        return new RocksDBConsumeQueueStore(this);
		    }		
",
,

	],
	/root/data_clump_solver/cloned_projects/rocketmq_refactor/store/src/main/java/org/apache/rocketmq/store/plugin/AbstractPluginMessageStore.java:
	[
		fromLine:"		326",
		toLine:"		346",
		oldContent:"
		    public ConsumeQueueInterface getConsumeQueue(String topic, int queueId) {
		        return next.getConsumeQueue(topic, queueId);
		    }
		
		    @Override
		    public ConsumeQueueInterface findConsumeQueue(String topic, int queueId) {
		        return next.findConsumeQueue(topic, queueId);
		    }
		
		    @Override
		    public BrokerStatsManager getBrokerStatsManager() {
		        return next.getBrokerStatsManager();
		    }
		
		    @Override
		    public int remainTransientStoreBufferNumbs() {
		        return next.remainTransientStoreBufferNumbs();
		    }
		
		    @Override
		    public long remainHowManyDataToCommit() {		
",
		newContent:"
		    public ConsumeQueueInterface getConsumeQueue(String topic, int queueId) {
		        return next.getConsumeQueue(topic, queueId);
		    }
		
		    @Override
		    public ConsumeQueueInterface findConsumeQueue(String topic, int queueId) {
		        return next.findConsumeQueue(topic, queueId);
		    }
		
		    // The following method has been removed as part of the refactoring process.
		    // @Override
		    // public BrokerStatsManager getBrokerStatsManager() {
		    //     return next.getBrokerStatsManager();
		    // }
		
		    @Override
		    public int remainTransientStoreBufferNumbs() {
		        return next.remainTransientStoreBufferNumbs();
		    }
		
		    @Override
		    public long remainHowManyDataToCommit() {		
",
,

	],

}
