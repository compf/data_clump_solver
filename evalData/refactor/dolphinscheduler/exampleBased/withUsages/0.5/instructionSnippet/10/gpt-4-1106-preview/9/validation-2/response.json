{
    "refactorings": {
        "/root/data_clump_solver/cloned_projects/dolphinscheduler/dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/api/model/TaskAlertInfo.java": [
            {
                "fromLine": 32,
                "toLine": 56,
                "oldContent": "    }\n\n    public String getContent() {\n        return content;\n    }\n\n    public void setContent(String content) {\n        this.content = content;\n    }\n\n    public String getContent() {\n        return content;\n    }\n\n    public void setContent(String content) {\n        this.content = content;\n    }\n\n    public Integer getAlertGroupId() {\n        return alertGroupId;\n    }\n\n    public void setAlertGroupId(Integer alertGroupId) {\n        this.alertGroupId = alertGroupId;\n    }",
                "newContent": "    }\n\n    public String getContent() {\n        return content;\n    }\n\n    public void setContent(String content) {\n        this.content = content;\n    }\n\n    public Integer getAlertGroupId() {\n        return alertGroupId;\n    }\n\n    public void setAlertGroupId(Integer alertGroupId) {\n        this.alertGroupId = alertGroupId;\n    }"
            }
        ],
        "/root/data_clump_solver/cloned_projects/dolphinscheduler/dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/api/parser/TimePlaceholderUtils.java": [
            {
                "fromLine": 316,
                "toLine": 336,
                "oldContent": "        public TimePlaceholderResolver(String value, Date date) {\n            this.value = value;\n            this.date = date;\n        }\n\n        @Override\n        public String resolvePlaceholder(String placeholderName) {\n            try {\n                return calculateTime(placeholderName, date);\n            } catch (Exception ex) {\n                log.error(\"resolve placeholder '{}' in [ {} ]\", placeholderName, value, ex);\n                return null;\n            }\n        }\n    }\n\n    /**\n     * return the formatted date according to the corresponding date format\n     *\n     * @param expression date expression\n     * @param date       date",
                "newContent": "        public TimePlaceholderResolver(String value, Date date) {\n            this.value = value;\n            this.date = date;\n        }\n\n        @Override\n        public String resolvePlaceholder(String placeholderName) {\n            try {\n                return calculateTime(placeholderName, date);\n            } catch (Exception ex) {\n                return null;\n            }\n        }\n    }\n\n    /**\n     * return the formatted date according to the corresponding date format\n     *\n     * @param expression date expression\n     * @param date       date"
            }
        ],
        "/root/data_clump_solver/cloned_projects/dolphinscheduler/dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/api/parser/PropertyPlaceholderHelper.java": [
            {
                "fromLine": 151,
                "toLine": 172,
                "oldContent": "                        if (propVal == null) {\n                            propVal = defaultValue;\n                        }\n                    }\n                }\n                if (propVal != null) {\n                    // Recursive invocation, parsing placeholders contained in the\n                    // previously resolved placeholder value.\n                    propVal = parseStringValue(propVal, placeholderResolver, visitedPlaceholders);\n                    result.replace(startIndex, endIndex + this.placeholderSuffix.length(), propVal);\n                    if (log.isTraceEnabled()) {\n                        log.trace(\"Resolved placeholder '\" + placeholder + \"'\");\n                    }\n                    startIndex = result.indexOf(this.placeholderPrefix, startIndex + propVal.length());\n                } else if (this.ignoreUnresolvablePlaceholders) {\n                    // Proceed with unprocessed value.\n                    startIndex = result.indexOf(this.placeholderPrefix, endIndex + this.placeholderSuffix.length());\n                } else {\n                    throw new IllegalArgumentException(\"Could not resolve placeholder '\"\n                            + placeholder + \"'\" + \" in value \\\"\" + value + \"\\\"\");\n                }\n                visitedPlaceholders.remove(originalPlaceholder);",
                "newContent": "                        if (propVal == null) {\n                            propVal = defaultValue;\n                        }\n                    }\n                }\n                if (propVal != null) {\n                    // Recursive invocation, parsing placeholders contained in the\n                    // previously resolved placeholder value.\n                    propVal = parseStringValue(propVal, placeholderResolver, visitedPlaceholders);\n                    result.replace(startIndex, endIndex + this.placeholderSuffix.length(), propVal);\n                    startIndex = result.indexOf(this.placeholderPrefix, startIndex + propVal.length());\n                } else if (this.ignoreUnresolvablePlaceholders) {\n                    // Proceed with unprocessed value.\n                    startIndex = result.indexOf(this.placeholderPrefix, endIndex + this.placeholderSuffix.length());\n                } else {\n                    throw new IllegalArgumentException(\"Could not resolve placeholder '\"\n                            + placeholder + \"'\" + \" in value \\\"\" + value + \"\\\"\");\n                }\n                visitedPlaceholders.remove(originalPlaceholder);"
            }
        ],
        "/root/data_clump_solver/cloned_projects/dolphinscheduler/dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/api/parameters/AbstractParameters.java": [
            {
                "fromLine": 60,
                "toLine": 123,
                "oldContent": "\n    @Override\n    public List<ResourceInfo> getResourceFilesList() {\n        return new ArrayList<>();\n    }\n\n    public Map<String, Property> getLocalParametersMap() {\n        Map<String, Property> localParametersMaps = new LinkedHashMap<>();\n        if (localParams != null) {\n            for (Property property : localParams) {\n                localParametersMaps.put(property.getProp(), property);\n            }\n        }\n        return localParametersMaps;\n    }\n\n    public K8sTaskExecutionContext generateK8sTaskExecutionContext(ResourceParametersHelper parametersHelper,\n                                                                   int datasource) {\n        DataSourceParameters dataSourceParameters =\n                (DataSourceParameters) parametersHelper.getResourceParameters(ResourceType.DATASOURCE, datasource);\n        K8sTaskExecutionContext k8sTaskExecutionContext = new K8sTaskExecutionContext();\n        k8sTaskExecutionContext.setConnectionParams(\n                Objects.nonNull(dataSourceParameters) ? dataSourceParameters.getConnectionParams() : null);\n        return k8sTaskExecutionContext;\n    }\n\n    /**\n     * get input local parameters map if the param direct is IN\n     *\n     * @return parameters map\n     */\n    public Map<String, Property> getInputLocalParametersMap() {\n        Map<String, Property> localParametersMaps = new LinkedHashMap<>();\n        if (localParams != null) {\n            for (Property property : localParams) {\n                // The direct of some tasks is empty, default IN\n                if (property.getDirect() == null || Objects.equals(Direct.IN, property.getDirect())) {\n                    localParametersMaps.put(property.getProp(), property);\n                }\n            }\n        }\n        return localParametersMaps;\n    }\n\n    /**\n     * get varPool map\n     *\n     * @return parameters map\n     */\n    public Map<String, Property> getVarPoolMap() {\n        Map<String, Property> varPoolMap = new LinkedHashMap<>();\n        if (varPool != null) {\n            for (Property property : varPool) {\n                varPoolMap.put(property.getProp(), property);\n            }\n        }\n        return varPoolMap;\n    }\n\n    public void setVarPool(String varPool) {\n        if (StringUtils.isEmpty(varPool)) {\n            this.varPool = new ArrayList<>();\n        } else {\n            this.varPool = JSONUtils.toList(varPool, Property.class);",
                "newContent": "\n    @Override\n    public List<ResourceInfo> getResourceFilesList() {\n        return new ArrayList<>();\n    }\n\n    public Map<String, Property> getLocalParametersMap() {\n        Map<String, Property> localParametersMaps = new LinkedHashMap<>();\n        if (localParams != null) {\n            for (Property property : localParams) {\n                localParametersMaps.put(property.getProp(), property);\n            }\n        }\n        return localParametersMaps;\n    }\n\n    public K8sTaskExecutionContext generateK8sTaskExecutionContext(ResourceParametersHelper parametersHelper,\n                                                                   int datasource) {\n        DataSourceParameters dataSourceParameters =\n                (DataSourceParameters) parametersHelper.getResourceParameters(ResourceType.DATASOURCE, datasource);\n        K8sTaskExecutionContext k8sTaskExecutionContext = new K8sTaskExecutionContext();\n        k8sTaskExecutionContext.setConnectionParams(\n                Objects.nonNull(dataSourceParameters) ? dataSourceParameters.getConnectionParams() : null);\n        return k8sTaskExecutionContext;\n    }\n\n    /**\n     * get input local parameters map if the param direct is IN\n     *\n     * @return parameters map\n     */\n    public Map<String, Property> getInputLocalParametersMap() {\n        Map<String, Property> localParametersMaps = new LinkedHashMap<>();\n        if (localParams != null) {\n            for (Property property : localParams) {\n                // The direct of some tasks is empty, default IN\n                if (property.getDirect() == null || Objects.equals(Direct.IN, property.getDirect())) {\n                    localParametersMaps.put(property.getProp(), property);\n                }\n            }\n        }\n        return localParametersMaps;\n    }\n\n    /**\n     * get varPool map\n     *\n     * @return parameters map\n     */\n    public Map<String, Property> getVarPoolMap() {\n        Map<String, Property> varPoolMap = new LinkedHashMap<>();\n        if (varPool != null) {\n            for (Property property : varPool) {\n                varPoolMap.put(property.getProp(), property);\n            }\n        }\n        return varPoolMap;\n    }\n\n    public void setVarPool(String varPool) {\n        if (StringUtils.isEmpty(varPool)) {\n            this.varPool = new ArrayList<>();\n        } else {\n            this.varPool = JSONUtils.toList(varPool, Property.class);"
            },
            {
                "fromLine": 125,
                "toLine": 179,
                "oldContent": "    }\n\n    public void dealOutParam(Map<String, String> taskOutputParams) {\n        List<Property> outProperty = getOutProperty(localParams);\n        if (CollectionUtils.isEmpty(outProperty)) {\n            return;\n        }\n        if (CollectionUtils.isNotEmpty(outProperty) && MapUtils.isNotEmpty(taskOutputParams)) {\n            // Inject the value\n            for (Property info : outProperty) {\n                String value = taskOutputParams.get(info.getProp());\n                if (value != null) {\n                    info.setValue(value);\n                }\n            }\n        }\n\n        varPool = VarPoolUtils.mergeVarPool(Lists.newArrayList(varPool, outProperty));\n    }\n\n    protected List<Property> getOutProperty(List<Property> params) {\n        if (CollectionUtils.isEmpty(params)) {\n            return new ArrayList<>();\n        }\n        return params.stream()\n                .filter(info -> info.getDirect() == Direct.OUT)\n                .collect(Collectors.toList());\n    }\n\n    public List<Map<String, String>> getListMapByString(String json) {\n        List<Map<String, String>> allParams = new ArrayList<>();\n        ArrayNode paramsByJson = JSONUtils.parseArray(json);\n        for (JsonNode jsonNode : paramsByJson) {\n            Map<String, String> param = JSONUtils.toMap(jsonNode.toString());\n            allParams.add(param);\n        }\n        return allParams;\n    }\n\n    public ResourceParametersHelper getResources() {\n        return new ResourceParametersHelper();\n    }\n\n    public void addPropertyToValPool(Property property) {\n        varPool.removeIf(p -> p.getProp().equals(property.getProp()));\n        varPool.add(property);\n    }\n}\n",
                "newContent": "    }\n\n    public void dealOutParam(Map<String, String> taskOutputParams) {\n        List<Property> outProperty = getOutProperty(localParams);\n        if (CollectionUtils.isEmpty(outProperty)) {\n            return;\n        }\n        if (CollectionUtils.isNotEmpty(outProperty) && MapUtils.isNotEmpty(taskOutputParams)) {\n            // Inject the value\n            for (Property info : outProperty) {\n                String value = taskOutputParams.get(info.getProp());\n                if (value != null) {\n                    info.setValue(value);\n                }\n            }\n        }\n\n        varPool = VarPoolUtils.mergeVarPool(Lists.newArrayList(varPool, outProperty));\n    }\n\n    protected List<Property> getOutProperty(List<Property> params) {\n        if (CollectionUtils.isEmpty(params)) {\n            return new ArrayList<>();\n        }\n        return params.stream()\n                .filter(info -> info.getDirect() == Direct.OUT)\n                .collect(Collectors.toList());\n    }\n\n    public List<Map<String, String>> getListMapByString(String json) {\n        List<Map<String, String>> allParams = new ArrayList<>();\n        ArrayNode paramsByJson = JSONUtils.parseArray(json);\n        for (JsonNode jsonNode : paramsByJson) {\n            Map<String, String> param = JSONUtils.toMap(jsonNode.toString());\n            allParams.add(param);\n        }\n        return allParams;\n    }\n\n    public ResourceParametersHelper getResources() {\n        return new ResourceParametersHelper();\n    }\n\n    public void addPropertyToValPool(Property property) {\n        varPool.removeIf(p -> p.getProp().equals(property.getProp()));\n        varPool.add(property);\n    }\n"
            }
        ],
        "/root/data_clump_solver/cloned_projects/dolphinscheduler/dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/api/AbstractTask.java": [
            {
                "fromLine": 154,
                "toLine": 174,
                "oldContent": "     * log handle\n     *\n     * @param logs log list\n     */\n    public void logHandle(LinkedBlockingQueue<String> logs) {\n\n        StringJoiner joiner = new StringJoiner(\"\\n\\t\");\n        while (!logs.isEmpty()) {\n            joiner.add(logs.poll());\n        }\n        log.info(\" -> {}\", joiner);\n    }\n\n    /**\n     * regular expressions match the contents between two specified strings\n     *\n     * @param content content\n     * @param sqlParamsMap sql params map\n     * @param paramsPropsMap params props map\n     */\n    public void setSqlParamsMap(String content, Map<Integer, Property> sqlParamsMap,",
                "newContent": "     * log handle\n     *\n     * @param logs log list\n     */\n    public void logHandle(LinkedBlockingQueue<String> logs) {\n\n        StringJoiner joiner = new StringJoiner(\"\\n\\t\");\n        while (!logs.isEmpty()) {\n            joiner.add(logs.poll());\n        }\n    }\n\n    /**\n     * regular expressions match the contents between two specified strings\n     *\n     * @param content content\n     * @param sqlParamsMap sql params map\n     * @param paramsPropsMap params props map\n     */\n    public void setSqlParamsMap(String content, Map<Integer, Property> sqlParamsMap,"
            },
            {
                "fromLine": 182,
                "toLine": 209,
                "oldContent": "        while (m.find()) {\n\n            String paramName = m.group(TaskConstants.GROUP_NAME1);\n            if (paramName == null) {\n                paramName = m.group(TaskConstants.GROUP_NAME2);\n            }\n\n            Property prop = paramsPropsMap.get(paramName);\n\n            if (prop == null) {\n                log.error(\n                        \"setSqlParamsMap: No Property with paramName: {} is found in paramsPropsMap of task instance\"\n                                + \" with id: {}. So couldn't put Property in sqlParamsMap.\",\n                        paramName, taskInstanceId);\n            } else {\n                sqlParamsMap.put(index, prop);\n                index++;\n                log.info(\n                        \"setSqlParamsMap: Property with paramName: {} put in sqlParamsMap of content {} successfully.\",\n                        paramName, content);\n            }\n\n        }\n    }\n}\n",
                "newContent": "        while (m.find()) {\n\n            String paramName = m.group(TaskConstants.GROUP_NAME1);\n            if (paramName == null) {\n                paramName = m.group(TaskConstants.GROUP_NAME2);\n            }\n\n            Property prop = paramsPropsMap.get(paramName);\n\n            if (prop == null) {\n            } else {\n                sqlParamsMap.put(index, prop);\n                index++;\n            }\n\n        }\n    }\n"
            }
        ],
        "/root/data_clump_solver/cloned_projects/dolphinscheduler/dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/api/resource/ResourceContext.java": [
            {
                "fromLine": 35,
                "toLine": 55,
                "oldContent": "     * ResourceAbsolutePathInStorage -> ResourceItem\n     */\n    private final Map<String, ResourceItem> resourceItemMap;\n\n    public ResourceContext() {\n        this.resourceItemMap = new HashMap<>();\n    }\n\n    public void addResourceItem(ResourceItem resourceItem) {\n        checkNotNull(resourceItem);\n        resourceItemMap.put(resourceItem.getResourceAbsolutePathInStorage(), resourceItem);\n    }\n\n    public ResourceItem getResourceItem(String resourceAbsolutePathInStorage) {\n        ResourceItem resourceItem = resourceItemMap.get(resourceAbsolutePathInStorage);\n        if (resourceItem == null) {\n            throw new IllegalArgumentException(\"Cannot find the resourceItem: \" + resourceAbsolutePathInStorage);\n        }\n        return resourceItem;\n    }\n",
                "newContent": "     * ResourceAbsolutePathInStorage -> ResourceItem\n     */\n    private final Map<String, ResourceItem> resourceItemMap;\n\n    public ResourceContext() {\n        this.resource
{
    "refactorings": {
        "/root/data_clump_solver/cloned_projects/dolphinscheduler/dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/api/resource/ResourceContext.java": [
            {
                "fromLine": 35,
                "toLine": 55,
                "oldContent": "     * ResourceAbsolutePathInStorage -> ResourceItem\n     */\n    private final Map<String, ResourceItem> resourceItemMap;\n\n    public ResourceContext() {\n        this.resourceItemMap = new HashMap<>();\n    }\n\n    public void addResourceItem(ResourceItem resourceItem) {\n        checkNotNull(resourceItem);\n        resourceItemMap.put(resourceItem.getResourceAbsolutePathInStorage(), resourceItem);\n    }\n\n    public ResourceItem getResourceItem(String resourceAbsolutePathInStorage) {\n        ResourceItem resourceItem = resourceItemMap.get(resourceAbsolutePathInStorage);\n        if (resourceItem == null) {\n            throw new IllegalArgumentException(\"Cannot find the resourceItem: \" + resourceAbsolutePathInStorage);\n        }\n        return resourceItem;\n    }\n",
                "newContent": "     * ResourceAbsolutePathInStorage -> ResourceItem\n     */\n    private final Map<String, ResourceItem> resourceItemMap;\n\n    public ResourceContext() {\n        this.resourceItemMap = new HashMap<>();\n    }\n\n    public void addResourceItem(ResourceItem resourceItem) {\n        checkNotNull(resourceItem);\n        resourceItemMap.put(resourceItem.getResourceAbsolutePathInStorage(), resourceItem);\n    }\n\n    public ResourceItem getResourceItem(String resourceAbsolutePathInStorage) {\n        return resourceItemMap.get(resourceAbsolutePathInStorage);\n    }\n"
            }
        ],
        "/root/data_clump_solver/cloned_projects/dolphinscheduler/dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/api/AbstractRemoteTask.java": [
            {
                "fromLine": 45,
                "toLine": 77,
                "oldContent": "\n    /**\n     * If appIds is empty, submit a new remote application; otherwise, just track application status.\n     *\n     * @param taskCallBack\n     * @throws TaskException\n     */\n    @Override\n    public void handle(TaskCallBack taskCallBack) throws TaskException {\n        // if appIds is not empty, just track application status, avoid resubmitting remote task\n        if (StringUtils.isNotEmpty(taskRequest.getAppIds())) {\n            setAppIds(taskRequest.getAppIds());\n            trackApplicationStatus();\n            return;\n        }\n\n        // submit a remote application\n        submitApplication();\n\n        if (StringUtils.isNotEmpty(getAppIds())) {\n            taskRequest.setAppIds(getAppIds());\n            // callback to update remote application info\n            taskCallBack.updateRemoteApplicationInfo(taskRequest.getTaskInstanceId(), new ApplicationInfo(getAppIds()));\n        }\n\n        // keep tracking application status\n        trackApplicationStatus();\n    }\n\n    /**\n     * submit a new remote application and get application info\n     *\n     * @return",
                "newContent": "\n    /**\n     * If appIds is empty, submit a new remote application; otherwise, just track application status.\n     *\n     * @param taskCallBack\n     * @throws TaskException\n     */\n    @Override\n    public void handle(TaskCallBack taskCallBack) throws TaskException {\n        // if appIds is not empty, just track application status, avoid resubmitting remote task\n        if (StringUtils.isNotEmpty(taskRequest.getAppIds())) {\n            setAppIds(taskRequest.getAppIds());\n            trackApplicationStatus();\n            return;\n        }\n\n        // submit a remote application\n        submitApplication();\n\n        if (StringUtils.isNotEmpty(getAppIds())) {\n            taskRequest.setAppIds(getAppIds());\n            // callback to update remote application info\n            taskCallBack.updateRemoteApplicationInfo(taskRequest.getTaskInstanceId(), getAppIds());\n        }\n\n        // keep tracking application status\n        trackApplicationStatus();\n    }\n\n    /**\n     * submit a new remote application and get application info\n     *\n     * @return"
            }
        ],
        "/root/data_clump_solver/cloned_projects/dolphinscheduler/dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/api/loop/BaseLoopTaskExecutor.java": [
            {
                "fromLine": 53,
                "toLine": 105,
                "oldContent": "    protected BaseLoopTaskExecutor(@NonNull TaskExecutionContext taskExecutionContext) {\n        super(taskExecutionContext);\n    }\n\n    @Override\n    public void handle(TaskCallBack taskCallBack) throws TaskException {\n        try {\n            final long loopInterval = getTaskInstanceStatusQueryInterval().toMillis();\n            loopTaskInstanceInfo = submitLoopTask();\n            this.setAppIds(loopTaskInstanceInfo.getTaskInstanceId());\n            taskCallBack.updateRemoteApplicationInfo(taskRequest.getTaskInstanceId(), new ApplicationInfo(getAppIds()));\n\n            // loop the task status until the task is finished or task has been canceled.\n            // we use retry utils here to avoid the task status query failure due to network failure.\n            // the default retry policy is 3 times, and the interval is 1 second.\n            LoopTaskInstanceStatus loopTaskInstanceStatus = null;\n            while (!cancel) {\n                loopTaskInstanceStatus = RetryUtils.retryFunction(() -> queryTaskInstanceStatus(loopTaskInstanceInfo));\n                if (loopTaskInstanceStatus.isFinished()) {\n                    break;\n                }\n                Thread.sleep(loopInterval);\n            }\n            if (loopTaskInstanceStatus != null && loopTaskInstanceStatus.isSuccess()) {\n                setExitStatusCode(TaskConstants.EXIT_CODE_SUCCESS);\n                log.info(\"The task instance: {} execute successfully.\", appIds);\n            } else {\n                setExitStatusCode(TaskConstants.EXIT_CODE_FAILURE);\n                log.info(\"The task instance: {} is execute failure.\", appIds);\n            }\n        } catch (InterruptedException e) {\n            setExitStatusCode(TaskConstants.EXIT_CODE_FAILURE);\n            log.error(\"The current loop thread has been interrupted\", e);\n            Thread.currentThread().interrupt();\n            throw new TaskException(\"The current loop thread has been interrupted\");\n        } catch (TaskException ex) {\n            // print the error message with task log.\n            log.error(\"Loop task execute error\", ex);\n            setExitStatusCode(TaskConstants.EXIT_CODE_FAILURE);\n            throw ex;\n        } catch (Exception ex) {\n            setExitStatusCode(TaskConstants.EXIT_CODE_FAILURE);\n            log.error(\"Loop task execute error\", ex);\n            throw new TaskException(\"Loop task execute error\", ex);\n        }\n    }\n\n    /**\n     * Submit the loop task, if submit failed, directly throw exception\n     */\n    public abstract @NonNull LoopTaskInstanceInfo submitLoopTask() throws TaskException;\n\n    /**",
                "newContent": "    protected BaseLoopTaskExecutor(@NonNull TaskExecutionContext taskExecutionContext) {\n        super(taskExecutionContext);\n    }\n\n    @Override\n    public void handle(TaskCallBack taskCallBack) throws TaskException {\n        try {\n            final long loopInterval = getTaskInstanceStatusQueryInterval().toMillis();\n            loopTaskInstanceInfo = submitLoopTask();\n            this.setAppIds(loopTaskInstanceInfo.getTaskInstanceId());\n            taskCallBack.updateRemoteApplicationInfo(taskRequest.getTaskInstanceId(), getAppIds());\n\n            // loop the task status until the task is finished or task has been canceled.\n            // we use retry utils here to avoid the task status query failure due to network failure.\n            // the default retry policy is 3 times, and the interval is 1 second.\n            LoopTaskInstanceStatus loopTaskInstanceStatus = null;\n            while (!cancel) {\n                loopTaskInstanceStatus = RetryUtils.retryFunction(() -> queryTaskInstanceStatus(loopTaskInstanceInfo));\n                if (loopTaskInstanceStatus.isFinished()) {\n                    break;\n                }\n                Thread.sleep(loopInterval);\n            }\n            if (loopTaskInstanceStatus != null && loopTaskInstanceStatus.isSuccess()) {\n                setExitStatusCode(TaskConstants.EXIT_CODE_SUCCESS);\n            } else {\n                setExitStatusCode(TaskConstants.EXIT_CODE_FAILURE);\n            }\n        } catch (InterruptedException e) {\n            setExitStatusCode(TaskConstants.EXIT_CODE_FAILURE);\n            Thread.currentThread().interrupt();\n            throw new TaskException(\"The current loop thread has been interrupted\");\n        } catch (TaskException ex) {\n            // print the error message with task log.\n            setExitStatusCode(TaskConstants.EXIT_CODE_FAILURE);\n            throw ex;\n        } catch (Exception ex) {\n            setExitStatusCode(TaskConstants.EXIT_CODE_FAILURE);\n            throw new TaskException(\"Loop task execute error\", ex);\n        }\n    }\n\n    /**\n     * Submit the loop task, if submit failed, directly throw exception\n     */\n    public abstract @NonNull LoopTaskInstanceInfo submitLoopTask() throws TaskException;\n\n    /**"
            }
        ],
        "/root/data_clump_solver/cloned_projects/dolphinscheduler/dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/api/parameters/dataquality/DataQualityParameters.java": [
            {
                "fromLine": 65,
                "toLine": 90,
                "oldContent": "\n    /**\n     * In this function ,we need more detailed check every parameter,\n     * if the parameter is non-conformant will return false\n     * @return boolean result\n     */\n    @Override\n    public boolean checkParameters() {\n\n        if (ruleId == 0) {\n            log.error(\"rule id is null\");\n            return false;\n        }\n\n        if (MapUtils.isEmpty(ruleInputParameter)) {\n            log.error(\"rule input parameter is empty\");\n            return false;\n        }\n\n        return sparkParameters != null;\n    }\n\n    @Override\n    public List<ResourceInfo> getResourceFilesList() {\n        return new ArrayList<>();\n    }",
                "newContent": "\n    /**\n     * In this function ,we need more detailed check every parameter,\n     * if the parameter is non-conformant will return false\n     * @return boolean result\n     */\n    @Override\n    public boolean checkParameters() {\n\n        if (ruleId == 0) {\n            return false;\n        }\n\n        if (MapUtils.isEmpty(ruleInputParameter)) {\n            return false;\n        }\n\n        return sparkParameters != null;\n    }\n\n    @Override\n    public List<ResourceInfo> getResourceFilesList() {\n        return new ArrayList<>();\n    }"
            }
        ],
        "/root/data_clump_solver/cloned_projects/dolphinscheduler/dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/api/utils/JdbcUrlParser.java": [
            {
                "fromLine": 98,
                "toLine": 139,
                "oldContent": "        }\n\n        if (database.contains(QUESTION)) {\n            database = database.substring(0, database.indexOf(QUESTION));\n        }\n\n        if (database.contains(SEMICOLON)) {\n            database = database.substring(0, database.indexOf(SEMICOLON));\n        }\n\n        jdbcInfo.setDriverName(driverName);\n        jdbcInfo.setHost(host);\n        jdbcInfo.setPort(port);\n        jdbcInfo.setDatabase(database);\n\n        if (StringUtils.isNotEmpty(params)) {\n            Map<String, String> others = new HashMap<>();\n            String[] paramList = params.split(\"&\");\n            for (String param : paramList) {\n                // handle bad params\n                if (StringUtils.isEmpty(param) || !param.contains(EQUAL_SIGN)) {\n                    continue;\n                }\n                String[] kv = param.split(EQUAL_SIGN);\n                others.put(kv[0], kv[1]);\n            }\n            jdbcInfo.setParams(others);\n        }\n\n        String address = \"jdbc:\" + driverName + \"://\" + host + COLON + port;\n        jdbcInfo.setAddress(address);\n        jdbcInfo.setJdbcUrl(address + SINGLE_SLASH + database);\n\n        return jdbcInfo;\n    }\n}\n",
                "newContent": "        }\n\n        if (database.contains(QUESTION)) {\n            database = database.substring(0, database.indexOf(QUESTION));\n        }\n\n        if (database.contains(SEMICOLON)) {\n            database = database.substring(0, database.indexOf(SEMICOLON));\n        }\n\n        jdbcInfo.setDriverName(driverName);\n        jdbcInfo.setHost(host);\n        jdbcInfo.setPort(port);\n        jdbcInfo.setDatabase(database);\n\n        if (StringUtils.isNotEmpty(params)) {\n            Map<String, String> others = new HashMap<>();\n            String[] paramList = params.split(\"&\");\n            for (String param : paramList) {\n                // handle bad params\n                if (StringUtils.isEmpty(param) || !param.contains(EQUAL_SIGN)) {\n                    continue;\n                }\n                String[] kv = param.split(EQUAL_SIGN);\n                others.put(kv[0], kv[1]);\n            }\n            jdbcInfo.setParams(others);\n        }\n\n        String address = \"jdbc:\" + driverName + \"://\" + host + COLON + port;\n        jdbcInfo.setAddress(address);\n        jdbcInfo.setJdbcUrl(address + SINGLE_SLASH + database);\n\n        return jdbcInfo;\n    }\n"
            }
        ],
        "/root/data_clump_solver/cloned_projects/dolphinscheduler/dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/api/shell/BaseWindowsShellInterceptorBuilder.java": [
            {
                "fromLine": 52,
                "toLine": 92,
                "oldContent": "        finalScripts.addAll(customEnvScript());\n        // add k8s config\n        finalScripts.addAll(k8sConfig());\n        // add shell body\n        finalScripts.add(shellBody());\n        // create shell file\n        String finalScript = finalScripts.stream().collect(Collectors.joining(System.lineSeparator()));\n        Path shellAbsolutePath = shellAbsolutePath();\n        FileUtils.createFileWith755(shellAbsolutePath);\n        Files.write(shellAbsolutePath, finalScript.getBytes(), StandardOpenOption.APPEND);\n        log.info(\"Final Shell file is : \\n{}\", finalScript);\n    }\n\n    private String shellBody() {\n        if (CollectionUtils.isEmpty(scripts)) {\n            return StringUtils.EMPTY;\n        }\n        String scriptBody = scripts\n                .stream()\n                .collect(Collectors.joining(System.lineSeparator()));\n        return ParameterUtils.convertParameterPlaceholders(scriptBody, propertyMap);\n    }\n\n    private Collection<String> k8sConfig() {\n        log.warn(\"k8s config is not supported in windows\");\n        return Collections.emptyList();\n    }\n\n    protected List<String> generateBootstrapCommand() {\n        if (sudoEnable) {\n            log.warn(\"sudo is not supported in windows\");\n        }\n        // todo: support tenant in widnows\n        List<String> bootstrapCommand = new ArrayList<>();\n        bootstrapCommand.add(shellInterpreter());\n        bootstrapCommand.add(shellAbsolutePath().toString());\n        return bootstrapCommand;\n    }\n\n    protected abstract String shellHeader();\n",
                "newContent": "        finalScripts.addAll(customEnvScript());\n        // add k8s config\n        finalScripts.addAll(k8sConfig());\n        // add shell body\n        finalScripts.add(shellBody());\n        // create shell file\n        String finalScript = finalScripts.stream().collect(Collectors.joining(System.lineSeparator()));\n        Path shellAbsolutePath = shellAbsolutePath();\n        FileUtils.createFileWith755(shellAbsolutePath);\n        Files.write(shellAbsolutePath, finalScript.getBytes(), StandardOpenOption.APPEND);\n    }\n\n    private String shellBody() {\n        if (CollectionUtils.isEmpty(scripts)) {\n            return StringUtils.EMPTY;\n        }\n        String scriptBody = scripts\n                .stream()\n                .collect(Collectors.joining(System.lineSeparator()));\n        return ParameterUtils.convertParameterPlaceholders(scriptBody, propertyMap);\n    }\n\n    private Collection<String> k8sConfig() {\n        return Collections.emptyList();\n    }\n\n    protected List<String> generateBootstrapCommand() {\n        if (sudoEnable) {\n        }\n        // todo: support tenant in widnows\n        List<String> bootstrapCommand = new ArrayList<>();\n        bootstrapCommand.add(shellInterpreter());\n        bootstrapCommand.add(shellAbsolutePath().toString());\n        return bootstrapCommand;\n    }\n\n    protected abstract String shellHeader();\n"
            }
        ],
        "/root/data_clump_solver/cloned_projects/dolphinscheduler/dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/api/shell/BaseShellInterceptor.java": [
            {
                "fromLine": 36,
                "toLine": 56,
                "oldContent": "\n    @Override\n    public Process execute() throws IOException {\n        // init process builder\n        ProcessBuilder processBuilder = new ProcessBuilder();\n        // setting up a working directory\n        processBuilder.directory(new File(workingDirectory));\n        // merge error information to standard output stream\n        processBuilder.redirectErrorStream(true);\n        processBuilder.command(executeCommands);\n        log.info(\"Executing shell command : {}\", String.join(\" \", executeCommands));\n        return processBuilder.start();\n    }\n\n}\n",
                "newContent": "\n    @Override\n    public Process execute() throws IOException {\n        // init process builder\n        ProcessBuilder processBuilder = new ProcessBuilder();\n        // setting up a working directory\n        processBuilder.directory(new File(workingDirectory));\n        // merge error information to standard output stream\n        processBuilder.redirectErrorStream(true);\n        processBuilder.command(executeCommands);\n        return processBuilder.start();\n    }\n\n}\n"
            }
        ],
        "/root/data_clump_solver/cloned_projects/dolphinscheduler/dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/api/log/TaskLogDiscriminator.java": [
            {
                "fromLine": 33,
                "toLine": 53,
                "oldContent": "public class TaskLogDiscriminator
{
    "refactorings": {
        "/root/data_clump_solver/cloned_projects/dolphinscheduler/dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/api/log/TaskLogDiscriminator.java": [
            {
                "fromLine": 33,
                "toLine": 53,
                "oldContent": "public class TaskLogDiscriminator extends AbstractDiscriminator<ILoggingEvent> {\n\n    private String key;\n\n    private String logBase;\n\n    @Override\n    public String getDiscriminatingValue(ILoggingEvent event) {\n        String taskInstanceLogPath = MDC.get(LogUtils.TASK_INSTANCE_LOG_FULL_PATH_MDC_KEY);\n        if (taskInstanceLogPath == null) {\n            log.error(\"The task instance log path is null, please check the logback configuration, log: {}\", event);\n        }\n        return taskInstanceLogPath;\n    }\n\n    @Override\n    public void start() {\n        started = true;\n    }\n\n    @Override",
                "newContent": "public class TaskLogDiscriminator extends AbstractDiscriminator<ILoggingEvent> {\n\n    private String key;\n\n    private String logBase;\n\n    @Override\n    public String getDiscriminatingValue(ILoggingEvent event) {\n        String taskInstanceLogPath = MDC.get(LogUtils.TASK_INSTANCE_LOG_FULL_PATH_MDC_KEY);\n        return taskInstanceLogPath;\n    }\n\n    @Override\n    public void start() {\n        started = true;\n    }\n\n    @Override"
            }
        ],
        "/root/data_clump_solver/cloned_projects/dolphinscheduler/dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/api/utils/PropertyUtils.java": [
            {
                "fromLine": 40,
                "toLine": 61,
                "oldContent": "     *\n     * @param startParams startParams\n     * @return startParamList\n     */\n    public static List<Property> startParamsTransformPropertyList(String startParams) {\n        List<Property> startParamList = null;\n        if (startParams != null) {\n            try {\n                Map<String, String> startParamMap = JSONUtils.toMap(startParams);\n                startParamList = startParamMap.entrySet().stream()\n                        .map(entry -> new Property(entry.getKey(), Direct.IN, DataType.VARCHAR, entry.getValue()))\n                        .collect(Collectors.toList());\n            } catch (Exception ignore) {\n                startParamList = JSONUtils.toList(startParams, Property.class);\n            }\n        }\n        return startParamList;\n    }\n\n}\n",
                "newContent": "     *\n     * @param startParams startParams\n     * @return startParamList\n     */\n    public static List<Property> startParamsTransformPropertyList(String startParams) {\n        List<Property> startParamList = null;\n        if (startParams != null) {\n            try {\n                Map<String, String> startParamMap = JSONUtils.toMap(startParams);\n                startParamList = startParamMap.entrySet().stream()\n                        .map(entry -> new Property(entry.getKey(), Direct.IN, DataType.VARCHAR, entry.getValue()))\n                        .collect(Collectors.toList());\n            } catch (Exception ignore) {\n                startParamList = JSONUtils.toList(startParams, Property.class);\n            }\n        }\n        return startParamList;\n    }\n"
            }
        ],
        "/root/data_clump_solver/cloned_projects/dolphinscheduler/dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/api/parser/PlaceholderUtils.java": [
            {
                "fromLine": 87,
                "toLine": 107,
                "oldContent": "        public PropertyPlaceholderResolver(String value, Map<String, String> paramsMap) {\n            this.value = value;\n            this.paramsMap = paramsMap;\n        }\n\n        @Override\n        public String resolvePlaceholder(String placeholderName) {\n            try {\n                return paramsMap.get(placeholderName);\n            } catch (Exception ex) {\n                log.error(\"resolve placeholder '{}' in [ {} ]\", placeholderName, value, ex);\n                return null;\n            }\n        }\n    }\n\n}\n",
                "newContent": "        public PropertyPlaceholderResolver(String value, Map<String, String> paramsMap) {\n            this.value = value;\n            this.paramsMap = paramsMap;\n        }\n\n        @Override\n        public String resolvePlaceholder(String placeholderName) {\n            try {\n                return paramsMap.get(placeholderName);\n            } catch (Exception ex) {\n                return null;\n            }\n        }\n    }\n\n}\n"
            }
        ],
        "/root/data_clump_solver/cloned_projects/dolphinscheduler/dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/api/parameters/ConditionsParameters.java": [
            {
                "fromLine": 34,
                "toLine": 58,
                "oldContent": "@NoArgsConstructor\n@AllArgsConstructor\npublic class ConditionsParameters extends AbstractParameters {\n\n    private ConditionDependency dependence;\n\n    private ConditionResult conditionResult;\n\n    @Override\n    public boolean checkParameters() {\n        if (dependence == null || CollectionUtils.isEmpty(dependence.getDependTaskList())) {\n            return false;\n        }\n        if (conditionResult == null || CollectionUtils.isEmpty(conditionResult.getSuccessNode())\n                || CollectionUtils.isEmpty(conditionResult.getFailedNode())) {\n            return false;\n        }\n        return true;\n    }\n\n    @Data\n    @Builder\n    @NoArgsConstructor\n    @AllArgsConstructor\n    public static class ConditionDependency {",
                "newContent": "@NoArgsConstructor\n@AllArgsConstructor\npublic class ConditionsParameters extends AbstractParameters {\n\n    private ConditionDependency dependence;\n\n    private ConditionResult conditionResult;\n\n    @Override\n    public boolean checkParameters() {\n        if (dependence == null || CollectionUtils.isEmpty(dependence.getDependTaskList())) {\n            return false;\n        }\n        if (conditionResult == null || CollectionUtils.isEmpty(conditionResult.getSuccessNode())\n                || CollectionUtils.isEmpty(conditionResult.getFailedNode())) {\n            return false;\n        }\n        return true;\n    }\n\n    @Data\n    @Builder\n    @NoArgsConstructor\n    @AllArgsConstructor\n    public static class ConditionDependency {"
            }
        ],
        "/root/data_clump_solver/cloned_projects/dolphinscheduler/dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/api/model/DependentItem.java": [
            {
                "fromLine": 32,
                "toLine": 55,
                "oldContent": "    private long definitionCode;\n    private long depTaskCode;\n    private String cycle;\n    private String dateValue;\n    private DependResult dependResult;\n    private TaskExecutionStatus status;\n    private Boolean parameterPassing = false;\n\n    public String getKey() {\n        return String.format(\"%d-%d-%s-%s\",\n                getDefinitionCode(),\n                getDepTaskCode(),\n                getCycle(),\n                getDateValue());\n    }\n\n}\n",
                "newContent": "    private long definitionCode;\n    private long depTaskCode;\n    private String cycle;\n    private String dateValue;\n    private DependResult dependResult;\n    private TaskExecutionStatus status;\n    private Boolean parameterPassing = false;\n\n    public String getKey() {\n        return String.format(\"%d-%d-%s-%s\",\n                definitionCode,\n                depTaskCode,\n                cycle,\n                dateValue);\n    }\n\n}\n"
            }
        ],
        "/root/data_clump_solver/cloned_projects/dolphinscheduler/dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/api/utils/K8sUtils.java": [
            {
                "fromLine": 91,
                "toLine": 112,
                "oldContent": "                podName = pod.getMetadata().getName();\n                if (podName.contains(\"-\") && jobName.equals(podName.substring(0, podName.lastIndexOf(\"-\")))) {\n                    break;\n                }\n            }\n            return client.pods().inNamespace(namespace)\n                    .withName(podName)\n                    .tailingLines(LOG_LINES)\n                    .getLog(Boolean.TRUE);\n        } catch (Exception e) {\n            log.error(\"fail to getPodLog\", e);\n            log.error(\"response bodies : {}\", e.getMessage());\n        }\n        return null;\n    }\n\n    public void buildClient(String configYaml) {\n        try {\n            Config config = Config.fromKubeconfig(configYaml);\n            client = new KubernetesClientBuilder().withConfig(config).build();\n        } catch (Exception e) {\n            throw new TaskException(\"fail to build k8s ApiClient\", e);",
                "newContent": "                podName = pod.getMetadata().getName();\n                if (podName.contains(\"-\") && jobName.equals(podName.substring(0, podName.lastIndexOf(\"-\")))) {\n                    break;\n                }\n            }\n            return client.pods().inNamespace(namespace)\n                    .withName(podName)\n                    .tailingLines(LOG_LINES)\n                    .getLog(Boolean.TRUE);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    public void buildClient(String configYaml) {\n        try {\n            Config config = Config.fromKubeconfig(configYaml);\n            client = new KubernetesClientBuilder().withConfig(config).build();\n        } catch (Exception e) {\n            throw new TaskException(\"fail to build k8s ApiClient\", e);"
            }
        ],
        "/root/data_clump_solver/cloned_projects/dolphinscheduler/dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/api/utils/ProcessUtils.java": [
            {
                "fromLine": 83,
                "toLine": 118,
                "oldContent": "     * Expression of PID recognition in Linux scene\n     */\n    private static final Pattern LINUXPATTERN = Pattern.compile(\"\\\\((\\\\d+)\\\\)\");\n\n    /**\n     * kill tasks according to different task types.\n     */\n    @Deprecated\n    public static boolean kill(@NonNull TaskExecutionContext request) {\n        try {\n            log.info(\"Begin kill task instance, processId: {}\", request.getProcessId());\n            int processId = request.getProcessId();\n            if (processId == 0) {\n                log.error(\"Task instance kill failed, processId is not exist\");\n                return false;\n            }\n\n            String cmd = String.format(\"kill -9 %s\", getPidsStr(processId));\n            cmd = OSUtils.getSudoCmd(request.getTenantCode(), cmd);\n            log.info(\"process id:{}, cmd:{}\", processId, cmd);\n\n            OSUtils.exeCmd(cmd);\n            log.info(\"Success kill task instance, processId: {}\", request.getProcessId());\n            return true;\n        } catch (Exception e) {\n            log.error(\"Kill task instance error, processId: {}\", request.getProcessId(), e);\n            return false;\n        }\n    }\n\n    /**\n     * get pids str.\n     *\n     * @param processId process id\n     * @return pids pid String\n     * @throws Exception exception",
                "newContent": "     * Expression of PID recognition in Linux scene\n     */\n    private static final Pattern LINUXPATTERN = Pattern.compile(\"\\\\((\\\\d+)\\\\)\");\n\n    /**\n     * kill tasks according to different task types.\n     */\n    @Deprecated\n    public static boolean kill(@NonNull TaskExecutionContext request) {\n        try {\n            int processId = request.getProcessId();\n            if (processId == 0) {\n                return false;\n            }\n\n            String cmd = String.format(\"kill -9 %s\", getPidsStr(processId));\n            cmd = OSUtils.getSudoCmd(request.getTenantCode(), cmd);\n\n            OSUtils.exeCmd(cmd);\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    /**\n     * get pids str.\n     *\n     * @param processId process id\n     * @return pids pid String\n     * @throws Exception exception"
            },
            {
                "fromLine": 128,
                "toLine": 148,
                "oldContent": "            rawPidStr = OSUtils.exeCmd(String.format(\"%s -p %d\", TaskConstants.PSTREE, processId));\n        } else {\n            rawPidStr = OSUtils.exeCmd(String.format(\"%s -p %d\", TaskConstants.PSTREE, processId));\n        }\n\n        return parsePidStr(rawPidStr);\n    }\n\n    public static String parsePidStr(String rawPidStr) {\n\n        log.info(\"prepare to parse pid, raw pid string: {}\", rawPidStr);\n        ArrayList<String> allPidList = new ArrayList<>();\n        Matcher mat = null;\n        if (SystemUtils.IS_OS_MAC) {\n            if (StringUtils.isNotEmpty(rawPidStr)) {\n                mat = MACPATTERN.matcher(rawPidStr);\n            }\n        } else if (SystemUtils.IS_OS_LINUX) {\n            if (StringUtils.isNotEmpty(rawPidStr)) {\n                mat = LINUXPATTERN.matcher(rawPidStr);\n            }",
                "newContent": "            rawPidStr = OSUtils.exeCmd(String.format(\"%s -p %d\", TaskConstants.PSTREE, processId));\n        } else {\n            rawPidStr = OSUtils.exeCmd(String.format(\"%s -p %d\", TaskConstants.PSTREE, processId));\n        }\n\n        return parsePidStr(rawPidStr);\n    }\n\n    public static String parsePidStr(String rawPidStr) {\n\n        ArrayList<String> allPidList = new ArrayList<>();\n        Matcher mat = null;\n        if (SystemUtils.IS_OS_MAC) {\n            if (StringUtils.isNotEmpty(rawPidStr)) {\n                mat = MACPATTERN.matcher(rawPidStr);\n            }\n        } else if (SystemUtils.IS_OS_LINUX) {\n            if (StringUtils.isNotEmpty(rawPidStr)) {\n                mat = LINUXPATTERN.matcher(rawPidStr);\n            }"
            },
            {
                "fromLine": 160,
                "toLine": 254,
                "oldContent": "    }\n\n    /**\n     * cancel k8s / yarn application\n     *\n     * @param taskExecutionContext\n     * @return\n     */\n    public static void cancelApplication(TaskExecutionContext taskExecutionContext) {\n        try {\n            if (Objects.nonNull(taskExecutionContext.getK8sTaskExecutionContext())) {\n                if (!TASK_TYPE_SET_K8S.contains(taskExecutionContext.getTaskType())) {\n                    // Set empty container name for Spark on K8S task\n                    applicationManagerMap.get(ResourceManagerType.KUBERNETES)\n                            .killApplication(new KubernetesApplicationManagerContext(\n                                    taskExecutionContext.getK8sTaskExecutionContext(),\n                                    taskExecutionContext.getTaskAppId(), \"\"));\n                }\n            } else {\n                String host = taskExecutionContext.getHost();\n                String executePath = taskExecutionContext.getExecutePath();\n                String tenantCode = taskExecutionContext.getTenantCode();\n                List<String> appIds;\n                if (StringUtils.isNotEmpty(taskExecutionContext.getAppIds())) {\n                    // is failover\n                    appIds = Arrays.asList(taskExecutionContext.getAppIds().split(COMMA));\n                } else {\n                    String logPath = taskExecutionContext.getLogPath();\n                    String appInfoPath = taskExecutionContext.getAppInfoPath();\n                    if (logPath == null || appInfoPath == null || executePath == null || tenantCode == null) {\n                        log.error(\n                                \"Kill yarn job error, the input params is illegal, host: {}, logPath: {}, appInfoPath: {}, executePath: {}, tenantCode: {}\",\n                                host, logPath, appInfoPath, executePath, tenantCode);\n                        throw new TaskException(\"Cancel application failed!\");\n                    }\n                    log.info(\"Get appIds from worker {}, taskLogPath: {}\", host, logPath);\n                    appIds = LogUtils.getAppIds(logPath, appInfoPath,\n                            PropertyUtils.getString(APPID_COLLECT, DEFAULT_COLLECT_WAY));\n                    taskExecutionContext.setAppIds(String.join(TaskConstants.COMMA, appIds));\n                }\n                if (CollectionUtils.isEmpty(appIds)) {\n                    log.info(\"The appId is empty\");\n                    return;\n                }\n                ApplicationManager applicationManager = applicationManagerMap.get(ResourceManagerType.YARN);\n                applicationManager.killApplication(new YarnApplicationManagerContext(executePath, tenantCode, appIds));\n            }\n        } catch (Exception e) {\n            log.error(\"Cancel application failed: {}\", e.getMessage());\n        }\n    }\n\n    /**\n     * get k8s application status\n     *\n     * @param k8sTaskExecutionContext\n     * @param taskAppId\n     * @return\n     */\n    public static TaskExecutionStatus getApplicationStatus(K8sTaskExecutionContext k8sTaskExecutionContext,\n                                                           String taskAppId) {\n        if (Objects.isNull(k8sTaskExecutionContext)) {\n            return TaskExecutionStatus.SUCCESS;\n        }\n        KubernetesApplicationManager applicationManager =\n                (KubernetesApplicationManager) applicationManagerMap.get(ResourceManagerType.KUBERNETES);\n        return applicationManager\n                .getApplicationStatus(new KubernetesApplicationManagerContext(k8sTaskExecutionContext, taskAppId, \"\"));\n    }\n\n    /**\n     * get driver pod logs\n     *\n     * @param k8sTaskExecutionContext\n     * @param taskAppId\n     * @return\n     */\n    public static LogWatch getPodLogWatcher(K8sTaskExecutionContext k8sTaskExecutionContext, String taskAppId,\n                                            String containerName) {\n        KubernetesApplicationManager applicationManager =\n                (KubernetesApplicationManager) applicationManagerMap.get(ResourceManagerType.KUBERNETES);\
{
    "refactorings": {
        "/root/data_clump_solver/cloned_projects/dolphinscheduler/dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/api/utils/ProcessUtils.java": [
            {
                "fromLine": 160,
                "toLine": 254,
                "oldContent": "    }\n\n    /**\n     * cancel k8s / yarn application\n     *\n     * @param taskExecutionContext\n     * @return\n     */\n    public static void cancelApplication(TaskExecutionContext taskExecutionContext) {\n        try {\n            if (Objects.nonNull(taskExecutionContext.getK8sTaskExecutionContext())) {\n                if (!TASK_TYPE_SET_K8S.contains(taskExecutionContext.getTaskType())) {\n                    // Set empty container name for Spark on K8S task\n                    applicationManagerMap.get(ResourceManagerType.KUBERNETES)\n                            .killApplication(new KubernetesApplicationManagerContext(\n                                    taskExecutionContext.getK8sTaskExecutionContext(),\n                                    taskExecutionContext.getTaskAppId(), \"\"));\n                }\n            } else {\n                String host = taskExecutionContext.getHost();\n                String executePath = taskExecutionContext.getExecutePath();\n                String tenantCode = taskExecutionContext.getTenantCode();\n                List<String> appIds;\n                if (StringUtils.isNotEmpty(taskExecutionContext.getAppIds())) {\n                    // is failover\n                    appIds = Arrays.asList(taskExecutionContext.getAppIds().split(COMMA));\n                } else {\n                    String logPath = taskExecutionContext.getLogPath();\n                    String appInfoPath = taskExecutionContext.getAppInfoPath();\n                    if (logPath == null || appInfoPath == null || executePath == null || tenantCode == null) {\n                        log.error(\n                                \"Kill yarn job error, the input params is illegal, host: {}, logPath: {}, appInfoPath: {}, executePath: {}, tenantCode: {}\",\n                                host, logPath, appInfoPath, executePath, tenantCode);\n                        throw new TaskException(\"Cancel application failed!\");\n                    }\n                    log.info(\"Get appIds from worker {}, taskLogPath: {}\", host, logPath);\n                    appIds = LogUtils.getAppIds(logPath, appInfoPath,\n                            PropertyUtils.getString(APPID_COLLECT, DEFAULT_COLLECT_WAY));\n                    taskExecutionContext.setAppIds(String.join(TaskConstants.COMMA, appIds));\n                }\n                if (CollectionUtils.isEmpty(appIds)) {\n                    log.info(\"The appId is empty\");\n                    return;\n                }\n                ApplicationManager applicationManager = applicationManagerMap.get(ResourceManagerType.YARN);\n                applicationManager.killApplication(new YarnApplicationManagerContext(executePath, tenantCode, appIds));\n            }\n        } catch (Exception e) {\n            log.error(\"Cancel application failed: {}\", e.getMessage());\n        }\n    }\n\n    /**\n     * get k8s application status\n     *\n     * @param k8sTaskExecutionContext\n     * @param taskAppId\n     * @return\n     */\n    public static TaskExecutionStatus getApplicationStatus(K8sTaskExecutionContext k8sTaskExecutionContext,\n                                                           String taskAppId) {\n        if (Objects.isNull(k8sTaskExecutionContext)) {\n            return TaskExecutionStatus.SUCCESS;\n        }\n        KubernetesApplicationManager applicationManager =\n                (KubernetesApplicationManager) applicationManagerMap.get(ResourceManagerType.KUBERNETES);\n        return applicationManager\n                .getApplicationStatus(new KubernetesApplicationManagerContext(k8sTaskExecutionContext, taskAppId, \"\"));\n    }\n\n    /**\n     * get driver pod logs\n     *\n     * @param k8sTaskExecutionContext\n     * @param taskAppId\n     * @return\n     */\n    public static LogWatch getPodLogWatcher(K8sTaskExecutionContext k8sTaskExecutionContext, String taskAppId,\n                                            String containerName) {\n        KubernetesApplicationManager applicationManager =\n                (KubernetesApplicationManager) applicationManagerMap.get(ResourceManagerType.KUBERNETES);\n\n        return applicationManager\n                .getPodLogWatcher(\n                        new KubernetesApplicationManagerContext(k8sTaskExecutionContext, taskAppId, containerName));\n    }\n\n    public static void removeK8sClientCache(String taskAppId) {\n        KubernetesApplicationManager applicationManager =\n                (KubernetesApplicationManager) applicationManagerMap.get(ResourceManagerType.KUBERNETES);\n        applicationManager.removeCache(taskAppId);\n    }\n}\n",
                "newContent": "    }\n\n    /**\n     * cancel k8s / yarn application\n     *\n     * @param taskExecutionContext\n     * @return\n     */\n    public static void cancelApplication(TaskExecutionContext taskExecutionContext) {\n        try {\n            if (Objects.nonNull(taskExecutionContext.getK8sTaskExecutionContext())) {\n                if (!TASK_TYPE_SET_K8S.contains(taskExecutionContext.getTaskType())) {\n                    // Set empty container name for Spark on K8S task\n                    applicationManagerMap.get(ResourceManagerType.KUBERNETES)\n                            .killApplication(new KubernetesApplicationManagerContext(\n                                    taskExecutionContext.getK8sTaskExecutionContext(),\n                                    taskExecutionContext.getTaskAppId(), \"\"));\n                }\n            } else {\n                String host = taskExecutionContext.getHost();\n                String executePath = taskExecutionContext.getExecutePath();\n                String tenantCode = taskExecutionContext.getTenantCode();\n                List<String> appIds;\n                if (StringUtils.isNotEmpty(taskExecutionContext.getAppIds())) {\n                    // is failover\n                    appIds = Arrays.asList(taskExecutionContext.getAppIds().split(COMMA));\n                } else {\n                    String logPath = taskExecutionContext.getLogPath();\n                    String appInfoPath = taskExecutionContext.getAppInfoPath();\n                    if (logPath == null || appInfoPath == null || executePath == null || tenantCode == null) {\n                        throw new TaskException(\"Cancel application failed!\");\n                    }\n                    appIds = LogUtils.getAppIds(logPath, appInfoPath,\n                            PropertyUtils.getString(APPID_COLLECT, DEFAULT_COLLECT_WAY));\n                    taskExecutionContext.setAppIds(String.join(TaskConstants.COMMA, appIds));\n                }\n                if (CollectionUtils.isEmpty(appIds)) {\n                    return;\n                }\n                ApplicationManager applicationManager = applicationManagerMap.get(ResourceManagerType.YARN);\n                applicationManager.killApplication(new YarnApplicationManagerContext(executePath, tenantCode, appIds));\n            }\n        } catch (Exception e) {\n        }\n    }\n\n    /**\n     * get k8s application status\n     *\n     * @param k8sTaskExecutionContext\n     * @param taskAppId\n     * @return\n     */\n    public static TaskExecutionStatus getApplicationStatus(K8sTaskExecutionContext k8sTaskExecutionContext,\n                                                           String taskAppId) {\n        if (Objects.isNull(k8sTaskExecutionContext)) {\n            return TaskExecutionStatus.SUCCESS;\n        }\n        KubernetesApplicationManager applicationManager =\n                (KubernetesApplicationManager) applicationManagerMap.get(ResourceManagerType.KUBERNETES);\n        return applicationManager\n                .getApplicationStatus(new KubernetesApplicationManagerContext(k8sTaskExecutionContext, taskAppId, \"\"));\n    }\n\n    /**\n     * get driver pod logs\n     *\n     * @param k8sTaskExecutionContext\n     * @param taskAppId\n     * @return\n     */\n    public static LogWatch getPodLogWatcher(K8sTaskExecutionContext k8sTaskExecutionContext, String taskAppId,\n                                            String containerName) {\n        KubernetesApplicationManager applicationManager =\n                (KubernetesApplicationManager) applicationManagerMap.get(ResourceManagerType.KUBERNETES);\n\n        return applicationManager\n                .getPodLogWatcher(\n                        new KubernetesApplicationManagerContext(k8sTaskExecutionContext, taskAppId, containerName));\n    }\n\n    public static void removeK8sClientCache(String taskAppId) {\n        KubernetesApplicationManager applicationManager =\n                (KubernetesApplicationManager) applicationManagerMap.get(ResourceManagerType.KUBERNETES);\n        applicationManager.removeCache(taskAppId);\n    }\n}\n"
            }
        ],
        "/root/data_clump_solver/cloned_projects/dolphinscheduler/dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/api/shell/BaseLinuxShellInterceptorBuilder.java": [
            {
                "fromLine": 54,
                "toLine": 74,
                "oldContent": "        finalScripts.addAll(customEnvScript());\n        // add k8s config\n        finalScripts.addAll(k8sConfig());\n        // add shell body\n        finalScripts.add(shellBody());\n        // create shell file\n        String finalScript = finalScripts.stream().collect(Collectors.joining(System.lineSeparator()));\n        Path shellAbsolutePath = shellAbsolutePath();\n        FileUtils.createFileWith755(shellAbsolutePath);\n        Files.write(shellAbsolutePath, finalScript.getBytes(), StandardOpenOption.APPEND);\n        log.info(\n                \"Final Shell file is: \\n****************************** Script Content *****************************************************************\"\n                        +\n                        \"{}\" +\n                        \"\\n****************************** Script Content *****************************************************************\",\n                finalScript);\n    }\n\n    protected List<String> generateBootstrapCommand() {\n        if (sudoEnable) {\n            return bootstrapCommandInSudoMode();",
                "newContent": "        finalScripts.addAll(customEnvScript());\n        // add k8s config\n        finalScripts.addAll(k8sConfig());\n        // add shell body\n        finalScripts.add(shellBody());\n        // create shell file\n        String finalScript = finalScripts.stream().collect(Collectors.joining(System.lineSeparator()));\n        Path shellAbsolutePath = shellAbsolutePath();\n        FileUtils.createFileWith755(shellAbsolutePath);\n        Files.write(shellAbsolutePath, finalScript.getBytes(), StandardOpenOption.APPEND);\n    }\n\n    protected List<String> generateBootstrapCommand() {\n        if (sudoEnable) {\n            return bootstrapCommandInSudoMode();"
            },
            {
                "fromLine": 98,
                "toLine": 118,
                "oldContent": "        return customEnvScripts;\n    }\n\n    private List<String> k8sConfig() throws IOException {\n        if (StringUtils.isEmpty(k8sConfigYaml)) {\n            return Collections.emptyList();\n        }\n        Path kubeConfigPath = Paths.get(FileUtils.getKubeConfigPath(shellDirectory));\n        FileUtils.createFileWith755(kubeConfigPath);\n        Files.write(kubeConfigPath, k8sConfigYaml.getBytes(), StandardOpenOption.APPEND);\n        log.info(\"Created kubernetes configuration file: {}.\", kubeConfigPath);\n        return Collections.singletonList(\"export KUBECONFIG=\" + kubeConfigPath);\n    }\n\n    private String shellBody() {\n        if (CollectionUtils.isEmpty(scripts)) {\n            return StringUtils.EMPTY;\n        }\n        String scriptBody = scripts\n                .stream()\n                .collect(Collectors.joining(System.lineSeparator()));",
                "newContent": "        return customEnvScripts;\n    }\n\n    private List<String> k8sConfig() throws IOException {\n        if (StringUtils.isEmpty(k8sConfigYaml)) {\n            return Collections.emptyList();\n        }\n        Path kubeConfigPath = Paths.get(FileUtils.getKubeConfigPath(shellDirectory));\n        FileUtils.createFileWith755(kubeConfigPath);\n        Files.write(kubeConfigPath, k8sConfigYaml.getBytes(), StandardOpenOption.APPEND);\n        return Collections.singletonList(\"export KUBECONFIG=\" + kubeConfigPath);\n    }\n\n    private String shellBody() {\n        if (CollectionUtils.isEmpty(scripts)) {\n            return StringUtils.EMPTY;\n        }\n        String scriptBody = scripts\n                .stream()\n                .collect(Collectors.joining(System.lineSeparator()));"
            }
        ],
        "/root/data_clump_solver/cloned_projects/dolphinscheduler/dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/api/utils/VarPoolUtils.java": [
            {
                "fromLine": 41,
                "toLine": 61,
                "oldContent": "    }\n\n    /**\n     * @see #mergeVarPool(List)\n     */\n    public String mergeVarPoolJsonString(List<String> varPoolJsons) {\n        if (CollectionUtils.isEmpty(varPoolJsons)) {\n            return null;\n        }\n        List<List<Property>> varPools = varPoolJsons.stream()\n                .map(VarPoolUtils::deserializeVarPool)\n                .collect(Collectors.toList());\n        List<Property> finalVarPool = mergeVarPool(varPools);\n        return JSONUtils.toJsonString(finalVarPool);\n    }\n\n    /**\n     * Merge the given two varpools, and return the merged varpool.\n     * If the two varpools have the same property({@link Property#getProp()} and {@link Property#getDirect()} is same), the value of the property in varpool2 will be used.\n     * // todo: we may need to consider the datatype of the property\n     */",
                "newContent": "    }\n\n    /**\n     * @see #mergeVarPool(List)\n     */\n    public String mergeVarPoolJsonString(List<String> varPoolJsons) {\n        if (CollectionUtils.isEmpty(varPoolJsons)) {\n            return null;\n        }\n        List<List<Property>> varPools = varPoolJsons.stream()\n                .map(VarPoolUtils::deserializeVarPool)\n                .collect(Collectors.toList());\n        List<Property> finalVarPool = mergeVarPool(varPools);\n        return JSONUtils.toJsonString(finalVarPool);\n    }\n\n    /**\n     * Merge the given two varpools, and return the merged varpool.\n     * If the two varpools have the same property({@link Property#getProp()} and {@link Property#getDirect()} is same), the value of the property in varpool2 will be used.\n     * // todo: we may need to consider the datatype of the property\n     */"
            },
            {
                "fromLine": 65,
                "toLine": 122,
                "oldContent": "        }\n        if (varPools.size() == 1) {\n            return varPools.get(0);\n        }\n        Map<String, Property> result = new HashMap<>();\n        for (List<Property> varPool : varPools) {\n            if (CollectionUtils.isEmpty(varPool)) {\n                continue;\n            }\n            for (Property property : varPool) {\n                if (!Direct.OUT.equals(property.getDirect())) {\n                    log.info(\"The direct should be OUT in varPool, but got {}\", property.getDirect());\n                    continue;\n                }\n                result.put(property.getProp(), property);\n            }\n        }\n        return new ArrayList<>(result.values());\n    }\n\n    public String subtractVarPoolJson(String varPool, List<String> subtractVarPool) {\n        List<Property> varPoolList = deserializeVarPool(varPool);\n        List<List<Property>> subtractVarPoolList = subtractVarPool.stream()\n                .map(VarPoolUtils::deserializeVarPool)\n                .collect(Collectors.toList());\n        List<Property> finalVarPool = subtractVarPool(varPoolList, subtractVarPoolList);\n        return JSONUtils.toJsonString(finalVarPool);\n    }\n\n    /**\n     * Return the subtracted varpool, which key is in varPool but not in subtractVarPool.\n     */\n    public List<Property> subtractVarPool(List<Property> varPool, List<List<Property>> subtractVarPool) {\n        if (CollectionUtils.isEmpty(varPool)) {\n            return null;\n        }\n        if (CollectionUtils.isEmpty(subtractVarPool)) {\n            return varPool;\n        }\n        Map<String, Property> subtractVarPoolMap = new HashMap<>();\n        for (List<Property> properties : subtractVarPool) {\n            for (Property property : properties) {\n                subtractVarPoolMap.put(property.getProp(), property);\n            }\n        }\n        List<Property> result = new ArrayList<>();\n        for (Property property : varPool) {\n            if (!subtractVarPoolMap.containsKey(property.getProp())) {\n                result.add(property);\n            }\n        }\n        return result;\n    }\n\n}\n",
                "newContent": "        }\n        if (varPools.size() == 1) {\n            return varPools.get(0);\n        }\n        Map<String, Property> result = new HashMap<>();\n        for (List<Property> varPool : varPools) {\n            if (CollectionUtils.isEmpty(varPool)) {\n                continue;\n            }\n            for (Property property : varPool) {\n                if (!Direct.OUT.equals(property.getDirect())) {\n                    continue;\n                }\n                result.put(property.getProp(), property);\n            }\n        }\n        return new ArrayList<>(result.values());\n    }\n\n    public String subtractVarPoolJson(String varPool, List<String> subtractVarPool) {\n        List<Property> varPoolList = deserializeVarPool(varPool);\n        List<List<Property>> subtractVarPoolList = subtractVarPool.stream()\n                .map(VarPoolUtils::deserializeVarPool)\n                .collect(Collectors.toList());\n        List<Property> finalVarPool = subtractVarPool(varPoolList, subtractVarPoolList);\n        return JSONUtils.toJsonString(finalVarPool);\n    }\n\n    /**\n     * Return the subtracted varpool, which key is in varPool but not in subtractVarPool.\n     */\n    public List<Property> subtractVarPool(List<Property> varPool, List<List<Property>> subtractVarPool) {\n        if (CollectionUtils.isEmpty(varPool)) {\n            return null;\n        }\n        if (CollectionUtils.isEmpty(subtractVarPool)) {\n            return varPool;\n        }\n        Map<String, Property> subtractVarPoolMap = new HashMap<>();\n        for (List<Property> properties : subtractVarPool) {\n            for (Property property : properties) {\n                subtractVarPoolMap.put(property.getProp(), property);\n            }\n        }\n        List<Property> result = new ArrayList<>();\n        for (Property property : varPool) {\n            if (!subtractVarPool
{
    "refactorings": {
        "/root/data_clump_solver/cloned_projects/dolphinscheduler/dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/api/utils/VarPoolUtils.java": [
            {
                "fromLine": 65,
                "toLine": 122,
                "oldContent": "        }\n        if (varPools.size() == 1) {\n            return varPools.get(0);\n        }\n        Map<String, Property> result = new HashMap<>();\n        for (List<Property> varPool : varPools) {\n            if (CollectionUtils.isEmpty(varPool)) {\n                continue;\n            }\n            for (Property property : varPool) {\n                if (!Direct.OUT.equals(property.getDirect())) {\n                    continue;\n                }\n                result.put(property.getProp(), property);\n            }\n        }\n        return new ArrayList<>(result.values());\n    }\n\n    public String subtractVarPoolJson(String varPool, List<String> subtractVarPool) {\n        List<Property> varPoolList = deserializeVarPool(varPool);\n        List<List<Property>> subtractVarPoolList = subtractVarPool.stream()\n                .map(VarPoolUtils::deserializeVarPool)\n                .collect(Collectors.toList());\n        List<Property> finalVarPool = subtractVarPool(varPoolList, subtractVarPoolList);\n        return JSONUtils.toJsonString(finalVarPool);\n    }\n\n    /**\n     * Return the subtracted varpool, which key is in varPool but not in subtractVarPool.\n     */\n    public List<Property> subtractVarPool(List<Property> varPool, List<List<Property>> subtractVarPool) {\n        if (CollectionUtils.isEmpty(varPool)) {\n            return null;\n        }\n        if (CollectionUtils.isEmpty(subtractVarPool)) {\n            return varPool;\n        }\n        Map<String, Property> subtractVarPoolMap = new HashMap<>();\n        for (List<Property> properties : subtractVarPool) {\n            for (Property property : properties) {\n                subtractVarPoolMap.put(property.getProp(), property);\n            }\n        }\n        List<Property> result = new ArrayList<>();\n        for (Property property : varPool) {\n            if (!subtractVarPoolMap.containsKey(property.getProp())) {\n                result.add(property);\n            }\n        }\n        return result;\n    }\n\n}\n",
                "newContent": "        }\n        if (varPools.size() == 1) {\n            return varPools.get(0);\n        }\n        Map<String, Property> result = new HashMap<>();\n        for (List<Property> varPool : varPools) {\n            if (CollectionUtils.isEmpty(varPool)) {\n                continue;\n            }\n            for (Property property : varPool) {\n                if (!Direct.OUT.equals(property.getDirect())) {\n                    continue;\n                }\n                result.put(property.getProp(), property);\n            }\n        }\n        return new ArrayList<>(result.values());\n    }\n\n    public String subtractVarPoolJson(String varPool, List<String> subtractVarPool) {\n        List<Property> varPoolList = deserializeVarPool(varPool);\n        List<List<Property>> subtractVarPoolList = subtractVarPool.stream()\n                .map(VarPoolUtils::deserializeVarPool)\n                .collect(Collectors.toList());\n        List<Property> finalVarPool = subtractVarPool(varPoolList, subtractVarPoolList);\n        return JSONUtils.toJsonString(finalVarPool);\n    }\n\n    /**\n     * Return the subtracted varpool, which key is in varPool but not in subtractVarPool.\n     */\n    public List<Property> subtractVarPool(List<Property> varPool, List<List<Property>> subtractVarPool) {\n        if (CollectionUtils.isEmpty(varPool)) {\n            return null;\n        }\n        if (CollectionUtils.isEmpty(subtractVarPool)) {\n            return varPool;\n        }\n        Map<String, Property> subtractVarPoolMap = new HashMap<>();\n        for (List<Property> properties : subtractVarPool) {\n            for (Property property : properties) {\n                subtractVarPoolMap.put(property.getProp(), property);\n            }\n        }\n        List<Property> result = new ArrayList<>();\n        for (Property property : varPool) {\n            if (!subtractVarPoolMap.containsKey(property.getProp())) {\n                result.add(property);\n            }\n        }\n        return result;\n    }\n\n}\n"
            }
        ]
    }
}