{
    "refactorings": {
        "/root/data_clump_solver/cloned_projects/dolphinscheduler/dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/api/model/TaskAlertInfo.java": [
            {
                "fromLine": 40,
                "toLine": 64,
                "oldContent": "    }\n\n    public Integer getAlertGroupId() {\n        return alertGroupId;\n    }\n\n    public void setAlertGroupId(Integer alertGroupId) {\n        this.alertGroupId = alertGroupId;\n    }\n\n    public String getContent() {\n        return content;\n    }\n\n    public void setContent(String content) {\n        this.content = content;\n    }\n}\n",
                "newContent": "    private String title;\n    private String content;\n    private Integer alertGroupId;\n\n    public String getTitle() {\n        return title;\n    }\n\n    public void setTitle(String title) {\n        this.title = title;\n    }\n\n    public String getContent() {\n        return content;\n    }\n\n    public void setContent(String content) {\n        this.content = content;\n    }\n\n    public Integer getAlertGroupId() {\n        return alertGroupId;\n    }\n\n    public void setAlertGroupId(Integer alertGroupId) {\n        this.alertGroupId = alertGroupId;\n    }\n}\n"
            }
        ],
        "/root/data_clump_solver/cloned_projects/dolphinscheduler/dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/api/parser/TimePlaceholderUtils.java": [
            {
                "fromLine": 316,
                "toLine": 336,
                "oldContent": "        public TimePlaceholderResolver(String value, Date date) {\n            this.value = value;\n            this.date = date;\n        }\n\n        @Override\n        public String resolvePlaceholder(String placeholderName) {\n            try {\n                return calculateTime(placeholderName, date);\n            } catch (Exception ex) {\n                log.error(\"resolve placeholder '{}' in [ {} ]\", placeholderName, value, ex);\n                return null;\n            }\n        }\n    }\n\n    /**\n     * return the formatted date according to the corresponding date format\n     *\n     * @param expression date expression\n     * @param date       date",
                "newContent": "        public TimePlaceholderResolver(String value, Date date) {\n            this.value = value;\n            this.date = date;\n        }\n\n        @Override\n        public String resolvePlaceholder(String placeholderName) {\n            try {\n                return calculateTime(placeholderName, date);\n            } catch (Exception ex) {\n                // log.error(\"resolve placeholder '{}' in [ {} ]\", placeholderName, value, ex);\n                return null;\n            }\n        }\n    }\n\n    /**\n     * return the formatted date according to the corresponding date format\n     *\n     * @param expression date expression\n     * @param date       date"
            }
        ],
        "/root/data_clump_solver/cloned_projects/dolphinscheduler/dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/api/parser/PropertyPlaceholderHelper.java": [
            {
                "fromLine": 151,
                "toLine": 172,
                "oldContent": "                        if (propVal == null) {\n                            propVal = defaultValue;\n                        }\n                    }\n                }\n                if (propVal != null) {\n                    // Recursive invocation, parsing placeholders contained in the\n                    // previously resolved placeholder value.\n                    propVal = parseStringValue(propVal, placeholderResolver, visitedPlaceholders);\n                    result.replace(startIndex, endIndex + this.placeholderSuffix.length(), propVal);\n                    if (log.isTraceEnabled()) {\n                        log.trace(\"Resolved placeholder '\" + placeholder + \"'\");\n                    }\n                    startIndex = result.indexOf(this.placeholderPrefix, startIndex + propVal.length());\n                } else if (this.ignoreUnresolvablePlaceholders) {\n                    // Proceed with unprocessed value.\n                    startIndex = result.indexOf(this.placeholderPrefix, endIndex + this.placeholderSuffix.length());\n                } else {\n                    throw new IllegalArgumentException(\"Could not resolve placeholder '\"\n                            + placeholder + \"'\" + \" in value \\\"\" + value + \"\\\"\");\n                }\n                visitedPlaceholders.remove(originalPlaceholder);",
                "newContent": "                        if (propVal == null) {\n                            propVal = defaultValue;\n                        }\n                    }\n                }\n                if (propVal != null) {\n                    // Recursive invocation, parsing placeholders contained in the\n                    // previously resolved placeholder value.\n                    propVal = parseStringValue(propVal, placeholderResolver, visitedPlaceholders);\n                    result.replace(startIndex, endIndex + this.placeholderSuffix.length(), propVal);\n                    // if (log.isTraceEnabled()) {\n                    //     log.trace(\"Resolved placeholder '\" + placeholder + \"'\");\n                    // }\n                    startIndex = result.indexOf(this.placeholderPrefix, startIndex + propVal.length());\n                } else if (this.ignoreUnresolvablePlaceholders) {\n                    // Proceed with unprocessed value.\n                    startIndex = result.indexOf(this.placeholderPrefix, endIndex + this.placeholderSuffix.length());\n                } else {\n                    throw new IllegalArgumentException(\"Could not resolve placeholder '\"\n                            + placeholder + \"'\" + \" in value \\\"\" + value + \"\\\"\");\n                }\n                visitedPlaceholders.remove(originalPlaceholder);"
            }
        ],
        "/root/data_clump_solver/cloned_projects/dolphinscheduler/dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/api/parameters/AbstractParameters.java": [
            {
                "fromLine": 60,
                "toLine": 123,
                "oldContent": "\n    @Override\n    public List<ResourceInfo> getResourceFilesList() {\n        return new ArrayList<>();\n    }\n\n    public Map<String, Property> getLocalParametersMap() {\n        Map<String, Property> localParametersMaps = new LinkedHashMap<>();\n        if (localParams != null) {\n            for (Property property : localParams) {\n                localParametersMaps.put(property.getProp(), property);\n            }\n        }\n        return localParametersMaps;\n    }\n\n    public K8sTaskExecutionContext generateK8sTaskExecutionContext(ResourceParametersHelper parametersHelper,\n                                                                   int datasource) {\n        DataSourceParameters dataSourceParameters =\n                (DataSourceParameters) parametersHelper.getResourceParameters(ResourceType.DATASOURCE, datasource);\n        K8sTaskExecutionContext k8sTaskExecutionContext = new K8sTaskExecutionContext();\n        k8sTaskExecutionContext.setConnectionParams(\n                Objects.nonNull(dataSourceParameters) ? dataSourceParameters.getConnectionParams() : null);\n        return k8sTaskExecutionContext;\n    }\n\n    /**\n     * get input local parameters map if the param direct is IN\n     *\n     * @return parameters map\n     */\n    public Map<String, Property> getInputLocalParametersMap() {\n        Map<String, Property> localParametersMaps = new LinkedHashMap<>();\n        if (localParams != null) {\n            for (Property property : localParams) {\n                // The direct of some tasks is empty, default IN\n                if (property.getDirect() == null || Objects.equals(Direct.IN, property.getDirect())) {\n                    localParametersMaps.put(property.getProp(), property);\n                }\n            }\n        }\n        return localParametersMaps;\n    }\n\n    /**\n     * get varPool map\n     *\n     * @return parameters map\n     */\n    public Map<String, Property> getVarPoolMap() {\n        Map<String, Property> varPoolMap = new LinkedHashMap<>();\n        if (varPool != null) {\n            for (Property property : varPool) {\n                varPoolMap.put(property.getProp(), property);\n            }\n        }\n        return varPoolMap;\n    }\n\n    public void setVarPool(String varPool) {\n        if (StringUtils.isEmpty(varPool)) {\n            this.varPool = new ArrayList<>();\n        } else {\n            this.varPool = JSONUtils.toList(varPool, Property.class);",
                "newContent": "\n    @Override\n    public List<ResourceInfo> getResourceFilesList() {\n        return new ArrayList<>();\n    }\n\n    public Map<String, Property> getLocalParametersMap() {\n        Map<String, Property> localParametersMaps = new LinkedHashMap<>();\n        if (localParams != null) {\n            for (Property property : localParams) {\n                localParametersMaps.put(property.getProp(), property);\n            }\n        }\n        return localParametersMaps;\n    }\n\n    public K8sTaskExecutionContext generateK8sTaskExecutionContext(ResourceParametersHelper parametersHelper,\n                                                                   int datasource) {\n        DataSourceParameters dataSourceParameters =\n                (DataSourceParameters) parametersHelper.getResourceParameters(ResourceType.DATASOURCE, datasource);\n        K8sTaskExecutionContext k8sTaskExecutionContext = new K8sTaskExecutionContext();\n        // k8sTaskExecutionContext.setConnectionParams(\n        //        Objects.nonNull(dataSourceParameters) ? dataSourceParameters.getConnectionParams() : null);\n        return k8sTaskExecutionContext;\n    }\n\n    /**\n     * get input local parameters map if the param direct is IN\n     *\n     * @return parameters map\n     */\n    public Map<String, Property> getInputLocalParametersMap() {\n        Map<String, Property> localParametersMaps = new LinkedHashMap<>();\n        if (localParams != null) {\n            for (Property property : localParams) {\n                // The direct of some tasks is empty, default IN\n                if (property.getDirect() == null || Objects.equals(Direct.IN, property.getDirect())) {\n                    localParametersMaps.put(property.getProp(), property);\n                }\n            }\n        }\n        return localParametersMaps;\n    }\n\n    /**\n     * get varPool map\n     *\n     * @return parameters map\n     */\n    public Map<String, Property> getVarPoolMap() {\n        Map<String, Property> varPoolMap = new LinkedHashMap<>();\n        if (varPool != null) {\n            for (Property property : varPool) {\n                varPoolMap.put(property.getProp(), property);\n            }\n        }\n        return varPoolMap;\n    }\n\n    public void setVarPool(String varPool) {\n        if (StringUtils.isEmpty(varPool)) {\n            this.varPool = new ArrayList<>();\n        } else {\n            this.varPool = JSONUtils.toList(varPool, Property.class);"
            }
        ],
        "/root/data_clump_solver/cloned_projects/dolphinscheduler/dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/api/AbstractTask.java": [
            {
                "fromLine": 154,
                "toLine": 174,
                "oldContent": "     * log handle\n     *\n     * @param logs log list\n     */\n    public void logHandle(LinkedBlockingQueue<String> logs) {\n\n        StringJoiner joiner = new StringJoiner(\"\\n\\t\");\n        while (!logs.isEmpty()) {\n            joiner.add(logs.poll());\n        }\n        log.info(\" -> {}\", joiner);\n    }\n\n    /**\n     * regular expressions match the contents between two specified strings\n     *\n     * @param content content\n     * @param sqlParamsMap sql params map\n     * @param paramsPropsMap params props map\n     */\n    public void setSqlParamsMap(String content, Map<Integer, Property> sqlParamsMap,",
                "newContent": "     * log handle\n     *\n     * @param logs log list\n     */\n    public void logHandle(LinkedBlockingQueue<String> logs) {\n\n        StringJoiner joiner = new StringJoiner(\"\\n\\t\");\n        while (!logs.isEmpty()) {\n            joiner.add(logs.poll());\n        }\n        // log.info(\" -> {}\", joiner);\n    }\n\n    /**\n     * regular expressions match the contents between two specified strings\n     *\n     * @param content content\n     * @param sqlParamsMap sql params map\n     * @param paramsPropsMap params props map\n     */\n    public void setSqlParamsMap(String content, Map<Integer, Property> sqlParamsMap,"
            }
        ],
        "/root/data_clump_solver/cloned_projects/dolphinscheduler/dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/api/resource/ResourceContext.java": [
            {
                "fromLine": 35,
                "toLine": 55,
                "oldContent": "     * ResourceAbsolutePathInStorage -> ResourceItem\n     */\n    private final Map<String, ResourceItem> resourceItemMap;\n\n    public ResourceContext() {\n        this.resourceItemMap = new HashMap<>();\n    }\n\n    public void addResourceItem(ResourceItem resourceItem) {\n        checkNotNull(resourceItem);\n        resourceItemMap.put(resourceItem.getResourceAbsolutePathInStorage(), resourceItem);\n    }\n\n    public ResourceItem getResourceItem(String resourceAbsolutePathInStorage) {\n        ResourceItem resourceItem = resourceItemMap.get(resourceAbsolutePathInStorage);\n        if (resourceItem == null) {\n            throw new IllegalArgumentException(\"Cannot find the resourceItem: \" + resourceAbsolutePathInStorage);\n        }\n        return resourceItem;\n    }\n",
                "newContent": "     * ResourceAbsolutePathInStorage -> ResourceItem\n     */\n    private final Map<String, ResourceItem> resourceItemMap;\n\n    public ResourceContext() {\n        this.resourceItemMap = new HashMap<>();\n    }\n\n    public void addResourceItem(ResourceItem resourceItem) {\n        checkNotNull(resourceItem);\n        // resourceItemMap.put(resourceItem.getResourceAbsolutePathInStorage(), resourceItem);\n    }\n\n    public ResourceItem getResourceItem(String resourceAbsolutePathInStorage) {\n        ResourceItem resourceItem = resourceItemMap.get(resourceAbsolutePathInStorage);\n        if (resourceItem == null) {\n            throw new IllegalArgumentException(\"Cannot find the resourceItem: \" + resourceAbsolutePathInStorage);\n        }\n        return resourceItem;\n    }\n"
            }
        ],
        "/root/data_clump_solver/cloned_projects/dolphinscheduler/dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/api/AbstractRemoteTask.java": [
            {
                "fromLine": 45,
                "toLine": 77,
                "oldContent": "\n    /**\n     * If appIds is empty, submit a new remote application; otherwise, just track application status.\n     *\n     * @param taskCallBack\n     * @throws TaskException\n     */\n    @Override\n    public void handle(TaskCallBack taskCallBack) throws TaskException {\n        // if appIds is not empty, just track application status, avoid resubmitting remote task\n        if (StringUtils.isNotEmpty(taskRequest.getAppIds())) {\n            setAppIds(taskRequest.getAppIds());\n            trackApplicationStatus();\n            return;\n        }\n\n        // submit a remote application\n        submitApplication();\n\n        if (StringUtils.isNotEmpty(getAppIds())) {\n            taskRequest.setAppIds(getAppIds());\n            // callback to update remote application info\n            taskCallBack.updateRemoteApplicationInfo(taskRequest.getTaskInstanceId(), new ApplicationInfo(getAppIds()));\n        }\n\n        // keep tracking application status\n        trackApplicationStatus();\n    }\n\n    /**\n     * submit a new remote application and get application info\n     *\n     * @return",
                "newContent": "\n    /**\n     * If appIds is empty, submit a new remote application; otherwise, just track application status.\n     *\n     * @param taskCallBack\n     * @throws TaskException\n     */\n    @Override\n    public void handle(TaskCallBack taskCallBack) throws TaskException {\n        // if appIds is not empty, just track application status, avoid resubmitting remote task\n        if (StringUtils.isNotEmpty(taskRequest.getAppIds())) {\n            setAppIds(taskRequest.getAppIds());\n            trackApplicationStatus();\n            return;\n        }\n\n        // submit a remote application\n        submitApplication();\n\n        if (StringUtils.isNotEmpty(getAppIds())) {\n            taskRequest.setAppIds(getAppIds());\n            // callback to update remote application info\n            // taskCallBack.updateRemoteApplicationInfo(taskRequest.getTaskInstanceId(), new ApplicationInfo(getAppIds()));\n        }\n\n        // keep tracking application status\n        trackApplicationStatus();\n    }\n\n    /**\n     * submit a new remote application and get application info\n     *\n     * @return"
            }
        ],
        "/root/data_clump_solver/cloned_projects/dolphinscheduler/dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/api/loop/BaseLoopTaskExecutor.java": [
            {
                "fromLine": 53,
                "toLine": 105,
                "oldContent": "    protected BaseLoopTaskExecutor(@NonNull TaskExecutionContext taskExecutionContext) {\n        super(taskExecutionContext);\n    }\n\n    @Override\n    public void handle(TaskCallBack taskCallBack) throws TaskException {\n        try {\n            final long loopInterval = getTaskInstanceStatusQueryInterval().toMillis();\n            loopTaskInstanceInfo = submitLoopTask();\n            this.setAppIds(loopTaskInstanceInfo.getTaskInstanceId());\n            taskCallBack.updateRemoteApplicationInfo(taskRequest.getTaskInstanceId(), new ApplicationInfo(getAppIds()));\n\n            // loop the task status until the task is finished or task has been canceled.\n            // we use retry utils here to avoid the task status query failure due to network failure.\n            // the default retry policy is 3 times, and the interval is 1 second.\n            LoopTaskInstanceStatus loopTaskInstanceStatus = null;\n            while (!cancel) {\n                loopTaskInstanceStatus = RetryUtils.retryFunction(() -> queryTaskInstanceStatus(loopTaskInstanceInfo));\n                if (loopTaskInstanceStatus.isFinished()) {\n                    break;\n                }\n                Thread.sleep(loopInterval);\n            }\n            if (loopTaskInstanceStatus != null && loopTaskInstanceStatus.isSuccess()) {\n                setExitStatusCode(TaskConstants.EXIT_CODE_SUCCESS);\n                log.info(\"The task instance: {} execute successfully.\", appIds
                { "fromLine": 53,
                  "toLine": 105,
                  "oldContent": "    protected BaseLoopTaskExecutor(@NonNull TaskExecutionContext taskExecutionContext) {\n        super(taskExecutionContext);\n    }\n\n    @Override\n    public void handle(TaskCallBack taskCallBack) throws TaskException {\n        try {\n            final long loopInterval = getTaskInstanceStatusQueryInterval().toMillis();\n            loopTaskInstanceInfo = submitLoopTask();\n            this.setAppIds(loopTaskInstanceInfo.getTaskInstanceId());\n            taskCallBack.updateRemoteApplicationInfo(taskRequest.getTaskInstanceId(), new ApplicationInfo(getAppIds()));\n\n            // loop the task status until the task is finished or task has been canceled.\n            // we use retry utils here to avoid the task status query failure due to network failure.\n            // the default retry policy is 3 times, and the interval is 1 second.\n            LoopTaskInstanceStatus loopTaskInstanceStatus = null;\n            while (!cancel) {\n                loopTaskInstanceStatus = RetryUtils.retryFunction(() -> queryTaskInstanceStatus(loopTaskInstanceInfo));\n                if (loopTaskInstanceStatus.isFinished()) {\n                    break;\n                }\n                Thread.sleep(loopInterval);\n            }\n            if (loopTaskInstanceStatus != null && loopTaskInstanceStatus.isSuccess()) {\n                setExitStatusCode(TaskConstants.EXIT_CODE_SUCCESS);\n                log.info(\"The task instance: {} execute successfully.\", appIds);\n            } else {\n                setExitStatusCode(TaskConstants.EXIT_CODE_FAILURE);\n                log.info(\"The task instance: {} is execute failure.\", appIds);\n            }\n        } catch (InterruptedException e) {\n            setExitStatusCode(TaskConstants.EXIT_CODE_FAILURE);\n            log.error(\"The current loop thread has been interrupted\", e);\n            Thread.currentThread().interrupt();\n            throw new TaskException(\"The current loop thread has been interrupted\");\n        } catch (TaskException ex) {\n            // print the error message with task log.\n            log.error(\"Loop task execute error\", ex);\n            setExitStatusCode(TaskConstants.EXIT_CODE_FAILURE);\n            throw ex;\n        } catch (Exception ex) {\n            setExitStatusCode(TaskConstants.EXIT_CODE_FAILURE);\n            log.error(\"Loop task execute error\", ex);\n            throw new TaskException(\"Loop task execute error\", ex);\n        }\n    }\n\n    /**\n     * Submit the loop task, if submit failed, directly throw exception\n     */\n    public abstract @NonNull LoopTaskInstanceInfo submitLoopTask() throws TaskException;\n\n    /**",
                  "newContent": "    protected BaseLoopTaskExecutor(@NonNull TaskExecutionContext taskExecutionContext) {\n        super(taskExecutionContext);\n    }\n\n    @Override\n    public void handle(TaskCallBack taskCallBack) throws TaskException {\n        try {\n            final long loopInterval = getTaskInstanceStatusQueryInterval().toMillis();\n            loopTaskInstanceInfo = submitLoopTask();\n            this.setAppIds(loopTaskInstanceInfo.getTaskInstanceId());\n            // taskCallBack.updateRemoteApplicationInfo(taskRequest.getTaskInstanceId(), new ApplicationInfo(getAppIds()));\n\n            // loop the task status until the task is finished or task has been canceled.\n            // we use retry utils here to avoid the task status query failure due to network failure.\n            // the default retry policy is 3 times, and the interval is 1 second.\n            LoopTaskInstanceStatus loopTaskInstanceStatus = null;\n            while (!cancel) {\n                loopTaskInstanceStatus = RetryUtils.retryFunction(() -> queryTaskInstanceStatus(loopTaskInstanceInfo));\n                if (loopTaskInstanceStatus.isFinished()) {\n                    break;\n                }\n                Thread.sleep(loopInterval);\n            }\n            if (loopTaskInstanceStatus != null && loopTaskInstanceStatus.isSuccess()) {\n                setExitStatusCode(TaskConstants.EXIT_CODE_SUCCESS);\n                // log.info(\"The task instance: {} execute successfully.\", appIds);\n            } else {\n                setExitStatusCode(TaskConstants.EXIT_CODE_FAILURE);\n                // log.info(\"The task instance: {} is execute failure.\", appIds);\n            }\n        } catch (InterruptedException e) {\n            setExitStatusCode(TaskConstants.EXIT_CODE_FAILURE);\n            // log.error(\"The current loop thread has been interrupted\", e);\n            Thread.currentThread().interrupt();\n            throw new TaskException(\"The current loop thread has been interrupted\");\n        } catch (TaskException ex) {\n            // print the error message with task log.\n            // log.error(\"Loop task execute error\", ex);\n            setExitStatusCode(TaskConstants.EXIT_CODE_FAILURE);\n            throw ex;\n        } catch (Exception ex) {\n            setExitStatusCode(TaskConstants.EXIT_CODE_FAILURE);\n            // log.error(\"Loop task execute error\", ex);\n            throw new TaskException(\"Loop task execute error\", ex);\n        }\n    }\n\n    /**\n     * Submit the loop task, if submit failed, directly throw exception\n     */\n    public abstract @NonNull LoopTaskInstanceInfo submitLoopTask() throws TaskException;\n\n    /**"
                }
           			