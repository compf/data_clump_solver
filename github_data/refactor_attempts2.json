{"codellama":{"0.1":["This is a Java class named TraversalUtils, which provides utility methods for traversing and manipulating the AST (Abstract Syntax Tree) of a programming language. The class is part of the PMD (PHP Mess Detector) project, which is an open-source tool for analyzing and improving the quality of PHP code.\n\nThe methods provided by this class are used to traverse the AST in different ways, such as finding the first parent or child node that matches a certain condition, counting the number of children that match a given filter, or iterating over all children that match a specific filter.\n\nSome of the key features of this class include:\n\n* The ability to find the first parent or child node that matches a certain condition using the `getFirstParentOrSelfMatching` and `getFirstChildMatching` methods. These methods take a Node object as input, a Filtermap object that defines the condition for matching nodes, and an index range within the Node's children to search.\n* The ability to find all children that match a specific filter using the `findChildrenMatching` method. This method takes a Node object as input, a Filtermap object that defines the condition for matching nodes, an index range within the Node's children to search, and an optional maximum size of the returned list.\n* The ability to count the number of children that match a specific filter using the `countChildrenMatching` method. This method takes a Node object as input, a Filtermap object that defines the condition for matching nodes, and an index range within the Node's children to search.\n* The ability to iterate over all children that match a specific filter using the `childrenIterator` method. This method takes a Node object as input, a Filtermap object that defines the condition for matching nodes, and an index range within the Node's children to search.\n\nOverall, this class provides a convenient way to traverse and manipulate the AST of a programming language, making it easier to write code that can analyze and improve the quality of PHP code.",[" This is a Java class that provides utility methods for traversing and searching the AST (Abstract Syntax Tree) of a programming language. The class is named `TraversalUtils` and it is located in the `net.sourceforge.pmd.lang.ast.internal` package.","","The class contains several static methods that can be used to perform various tasks related to traversing the AST, such as finding the first parent or child node that matches a given filter, counting the number of children that match a given filter, and iterating over the children of a node.","","Here is an example of how these methods can be used:","```","Node root = ...; // get the root node of the AST","Filtermap<Node, MyNodeType> filter = new Filtermap<Node, MyNodeType>() {","    @Override","    public MyNodeType apply(Node node) {","        if (node instanceof MyNodeType) {","            return (MyNodeType) node;","        } else {","            return null;","        }","    }","};","","// find the first parent or child node that matches the filter","MyNodeType matchingNode = TraversalUtils.getFirstParentOrSelfMatching(root, filter);","","// count the number of children that match the filter","int numChildren = TraversalUtils.countChildrenMatching(root, filter, 0, root.getNumChildren());","","// iterate over the children of a node","Iterator<Node> iterator = TraversalUtils.childrenIterator(root, 0, root.getNumChildren());","while (iterator.hasNext()) {","    Node child = iterator.next();","    // do something with the child node","}","```","The `Filtermap` interface is used to define a filter that can be applied to nodes in the AST. In this example, we define a filter that checks if a node is an instance of a specific type (in this case, `MyNodeType`). The `apply` method of the filter returns `null` if the node does not match the filter, and the node itself if it does.","","The `getFirstParentOrSelfMatching` method finds the first parent or child node that matches the given filter. It starts at the root node and iterates over its children until it finds a matching node. If no matching node is found, the method returns `null`.","","The `countChildrenMatching` method counts the number of children of a node that match a given filter. It takes three arguments: the parent node, the starting index of the range of children to check (inclusive), and the ending index of the range of children to check (exclusive). The method returns the number of matching children.","","The `childrenIterator` method creates an iterator over the children of a node that matches a given filter. It takes three arguments: the parent node, the starting index of the range of children to iterate over (inclusive), and the ending index of the range of children to iterate over (exclusive). The iterator returns `null` if there are no more matching children.","","Note that these methods can be used in a variety of ways depending on the specific needs of your application. For example, you may want to use the `getFirstParentOrSelfMatching` method to find the first parent or child node that matches a given filter, and then perform some action on that node. You may also want to use the `countChildrenMatching` method to count the number of children that match a given filter, and then use the `childrenIterator` method to iterate over those children and perform an action on each one."],["","The data clump in this code is the set of parameters and fields that are used by multiple methods or classes. In this case, the `from`, `to` and `maxSize` parameters in the `findChildrenMatching` method are used by both the `countChildrenMatching` method and the `childrenIterator` method.","","To refactor this data clump, we can extract these parameters into a separate class called `TraversalUtils.Parameters`. This class will contain the fields and methods that are used by multiple methods in the `TraversalUtils` class.","","Here is an example of how the refactored code might look like:","```java","package net.sourceforge.pmd.lang.ast.internal;","","import java.util.ArrayList;","import java.util.Collections;","import java.util.Iterator;","import java.util.List;","","import org.checkerframework.checker.nullness.qual.NonNull;","","import net.sourceforge.pmd.lang.ast.Node;","","final class TraversalUtils {","","    /*","        Note that the methods of this class must not use node streams","        to iterate on children, because node streams are implemented","        using these methods.","     */","","    private TraversalUtils() {","","    }","","    static <T extends Node> T getFirstParentOrSelfMatching(final Node node, final Filtermap<? super Node, ? extends T> filter) {","        Node n = node;","        while (n != null) {","            T t = filter.apply(n);","            if (t != null) {","                return t;","            }","            n = n.getParent();","        }","        return null;","    }","","    static <T extends Node> T getFirstChildMatching(final Node node, final Filtermap<? super Node, ? extends T> filter, int from, int len) {","        for (int i = from, last = from + len; i < last; i++) {","            Node c = node.getChild(i);","            T t = filter.apply(c);","            if (t != null) {","                return t;","            }","        }","        return null;","    }","","    static <T extends Node> T getLastChildMatching(final Node node, final Filtermap<? super Node, ? extends T> filter, int from, int len) {","        for (int i = from + len - 1; i >= from; i--) {","            Node c = node.getChild(i);","            T t = filter.apply(c);","            if (t != null) {","                return t;","            }","        }","        return null;","    }","","    static <T> List<T> findChildrenMatching(final Node node, final Filtermap<? super Node, ? extends T> filter, int from, int len) {","        return findChildrenMatching(node, filter, from, len, TraversalUtils.Parameters.DEFAULT_MAX_SIZE);","    }","","    static <T> List<T> findChildrenMatching(final Node node, final Filtermap<? super Node, ? extends T> filter, int from, int len, int maxSize) {","        List<T> list = new ArrayList<>();","        for (int i = from, last = from + len; i < last; i++) {","            Node c = node.getChild(i);","            T t = filter.apply(c);","            if (t != null) {","                list.add(t);","                if (list.size() >= maxSize) {","                    return list;","                }","            }","        }","        return list;","    }","","    static int countChildrenMatching(final Node node, final Filtermap<Node, ?> filter, int from, int len) {","        int sum = 0;","        for (int i = from, last = from + len; i < last; i++) {","            Node c = node.getChild(i);","            T t = filter.apply(c);","            if (t != null) {","                sum++;","            }","        }","        return sum;","    }","","","    static Iterator<Node> childrenIterator(Node parent, final int from, final int to) {","        assert parent != null : \"parent should not be null\";","        assert from >= 0 && from <= parent.getNumChildren() : \"'from' should be a valid index\";","        assert to >= 0 && to <= parent.getNumChildren() : \"'to' should be a valid index\";","        assert from <= to : \"'from' should be lower than 'to'\";","","        if (to == from) {","            return Collections.emptyIterator();","        }","","        return new Iterator<Node>() {","","            private int i = from;","","            @Override","            public boolean hasNext() {","                return i < to;","            }","","            @Override","            public @NonNull","            Node next() {","                return parent.getChild(i++);","            }","        };","    }","","}","```","In this refactored code, the `TraversalUtils.Parameters` class contains the fields and methods that are used by multiple methods in the `TraversalUtils` class. The `findChildrenMatching` method now takes an additional `maxSize` parameter that specifies the maximum number of children to return.","","The benefits of this refactoring include:","","* Improved readability: By extracting the data clump into a separate class, the code becomes more readable and easier to understand.","* Reduced duplication: The `TraversalUtils` class now has fewer methods that are responsible for different tasks, which reduces the amount of code that needs to be maintained.","* Improved maintainability: By extracting the data clump into a separate class, it becomes easier to make changes to the code without affecting other parts of the system."],["","The data clump in this code is the set of parameters and fields that are used by multiple methods or classes. In this case, the parameters `from` and `to` are used by both the `childrenIterator()` method and the `countChildrenMatching()` method. These two methods have a common parameter list, which makes them part of the same data clump.","","To refactor this code, we can extract the common parameters into an instance of a new class called `Range`. This will allow us to reuse the `Range` instance in both methods, reducing code duplication and improving readability.","","Here's the updated code with the extracted class:","```java","package net.sourceforge.pmd.lang.ast.internal;","","import java.util.ArrayList;","import java.util.Collections;","import java.util.Iterator;","import java.util.List;","","import org.checkerframework.checker.nullness.qual.NonNull;","","import net.sourceforge.pmd.lang.ast.Node;","","final class TraversalUtils {","","    /*","        Note that the methods of this class must not use node streams","        to iterate on children, because node streams are implemented","        using these methods.","     */","","    private TraversalUtils() {","","    }","","    static <T extends Node> T getFirstParentOrSelfMatching(final Node node, final Filtermap<? super Node, ? extends T> filter) {","        Node n = node;","        while (n != null) {","            T t = filter.apply(n);","            if (t != null) {","                return t;","            }","            n = n.getParent();","        }","        return null;","    }","","    static <T extends Node> T getFirstChildMatching(final Node node, final Filtermap<? super Node, ? extends T> filter, int from, int len) {","        for (int i = from, last = from + len; i < last; i++) {","            Node c = node.getChild(i);","            T t = filter.apply(c);","            if (t != null) {","                return t;","            }","        }","        return null;","    }","","    static <T extends Node> T getLastChildMatching(final Node node, final Filtermap<? super Node, ? extends T> filter, int from, int len) {","        for (int i = from + len - 1; i >= from; i--) {","            Node c = node.getChild(i);","            T t = filter.apply(c);","            if (t != null) {","                return t;","            }","        }","        return null;","    }","","    static <T> List<T> findChildrenMatching(final Node node, final Filtermap<? super Node, ? extends T> filter, int from, int len) {","        return findChildrenMatching(node, filter, new Range(from, to));","    }","","    static <T extends Node> int countChildrenMatching(final Node node, final Filtermap<Node, T> filter, int from, int len) {","        int sum = 0;","        for (int i = from, last = from + len; i < last; i++) {","            Node c = node.getChild(i);","            T t = filter.apply(c);","            if (t != null) {","                sum++;","            }","        }","        return sum;","    }","","    static Iterator<Node> childrenIterator(Node parent, final int from, final int to) {","        assert parent != null : \"parent should not be null\";","        assert from >= 0 && from <= parent.getNumChildren() : \"'from' should be a valid index\";","        assert to >= 0 && to <= parent.getNumChildren() : \"'to' should be a valid index\";","        assert from <= to : \"'from' should be lower than 'to'\";","","        if (to == from) {","            return Collections.emptyIterator();","        }","","        return new Iterator<Node>() {","","            private int i = from;","","            @Override","            public boolean hasNext() {","                return i < to;","            }","","            @Override","            public @NonNull","            Node next() {","                return parent.getChild(i++);","            }","        };","    }","","}","","class Range {","    private final int from;","    private final int to;","","    public Range(int from, int to) {","        this.from = from;","        this.to = to;","    }","","    public int getFrom() {","        return from;","    }","","    public int getTo() {","        return to;","    }","}","```"],["","The data clump in this code is the set of parameters and fields that are common to multiple methods or classes, which are used to perform some operation on a node tree. The extracted class would be `NodeTraversal`, which would have the following methods:","```java","public static <T extends Node> T getFirstParentOrSelfMatching(final Node node, final Filtermap<? super Node, ? extends T> filter) {","    return TraversalUtils.getFirstParentOrSelfMatching(node, filter);","}","","public static <T extends Node> T getFirstChildMatching(final Node node, final Filtermap<? super Node, ? extends T> filter, int from, int len) {","    return TraversalUtils.getFirstChildMatching(node, filter, from, len);","}","","public static <T extends Node> T getLastChildMatching(final Node node, final Filtermap<? super Node, ? extends T> filter, int from, int len) {","    return TraversalUtils.getLastChildMatching(node, filter, from, len);","}","","public static <T> List<T> findChildrenMatching(final Node node, final Filtermap<? super Node, ? extends T> filter, int from, int len) {","    return TraversalUtils.findChildrenMatching(node, filter, from, len);","}","","public static <T> List<T> findChildrenMatching(final Node node, final Filtermap<? super Node, ? extends T> filter, int from, int len, int maxSize) {","    return TraversalUtils.findChildrenMatching(node, filter, from, len, maxSize);","}","","public static <T extends Node> int countChildrenMatching(final Node node, final Filtermap<Node, T> filter, int from, int len) {","    return TraversalUtils.countChildrenMatching(node, filter, from, len);","}","```","The extracted class would also have a constructor that takes the `Filtermap` as an argument and stores it in a field for later use.","","Here is the content of the extracted class:","```java","public class NodeTraversal {","    private final Filtermap<? super Node, ? extends T> filter;","","    public NodeTraversal(Filtermap<? super Node, ? extends T> filter) {","        this.filter = filter;","    }","","    public static <T extends Node> T getFirstParentOrSelfMatching(final Node node, final Filtermap<? super Node, ? extends T> filter) {","        return TraversalUtils.getFirstParentOrSelfMatching(node, filter);","    }","","    public static <T extends Node> T getFirstChildMatching(final Node node, final Filtermap<? super Node, ? extends T> filter, int from, int len) {","        return TraversalUtils.getFirstChildMatching(node, filter, from, len);","    }","","    public static <T extends Node> T getLastChildMatching(final Node node, final Filtermap<? super Node, ? extends T> filter, int from, int len) {","        return TraversalUtils.getLastChildMatching(node, filter, from, len);","    }","","    public static <T> List<T> findChildrenMatching(final Node node, final Filtermap<? super Node, ? extends T> filter, int from, int len) {","        return TraversalUtils.findChildrenMatching(node, filter, from, len);","    }","","    public static <T> List<T> findChildrenMatching(final Node node, final Filtermap<? super Node, ? extends T> filter, int from, int len, int maxSize) {","        return TraversalUtils.findChildrenMatching(node, filter, from, len, maxSize);","    }","","    public static <T extends Node> int countChildrenMatching(final Node node, final Filtermap<Node, T> filter, int from, int len) {","        return TraversalUtils.countChildrenMatching(node, filter, from, len);","    }","}","```"],["","The data clump in this code is the set of parameters and fields that are used by multiple methods, which are `from`, `to`, and `parent` in the `childrenIterator` method. These parameters are used to iterate over the children of a node, and they are common to all three methods.","","To refactor this data clump, we can extract it into its own class, called `ChildrenIteratorParams`. This class will contain the fields and methods that are used by multiple methods in the `TraversalUtils` class.","","Here is an example of how the refactored code might look:","```","class ChildrenIteratorParams {","    private int from;","    private int to;","    private Node parent;","","    public ChildrenIteratorParams(int from, int to, Node parent) {","        this.from = from;","        this.to = to;","        this.parent = parent;","    }","","    public int getFrom() {","        return from;","    }","","    public int getTo() {","        return to;","    }","","    public Node getParent() {","        return parent;","    }","}","```","We can then update the `TraversalUtils` class to use this new class instead of the original parameters. Here is an example of how the refactored code might look:","```","class TraversalUtils {","","    private static final ChildrenIteratorParams DEFAULT_PARAMS = new ChildrenIteratorParams(0, Integer.MAX_VALUE, null);","","    public static Iterator<Node> childrenIterator(Node parent) {","        return childrenIterator(parent, DEFAULT_PARAMS);","    }","","    public static Iterator<Node> childrenIterator(Node parent, int from, int to) {","        return childrenIterator(parent, new ChildrenIteratorParams(from, to, parent));","    }","","    private static Iterator<Node> childrenIterator(Node parent, ChildrenIteratorParams params) {","        assert parent != null : \"parent should not be null\";","        assert params.getFrom() >= 0 && params.getFrom() <= parent.getNumChildren() : \"'from' should be a valid index\";","        assert params.getTo() >= 0 && params.getTo() <= parent.getNumChildren() : \"'to' should be a valid index\";","        assert params.getFrom() <= params.getTo() : \"'from' should be lower than 'to'\";","","        if (params.getTo() == params.getFrom()) {","            return Collections.emptyIterator();","        }","","        return new Iterator<Node>() {","","            private int i = params.getFrom();","","            @Override","            public boolean hasNext() {","                return i < params.getTo();","            }","","            @Override","            public Node next() {","                return parent.getChild(i++);","            }","        };","    }","}","```","In this refactored code, we have extracted the data clump into its own class called `ChildrenIteratorParams`, which contains the fields and methods that are used by multiple methods in the `TraversalUtils` class. We have also updated the `TraversalUtils` class to use this new class instead of the original parameters. This makes the code more modular and easier to maintain, as we can now make changes to the data clump without affecting other parts of the code."],["","The data clump in this code is the set of parameters and fields that are used by multiple methods, which are `from`, `to`, and `parent` in the `childrenIterator` method. These parameters are used to iterate over the children of a node, and they are common to all three methods.","","To refactor this data clump, we can extract it into its own class, called `ChildrenIteratorParams`. This class will contain the fields and methods that are used by multiple methods in the `TraversalUtils` class.","","Here is an example of how the refactored code might look:","```","class ChildrenIteratorParams {","    private int from;","    private int to;","    private Node parent;","","    public ChildrenIteratorParams(int from, int to, Node parent) {","        this.from = from;","        this.to = to;","        this.parent = parent;","    }","","    public int getFrom() {","        return from;","    }","","    public int getTo() {","        return to;","    }","","    public Node getParent() {","        return parent;","    }","}","```","The `ChildrenIteratorParams` class contains the fields and methods that are used by multiple methods in the `TraversalUtils` class. The constructor takes three parameters, which are assigned to the corresponding fields of the class. The `getFrom`, `getTo`, and `getParent` methods return the values of these fields.","","In the `childrenIterator` method, we can replace the use of the `from`, `to`, and `parent` parameters with an instance of the `ChildrenIteratorParams` class. This will allow us to reuse the code for iterating over children in multiple methods, while still allowing each method to have its own set of parameters.","```","class TraversalUtils {","    // ...","","    static Iterator<Node> childrenIterator(Node parent, int from, int to) {","        return new ChildrenIteratorParams(from, to, parent).iterator();","    }","","    // ...","}","```","In this example, we create a new instance of the `ChildrenIteratorParams` class with the `from`, `to`, and `parent` parameters, and then call the `iterator` method on that instance. This will return an iterator over the children of the node, starting from the `from` index and ending at the `to` index.","","The content of the extracted class is as follows:","```","class ChildrenIteratorParams {","    private int from;","    private int to;","    private Node parent;","","    public ChildrenIteratorParams(int from, int to, Node parent) {","        this.from = from;","        this.to = to;","        this.parent = parent;","    }","","    public int getFrom() {","        return from;","    }","","    public int getTo() {","        return to;","    }","","    public Node getParent() {","        return parent;","    }","}","```"],["","The data clump in this code is the set of parameters `from`, `to` and `filter` that are used together in multiple methods, such as `childrenIterator`. These parameters are not related to each other and do not have a logical connection.","","To refactor this data clump, we can extract it into its own class, which will contain the common fields and methods for working with nodes. This will make the code more modular and easier to maintain.","","Here is an example of how we can extract the data clump:","```","public class NodeTraversal {","    private int from;","    private int to;","    private Filtermap<Node, T> filter;","","    public NodeTraversal(int from, int to, Filtermap<Node, T> filter) {","        this.from = from;","        this.to = to;","        this.filter = filter;","    }","","    public Iterator<Node> childrenIterator(Node parent) {","        assert parent != null : \"parent should not be null\";","        assert from >= 0 && from <= parent.getNumChildren() : \"'from' should be a valid index\";","        assert to >= 0 && to <= parent.getNumChildren() : \"'to' should be a valid index\";","        assert from <= to : \"'from' should be lower than 'to'\";","","        if (to == from) {","            return Collections.emptyIterator();","        }","","        return new Iterator<Node>() {","","            private int i = from;","","            @Override","            public boolean hasNext() {","                return i < to;","            }","","            @Override","            public @NonNull","            Node next() {","                return parent.getChild(i++);","            }","        };","    }","}","```","In this example, we have extracted the data clump into its own class `NodeTraversal`, which contains the fields and methods for working with nodes. The constructor takes the same parameters as the original methods, and the `childrenIterator` method is implemented in a similar way to the original method, but now it uses the `from`, `to` and `filter` fields from the `NodeTraversal` class.","","We can then use this extracted class in our code like this:","```","public class TraversalUtils {","    private static final NodeTraversal nodeTraversal = new NodeTraversal(0, Integer.MAX_VALUE, null);","","    public static <T extends Node> T getFirstParentOrSelfMatching(final Node node, final Filtermap<? super Node, ? extends T> filter) {","        return nodeTraversal.getFirstParentOrSelfMatching(node, filter);","    }","","    public static <T extends Node> T getFirstChildMatching(final Node node, final Filtermap<? super Node, ? extends T> filter, int from, int len) {","        return nodeTraversal.getFirstChildMatching(node, filter, from, len);","    }","","    public static <T extends Node> int countChildrenMatching(final Node node, final Filtermap<Node, T> filter, int from, int len) {","        return nodeTraversal.countChildrenMatching(node, filter, from, len);","    }","}","```","In this example, we have used the extracted `NodeTraversal` class in our code by creating a static instance of it and using its methods to implement the original methods. This makes the code more modular and easier to maintain, as the data clump is now contained in its own class."],["","The data clump in this code is the set of parameters and fields that are used by multiple methods, which are `from`, `to`, and `parent` in the `childrenIterator` method. These parameters are not used by any other methods in the class, and they are only used to iterate over the children of a node.","","To refactor this data clump, we can extract it into its own class, which will contain the fields and methods that are used by multiple methods in the class. Here is an example of how we could do this:","```","class ChildrenIteratorParams {","    private int from;","    private int to;","    private Node parent;","","    public ChildrenIteratorParams(int from, int to, Node parent) {","        this.from = from;","        this.to = to;","        this.parent = parent;","    }","","    public int getFrom() {","        return from;","    }","","    public int getTo() {","        return to;","    }","","    public Node getParent() {","        return parent;","    }","}","```","We can then update the `childrenIterator` method to use an instance of this class instead of the individual parameters:","```","static Iterator<Node> childrenIterator(ChildrenIteratorParams params) {","    assert params.getParent() != null : \"parent should not be null\";","    assert params.getFrom() >= 0 && params.getFrom() <= params.getParent().getNumChildren() : \"'from' should be a valid index\";","    assert params.getTo() >= 0 && params.getTo() <= params.getParent().getNumChildren() : \"'to' should be a valid index\";","    assert params.getFrom() <= params.getTo() : \"'from' should be lower than 'to'\";","","    if (params.getTo() == params.getFrom()) {","        return Collections.emptyIterator();","    }","","    return new Iterator<Node>() {","","        private int i = params.getFrom();","","        @Override","        public boolean hasNext() {","            return i < params.getTo();","        }","","        @Override","        public Node next() {","            return params.getParent().getChild(i++);","        }","    };","}","```","We can also update the other methods that use these parameters to use an instance of this class instead:","```","static <T extends Node> T getFirstParentOrSelfMatching(final Node node, final Filtermap<? super Node, ? extends T> filter) {","    ChildrenIteratorParams params = new ChildrenIteratorParams(0, node.getNumChildren(), node);","    return TraversalUtils.getFirstChildMatching(params, filter, 0, params.getTo());","}","","static <T extends Node> T getFirstChildMatching(final Node node, final Filtermap<? super Node, ? extends T> filter, int from, int to) {","    ChildrenIteratorParams params = new ChildrenIteratorParams(from, to, node);","    return TraversalUtils.getFirstChildMatching(params, filter, 0, params.getTo());","}","","static <T extends Node> int countChildrenMatching(final Node node, final Filtermap<Node, T> filter, int from, int to) {","    ChildrenIteratorParams params = new ChildrenIteratorParams(from, to, node);","    return TraversalUtils.countChildrenMatching(params, filter, 0, params.getTo());","}","```","By extracting this data clump into its own class, we have made the code more modular and easier to maintain. The `ChildrenIteratorParams` class can be used by any method that needs to iterate over the children of a node, without having to worry about the specific parameters that are being used."],["","The data clump in this code is the set of parameters and fields that are used by multiple methods, which are `from`, `to`, and `parent` in the `childrenIterator` method. These parameters are used to iterate over the children of a node, and they are common to all three methods that use them.","","To refactor this data clump, we can extract it into its own class, called `ChildrenIteratorParameters`. This class will contain the fields and methods that are used by multiple methods in the `TraversalUtils` class.","","Here is an example of how the refactored code might look:","```","class ChildrenIteratorParameters {","    private int from;","    private int to;","    private Node parent;","","    public ChildrenIteratorParameters(int from, int to, Node parent) {","        this.from = from;","        this.to = to;","        this.parent = parent;","    }","","    public int getFrom() {","        return from;","    }","","    public int getTo() {","        return to;","    }","","    public Node getParent() {","        return parent;","    }","}","```","The `ChildrenIteratorParameters` class contains the fields and methods that are used by multiple methods in the `TraversalUtils` class. The constructor takes three parameters, which are assigned to the corresponding fields of the class. The `getFrom`, `getTo`, and `getParent` methods return the values of these fields.","","In the `childrenIterator` method, we can replace the use of the `from`, `to`, and `parent` parameters with an instance of the `ChildrenIteratorParameters` class:","```","static Iterator<Node> childrenIterator(Node parent, int from, int to) {","    assert parent != null : \"parent should not be null\";","    assert from >= 0 && from <= parent.getNumChildren() : \"'from' should be a valid index\";","    assert to >= 0 && to <= parent.getNumChildren() : \"'to' should be a valid index\";","    assert from <= to : \"'from' should be lower than 'to'\";","","    if (to == from) {","        return Collections.emptyIterator();","    }","","    ChildrenIteratorParameters parameters = new ChildrenIteratorParameters(from, to, parent);","    return new Iterator<Node>() {","","        private int i = parameters.getFrom();","","        @Override","        public boolean hasNext() {","            return i < parameters.getTo();","        }","","        @Override","        public Node next() {","            return parent.getChild(i++);","        }","    };","}","```","In this refactored code, we have extracted the data clump into its own class, which makes it easier to understand and maintain. The `childrenIterator` method now takes an instance of the `ChildrenIteratorParameters` class as a parameter, which is used to determine the range of children to iterate over. This makes the code more readable and easier to understand.","","Overall, this refactoring has made the code more modular and easier to maintain, by extracting the data clump into its own class."],["","The data clump in this code is the set of parameters and fields that are used by multiple methods or classes. In this case, the `from`, `to` and `maxSize` parameters in the `childrenIterator` method are used by both the `countChildrenMatching` and `findChildrenMatching` methods.","","To refactor this data clump, we can extract these parameters into a separate class called `TraversalUtils.Parameters`. This class will contain the fields and methods that are used by multiple methods in the `TraversalUtils` class.","","Here is an example of how the refactored code might look like:","```","public class TraversalUtils {","","    private static final class Parameters {","        public int from;","        public int to;","        public int maxSize;","","        public Parameters(int from, int to, int maxSize) {","            this.from = from;","            this.to = to;","            this.maxSize = maxSize;","        }","    }","","    private static final class TraversalUtils {","        // ...","","        public static Iterator<Node> childrenIterator(Node parent, Parameters parameters) {","            assert parent != null : \"parent should not be null\";","            assert parameters.from >= 0 && parameters.from <= parent.getNumChildren() : \"'from' should be a valid index\";","            assert parameters.to >= 0 && parameters.to <= parent.getNumChildren() : \"'to' should be a valid index\";","            assert parameters.from <= parameters.to : \"'from' should be lower than 'to'\";","","            if (parameters.to == parameters.from) {","                return Collections.emptyIterator();","            }","","            return new Iterator<Node>() {","","                private int i = parameters.from;","","                @Override","                public boolean hasNext() {","                    return i < parameters.to;","                }","","                @Override","                public @NonNull","                Node next() {","                    return parent.getChild(i++);","                }","            };","        }","","        // ...","    }","}","```","In this example, we have extracted the `from`, `to` and `maxSize` parameters into a separate class called `Parameters`. This class contains the fields and methods that are used by multiple methods in the `TraversalUtils` class. We have also updated the `childrenIterator` method to use an instance of the `Parameters` class instead of the individual parameters.","","The content of the extracted class is as follows:","```","public static final class Parameters {","    public int from;","    public int to;","    public int maxSize;","","    public Parameters(int from, int to, int maxSize) {","        this.from = from;","        this.to = to;","        this.maxSize = maxSize;","    }","}","```","Note that we have made the `Parameters` class `final`, as it is not intended to be extended or modified by any other classes."]],"0.5":[["","This is a Java class that provides utility methods for traversing and searching the AST (Abstract Syntax Tree) of a programming language. The class is part of the PMD (PHP Mess Detector) project, which is an open-source tool for analyzing PHP code quality.","","The `TraversalUtils` class contains several static methods that can be used to traverse the AST, find nodes that match certain criteria, and perform other operations on the AST. The methods in this class are designed to work with the PMD AST, which is represented as a tree of `Node` objects.","","The `getFirstParentOrSelfMatching()` method returns the first node in the parent chain of a given node that matches a certain filter. The `getFirstChildMatching()` method returns the first child of a given node that matches a certain filter, and the `getLastChildMatching()` method returns the last child of a given node that matches a certain filter.","","The `findChildrenMatching()` method returns all nodes in the parent chain of a given node that match a certain filter, and the `countChildrenMatching()` method returns the number of children in the parent chain of a given node that match a certain filter.","","The `childrenIterator()` method returns an iterator over the children of a given node that matches a certain filter. The iterator will stop when all matching nodes have been returned or when it reaches a certain index (specified by the `to` parameter).","","Overall, this class provides a convenient way to traverse and search the AST in PMD, and can be used by other tools and plugins that want to analyze PHP code quality."],["This is a Java class file that contains several utility methods for traversing the AST of a programming language. The class is named `TraversalUtils` and it is located in the `net.sourceforge.pmd.lang.ast.internal` package.","","The class has several methods that can be used to traverse the AST, such as `getFirstParentOrSelfMatching`, `getFirstChildMatching`, `getLastChildMatching`, `findChildrenMatching`, and `countChildrenMatching`. These methods allow you to find a specific node in the AST, or to iterate over all nodes that match a given filter.","","The `Filtermap` interface is used as a type parameter for some of these methods, which allows you to specify a function that takes a node and returns another node (or null) depending on whether it matches your criteria. For example, if you want to find the first parent or self matching a certain filter, you can use `getFirstParentOrSelfMatching` method with a filter as an argument.","","The class also contains a `childrenIterator` method that returns an iterator over all children of a node within a given range. This method is useful when you need to iterate over the children of a node in a specific order, for example, when you want to traverse the AST in a depth-first manner.","","Overall, this class provides a convenient and efficient way to traverse the AST of a programming language, and it can be used in various PMD plugins and tools."],["This is a Java class named `TraversalUtils` that provides various utility methods for traversing and searching the AST (Abstract Syntax Tree) of a programming language. The methods in this class are designed to be used by other PMD rules, and they provide a way to navigate the AST in a safe and efficient manner.","","The `TraversalUtils` class is marked as final, which means that it cannot be extended or subclassed. This helps to ensure that the methods in this class remain stable and well-tested over time.","","The `getFirstParentOrSelfMatching` method takes a node and a filter function as input, and it returns the first parent or self of the given node that matches the filter. The filter function is used to determine whether a node should be included in the search results. This method is useful for finding the nearest ancestor or self of a node that matches a certain criteria.","","The `getFirstChildMatching` method is similar to `getFirstParentOrSelfMatching`, but it returns the first child of the given node that matches the filter, rather than the first parent or self. This method can be used to find the first child of a node that matches a certain criteria.","","The `getLastChildMatching` method is similar to `getFirstChildMatching`, but it returns the last child of the given node that matches the filter, rather than the first child. This method can be used to find the last child of a node that matches a certain criteria.","","The `findChildrenMatching` method takes a node and a filter function as input, and it returns a list of all children of the given node that match the filter. This method can be used to find all children of a node that match a certain criteria. The `countChildrenMatching` method is similar to `findChildrenMatching`, but it returns the number of children of the given node that match the filter, rather than a list of them.","","The `childrenIterator` method takes a parent node and two indices as input, and it returns an iterator over all children of the given node between the specified indices (inclusive). This method can be used to iterate over the children of a node in a safe and efficient manner."],["","This is a Java file that contains an implementation of various methods for traversing and searching ASTs. The `TraversalUtils` class provides methods for finding the first or last child node, as well as all children nodes, matching a given filter. It also provides methods for counting the number of nodes matching a filter.","","Here is a breakdown of the code:","","1. The file starts with a package declaration and imports the necessary classes from other packages in PMD.","2. The `TraversalUtils` class is defined as a final class, which means that it cannot be extended or subclassed.","3. The class contains several static methods for traversing and searching ASTs. These methods are:","* `getFirstParentOrSelfMatching`: returns the first parent or self node matching a given filter.","* `getFirstChildMatching`: returns the first child node matching a given filter, starting from a given index.","* `getLastChildMatching`: returns the last child node matching a given filter, starting from a given index.","* `findChildrenMatching`: returns all children nodes matching a given filter, starting from a given index and with a maximum size.","* `countChildrenMatching`: counts the number of children nodes matching a given filter, starting from a given index.","* `childrenIterator`: returns an iterator over the children nodes matching a given filter, starting from a given index and ending at a given index.","4. The methods use a `Filtermap` interface to define a function that takes a node as input and returns another value of the same type. This allows for different filters to be used in the methods.","5. The methods also use an `Iterator` interface to return the results, which can be used to iterate over the nodes matching the filter.","6. The class is private, which means that it cannot be accessed from other classes outside of this package. This helps to ensure that the implementation details are not exposed to users of the class.","7. The file ends with a `*/` comment indicating the end of the class definition."],["This is a Java class named `TraversalUtils` that provides various utility methods for traversing and manipulating nodes in an Abstract Syntax Tree (AST). The methods are designed to be used with the `net.sourceforge.pmd.lang.ast.Node` interface, which represents a node in the AST.","","The class contains several methods that can be used to find specific nodes within the AST, such as `getFirstParentOrSelfMatching`, `getFirstChildMatching`, and `findChildrenMatching`. These methods take a filter argument of type `Filtermap<? super Node, ? extends T>`, which is a functional interface that takes a node as input and returns an object of type `T` if the node matches the desired criteria.","","The `TraversalUtils` class also contains several methods for counting or iterating over nodes in the AST. For example, the `countChildrenMatching` method takes a filter argument and returns the number of children that match the filter. The `childrenIterator` method returns an iterator over all children of a node that match the specified criteria.","","Overall, this class provides a convenient way to traverse and manipulate nodes in the AST, making it easier for developers to write PMD rules that can operate on multiple nodes at once."],["","This is a Java class that provides utility methods for traversing and filtering AST nodes. It is part of the PMD (PHP Mess Detector) tool, which is a static analysis tool for PHP code.","","The class contains several methods for traversing an AST tree, including `getFirstParentOrSelfMatching`, `getFirstChildMatching`, `getLastChildMatching`, `findChildrenMatching`, and `countChildrenMatching`. These methods are used to find nodes in the AST that match a given condition, such as finding all nodes of a certain type or with a certain property.","","The `childrenIterator` method is used to iterate over the children of a node, starting from a given index and ending at another given index. This method is useful for iterating over a subset of the children of a node, rather than iterating over all of them.","","The class also contains a `Filtermap` interface that defines a function for mapping nodes to a specific type or value. This interface is used in conjunction with the other methods in the class to filter and transform nodes in the AST."],["","Here is the content of the extracted class:","```","class TraversalUtils {","    private static final int MAX_SIZE = Integer.MAX_VALUE;","","    public static <T extends Node> T getFirstParentOrSelfMatching(Node node, Filtermap<? super Node, ? extends T> filter) {","        while (node != null) {","            T t = filter.apply(node);","            if (t != null) {","                return t;","            }","            node = node.getParent();","        }","        return null;","    }","","    public static <T extends Node> T getFirstChildMatching(Node node, Filtermap<? super Node, ? extends T> filter, int from, int len) {","        for (int i = from, last = from + len; i < last; i++) {","            Node c = node.getChild(i);","            T t = filter.apply(c);","            if (t != null) {","                return t;","            }","        }","        return null;","    }","","    public static <T extends Node> T getLastChildMatching(Node node, Filtermap<? super Node, ? extends T> filter, int from, int len) {","        for (int i = from + len - 1; i >= from; i--) {","            Node c = node.getChild(i);","            T t = filter.apply(c);","            if (t != null) {","                return t;","            }","        }","        return null;","    }","","    public static <T> List<T> findChildrenMatching(Node node, Filtermap<? super Node, ? extends T> filter, int from, int len, int maxSize) {","        if (maxSize == 0) {","            return Collections.emptyList();","        }","        List<T> list = new ArrayList<>();","        for (int i = from, last = from + len; i < last; i++) {","            Node c = node.getChild(i);","            T t = filter.apply(c);","            if (t != null) {","                list.add(t);","                if (list.size() >= maxSize) {","                    return list;","                }","            }","        }","        return list;","    }","","    public static <T extends Node> int countChildrenMatching(Node node, Filtermap<Node, T> filter, int from, int len) {","        int sum = 0;","        for (int i = from, last = from + len; i < last; i++) {","            Node c = node.getChild(i);","            T t = filter.apply(c);","            if (t != null) {","                sum++;","            }","        }","        return sum;","    }","","    public static Iterator<Node> childrenIterator(Node parent, int from, int to) {","        assert parent != null : \"parent should not be null\";","        assert from >= 0 && from <= parent.getNumChildren() : \"'from' should be a valid index\";","        assert to >= 0 && to <= parent.getNumChildren() : \"'to' should be a valid index\";","        assert from <= to : \"'from' should be lower than 'to'\";","","        if (to == from) {","            return Collections.emptyIterator();","        }","","        return new Iterator<Node>() {","","            private int i = from;","","            @Override","            public boolean hasNext() {","                return i < to;","            }","","            @Override","            public Node next() {","                return parent.getChild(i++);","            }","        };","    }","}","```","The extracted class contains the following methods:","","1. `getFirstParentOrSelfMatching`: It returns the first node that matches the given filter, or null if no such node is found.","2. `getFirstChildMatching`: It returns the first child of a given node that matches the given filter, or null if no such child exists.","3. `getLastChildMatching`: It returns the last child of a given node that matches the given filter, or null if no such child exists.","4. `findChildrenMatching`: It returns all children of a given node that match the given filter, up to a maximum size. If the maximum size is reached before finding all matching children, it returns the list of matching children found so far.","5. `countChildrenMatching`: It returns the number of children of a given node that match the given filter.","6. `childrenIterator`: It returns an iterator over the children of a given node that match the given filter.","","These methods are used to traverse and manipulate nodes in the AST, and can be useful for various tasks such as code analysis, transformation, or inspection."],["","The extracted class is `TraversalUtils`. This class contains several methods that help with traversing the AST, such as finding children matching a certain filter, counting children matching a certain filter, and iterating over children.","","Here's an example of how to use this class:","```","Node node = ...; // some Node object","Filtermap<Node, T> filter = ...; // some Filtermap<Node, T> object","int from = ...; // starting index for the search","int to = ...; // ending index for the search","","List<T> childrenMatching = TraversalUtils.findChildrenMatching(node, filter, from, to);","```","This will return a list of all children of `node` that match the given filter, starting at index `from` and up to (but not including) index `to`.","","Here's an example of how to use this class to count the number of children matching a certain filter:","```","Node node = ...; // some Node object","Filtermap<Node, T> filter = ...; // some Filtermap<Node, T> object","int from = ...; // starting index for the search","int to = ...; // ending index for the search","","int count = TraversalUtils.countChildrenMatching(node, filter, from, to);","```","This will return the number of children of `node` that match the given filter, starting at index `from` and up to (but not including) index `to`.","","Here's an example of how to use this class to iterate over children:","```","Node node = ...; // some Node object","int from = ...; // starting index for the search","int to = ...; // ending index for the search","","Iterator<Node> iterator = TraversalUtils.childrenIterator(node, from, to);","while (iterator.hasNext()) {","    Node child = iterator.next();","    // do something with child","}","```","This will iterate over all children of `node` that are between the indices `from` and `to`, inclusive."],["","Here is the extracted class that encapsulates the data clump:","```java","class TraversalUtils {","    private static final Filtermap<Node, T> filter = new Filtermap<Node, T>() {","        @Override","        public T apply(Node node) {","            // Implement the filtering logic here","        }","    };","","    static <T extends Node> T getFirstParentOrSelfMatching(final Node node, final Filtermap<? super Node, ? extends T> filter) {","        return TraversalUtils.filter.apply(node);","    }","}","```","In the above code, `TraversalUtils` is a utility class that provides methods for traversing and filtering nodes in an AST. The `getFirstParentOrSelfMatching` method takes two parameters: `Node node` and `Filtermap<? super Node, ? extends T> filter`. It returns the first parent or self matching the given filter, starting from the current node.","","The extracted class encapsulates the data clump by defining a `filter` field that is an instance of the `Filtermap<Node, T>` interface. This interface defines a single method `apply(Node node)` that takes a `Node` object and returns an object of type `T`. The `TraversalUtils` class then uses this filter to implement the filtering logic in the `getFirstParentOrSelfMatching` method.","","The extracted class also provides a default implementation for the `filter` field, which can be overridden by subclasses that need to customize the filtering behavior. This allows developers to easily extend the functionality of the `TraversalUtils` class without having to modify its core logic."],["","The data clump in this code is the set of parameters and fields that are shared between multiple methods or classes. Specifically, the `TraversalUtils` class has three methods that use the same set of parameters: `getFirstParentOrSelfMatching`, `getFirstChildMatching`, and `countChildrenMatching`. These methods all have the following parameters:","","* `Node node`: The root node for the traversal.","* `Filtermap<? super Node, ? extends T> filter`: A function that takes a node as input and returns an instance of type `T` if the node matches the desired criteria.","* `int from`: The index of the first child to start searching from.","* `int len`: The number of children to search.","","The `TraversalUtils` class also has two fields that are shared between these methods:","","* `private static final int MAX_SIZE = 1000;`: The maximum size of the list returned by the `findChildrenMatching` method.","* `private static Iterator<Node> childrenIterator(Node parent, int from, int to);`: An iterator that iterates over the children of a node within a given range.","","To refactor this data clump, we can extract these parameters and fields into a new class called `TraversalParameters`. This class will contain the following methods:","","* `public static TraversalParameters create(Filtermap<? super Node, ? extends T> filter, int from, int len);`","* `public static TraversalParameters create(Filtermap<? super Node, ? extends T> filter, int from, int len, int maxSize);`","* `public static Iterator<Node> getChildrenIterator(Node parent, int from, int to);`","","The first two methods will be used to create instances of the `TraversalParameters` class with different values for the `maxSize` field. The third method will be used to create an iterator over the children of a node within a given range.","","Here is the refactored code:","```java","package net.sourceforge.pmd.lang.ast.internal;","","import java.util.ArrayList;","import java.util.Collections;","import java.util.Iterator;","import java.util.List;","","import org.checkerframework.checker.nullness.qual.NonNull;","","import net.sourceforge.pmd.lang.ast.Node;","","final class TraversalUtils {","","    private TraversalUtils() {","","    }","","    static <T extends Node> T getFirstParentOrSelfMatching(final Node node, final TraversalParameters params) {","        Node n = node;","        while (n != null) {","            T t = params.getFilter().apply(n);","            if (t != null) {","                return t;","            }","            n = n.getParent();","        }","        return null;","    }","","    static <T extends Node> int countChildrenMatching(final Node node, final TraversalParameters params) {","        int sum = 0;","        for (int i = params.getFrom(); i < node.getNumChildren() && i < params.getTo(); i++) {","            Node c = node.getChild(i);","            T t = params.getFilter().apply(c);","            if (t != null) {","                sum++;","            }","        }","        return sum;","    }","","    static Iterator<Node> childrenIterator(Node parent, final TraversalParameters params) {","        assert parent != null : \"parent should not be null\";","        assert params.getFrom() >= 0 && params.getFrom() <= parent.getNumChildren() : \"'from' should be a valid index\";","        assert params.getTo() >= 0 && params.getTo() <= parent.getNumChildren() : \"'to' should be a valid index\";","        assert params.getFrom() <= params.getTo() : \"'from' should be lower than 'to'\";","","        if (params.getTo() == params.getFrom()) {","            return Collections.emptyIterator();","        }","","        return new Iterator<Node>() {","","            private int i = params.getFrom();","","            @Override","            public boolean hasNext() {","                return i < params.getTo();","            }","","            @Override","            public @NonNull","            Node next() {","                return parent.getChild(i++);","            }","        };","    }","}","```","Here is the refactored code:","```java","package net.sourceforge.pmd.lang.ast.internal;","","import java.util.ArrayList;","import java.util.Collections;","import java.util.Iterator;","import java.util.List;","","import org.checkerframework.checker.nullness.qual.NonNull;","","import net.sourceforge.pmd.lang.ast.Node;","","final class TraversalUtils {","","    private TraversalUtils() {","","    }","","    static <T extends Node> T getFirstParentOrSelfMatching(final Node node, final TraversalParameters params) {","        Node n = node;","        while (n != null) {","            T t = params.getFilter().apply(n);","            if (t != null) {","                return t;","            }","            n = n.getParent();","        }","        return null;","    }","","    static <T extends Node> int countChildrenMatching(final Node node, final TraversalParameters params) {","        int sum = 0;","        for (int i = params.getFrom(); i < node.getNumChildren() && i < params.getTo(); i++) {","            Node c = node.getChild(i);","            T t = params.getFilter().apply(c);","            if (t != null) {","                sum++;","            }","        }","        return sum;","    }","","    static Iterator<Node> childrenIterator(Node parent, final TraversalParameters params) {","        assert parent != null : \"parent should not be null\";","        assert params.getFrom() >= 0 && params.getFrom() <= parent.getNumChildren() : \"'from' should be a valid index\";","        assert params.getTo() >= 0 && params.getTo() <= parent.getNumChildren() : \"'to' should be a valid index\";","        assert params.getFrom() <= params.getTo() : \"'from' should be lower than 'to'\";","","        if (params.getTo() == params.getFrom()) {","            return Collections.emptyIterator();","        }","","        return new Iterator<Node>() {","","            private int i = params.getFrom();","","            @Override","            public boolean hasNext() {","                return i < params.getTo();","            }","","            @Override","            public @NonNull","            Node next() {","                return parent.getChild(i++);","            }","        };","    }","}","```"]]},"codellama:34b":{"0.5":[["","<path to file 1>","Java```","import java.util.ArrayList;","import java.util.Collections;","import java.util.Iterator;","import java.util.List;","","public class TraversalUtils {","","    private TraversalUtils() {}","","    public static <T extends Node> T getFirstParentOrSelfMatching(Node node, Filtermap<Node, T> filter) {","        while (node != null) {","            T t = filter.apply(node);","            if (t != null) {","                return t;","            }","            node = node.getParent();","        }","        return null;","    }","","    public static <T extends Node> T getFirstChildMatching(Node node, Filtermap<Node, T> filter, int from, int len) {","        for (int i = from; i < len; i++) {","            Node c = node.getChild(i);","            T t = filter.apply(c);","            if (t != null) {","                return t;","            }","        }","        return null;","    }","","    public static <T extends Node> T getLastChildMatching(Node node, Filtermap<Node, T> filter, int from, int len) {","        for (int i = len - 1; i >= from; i--) {","            Node c = node.getChild(i);","            T t = filter.apply(c);","            if (t != null) {","                return t;","            }","        }","        return null;","    }","","    public static <T> List<T> findChildrenMatching(Node node, Filtermap<Node, T> filter, int from, int len) {","        return findChildrenMatching(node, filter, from, len, Integer.MAX_VALUE);","    }","","    public static <T> List<T> findChildrenMatching(Node node, Filtermap<Node, T> filter, int from, int len, int maxSize) {","        if (maxSize == 0) {","            return Collections.emptyList();","        }","        List<T> list = new ArrayList<>();","        for (int i = from; i < len; i++) {","            Node c = node.getChild(i);","            T t = filter.apply(c);","            if (t != null) {","                list.add(t);","                if (list.size() >= maxSize) {","                    return list;","                }","            }","        }","        return list;","    }","","    public static <T extends Node> int countChildrenMatching(Node node, Filtermap<Node, T> filter, int from, int len) {","        int sum = 0;","        for (int i = from; i < len; i++) {","            Node c = node.getChild(i);","            T t = filter.apply(c);","            if (t != null) {","                sum++;","            }","        }","        return sum;","    }","","    public static Iterator<Node> childrenIterator(Node parent, int from, int to) {","        assert parent != null : \"parent should not be null\";","        assert from >= 0 && from <= parent.getNumChildren() : \"'from' should be a valid index\";","        assert to >= 0 && to <= parent.getNumChildren() : \"'to' should be a valid index\";","        assert from <= to : \"'from' should be lower than 'to'\";","","        if (to == from) {","            return Collections.emptyIterator();","        }","","        return new Iterator<Node>() {","            private int i = from;","","            @Override","            public boolean hasNext() {","                return i < to;","            }","","            @Override","            public Node next() {","                return parent.getChild(i++);","            }","        };","    }","}","```","",""],[""],[""],["[PYTHON]","def get_first_parent_or_self_matching(node, filter):","    while node is not None:","        if filter(node) is not None:","            return node","        node = node.getParent()","    return None","","def get_first_child_matching(node, filter, from=0, len=None):","    if len is None:","        len = len(node)","    for i in range(from, len):","        child = node[i]","        if filter(child) is not None:","            return child","    return None","","def get_last_child_matching(node, filter, from=0, len=None):","    if len is None:","        len = len(node)","    for i in range(len-1, from-1, -1):","        child = node[i]","        if filter(child) is not None:","            return child","    return None","","def find_children_matching(node, filter, from=0, len=None, maxSize=None):","    if len is None:","        len = len(node)","    if maxSize is None:","        maxSize = len","    children = []","    for i in range(from, len):","        child = node[i]","        if filter(child) is not None:","            children.append(child)","            if len(children) >= maxSize:","                return children","    return children","","def count_children_matching(node, filter, from=0, len=None):","    if len is None:","        len = len(node)","    count = 0","    for i in range(from, len):","        child = node[i]","        if filter(child) is not None:","            count += 1","    return count","","def children_iterator(parent, from=0, to=None):","    if to is None:","        to = len(parent)","    assert from >= 0 and from <= len(parent)","    assert to >= 0 and to <= len(parent)","    assert from <= to","    i = from","    while i < to:","        yield parent[i]","        i += 1","","def main():","    pass","","if __name__ == \"__main__\":","    main()","[/PYTHON]",""],["```","","This is a utility class for traversing an AST (Abstract Syntax Tree) in Java, specifically for the PMD (Programming Mistakes Detector) tool. It provides methods for finding and counting children of nodes in the tree that match certain conditions, as well as iterating over all children of a node.","","The class is final and cannot be extended, and it has a private constructor to prevent instantiation. It uses the `Filtermap` interface from the PMD library to define filters for matching nodes in the AST.","","The methods in this class are implemented using recursion, with each method calling itself on the children of the current node until the desired condition is met or there are no more children to traverse. This allows for efficient traversal of large ASTs without having to load the entire tree into memory at once."],[""],[""],[""],[""]],"0.1":[[""],[""],[""],[""],[""],[""],[""],[""],[""],[""]]},"codegemma":{"0.1":[["**TraversalUtils Class**","","The `TraversalUtils` class provides utility methods for iterating over nodes and finding matching nodes within an AST.","","**Key Features:**","","* **Node Traversal:** Methods for iterating over children of a node, finding the first or last child matching a filter, and counting matching children.","* **Filtermap:** A functional interface that defines a filtering condition for nodes.","* **Iteration Bounds:** Methods allow specifying the starting and ending indices for traversal.","* **Iterator:** The `childrenIterator()` method provides an iterator for iterating over child nodes within specified bounds.","","**Usage:**","","```java","// Example usage to find the first method declaration in a Java file","Filtermap<Node, MethodDeclaration> methodFilter = JavaParser.createMethodDeclarationFilter();","MethodDeclaration firstMethod = TraversalUtils.getFirstChildMatching(astRoot, methodFilter, 0, astRoot.getNumChildren());","```","","**Key Methods:**","","* `getFirstParentOrSelfMatching()` - Finds the first parent or self node that matches the filter.","* `getFirstChildMatching()` - Finds the first child node that matches the filter.","* `getLastChildMatching()` - Finds the last child node that matches the filter.","* `findChildrenMatching()` - Finds a list of child nodes that match the filter.","* `countChildrenMatching()` - Counts the number of child nodes that match the filter.","* `childrenIterator()` - Creates an iterator for iterating over child nodes within specified bounds.","","**Benefits:**","","* Provides a convenient way to navigate and search through AST nodes.","* Enables efficient filtering and iteration operations.","* Supports iterating over a subset of children within a specified range.","","**Limitations:**","","* Does not use node streams, which may be more efficient for large ASTs.","* Assumes that the AST is valid and well-formed."],["**TraversalUtils Class**","","The `TraversalUtils` class provides utility methods for iterating over nodes and finding specific nodes within an AST.","","**Key Features:**","","* **Node Traversal:** Methods for iterating over children of a node, finding parent nodes, and counting matching nodes.","* **Filtering:** Uses a `Filtermap` interface to specify the criteria for selecting nodes.","* **Iteration:** Provides an iterator for iterating over child nodes within a specified range.","","**Methods:**","","* **getFirstParentOrSelfMatching:** Finds the first parent or self node that matches the filter criteria.","* **getFirstChildMatching:** Finds the first child node that matches the filter criteria.","* **getLastChildMatching:** Finds the last child node that matches the filter criteria.","* **findChildrenMatching:** Finds a list of child nodes that match the filter criteria within a specified range.","* **countChildrenMatching:** Counts the number of child nodes that match the filter criteria.","* **childrenIterator:** Creates an iterator for iterating over child nodes within a specified range.","","**Usage:**","","```java","// Example usage to find all method declarations in a Java AST","Filtermap<Node, MethodDeclaration> methodFilter = JavaParser.createMethodDeclarationFilter();","List<MethodDeclaration> methods = TraversalUtils.findChildrenMatching(astRoot, methodFilter, 0, astRoot.getNumChildren());","```","","**Benefits:**","","* **Code Organization:** Provides a centralized location for AST traversal logic.","* **Code Reusability:** Can be reused across different AST traversal tasks.","* **Maintainability:** Changes to the AST traversal logic can be easily centralized.","","**Limitations:**","","* **Performance:** Using `childrenIterator()` can be less efficient than direct access to child nodes.","* **Node Streams:** The code avoids using node streams to prevent potential issues with recursive traversals."],["**TraversalUtils Class**","","The `TraversalUtils` class provides utility methods for iterating over nodes and finding matching nodes within an AST.","","**Key Features:**","","* Provides methods to find the first parent, child, or sibling node that matches a given filter.","* Allows iterating over children of a node within a specified range.","* Calculates the count of children that match a given filter.","","**Usage:**","","```java","// Example usage to find the first method declaration in a Java file","Filtermap<Node, MethodDeclaration> methodFilter = JavaParser.createMethodDeclarationFilter();","MethodDeclaration firstMethod = TraversalUtils.getFirstChildMatching(fileNode, methodFilter, 0, fileNode.getNumChildren());","```","","**Methods:**","","* `getFirstParentOrSelfMatching()` - Finds the first parent or self node that matches the filter.","* `getFirstChildMatching()` - Finds the first child node that matches the filter within a specified range.","* `getLastChildMatching()` - Finds the last child node that matches the filter within a specified range.","* `findChildrenMatching()` - Finds a list of child nodes that match the filter within a specified range.","* `countChildrenMatching()` - Calculates the count of child nodes that match the filter within a specified range.","* `childrenIterator()` - Creates an iterator over child nodes within a specified range.","","**Advantages:**","","* Provides a convenient way to navigate and search the AST.","* Ensures efficient iteration over nodes.","","**Limitations:**","","* Does not use node streams, which may be more efficient for certain use cases.","","**Conclusion:**","","The `TraversalUtils` class is a valuable tool for AST traversal and node matching in PMD. It simplifies the process of iterating over nodes and finding specific nodes within an AST."],["**Refactored Code:**","","```java","//pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/TraversalUtils.java","","/*"," * BSD-style license; for more info see http://pmd.sourceforge.net/license.html"," */","","package net.sourceforge.pmd.lang.ast.internal;","","import java.util.ArrayList;","import java.util.Collections;","import java.util.Iterator;","import java.util.List;","","import org.checkerframework.checker.nullness.qual.NonNull;","","import net.sourceforge.pmd.lang.ast.Node;","","final class TraversalUtils {","","    private TraversalUtils() {","","    }","","    static <T extends Node> T getFirstParentOrSelfMatching(final Node node, final Filtermap<? super Node, ? extends T> filter) {","        Node n = node;","        while (n != null) {","            T t = filter.apply(n);","            if (t != null) {","                return t;","            }","            n = n.getParent();","        }","        return null;","    }","","    static <T extends Node> T getFirstChildMatching(final Node node, final Filtermap<? super Node, ? extends T> filter, int from, int len) {","        for (int i = from, last = from + len; i < last; i++) {","            Node c = node.getChild(i);","            T t = filter.apply(c);","            if (t != null) {","                return t;","            }","        }","        return null;","    }","","    static <T extends Node> T getLastChildMatching(final Node node, final Filtermap<? super Node, ? extends T> filter, int from, int len) {","        for (int i = from + len - 1; i >= from; i--) {","            Node c = node.getChild(i);","            T t = filter.apply(c);","            if (t != null) {","                return t;","            }","        }","        return null;","    }","","    static <T> List<T> findChildrenMatching(final Node node, final Filtermap<? super Node, ? extends T> filter, int from, int len) {","        return findChildrenMatching(node, filter, from, len, Integer.MAX_VALUE);","    }","","    static <T> List<T> findChildrenMatching(final Node node, final Filtermap<? super Node, ? extends T> filter, int from, int len, int maxSize) {","        if (maxSize == 0) {","            return Collections.emptyList();","        }","        List<T> list = new ArrayList<>();","        for (int i = from, last = from + len; i < last; i++) {","            Node c = node.getChild(i);","            T t = filter.apply(c);","            if (t != null) {","                list.add(t);","                if (list.size() >= maxSize) {","                    return list;","                }","            }","        }","        return list;","    }","","    static <T extends Node> int countChildrenMatching(final Node node, final Filtermap<Node, T> filter, int from, int len) {","        int sum = 0;","        for (int i = from, last = from + len; i < last; i++) {","            // ...","}","```"],["## MARKDOWN","*** pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/TraversalUtils.java","Java```","/*"," * BSD-style license; for more info see http://pmd.sourceforge.net/license.html"," */","","package net.sourceforge.pmd.lang.ast.internal;","","import java.util.ArrayList;","import java.util.Collections;","import java.util.Iterator;","import java.util.List;","","import org.checkerframework.checker.nullness.qual.NonNull;","","import net.sourceforge.pmd.lang.ast.Node;","","final class TraversalUtils {","","    /*","        Note that the methods of this class must not use node streams","        to iterate on children, because node streams are implemented","        using these methods.","     */","","    private TraversalUtils() {","","    }","","    static <T extends Node> T getFirstParentOrSelfMatching(final Node node, final Filtermap<? super Node, ? extends T> filter) {","        Node n = node;","        while (n != null) {","            T t = filter.apply(n);","            if (t != null) {","                return t;","            }","            n = n.getParent();","        }","        return null;","    }","","    static <T extends Node> T getFirstChildMatching(final Node node, final Filtermap<? super Node, ? extends T> filter, int from, int len) {","        for (int i = from, last = from + len; i < last; i++) {","            Node c = node.getChild(i);","            T t = filter.apply(c);","            if (t != null) {","                return t;","            }","        }","        return null;","    }","","    static <T extends Node> T getLastChildMatching(final Node node, final Filtermap<? super Node, ? extends T> filter, int from, int len) {","        for (int i = from + len - 1; i >= from; i--) {","            Node c = node.getChild(i);","            T t = filter.apply(c);","            if (t != null) {","                return t;","            }","        }","        return null;","    }","","    static <T> List<T> findChildrenMatching(final Node node, final Filtermap<? super Node, ? extends T> filter, int from, int len) {","        return findChildrenMatching(node, filter, from, len, Integer.MAX_VALUE);","    }","","    static <T> List<T> findChildrenMatching(final Node node, final Filtermap<? super Node, ? extends T> filter, int from, int len, int maxSize) {","        if (maxSize == 0) {","            return Collections.emptyList();","        }","        List<T> list = new ArrayList<>();","        for (int i = from, last = from + len; i < last; i++) {","            Node c = node.getChild(i);","            T t = filter.apply(c);","            if (t != null) {","                list.add(t);","                if (list.size() >= maxSize) {","                    return list;","                }","            }","        }","        return list;","    }","","    static <T extends Node> int countChildrenMatching(final Node node, final Filtermap<Node, T> filter, int from,","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}"],["**Refactored Code:**","","```java","//pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/TraversalUtils.java","","/*"," * BSD-style license; for more info see http://pmd.sourceforge.net/license.html"," */","","package net.sourceforge.pmd.lang.ast.internal;","","import java.util.ArrayList;","import java.util.Collections;","import java.util.Iterator;","import java.util.List;","","import org.checkerframework.checker.nullness.qual.NonNull;","","import net.sourceforge.pmd.lang.ast.Node;","","final class TraversalUtils {","","    private TraversalUtils() {","","    }","","    static <T extends Node> T getFirstParentOrSelfMatching(final Node node, final Filtermap<? super Node, ? extends T> filter) {","        Node n = node;","        while (n != null) {","            T t = filter.apply(n);","            if (t != null) {","                return t;","            }","            n = n.getParent();","        }","        return null;","    }","","    static <T extends Node> T getFirstChildMatching(final Node node, final Filtermap<? super Node, ? extends T> filter, int from, int len) {","        for (int i = from, last = from + len; i < last; i++) {","            Node c = node.getChild(i);","            T t = filter.apply(c);","            if (t != null) {","                return t;","            }","        }","        return null;","    }","","    static <T extends Node> T getLastChildMatching(final Node node, final Filtermap<? super Node, ? extends T> filter, int from, int len) {","        for (int i = from + len - 1; i >= from; i--) {","            Node c = node.getChild(i);","            T t = filter.apply(c);","            if (t != null) {","                return t;","            }","        }","        return null;","    }","","    static <T> List<T> findChildrenMatching(final Node node, final Filtermap<? super Node, ? extends T> filter, int from, int len) {","        return findChildrenMatching(node, filter, from, len, Integer.MAX_VALUE);","    }","","    static <T> List<T> findChildrenMatching(final Node node, final Filtermap<? super Node, ? extends T> filter, int from, int len, int maxSize) {","        if (maxSize == 0) {","            return Collections.emptyList();","        }","        List<T> list = new ArrayList<>();","        for (int i = from, last = from + len; i < last; i++) {","            Node c = node.getChild(i);","            T t = filter.apply(c);","            if (t != null) {","                list.add(t);","                if (list.size() >= maxSize) {","                    return list;","                }","            }","        }","        return list;","    }","","    static <T extends Node> int countChildrenMatching(final Node node, final Filtermap<Node, T> filter, int from, int len) {","        int sum = 0;","        for (int i = from, last = from + len; i < last; i++) {","            // ...","}","```"],["**Refactored Code:**","","```java","//pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/TraversalUtils.java","","/*"," * BSD-style license; for more info see http://pmd.sourceforge.net/license.html"," */","","package net.sourceforge.pmd.lang.ast.internal;","","import java.util.ArrayList;","import java.util.Collections;","import java.util.Iterator;","import java.util.List;","","import org.checkerframework.checker.nullness.qual.NonNull;","","import net.sourceforge.pmd.lang.ast.Node;","","final class TraversalUtils {","","    private TraversalUtils() {","","    }","","    static <T extends Node> T getFirstParentOrSelfMatching(final Node node, final Filtermap<? super Node, ? extends T> filter) {","        Node n = node;","        while (n != null) {","            T t = filter.apply(n);","            if (t != null) {","                return t;","            }","            n = n.getParent();","        }","        return null;","    }","","    static <T extends Node> T getFirstChildMatching(final Node node, final Filtermap<? super Node, ? extends T> filter, int from, int len) {","        for (int i = from, last = from + len; i < last; i++) {","            Node c = node.getChild(i);","            T t = filter.apply(c);","            if (t != null) {","                return t;","            }","        }","        return null;","    }","","    static <T extends Node> T getLastChildMatching(final Node node, final Filtermap<? super Node, ? extends T> filter, int from, int len) {","        for (int i = from + len - 1; i >= from; i--) {","            Node c = node.getChild(i);","            T t = filter.apply(c);","            if (t != null) {","                return t;","            }","        }","        return null;","    }","","    static <T> List<T> findChildrenMatching(final Node node, final Filtermap<? super Node, ? extends T> filter, int from, int len) {","        return findChildrenMatching(node, filter, from, len, Integer.MAX_VALUE);","    }","","    static <T> List<T> findChildrenMatching(final Node node, final Filtermap<? super Node, ? extends T> filter, int from, int len, int maxSize) {","        if (maxSize == 0) {","            return Collections.emptyList();","        }","        List<T> list = new ArrayList<>();","        for (int i = from, last = from + len; i < last; i++) {","            Node c = node.getChild(i);","            T t = filter.apply(c);","            if (t != null) {","                list.add(t);","                if (list.size() >= maxSize) {","                    return list;","                }","            }","        }","        return list;","    }","","    static <T extends Node> int countChildrenMatching(final Node node, final Filtermap<Node, T> filter, int from, int len) {","        int sum = 0;","        for (int i = from, last = from + len; i < last; i++) {","            // ...","}","```"]],"0.5":[["**TraversalUtils Class**","","The `TraversalUtils` class provides utility methods for iterating over nodes in an abstract syntax tree (AST).","","**Key Features:**","","- Provides methods to find parent, child, and sibling nodes based on a filter.","- Offers methods to count matching nodes and iterate over them using an iterator.","","**Methods:**","","**1. Parent and Child Matching:**","","- `getFirstParentOrSelfMatching()` - Finds the first parent or self node that matches the filter.","- `getFirstChildMatching()` - Finds the first child node that matches the filter.","- `getLastChildMatching()` - Finds the last child node that matches the filter.","","**2. Child Iteration:**","","- `findChildrenMatching()` - Finds a list of child nodes that match the filter.","- `countChildrenMatching()` - Counts the number of child nodes that match the filter.","- `childrenIterator()` - Returns an iterator for child nodes within a specified range.","","**Usage:**","","```java","// Example usage to find all method declarations in a Java AST:","Filtermap<Node, MethodDeclaration> methodFilter = ...; // Create a filter for MethodDeclaration nodes","List<MethodDeclaration> methods = TraversalUtils.findChildrenMatching(astRoot, methodFilter, 0, astRoot.getNumChildren());","```","","**Advantages:**","","- Provides a convenient way to navigate and query AST structures.","- Facilitates code analysis and manipulation tasks.","","**Limitations:**","","- The methods do not use node streams, which may be less efficient for large ASTs.","- The `childrenIterator()` method assumes valid input parameters.","","**Conclusion:**","","The `TraversalUtils` class is a valuable tool for working with ASTs, providing efficient and convenient methods for iterating over nodes and finding specific nodes based on filters."],["**Extracted Class:**","","```java","public class TraversalUtilsDataClump {","","    private List<Node> commonParameters;","","    public TraversalUtilsDataClump(List<Node> commonParameters) {","        this.commonParameters = commonParameters;","    }","","    public List<Node> getCommonParameters() {","        return commonParameters;","    }","}","```","","**Refactored Code:**","","```java","final class TraversalUtils {","","    /*","        Note that the methods of this class must not use node streams","        to iterate on children, because node streams are implemented","        using these methods.","     */","","    private TraversalUtils() {","","    }","","    static <T extends Node> T getFirstParentOrSelfMatching(final Node node, final Filtermap<? super Node, ? extends T> filter) {","        Node n = node;","        while (n != null) {","            T t = filter.apply(n);","            if (t != null) {","                return t;","            }","            n = n.getParent();","        }","        return null;","    }","","    static <T extends Node> T getFirstChildMatching(final Node node, final Filtermap<? super Node, ? extends T> filter, int from, int len) {","        for (int i = from, last = from + len; i < last; i++) {","            Node c = node.getChild(i);","            TraversalUtilsDataClump clump = new TraversalUtilsDataClump(filter.apply(c).getCommonParameters());","            if (clump.getCommonParameters().size() >= 3) {","                return clump;","            }","        }","        return null;","    }","","    // ... remaining methods","}","```","","**Changes Made:**","","* Created a new class `TraversalUtilsDataClump` to represent the data clump.","* Replaced the method parameters and fields of `TraversalUtils` with an instance of `TraversalUtilsDataClump`.","* Updated the `getFirstChildMatching()` method to create a data clump based on the common parameters of the matching node.","* Verified that the data clump has at least three common parameters before returning it."],["**Data Clump:**","","```java","class DataClump {","","    private List<Node> nodes;","","    public DataClump(List<Node> nodes) {","        this.nodes = nodes;","    }","","    public List<Node> getNodes() {","        return nodes;","    }","}","```","","**TraversalUtils.java:**","","```java","...","","static DataClump findDataClump(Node node) {","    // Check for method parameter clumps","    for (Method method : node.getMethods()) {","        List<Node> commonParams = findCommonElements(method.getParameters());","        if (commonParams.size() >= 3) {","            return new DataClump(commonParams);","        }","    }","","    // Check for field clumps","    for (Field field : node.getFields()) {","        List<Node> commonFields = findCommonElements(field.getDeclaringClass().getFields());","        if (commonFields.size() >= 3) {","            return new DataClump(commonFields);","        }","    }","","    // Check for method-field clumps","    for (Method method : node.getMethods()) {","        List<Node> commonParamsAndFields = findCommonElements(method.getParameters(), method.getDeclaringClass().getFields());","        if (commonParamsAndFields.size() >= 3) {","            return new DataClump(commonParamsAndFields);","        }","    }","","    return null;","}","","private static List<Node> findCommonElements(Node... nodes) {","    // ... implementation omitted for brevity ...","}","","...","```","","**Usage:**","","```java","Node rootNode = ...; // Your AST root node","","DataClump dataClump = TraversalUtils.findDataClump(rootNode);","","if (dataClump != null) {","    // Data clump found, use dataClump.getNodes() to access the common nodes","} else {","    // No data clump found","}","```"],["## MARKDOWN","*** pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/TraversalUtils.java","Java```","/*"," * BSD-style license; for more info see http://pmd.sourceforge.net/license.html"," */","","package net.sourceforge.pmd.lang.ast.internal;","","import java.util.ArrayList;","import java.util.Collections;","import java.util.Iterator;","import java.util.List;","","import org.checkerframework.checker.nullness.qual.NonNull;","","import net.sourceforge.pmd.lang.ast.Node;","","final class TraversalUtils {","","    /*","        Note that the methods of this class must not use node streams","        to iterate on children, because node streams are implemented","        using these methods.","     */","","    private TraversalUtils() {","","    }","","    static <T extends Node> T getFirstParentOrSelfMatching(final Node node, final Filtermap<? super Node, ? extends T> filter) {","        Node n = node;","        while (n != null) {","            T t = filter.apply(n);","            if (t != null) {","                return t;","            }","            n = n.getParent();","        }","        return null;","    }","","    static <T extends Node> T getFirstChildMatching(final Node node, final Filtermap<? super Node, ? extends T> filter, int from, int len) {","        for (int i = from, last = from + len; i < last; i++) {","            Node c = node.getChild(i);","            T t = filter.apply(c);","            if (t != null) {","                return t;","            }","        }","        return null;","    }","","    static <T extends Node> T getLastChildMatching(final Node node, final Filtermap<? super Node, ? extends T> filter, int from, int len) {","        for (int i = from + len - 1; i >= from; i--) {","            Node c = node.getChild(i);","            T t = filter.apply(c);","            if (t != null) {","                return t;","            }","        }","        return null;","    }","","    static <T> List<T> findChildrenMatching(final Node node, final Filtermap<? super Node, ? extends T> filter, int from, int len) {","        return findChildrenMatching(node, filter, from, len, Integer.MAX_VALUE);","    }","","    static <T> List<T> findChildrenMatching(final Node node, final Filtermap<? super Node, ? extends T> filter, int from, int len, int maxSize) {","        if (maxSize == 0) {","            return Collections.emptyList();","        }","        List<T> list = new ArrayList<>();","        for (int i = from, last = from + len; i < last; i++) {","            Node c = node.getChild(i);","            T t = filter.apply(c);","            if (t != null) {","                list.add(t);","                if (list.size() >= maxSize) {","                    return list;","                }","            }","        }","        return list;","    }","","    static <T extends Node> int countChildrenMatching(final Node node, final Filtermap<Node, T> filter, int from,","    return new ArrayList<>();","}","","    T> list = new ArrayList<>();","    return list;","}","    return list;","}","","    return list;","}","}","    return list;","}","}","","    return list;","}","}","","    return new ArrayList<>();","}","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","","    return new ArrayList<>();","}","}","}","}","}"]]}}