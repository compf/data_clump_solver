{
    "refactorings":{
        "core/src/main/java/org/bitcoinj/core/Transaction.java": [
            {
                "fromLine": 891,
                "toLine": 932,
                "oldContent": "    public TransactionInput addSignedInput(TransactionOutPoint prevOut, Script scriptPubKey, Coin amount, ECKey sigKey,\n                                           SigHash sigHash, boolean anyoneCanPay) throws ScriptException {\n        // Verify the API user didn't try to do operations out of order.\n        checkState(!outputs.isEmpty(), () ->\n                \"attempting to sign tx without outputs\");\n        if (amount == null || amount.value <= 0) {\n            log.warn(\"Illegal amount value. Amount is required for SegWit transactions.\");\n        }\n        TransactionInput input = new TransactionInput(this, new byte[] {}, prevOut, amount);\n        addInput(input);\n        int inputIndex = inputs.size() - 1;\n        if (ScriptPattern.isP2PK(scriptPubKey)) {\n            TransactionSignature signature = calculateSignature(inputIndex, sigKey, scriptPubKey, sigHash,\n                    anyoneCanPay);\n            input.setScriptSig(ScriptBuilder.createInputScript(signature));\n            input.setWitness(null);\n        } else if (ScriptPattern.isP2PKH(scriptPubKey)) {\n            TransactionSignature signature = calculateSignature(inputIndex, sigKey, scriptPubKey, sigHash,\n                    anyoneCanPay);\n            input.setScriptSig(ScriptBuilder.createInputScript(signature, sigKey));\n            input.setWitness(null);\n        } else if (ScriptPattern.isP2WPKH(scriptPubKey)) {\n            Script scriptCode = ScriptBuilder.createP2PKHOutputScript(sigKey);",
                "newContent": "    public TransactionInput addSignedInput(TransactionOutPoint prevOut, Script scriptPubKey, Coin amount, ECKey sigKey,\n                                           SigHash sigHash, boolean anyoneCanPay) throws ScriptException {\n        SignedInput signedInput = createSignedInput(prevOut, scriptPubKey, amount, sigKey, sigHash, anyoneCanPay);\n        addInput(signedInput.getInput());\n        return signedInput.getInput();\n    }\n\n    private SignedInput createSignedInput(TransactionOutPoint prevOut, Script scriptPubKey, Coin amount, ECKey sigKey,\n                                          SigHash sigHash, boolean anyoneCanPay) throws ScriptException {\n        // Verify the API user didn't try to do operations out of order.\n        checkState(!outputs.isEmpty(), () ->\n                \"attempting to sign tx without outputs\");\n        if (amount == null || amount.value <= 0) {\n            log.warn(\"Illegal amount value. Amount is required for SegWit transactions.\");\n        }\n        TransactionInput input = new TransactionInput(this, new byte[] {}, prevOut, amount);\n        int inputIndex = inputs.size() - 1;    // Account for the new input being added\n        if (ScriptPattern.isP2PK(scriptPubKey)) {\n            TransactionSignature signature = calculateSignature(inputIndex, sigKey, scriptPubKey, sigHash, anyoneCanPay);\n            input.setScriptSig(ScriptBuilder.createInputScript(signature));\n            input.setWitness(null);\n        } else if (ScriptPattern.isP2PKH(scriptPubKey)) {\n            TransactionSignature signature = calculateSignature(inputIndex, sigKey, scriptPubKey, sigHash, anyoneCanPay);\n            input.setScriptSig(ScriptBuilder.createInputScript(signature, sigKey));\n            input.setWitness(null);\n        } else if (ScriptPattern.isP2WPKH(scriptPubKey)) {\n            Script scriptCode = ScriptBuilder.createP2PKHOutputScript(sigKey);"
            },
            {
                "fromLine": 935,
                "toLine": 1029,
                "oldContent": "            input.setScriptSig(ScriptBuilder.createEmpty());\n            input.setWitness(TransactionWitness.redeemP2WPKH(signature, sigKey));\n        } else {\n            throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, \"Don't know how to sign for this kind of scriptPubKey: \" + scriptPubKey);\n        }\n        return input;\n    }\n\n    /**\n     * @param prevOut A reference to the output being spent\n     * @param scriptPubKey The scriptPubKey of the output\n     * @param sigKey The signing key\n     * @param sigHash enum specifying how the transaction hash is calculated\n     * @param anyoneCanPay anyone-can-pay hashing\n     * @return The newly created input\n     * @throws ScriptException if the scriptPubKey is something we don't know how to sign.\n     * @deprecated Use {@link Transaction#addSignedInput(TransactionOutPoint, Script, Coin, ECKey, SigHash, boolean)}\n     */\n    @Deprecated\n    public TransactionInput addSignedInput(TransactionOutPoint prevOut, Script scriptPubKey, ECKey sigKey,\n                                           SigHash sigHash, boolean anyoneCanPay) throws ScriptException {\n        return addSignedInput(prevOut, scriptPubKey, null, sigKey, sigHash, anyoneCanPay);\n    }\n\n    /**\n     * Adds a new and fully signed input for the given parameters. Note that this method is <b>not</b> thread safe\n     * and requires external synchronization.\n     * Defaults to {@link SigHash#ALL} and \"false\" for the anyoneCanPay flag. This is normally what you want.\n     * @param prevOut A reference to the output being spent\n     * @param scriptPubKey The scriptPubKey of the output\n     * @param amount The amount of the output (which is part of the signature hash for segwit)\n     * @param sigKey The signing key\n     * @return The newly created input\n     * @throws ScriptException if the scriptPubKey is something we don't know how to sign.\n     */\n    public TransactionInput addSignedInput(TransactionOutPoint prevOut, Script scriptPubKey, Coin amount, ECKey sigKey) throws ScriptException {\n        return addSignedInput(prevOut, scriptPubKey, amount, sigKey, SigHash.ALL, false);\n    }\n\n    /**\n     * @param prevOut A reference to the output being spent\n     * @param scriptPubKey The scriptPubKey of the output\n     * @param sigKey The signing key\n     * @return The newly created input\n     * @throws ScriptException if the scriptPubKey is something we don't know how to sign.\n     * @deprecated Use {@link Transaction#addSignedInput(TransactionOutPoint, Script, Coin, ECKey)}\n     */\n    @Deprecated\n    public TransactionInput addSignedInput(TransactionOutPoint prevOut, Script scriptPubKey, ECKey sigKey) throws ScriptException {\n        return addSignedInput(prevOut, scriptPubKey, null, sigKey);\n    }\n\n    /**\n     * Adds an input that points to the given output and contains a valid signature for it, calculated using the\n     * signing key. Defaults to {@link SigHash#ALL} and \"false\" for the anyoneCanPay flag. This is normally what you want.\n     * @param output output to sign and use as input\n     * @param sigKey The signing key\n     * @return The newly created input\n     */\n    public TransactionInput addSignedInput(TransactionOutput output, ECKey sigKey) {\n        return addSignedInput(output, sigKey, SigHash.ALL, false);\n    }\n\n    /**\n     * Adds an input that points to the given output and contains a valid signature for it, calculated using the\n     * signing key.\n     * @see Transaction#addSignedInput(TransactionOutPoint, Script, Coin, ECKey, SigHash, boolean)\n     * @param output output to sign and use as input\n     * @param sigKey The signing key\n     * @param sigHash enum specifying how the transaction hash is calculated\n     * @param anyoneCanPay anyone-can-pay hashing\n     * @return The newly created input\n     */\n    public TransactionInput addSignedInput(TransactionOutput output, ECKey sigKey, SigHash sigHash, boolean anyoneCanPay) {\n        Objects.requireNonNull(output.getValue(), \"TransactionOutput.getValue() must not be null\");\n        checkState(output.getValue().value > 0, () ->\n                \"transactionOutput.getValue() must not be greater than zero\");\n        return addSignedInput(output.getOutPointFor(), output.getScriptPubKey(), output.getValue(), sigKey, sigHash, anyoneCanPay);\n    }\n\n    /**\n     * Removes all the outputs from this transaction.\n     * Note that this also invalidates the length attribute\n     */\n    public void clearOutputs() {\n        for (TransactionOutput output : outputs) {\n            output.setParent(null);\n        }\n        outputs.clear();\n    }\n\n    /**\n     * Adds the given output to this transaction. The output must be completely initialized. Returns the given output.\n     */\n    public TransactionOutput addOutput(TransactionOutput to) {",
                "newContent": "            input.setScriptSig(ScriptBuilder.createEmpty());\n            input.setWitness(TransactionWitness.redeemP2WPKH(signature, sigKey));\n        } else {\n            throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, \"Don't know how to sign for this kind of scriptPubKey: \" + scriptPubKey);\n        }\n        return new SignedInput(input, sigKey);\n    }\n\n    private class SignedInput {\n        private final TransactionInput input;\n        private final ECKey sigKey;\n\n        public SignedInput(TransactionInput input, ECKey sigKey) {\n            this.input = input;\n            this.sigKey = sigKey;\n        }\n\n        public TransactionInput getInput() {\n            return input;\n        }\n\n        public ECKey getSigKey() {\n            return sigKey;\n        }\n    }"
            },
            {
                "fromLine": 1053,
                "toLine": 1197,
                "oldContent": "     */\n    public TransactionOutput addOutput(Coin value, Script script) {\n        return addOutput(new TransactionOutput(this, value, script.program()));\n    }\n\n\n    /**\n     * Calculates a signature that is valid for being inserted into the input at the given position. This is simply\n     * a wrapper around calling {@link Transaction#hashForSignature(int, byte[], Transaction.SigHash, boolean)}\n     * followed by {@link ECKey#sign(Sha256Hash)} and then returning a new {@link TransactionSignature}. The key\n     * must be usable for signing as-is: if the key is encrypted it must be decrypted first external to this method.\n     *\n     * @param inputIndex Which input to calculate the signature for, as an index.\n     * @param key The private key used to calculate the signature.\n     * @param redeemScript Byte-exact contents of the scriptPubKey that is being satisfied, or the P2SH redeem script.\n     * @param hashType Signing mode, see the enum for documentation.\n     * @param anyoneCanPay Signing mode, see the SigHash enum for documentation.\n     * @return A newly calculated signature object that wraps the r, s and sighash components.\n     */\n    public TransactionSignature calculateSignature(int inputIndex, ECKey key,\n                                                                byte[] redeemScript,\n                                                                SigHash hashType, boolean anyoneCanPay) {\n        Sha256Hash hash = hashForSignature(inputIndex, redeemScript, hashType, anyoneCanPay);\n        return new TransactionSignature(key.sign(hash), hashType, anyoneCanPay);\n    }\n\n    /**\n     * Calculates a signature that is valid for being inserted into the input at the given position. This is simply\n     * a wrapper around calling {@link Transaction#hashForSignature(int, byte[], Transaction.SigHash, boolean)}\n     * followed by {@link ECKey#sign(Sha256Hash)} and then returning a new {@link TransactionSignature}.\n     *\n     * @param inputIndex Which input to calculate the signature for, as an index.\n     * @param key The private key used to calculate the signature.\n     * @param redeemScript The scriptPubKey that is being satisfied, or the P2SH redeem script.\n     * @param hashType Signing mode, see the enum for documentation.\n     * @param anyoneCanPay Signing mode, see the SigHash enum for documentation.\n     * @return A newly calculated signature object that wraps the r, s and sighash components.\n     */\n    public TransactionSignature calculateSignature(int inputIndex, ECKey key,\n                                                                 Script redeemScript,\n                                                                 SigHash hashType, boolean anyoneCanPay) {\n        Sha256Hash hash = hashForSignature(inputIndex, redeemScript.program(), hashType, anyoneCanPay);\n        return new TransactionSignature(key.sign(hash), hashType, anyoneCanPay);\n    }\n\n    /**\n     * Calculates a signature that is valid for being inserted into the input at the given position. This is simply\n     * a wrapper around calling {@link Transaction#hashForSignature(int, byte[], Transaction.SigHash, boolean)}\n     * followed by {@link ECKey#sign(Sha256Hash)} and then returning a new {@link TransactionSignature}. The key\n     * must be usable for signing as-is: if the key is encrypted it must be decrypted first external to this method.\n     *\n     * @param inputIndex Which input to calculate the signature for, as an index.\n     * @param key The private key used to calculate the signature.\n     * @param aesKey The AES key to use for decryption of the private key. If null then no decryption is required.\n     * @param redeemScript Byte-exact contents of the scriptPubKey that is being satisfied, or the P2SH redeem script.\n     * @param hashType Signing mode, see the enum for documentation.\n     * @param anyoneCanPay Signing mode, see the SigHash enum for documentation.\n     * @return A newly calculated signature object that wraps the r, s and sighash components.\n     */\n    public TransactionSignature calculateSignature(int inputIndex, ECKey key,\n                                                   @Nullable AesKey aesKey,\n                                                   byte[] redeemScript,\n                                                   SigHash hashType, boolean anyoneCanPay) {\n        Sha256Hash hash = hashForSignature(inputIndex, redeemScript, hashType, anyoneCanPay);\n        return new TransactionSignature(key.sign(hash, aesKey), hashType, anyoneCanPay);\n    }\n\n    /**\n     * Calculates a signature that is valid for being inserted into the input at the given position. This is simply\n     * a wrapper around calling {@link Transaction#hashForSignature(int, byte[], Transaction.SigHash, boolean)}\n     * followed by {@link ECKey#sign(Sha256Hash)} and then returning a new {@link TransactionSignature}.\n     *\n     * @param inputIndex Which input to calculate the signature for, as an index.\n     * @param key The private key used to calculate the signature.\n     * @param aesKey The AES key to use for decryption of the private key. If null then no decryption is required.\n     * @param redeemScript The scriptPubKey that is being satisfied, or the P2SH redeem script.\n     * @param hashType Signing mode, see the enum for documentation.\n     * @param anyoneCanPay Signing mode, see the SigHash enum for documentation.\n     * @return A newly calculated signature object that wraps the r, s and sighash components.\n     */\n    public TransactionSignature calculateSignature(int inputIndex, ECKey key,\n                                                   @Nullable AesKey aesKey,\n                                                   Script redeemScript,\n                                                   SigHash hashType, boolean anyoneCanPay) {\n        Sha256Hash hash = hashForSignature(inputIndex, redeemScript.program(), hashType, anyoneCanPay);\n        return new TransactionSignature(key.sign(hash, aesKey), hashType, anyoneCanPay);\n    }\n\n    /**\n     * <p>Calculates a signature hash, that is, a hash of a simplified form of the transaction. How exactly the transaction\n     * is simplified is specified by the type and anyoneCanPay parameters.</p>\n     *\n     * <p>This is a low level API and when using the regular {@link Wallet} class you don't have to call this yourself.\n     * When working with more complex transaction types and contracts, it can be necessary. When signing a P2SH output\n     * the redeemScript should be the script encoded into the scriptSig field, for normal transactions, it's the\n     * scriptPubKey of the output you're signing for.</p>\n     *\n     * @param inputIndex input the signature is being calculated for. Tx signatures are always relative to an input.\n     * @param redeemScript the bytes that should be in the given input during signing.\n     * @param type Should be SigHash.ALL\n     * @param anyoneCanPay should be false.\n     */\n    public Sha256Hash hashForSignature(int inputIndex, byte[] redeemScript,\n                                                    SigHash type, boolean anyoneCanPay) {\n        byte sigHashType = (byte) TransactionSignature.calcSigHashValue(type, anyoneCanPay);\n        return hashForSignature(inputIndex, redeemScript, sigHashType);\n    }\n\n    /**\n     * <p>Calculates a signature hash, that is, a hash of a simplified form of the transaction. How exactly the transaction\n     * is simplified is specified by the type and anyoneCanPay parameters.</p>\n     *\n     * <p>This is a low level API and when using the regular {@link Wallet} class you don't have to call this yourself.\n     * When working with more complex transaction types and contracts, it can be necessary. When signing a P2SH output\n     * the redeemScript should be the script encoded into the scriptSig field, for normal transactions, it's the\n     * scriptPubKey of the output you're signing for.</p>\n     *\n     * @param inputIndex input the signature is being calculated for. Tx signatures are always relative to an input.\n     * @param redeemScript the script that should be in the given input during signing.\n     * @param type Should be SigHash.ALL\n     * @param anyoneCanPay should be false.\n     */\n    public Sha256Hash hashForSignature(int inputIndex, Script redeemScript,\n                                                    SigHash type, boolean anyoneCanPay) {\n        int sigHash = TransactionSignature.calcSigHashValue(type, anyoneCanPay);\n        return hashForSignature