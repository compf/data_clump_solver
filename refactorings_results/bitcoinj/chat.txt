{"refactorings":{"core/src/main/java/org/bitcoinj/core/Transaction.java":[{"fromLine":891,"toLine":932,"oldContent":"    public TransactionInput addInput(Sha256Hash spendTxHash, long outputIndex, Script script) {\n        return addInput(new TransactionInput(this, script.program(), new TransactionOutPoint(outputIndex, spendTxHash)));\n    }\n\n    /**\n     * Adds a new and fully signed input for the given parameters. Note that this method is <b>not</b> thread safe\n     * and requires external synchronization. Please refer to general documentation on Bitcoin scripting and contracts\n     * to understand the values of sigHash and anyoneCanPay: otherwise you can use the other form of this method\n     * that sets them to typical defaults.\n     *\n     * @param prevOut A reference to the output being spent\n     * @param scriptPubKey The scriptPubKey of the output\n     * @param amount The amount of the output (which is part of the signature hash for segwit)\n     * @param sigKey The signing key\n     * @param sigHash enum specifying how the transaction hash is calculated\n     * @param anyoneCanPay anyone-can-pay hashing\n     * @return The newly created input\n     * @throws ScriptException if the scriptPubKey is something we don't know how to sign.\n     */\n    public TransactionInput addSignedInput(TransactionOutPoint prevOut, Script scriptPubKey, Coin amount, ECKey sigKey,\n                                           SigHash sigHash, boolean anyoneCanPay) throws ScriptException {\n        // Verify the API user didn't try to do operations out of order.\n        checkState(!outputs.isEmpty(), () ->\n                \"attempting to sign tx without outputs\");\n        if (amount == null || amount.value <= 0) {\n            log.warn(\"Illegal amount value. Amount is required for SegWit transactions.\");\n        }\n        TransactionInput input = new TransactionInput(this, new byte[] {}, prevOut, amount);\n        addInput(input);\n        int inputIndex = inputs.size() - 1;\n        if (ScriptPattern.isP2PK(scriptPubKey)) {\n            TransactionSignature signature = calculateSignature(inputIndex, sigKey, scriptPubKey, sigHash,\n                    anyoneCanPay);\n            input.setScriptSig(ScriptBuilder.createInputScript(signature));\n            input.setWitness(null);\n        } else if (ScriptPattern.isP2PKH(scriptPubKey)) {\n            TransactionSignature signature = calculateSignature(inputIndex, sigKey, scriptPubKey, sigHash,\n                    anyoneCanPay);\n            input.setScriptSig(ScriptBuilder.createInputScript(signature, sigKey));\n            input.setWitness(null);\n        } else if (ScriptsPattern.isP2WPKH(scriptPubKey)) {\n            Script scriptCode = ScriptBuilder.createP2PKHOutputScript(sigKey);","newContent":"    public TransactionInput addSignedInput(TransactionOutPoint prevOut, Script scriptPubKey, Coin amount, ECKey sigKey,\n                                           SigHash sigHash, boolean anyoneCanPay) throws ScriptException {\n        return addSignedInput(new TransactionInput.SignatureData(prevOut, scriptPubKey, amount, sigKey, sigHash, anyoneCanPay));\n    }"},{"fromLine":935,"toLine":1029,"oldContent":"            input.setScriptSig(ScriptBuilder.createEmpty());\n            input.setWitness(TransactionWitness.redeemP2WPKH(signature, sigKey));\n        } else {\n            throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, \"Don't know how to sign for this kind of scriptPubKey: \" + scriptPubKey);\n        }\n        return input;\n    }\n\n    /**\n     * @param prevOut A reference to the output being spent\n     * @param scriptPubKey The scriptPubKey of the output\n     * @param sigKey The signing key\n     * @param sigHash enum specifying how the transaction hash is calculated\n     * @param anyoneCanPay anyone-can-pay hashing\n     * @return The newly created input\n     * @throws ScriptException if the scriptPubKey is something we don't know how to sign.\n     * @deprecated Use {@link Transaction#addSignedInput(TransactionOutPoint, Script, Coin, ECKey, SigHash, boolean)}\n     */\n    @Deprecated\n    public TransactionInput addSignedInput(TransactionOutPoint prevOut, Script scriptPubKey, ECKey sigKey,\n                                           SigHash sigHash, boolean anyoneCanPay) throws ScriptException {\n        return addSignedInput(prevOut, scriptPubKey, null, sigKey, sigHash, anyoneCanPay);\n    }\n\n    /**\n     * Adds a new and fully signed input for the given parameters. Note that this method is <b>not</b> thread safe\n     * and requires external synchronization.\n     * Defaults to {@link SigHash#ALL} and \"false\" for the anyoneCanPay flag. This is normally what you want.\n     * @param prevOut A reference to the output being spent\n     * @param scriptPubKey The scriptPubKey of the output\n     * @param amount The amount of the output (which is part of the signature hash for segwit)\n     * @param sigKey The signing key\n     * @return The newly created input\n     * @throws ScriptException if the scriptPubKey is something we don't know how to sign.\n     */\n    public TransactionInput addSignedInput(TransactionOutPoint prevOut, Script scriptPubKey, Coin amount, ECKey sigKey) throws ScriptException {\n        return addSignedInput(prevOut, scriptPubKey, amount, sigKey, SigHash.ALL, false);\n    }\n\n    /**\n     * @param prevOut A reference to the output being spent\n     * @param scriptPubKey The scriptPubKey of the output\n     * @param sigKey The signing key\n     * @return The newly created input\n     * @throws ScriptException if the scriptPubKey is something we don't know how to sign.\n     * @deprecated Use {@link Transaction#addSignedInput(TransactionOutPoint, Script, Coin, ECKey)}\n     */\n    @Deprecated\n    public TransactionInput addSignedInput(TransactionOutPoint prevOut, Script scriptPubKey, ECKey sigKey) throws ScriptException {\n        return addSignedInput(prevOut, scriptPubKey, null, sigKey);\n    }\n\n    /**\n     * Adds an input that points to the given output and contains a valid signature for it, calculated using the\n     * signing key. Defaults to {@link SigHash#ALL} and \"false\" for the anyoneCanPay flag. This is normally what you want.\n     * @param output output to sign and use as input\n     * @param sigKey The signing key\n     * @return The newly created input\n     */\n    public TransactionInput addSignedInput(TransactionOutput output, ECKey sigKey) {\n        return addSignedInput(output, sigKey, SigHash.ALL, false);\n    }\n\n    /**\n     * Adds an input that points to the given output and contains a valid signature for it, calculated using the\n     * signing key.\n     * @see Transaction#addSignedInput(TransactionOutPoint, Script, Coin, ECKey, SigHash, boolean)\n     * @param output output to sign and use as input\n     * @param sigKey The signing key\n     * @param sigHash enum specifying how the transaction hash is calculated\n     * @param anyoneCanPay anyone-can-pay hashing\n     * @return The newly created input\n     */\n    public TransactionInput addSignedInput(TransactionOutput output, ECKey sigKey, SigHash sigHash, boolean anyoneCanPay) {\n        Objects.requireNonNull(output.getValue(), \"TransactionOutput.getValue() must not be null\");\n        checkState(output.getValue().value > 0, () ->\n                \"transactionOutput.getValue() must not be greater than zero\");\n        return addSignedInput(output.getOutPointFor(), output.getScriptPubKey(), output.getValue(), sigKey, sigHash, anyoneCanPay);\n    }\n\n    /**\n     * Removes all the outputs from this transaction.\n     * Note that this also invalidates the length attribute\n     */\n    public void clearOutputs() {\n        for (TransactionOutput output : outputs) {\n            output.setParent(null);\n        }\n        outputs.clear();\n    }\n\n    /**\n     * Adds the given output to this transaction. The output must be completely initialized. Returns the given output.\n     */\n    public TransactionOutput addOutput(TransactionOutput to) {","newContent":"    public TransactionOutput addOutput(TransactionOutput to) {\n        return addOutput(new TransactionOutput(this, to.getValue(), to.getScriptBytes()));\n    }"}],"core/src/main/java/org/bitcoinj/kits/WalletAppKit.java":[{"fromLine":73,"toLine":123,"oldContent":" *\n * <p>To add listeners and modify the objects that are constructed, you can either do that by overriding the\n * {@link #onSetupCompleted()} method (which will run on a background thread) and make your changes there,\n * or by waiting for the service to start and then accessing the objects from wherever you want. However, you cannot\n * access the objects this class creates until startup is complete.</p>\n *\n * <p>The asynchronous design of this class may seem puzzling (just use {@link #awaitRunning()} if you don't want that).\n * It is to make it easier to fit bitcoinj into GUI apps, which require a high degree of responsiveness on their main\n * thread which handles all the animation and user interaction. Even when blockingStart is false, initializing bitcoinj\n * means doing potentially blocking file IO, generating keys and other potentially intensive operations. By running it\n * on a background thread, there's no risk of accidentally causing UI lag.</p>\n *\n * <p>Note that {@link #awaitRunning()} can throw an unchecked {@link IllegalStateException}\n * if anything goes wrong during startup - you should probably handle it and use {@link Exception#getCause()} to figure\n * out what went wrong more precisely. Same thing if you just use the {@link #startAsync()} method.</p>\n */\npublic class WalletAppKit extends AbstractIdleService implements Closeable {\n    protected static final Logger log = LoggerFactory.getLogger(WalletAppKit.class);\n\n    protected final BitcoinNetwork network;\n    protected final NetworkParameters params;\n    protected final ScriptType preferredOutputScriptType;\n    protected final KeyChainGroupStructure structure;\n    protected final String filePrefix;\n    protected volatile BlockChain vChain;\n    protected volatile SPVBlockStore vStore;\n    protected volatile Wallet vWallet;\n    protected volatile PeerGroup vPeerGroup;\n\n    protected final File directory;\n    protected volatile File vWalletFile;\n\n    protected boolean useAutoSave = true;\n    protected PeerAddress[] peerAddresses;\n    protected DownloadProgressTracker downloadListener = new DownloadProgressTracker();\n    protected boolean autoStop = true;\n    protected InputStream checkpoints;\n    protected boolean blockingStartup = true;\n    protected String userAgent, version;\n    @Nonnull protected WalletProtobufSerializer.WalletFactory walletFactory = WalletProtobufSerializer.WalletFactory.DEFAULT;\n    @Nullable protected DeterministicSeed restoreFromSeed;\n    @Nullable protected DeterministicKey restoreFromKey;\n    @Nullable protected PeerDiscovery discovery;\n\n    /**\n     * Creates a new WalletAppKit, with a newly created {@link Context}. Files will be stored in the given directory.\n     * @deprecated Use {@link #WalletAppKit(BitcoinNetwork, ScriptType, KeyChainGroupStructure, File, String)}\n     */\n    @Deprecated\n    public WalletAppKit(NetworkParameters params, File directory, String filePrefix) {\n        this((BitcoinNetwork) params.network(), ScriptType.P2PKH, KeyChainGroupStructure.BIP32, directory, fileStripPrefix);","newContent":"    public WalletAppKit(NetworkParameters params, File directory, String filePrefix) {\n        this((BitcoinNetwork) params.network(), ScriptType.P2PKH, KeyChainGroupStructure.BIP32, directory, filePrefix);\n    }"}],"core/src/main/java/org/bitcoinj/utils/BtcFormat.java":[{"fromLine":949,"toLine":989,"oldContent":"    public static BtcFormat getCoinInstance(int minFractionPlaces, int... groups) {\n        return getInstance(COIN_SCALE, defaultLocale(), minFractionPlaces, boxAsList(groups));\n    }\n\n    /**\n     * Return a new coin-denominated formatter for the given locale.  The returned object will\n     * format the fractional part of numbers with two decimal places, rounding as necessary.\n     */\n    public static BtcFormat getCoinInstance(Locale locale) {\n        return getInstance(COIN_SCALE, locale, 2);\n    }\n\n    /**\n     * Return a newly-constructed instance for the given locale that will format\n     * values in terms of bitcoins, with the given minimum number of fractional\n     * decimal places.  Optionally, repeating integer arguments can be passed, each\n     * indicating the size of an additional group of fractional decimal places to be\n     * used as necessary to avoid rounding, to a limiting precision of satoshis.\n     */\n    public static BtcFormat getCoinInstance(Locale locale, int scale, int... groups) {\n        return getInstance(COIN_SCALE, locale, scale, boxAsList(groups));\n    }\n\n    /**\n     * Return a new millicoin-denominated formatter.  The returned object will format and\n     * parse values for the default locale, and will format the fractional part of numbers with\n     * two decimal places, rounding as necessary.\n     */\n    public static BtcFormat getMilliInstance() { return getMilliInstance(defaultLocale()); }\n\n    /**\n     * Return a new millicoin-denominated formatter for the given locale.  The returned object\n     * will format the fractional part of numbers with two decimal places, rounding as\n     * necessary.\n     */\n    public static BtcFormat getMilliInstance(Locale locale) {\n        return getInstance(MILLICOIN_SCALE, locale, 2);\n    }\n\n    /**\n     * Return a new millicoin-denominated formatter with the specified fractional decimal","newContent":"    public static BtcFormat getCoinInstance(int minFractionPlaces, int... groups) {\n        return getInstance(COIN_SCALE, defaultLocale(), minFractionPlaces, Arrays.asList(box(groups)));\n    }\n\n    public static BtcFormat getCoinInstance(Locale locale) {\n        return getInstance(COIN_SCALE, locale, 2);\n    }\n\n    public static BtcFormat getCoinInstance(Locale locale, int scale, int... groups) {\n        return getInstance(COIN_SCALE, locale, scale, Arrays.asList(box(groups)));\n    }\n\n    public static BtcFormat getMilliInstance() {\n        return getMilliInstance(defaultLocale());\n    }\n\n    public static BtcFormat getMilliInstance(Locale locale) {\n        return getInstance(MILLICOIN_SCALE, locale, 2);\n    }\n\n    public static BtcFormat getMicroInstance(Locale locale, int scale, int... groups) {\n        return getInstance(MICROCOIN_SCALE, locale, scale, Arrays.asList(box(groups)));\n    }\n\n    public static BtcFormat getInstance(int scale, int minDecimals, int... groups) {\n        return getInstance(scale, defaultLocale(), minDecimals, Arrays.asList(box(groups)));\n    }\n\n    public static BtcFormat getInstance(int scale) {\n        return getInstance(scale, defaultLocale());\n    }\n\n    public static BtcFormat getInstance(int scale, Locale locale) {\n        return getInstance(scale, locale, 2);\n    }\n\n    public static BtcFormat getInstance(int scale, Locale locale, int minDecimals, int... groups) {\n        return getInstance(scale, locale, minDecimals, Arrays.asList(box(groups)));\n    }\n\n    @Override\n    public StringBuffer format(Object qty, StringBuffer toAppendTo, FieldPosition pos) {\n        return format(qty, toAppendTo, pos, minimumFractionDigits, decimalGroups);\n    }\n\n    public String format(Object qty, int minDecimals, int... fractionGroups) {\n        return format(qyq, new StringBuffer(), new FieldPosition(0), minDecimals, Arrays.asList(box(fractionGroups))).toString();\n    }\n\n    public StringBuffer format(Object qty, StringBuffer toAppendTo, FieldPosition pos,\n                                            int minDecimals, int... fractionGroups) {\n        return format(qty, toAppendTo, pos, minDecimals, Arrays.asList(box(fractionGroups)));\n    }\n\n    // Remaining content unchanged\n    "}],"core/src/main/java/org/bitcoinj/script/Script.java":[{"fromLine":893,"toLine":934,"oldContent":"                // it would conflict with the sign bit. An example of this case\n                // is +-255, which encode to 0xff00 and 0xff80 respectively.\n                // (big-endian).\n                if (chunk.length <= 1 || (chunk[chunk.length - 2] & 0x80) == 0) {\n                    throw  new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, \"non-minimally encoded script number\");\n                }\n            }\n        }\n\n        return ByteUtils.decodeMPI(ByteUtils.reverseBytes(chunk), false);\n    }\n\n    /**\n     * Exposes the script interpreter. Normally you should not use this directly, instead use\n     * {@link TransactionInput#verify(TransactionOutput)} or\n     * {@link Script#correctlySpends(Transaction, int, TransactionWitness, Coin, Script, Set)}. This method\n     * is useful if you need more precise control or access to the final state of the stack. This interface is very\n     * likely to change in future.\n     */\n    public static void executeScript(@Nullable Transaction txContainingThis, long index,\n                                     Script script, LinkedList<byte[]> stack, Set<VerifyFlag> verifyFlags) throws ScriptException {\n        int opCount = 0;\n        int lastCodeSepLocation = 0;\n        \n        LinkedList<byte[]> altstack = new LinkedList<>();\n        LinkedList<Boolean> ifStack = new LinkedList<>();\n\n        int nextLocationInScript = 0;\n        for (ScriptChunk chunk : script.chunks) {\n            boolean shouldExecute = !ifStack.contains(false);\n            int opcode = chunk.opcode;\n            nextLocationInScript += chunk.size();\n\n            // Check stack element size\n            if