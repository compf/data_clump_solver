{
    "refactorings": {
        "core/src/main/java/org/bitcoinj/core/Transaction.java": [
            {
                "fromLine": 891,
                "toLine": 932,
                "oldContent": "    public TransactionInput addSignedInput(TransactionOutPoint prevOut, Script scriptPubKey, Coin amount, ECKey sigKey,\n                                           SigHash sigHash, boolean anyoneCanPay) throws ScriptException {\n        // Verify the API user didn't try to do operations out of order.\n        checkState(!outputs.isEmpty(), () ->\n                \"attempting to sign tx without outputs\");\n        if (amount == null || amount.value <= 0) {\n            log.warn(\"Illegal amount value. Amount is required for SegWit transactions.\");\n        }\n        TransactionInput input = new TransactionInput(this, new byte[] {}, prevOut, amount);\n        addInput(input);\n        int inputIndex = inputs.size() - 1;\n        if (ScriptPattern.isP2PK(scriptPubKey)) {\n            TransactionSignature signature = calculateSignature(inputIndex, sigKey, scriptPubKey, sigHash,\n                    anyoneCanPay);\n            input.setScriptSig(ScriptBuilder.createInputScript(signature));\n            input.setWitness(null);\n        } else if (ScriptPattern.isP2PKH(scriptPubKey)) {\n            TransactionSignature signature = calculateSignature(inputIndex, sigKey, scriptPubKey, sigHash,\n                    anyoneCanPay);\n            input.setScriptSig(ScriptBuilder.createInputScript(signature, sigKey));\n            input.setWitness(null);\n        } else if (ScriptPattern.isP2WPKH(scriptPubKey)) {\n            Script scriptCode = ScriptBuilder.createP2PKHOutputScript(sigKey);",
                "newContent": "    public TransactionInput addSignedInput(TransactionOutPoint prevOut, Script scriptPubKey, Coin amount, ECKey sigKey,\n                                           SigHash sigHash, boolean anyoneCanPay) throws ScriptException {\n        // Verify the API user didn't try to do operations out of order.\n        checkState(!outputs.isEmpty(), () ->\n                \"attempting to sign tx without outputs\");\n        if (amount == null || amount.value <= 0) {\n            log.warn(\"Illegal amount value. Amount is required for SegWit transactions.\");\n        }\n        TransactionInput input = new TransactionInput(this, new byte[] {}, prevOut, amount);\n        addInput(input);\n        int inputIndex = inputs.size() - 1;\n        if (ScriptPattern.isP2PK(scriptPubKey)) {\n            TransactionSignature signature = calculateSignature(inputIndex, sigKey, scriptPubKey, sigHash,\n                    anyoneCanPay);\n            input.setScriptSig(ScriptBuilder.createInputScript(signature));\n            input.setWitness(null);\n        } else if (ScriptPattern.isP2PKH(scriptPubKey)) {\n            TransactionSignature signature = calculateSignature(inputIndex, sigKey, scriptPubKey, sigHash,\n                    anyoneCanPay);\n            input.setScriptSig(ScriptBuilder.createInputScript(signature, sigKey));\n            input.setWitness(null);\n        } else if (ScriptPattern.isP2WPKH(scriptPubKey)) {\n            SignatureData signatureData = calculateWitnessSignature(inputIndex, sigKey, scriptPubKey,\n                    amount, sigHash, anyoneCanPay);\n            input.setScriptSig(ScriptBuilder.createEmpty());\n            input.setWitness(signatureData.getWitness());"
            },
            {
                "fromLine": 935,
                "toLine": 1029,
                "oldContent": "            input.setScriptSig(ScriptBuilder.createEmpty());\n            input.setWitness(TransactionWitness.redeemP2WPKH(signature, sigKey));\n        } else {\n            throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, \"Don't know how to sign for this kind of scriptPubKey: \" + scriptPubKey);\n        }\n        return input;\n    }\n\n    /**\n     * @param prevOut A reference to the output being spent\n     * @param scriptPubKey The scriptPubKey of the output\n     * @param sigKey The signing key\n     * @param sigHash enum specifying how the transaction hash is calculated\n     * @param anyoneCanPay anyone-can-pay hashing\n     * @return The newly created input\n     * @throws ScriptException if the scriptPubKey is something we don't know how to sign.\n     * @deprecated Use {@link Transaction#addSignedInput(TransactionOutPoint, Script, Coin, ECKey, SigHash, boolean)}\n     */\n",
                "newContent": "        } else {\n            SignatureData signatureData = calculateSignatureData(scriptPubKey, inputIndex, sigKey, amount,\n                    sigHash, anyoneCanPay);\n            input.setScriptSig(signatureData.getScriptSig());\n            if (signatureData.getWitness() != null)\n                input.setWitness(signatureData.getWitness());\n        }\n        return input;\n    }\n\n    private SignatureData calculateSignatureData(Script scriptPubKey, int inputIndex, ECKey sigKey, Coin amount,\n                                                  SigHash sigHash, boolean anyoneCanPay) throws ScriptException {\n        if (ScriptPattern.isP2PK(scriptPubKey) || ScriptPattern.isP2PKH(scriptPubKey)) {\n            TransactionSignature signature = calculateSignature(inputIndex, sigKey, scriptPubKey, sigHash, anyoneCanPay);\n            return new SignatureData(ScriptBuilder.createInputScript(signature, sigKey), null);\n        } else if (ScriptPattern.isP2WPKH(scriptPubKey)) {\n            TransactionSignature signature = calculateSignature(inputIndex, sigKey, scriptPubKey, sigHash, anyoneCanPay);\n            return new SignatureData(ScriptBuilder.createEmpty(), TransactionWitness.redeemP2WPKH(signature, sigKey));\n        } else {\n            throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, \"Don't know how to sign for this kind of scriptPubKey: \" + scriptPubKey);\n        }\n    }\n\n    /**\n     * @param prevOut A reference to the output being spent\n     * @param scriptPubKey The scriptPubKey of the output\n     * @param sigKey The signing key\n     * @param sigHash enum specifying how the transaction hash is calculated\n     * @param anyoneCanPay anyone-can-pay hashing\n     * @return The newly created input\n     * @throws ScriptException if the scriptPubKey is something we don't know how to sign.\n     * @deprecated Use {@link Transaction#addSignedInput(TransactionOutPoint, Script, Coin, ECKey, SigHash, boolean)}\n     */\n"
            }
        ]
    },
    "extractedClasses": {
        "core/src/main/java/org/bitcoinj/core/SignatureData.java": "package org.bitcoinj.core;\n\nimport org.bitcoinj.script.Script;\n\n/**\n * Holds the scriptSig and witness of an input script.\n */\npublic class SignatureData {\n    private final Script scriptSig;\n    private final TransactionWitness witness;\n\n    public SignatureData(Script scriptSig, TransactionWitness witness) {\n        this.scriptSig = scriptSig;\n        this.witness = witness;\n    }\n\n    public Script getScriptSig() {\n        return scriptSig;\n    }\n\n    public TransactionWitness getWitness() {\n        return witness;\n    }\n}\n"
    }
}