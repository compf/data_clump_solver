{
    "refactorings": {
        "core/src/main/java/org/bitcoinj/core/Transaction.java": [
            {
                "fromLine": 891,
                "toLine": 932,
                "oldContent": "    public TransactionInput addSignedInput(TransactionOutPoint prevOut, Script scriptPubKey, Coin amount, ECKey sigKey,\n                                           SigHash sigHash, boolean anyoneCanPay) throws ScriptException {\n        // Verify the API user didn't try to do operations out of order.\n        checkState(!outputs.isEmpty(), () ->\n                \"attempting to sign tx without outputs\");\n        if (amount == null || amount.value <= 0) {\n            log.warn(\"Illegal amount value. Amount is required for SegWit transactions.\");\n        }\n        TransactionInput input = new TransactionInput(this, new byte[] {}, prevOut, amount);\n        addInput(input);\n        int inputIndex = inputs.size() - 1;\n        if (ScriptPattern.isP2PK(scriptPubKey)) {\n            TransactionSignature signature = calculateSignature(inputIndex, sigKey, scriptPubKey, sigHash,\n                    anyoneCanPay);\n            input.setScriptSig(ScriptBuilder.createInputScript(signature));\n            input.setWitness(null);\n        } else if (ScriptPattern.isP2PKH(scriptPubKey)) {\n            TransactionSignature signature = calculateSignature(inputIndex, sigKey, scriptPubKey, sigHash,\n                    anyoneCanPay);\n            input.setScriptSig(ScriptBuilder.createInputScript(signature, sigKey));\n            input.setWitness(null);\n        } else if (ScriptPattern.isP2WPKH(scriptPubKey)) {\n            Script scriptCode = ScriptBuilder.createP2PKHOutputScript(sigKey);",
                "newContent": "    public TransactionInput addSignedInput(SignedInputParameters parameters) throws ScriptException {\n        // Verify the API user didn't try to do operations out of order.\n        checkState(!outputs.isEmpty(), () ->\n                \"attempting to sign tx without outputs\");\n        if (parameters.amount == null || parameters.amount.value <= 0) {\n            log.warn(\"Illegal amount value. Amount is required for SegWit transactions.\");\n        }\n        TransactionInput input = new TransactionInput(this, new byte[] {}, parameters.prevOut, parameters.amount);\n        addInput(input);\n        int inputIndex = inputs.size() - 1;\n        if (ScriptPattern.isP2PK(parameters.scriptPubKey)) {\n            TransactionSignature signature = calculateSignature(inputIndex, parameters.sigKey, parameters.scriptPubKey, parameters.sigHash,\n                    parameters.anyoneCanPay);\n            input.setScriptSig(ScriptBuilder.createInputScript(signature));\n            input.setWitness(null);\n        } else if (ScriptPattern.isP2PKH(parameters.scriptPubKey)) {\n            TransactionSignature signature = calculateSignature(inputIndex, parameters.sigKey, parameters.scriptPubKey, parameters.sigHash,\n                    parameters.anyoneCanPay);\n            input.setScriptSig(ScriptBuilder.createInputScript(signature, parameters.sigKey));\n            input.setWitness(null);\n        } else if (ScriptPattern.isP2WPKH(parameters.scriptPubKey)) {\n            Script scriptCode = ScriptBuilder.createP2PKHOutputScript(parameters.sigKey);"
            },
            {
                "fromLine": 935,
                "toLine": 1029,
                "oldContent": "            input.setScriptSig(ScriptBuilder.createEmpty());\n            input.setWitness(TransactionWitness.redeemP2WPKH(signature, sigKey));\n        } else {\n            throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, \"Don't know how to sign for this kind of scriptPubKey: \" + scriptPubKey);\n        }\n        return input;\n    }\n\n    /**\n     * @param prevOut A reference to the output being spent\n     * @param scriptPubKey The scriptPubKey of the output\n     * @param sigKey The signing key\n     * @param sigHash enum specifying how the transaction hash is calculated\n     * @param anyoneCanPay anyone-can-pay hashing\n     * @return The newly created input\n     * @throws ScriptException if the scriptPubKey is something we don't know how to sign.\n     * @deprecated Use {@link Transaction#addSignedInput(TransactionOutPoint, Script, Coin, ECKey, SigHash, boolean)}\n     */\n    @Deprecated\n    public TransactionInput addSignedInput(TransactionOutPoint prevOut, Script scriptPubKey, ECKey sigKey,\n                                           SigHash sigHash, boolean anyoneCanPay) throws ScriptException {\n        return addSignedInput(prevOut, scriptPubKey, null, sigKey, sigHash, anyoneCanPay);\n    }\n\n    /**\n     * Adds a new and fully signed input for the given parameters. Note that this method is <b>not</b> thread safe\n     * and requires external synchronization.\n     * Defaults to {@link SigHash#ALL} and \"false\" for the anyoneCanPay flag. This is normally what you want.\n     * @param prevOut A reference to the output being spent\n     * @param scriptPubKey The scriptPubKey of the output\n     * @param amount The amount of the output (which is part of the signature hash for segwit)\n     * @param sigKey The signing key\n     * @return The newly created input\n     * @throws ScriptException if the scriptPubKey is something we don't know how to sign.\n     */\n    public TransactionInput addSignedInput(TransactionOutPoint prevOut, Script scriptPubKey, Coin amount, ECKey sigKey) throws ScriptException {\n        return addSignedInput(prevOut, scriptPubKey, amount, sigKey, SigHash.ALL, false);\n    }\n\n    /**\n     * @param prevOut A reference to the output being spent\n     * @param scriptPubKey The scriptPubKey of the output\n     * @param sigKey The signing key\n     * @return The newly created input\n     * @throws ScriptException if the scriptPubKey is something we don't know how to sign.\n     * @deprecated Use {@link Transaction#addSignedInput(TransactionOutPoint, Script, Coin, ECKey)}\n     */\n    @Deprecated\n    public TransactionInput addSignedInput(TransactionOutPoint prevOut, Script scriptPubKey, ECKey sigKey) throws ScriptException {\n        return addSignedInput(prevOut, scriptPubKey, null, sigKey);\n    }\n\n    /**\n     * Adds an input that points to the given output and contains a valid signature for it, calculated using the\n     * signing key. Defaults to {@link SigHash#ALL} and \"false\" for the anyoneCanPay flag. This is normally what you want.\n     * @param output output to sign and use as input\n     * @param sigKey The signing key\n     * @return The newly created input\n     */\n    public TransactionInput addSignedInput(TransactionOutput output, ECKey sigKey) {\n        return addSignedInput(output, sigKey, SigHash.ALL, false);\n    }\n\n    /**\n     * Adds an input that points to the given output and contains a valid signature for it, calculated using the\n     * signing key.\n     * @see Transaction#addSignedInput(TransactionOutPoint, Script, Coin, ECKey, SigHash, boolean)\n     * @param output output to sign and use as input\n     * @param sigKey The signing key\n     * @param sigHash enum specifying how the transaction hash is calculated\n     * @param anyoneCanPay anyone-can-pay hashing\n     * @return The newly created input\n     */\n    public TransactionInput ",
                "newContent": "            input.setScriptSig(ScriptBuilder.createEmpty());\n            input.setWitness(TransactionWitness.redeemP2WPKH(signature, parameters.sigKey));\n        } else {\n            throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, \"Don't know how to sign for this kind of scriptPubKey: \" + parameters.scriptPubKey);\n        }\n        return input;\n    }\n\n    /**\n     * @param parameters A reference to the parameters of the signed input\n     * @return The newly created input\n     * @throws ScriptException if the scriptPubKey is something we don't know how to sign.\n     * @deprecated Use {@link Transaction#addSignedInput(SignedInputParameters)}\n     */\n    @Deprecated\n    public TransactionInput addSignedInput(SignedInputParameters parameters) throws ScriptException {\n        return addSignedInput(parameters.withAmount(null));\n    }\n\n    /**\n     * Adds a new and fully signed input for the given parameters using default values.\n     * Note that this method is <b>not</b> thread safe and requires external synchronization.\n     * Defaults to {@link SigHash#ALL} and \"false\" for the anyoneCanPay flag. This is normally what you want.\n     * @param parameters A reference to the parameters of the signed input\n     * @return The newly created input\n     * @throws ScriptException if the scriptPubKey is something we don't know how to sign.\n     */\n    public TransactionInput addSignedInput(SignedInputParameters parameters) throws ScriptException {\n        return addSignedInput(parameters.withSigHash(SigHash.ALL).withAnyoneCanPay(false));\n    }\n\n    /**\n     * @param parameters A reference to the parameters of the signed input\n     * @return The newly created input\n     * @throws ScriptException if the scriptPubKey is something we don't know how to sign.\n     * @deprecated Use {@link Transaction#addSignedInput(SignedInputParameters)}\n     */\n    @Deprecated\n    public TransactionInput addSignedInput(SignedInputParameters parameters) throws ScriptException {\n        return addSignedInput(parameters);\n    }\n\n    /**\n     * Adds an input that points to the given output and contains a valid signature for it, calculated using the\n     * signing key. Defaults to {@link SigHash#ALL} and \"false\" for the anyoneCanPay flag. This is normally what you want.\n     * @param output output to sign and use as input\n     * @param sigKey The signing key\n     * @return The newly created input\n     */\n    public TransactionInput addSignedInput(TransactionOutput output, ECKey sigKey) {\n        return addSignedInput(new SignedInputParameters(null, output.getOutPointFor(), output.getScriptPubKey(), output.getValue(), sigKey));\n    }\n\n    /**\n     * Adds an input that points to the given output and contains a valid signature for it, calculated using the\n     * signing key.\n     * @see Transaction#addSignedInput(SignedInputParameters)\n     * @param output output to sign and use as input\n     * @param sigKey The signing key\n     * @param sigHash enum specifying how the transaction hash is calculated\n     * @param anyoneCanPay anyone-can-pay hashing\n     * @return The newly created input\n     */\n    public TransactionInput "
            },
            {
                "fromLine": 1053,
                "toLine": 1197,
                "oldContent": "                tx.inputs.add(input);\n            }\n\n            ByteArrayOutputStream bos = new ByteArrayOutputStream(255); // just a guess at an average tx length\n            tx.bitcoinSerializeToStream(bos, false);\n            // We also have to write a hash type (sigHashType is actually an unsigned char)\n            writeInt32LE(0x000000ff & sigHashType, bos);\n            // Note that this is NOT reversed to ensure it will be signed correctly. If it were to be printed out\n            // however then we would expect that it is IS reversed.\n            Sha256Hash hash = Sha256Hash.twiceOf(bos.toByteArray());\n            bos.close();\n\n            return hash;\n        } catch (IOException e) {\n            throw new RuntimeException(e);  // Cannot happen.\n        }\n    }\n\n    public TransactionSignature calculateWitnessSignature(\n            int inputIndex,\n            ECKey key,\n            byte[] scriptCode,\n            Coin value,\n            SigHash hashType,\n            boolean anyoneCanPay) {\n        Sha256Hash hash = hashForWitnessSignature(inputIndex, scriptCode, value, hashType, anyoneCanPay);\n        return new TransactionSignature(key.sign(hash), hashType, anyoneCanPay);\n    }\n\n    public TransactionSignature calculateWitnessSignature(\n            int inputIndex,\n            ECKey key,\n            Script scriptCode,\n            Coin value,\n            SigHash hashType,\n            boolean anyoneCanPay) {\n        return calculateWitnessSignature(inputIndex, key, scriptCode.program(), value, hashType, anyoneCanPay);\n    }\n\n    public TransactionSignature calculateWitnessSignature(\n            int inputIndex,\n            ECKey key,\n            @Nullable AesKey aesKey,\n            byte[] scriptCode,\n            Coin value,\n            SigHash hashType,\n            boolean anyoneCanPay) {\n        Sha256Hash hash = hashForWitnessSignature(inputIndex, scriptCode, value, hashType, anyoneCanPay);\n        return new TransactionSignature(key.sign(hash, aesKey), hashType, anyoneCanPay);\n    }\n\n    public TransactionSignature calculateWitnessSignature(\n            int inputIndex,\n            ECKey key,\n            @Nullable AesKey aesKey,\n            Script scriptCode,\n            Coin value,\n            SigHash hashType,\n            boolean anyoneCanPay) {\n        return calculateWitnessSignature(inputIndex, key, aesKey, scriptCode.program(), value, hashType, anyoneCanPay);\n    }\n\n    public synchronized Sha256Hash hashForWitnessSignature(\n            int inputIndex,\n            byte[] scriptCode,\n            Coin prevValue,\n            SigHash type,\n            boolean anyoneCanPay) {\n        int sigHash = TransactionSignature.calcSigHashValue(type, anyoneCanPay);\n        return hashForWitnessSignature(inputIndex, scriptCode, prevValue, (byte) sigHash);\n    }\n\n    /**\n     * <p>Calculates a signature hash, that is, a hash of a simplified form of the transaction. How exactly the transaction\n     * is simplified is specified by the type and anyoneCanPay parameters.</p>\n     *\n     * <p>This is a low level API and when using the regular {@link Wallet} class you don't have to call this yourself.\n     * When working with more complex transaction types and contracts, it can be necessary. When signing a Witness output\n     * the scriptCode should be the script encoded into the scriptSig field, for normal transactions, it's the\n     * scriptPubKey of the output you're signing for. (See BIP143: https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki)</p>\n     *\n     * @param inputIndex   input the signature is being calculated for. Tx signatures are always relative to an input.\n     * @param scriptCode   the script that should be in the given input during signing.\n     * @param prevValue    the value of the coin being spent\n     * @param type         Should be SigHash.ALL\n     * @param anyoneCanPay should be false.\n     */\n    public synchronized Sha256Hash hashForWitnessSignature(\n            int inputIndex,\n            Script scriptCode,\n            Coin prevValue,\n            SigHash type,\n            boolean anyoneCanPay) {\n        return hashForWitnessSignature(inputIndex, scriptCode.program(), prevValue, type, anyoneCanPay);\n    }\n\n    public synchronized Sha256Hash hashForWitnessSignature(\n            int inputIndex,\n            byte[] scriptCode,\n            Coin prevValue,\n            byte sigHashType){\n        ByteArrayOutputStream bos = new ByteArrayOutputStream(255); // just a guess at an average tx length\n        try {\n            byte[] hashPrevouts = new byte[32];\n            byte[] hashSequence = new byte[32];\n            byte[] hashOutputs = new byte[32];\n            int basicSigHashType = sigHashType & 0x1f;\n            boolean anyoneCanPay = (sigHashType & SigHash.ANYONECANPAY.value) == SigHash.ANYONECANPAY.value;\n            boolean signAll = (basicSigHashType != SigHash.SINGLE.value) && (basicSigHashType != SigHash.NONE.value);\n",
                "newContent": "                tx.inputs.add(input);\n            }\n\n            ByteArrayOutputStream bos = new ByteArrayOutputStream(255); // just a guess at an average tx length\n            tx.bitcoinSerializeToStream(bos, false);\n            // We also have to write a hash type (sigHashType is actually an unsigned char)\n            writeInt32LE(0x000000ff & sigHashType, bos);\n            // Note that this is NOT reversed to ensure it will be signed correctly. If it were to be printed out\n            // however then we would expect that it is IS reversed.\n            Sha256Hash hash = Sha256Hash.twiceOf(bos.toByteArray());\n            bos.close();\n\n            return hash;\n        } catch (IOException e) {\n            throw new RuntimeException(e);  // Cannot happen.\n        }\n    }\n\n    public TransactionSignature calculateWitnessSignature(WitnessSignatureParameters parameters) {\n        Sha256Hash hash = hashForWitnessSignature(parameters.inputIndex, parameters.scriptCode, parameters.value, parameters.sigHash, parameters.anyoneCanPay);\n        return new TransactionSignature(parameters.sigKey.sign(hash), parameters.sigHash, parameters.anyoneCanPay);\n    }\n\n    public TransactionSignature calculateWitnessSignature(WitnessSignatureParameters parameters) {\n        return calculateWitnessSignature(parameters.inputIndex, parameters.sigKey, parameters.scriptCode.program(), parameters.value, parameters.sigHash, parameters.anyoneCanPay);\n    }\n\n    public TransactionSignature calculateWitnessSignature(WitnessSignatureParameters parameters) {\n        Sha256Hash hash = hashForWitnessSignature(parameters.inputIndex, parameters.scriptCode, parameters.value, parameters.sigHash, parameters.anyoneCanPay);\n        return new TransactionSignature(parameters.sigKey.sign(hash, parameters.aesKey), parameters.sigHash, parameters.anyoneCanPay);\n    }\n\n    public TransactionSignature calculateWitnessSignature(WitnessSignatureParameters parameters) {\n        return calculateWitnessSignature(parameters.inputIndex, parameters.sigKey, parameters.aesKey, parameters.scriptCode.program(), parameters.value, parameters.sigHash, parameters.anyoneCanPay);\n    }\n\n    public synchronized Sha256Hash hashForWitnessSignature(WitnessSignatureParameters parameters) {\n        int sigHash = TransactionSignature.calcSigHashValue(parameters.sigHash, parameters.anyoneCanPay);\n        return hashForWitnessSignature(parameters.input