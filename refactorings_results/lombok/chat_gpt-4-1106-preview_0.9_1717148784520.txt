{
    "refactorings": {
        "src/core/lombok/javac/handlers/HandleEqualsAndHashCode.java": [
            {
                "fromLine": 114,
                "toLine": 122,
                "oldContent": "\tpublic void generateMethods(JavacNode typeNode, JavacNode source, java.util.List<Included<JavacNode, EqualsAndHashCode.Include>> members,\n\t\tBoolean callSuper, boolean whineIfExists, boolean cacheHashCode, FieldAccess fieldAccess, List<JCAnnotation> onParam) {",
                "newContent": "\tpublic void generateMethods(JavacNode typeNode, JavacNode source, java.util.List<Included<JavacNode, EqualsAndHashCode.Include>> members,\n\t\tGenerationConfig config) {"
            },
            {
                "fromLine": 162,
                "toLine": 171,
                "oldContent": "\t\tif (isDirectDescendantOfObject && callSuper) {\n\t\t\tsource.addError(\"Generating equals/hashCode with a supercall to java.lang.Object is pointless.\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (implicitCallSuper && !isDirectDescendantOfObject) {\n\t\t\tCallSuperType cst = typeNode.getAst().readConfiguration(ConfigurationKeys.EQUALS_AND_HASH_CODE_CALL_SUPER);\n\t\t\tif (cst == null) cst = CallSuperType.WARN;\n\t\t\t",
                "newContent": "\t\tif (isDirectDescendantOfObject && config.getCallSuper()) {\n\t\t\tsource.addError(\"Generating equals/hashCode with a supercall to java.lang.Object is pointless.\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (implicitCallSuper && !isDirectDescendantOfObject) {\n\t\t\tCallSuperType cst = typeNode.getAst().readConfiguration(ConfigurationKeys.EQUALS_AND_HASH_CODE_CALL_SUPER);\n\t\t\tif (cst == null) cst = CallSuperType.WARN;\n\t\t\t"
            },
            {
                "fromLine": 185,
                "toLine": 209,
                "oldContent": "\t\tJCMethodDecl equalsMethod = createEquals(typeNode, members, callSuper, fieldAccess, needsCanEqual, source, onParam);\n\t\t\n\t\tinjectMethod(typeNode, equalsMethod);\n\t\t\n\t\tif (needsCanEqual && canEqualExists == MemberExistsResult.NOT_EXISTS) {\n\t\t\tJCMethodDecl canEqualMethod = createCanEqual(typeNode, source, copyAnnotations(onParam));\n\t\t\tinjectMethod(typeNode, canEqualMethod);\n\t\t}\n\t\t\n\t\tif (cacheHashCode){\n\t\t\tif (fieldExists(HASH_CODE_CACHE_NAME, typeNode) != MemberExistsResult.NOT_EXISTS) {\n\t\t\t\tString msg = String.format(\"Not caching the result of hashCode: A field named %s already exists.\", HASH_CODE_CACHE_name);\n\t\t\t\tsource.addWarning(msg);\n\t\t\t\tcacheHashCode = false;\n\t\t\t} else {\n\t\t\t\tcreateHashCodeCacheField(typeNode, source);\n\t\t\t}\n\t\t}\n\t\t\n\t\tJCMethodDecl hashCodeMethod = createHashCode(typeNode, members, callSuper, cacheHashCode, fieldAccess, source);\n\t\tinjectMethod(typeNode, hashCodeMethod);\n\t}\n",
                "newContent": "\t\tJCMethodDecl equalsMethod = createEquals(typeNode, members, config, needsCanEqual, source);\n\t\t\n\t\tinjectMethod(typeNode, equalsMethod);\n\t\t\n\t\tif (needsCanEqual && canEqualExists == MemberExistsResult.NOT_EXISTS) {\n\t\t\tJCMethodDecl canEqualMethod = createCanEqual(typeNode, source, copyAnnotations(config.getOnParam()));\n\t\t\tinjectMethod(typeNode, canEqualMethod);\n\t\t}\n\t\t\n\t\tif (config.getCacheHashCode()){\n\t\t\tif (fieldExists(HASH_CODE_CACHE_NAME, typeNode) != MemberExistsResult.NOT_EXISTS) {\n\t\t\t\tString msg = String.format(\"Not caching the result of hashCode: A field named %s already exists.\", HASH_CODE_CACHE_name);\n\t\t\t\tsource.addWarning(msg);\n\t\t\t\tconfig.setCacheHashCode(false);\n\t\t\t} else {\n\t\t\t\tcreateHashCodeCacheField(typeNode, source);\n\t\t\t}\n\t\t}\n\t\t\n\t\tJCMethodDecl hashCodeMethod = createHashCode(typeNode, members, config, source);\n\t\tinjectMethod(typeNode, hashCodeMethod);\n\t}\n"
            },
            {
                "fromLine": 423,
                "toLine": 447,
                "oldContent": "\tpublic JCMethodDecl createEquals(JavacNode typeNode, java.util.List<Included<JavacNode, EqualsAndHashCode.Include>> members, boolean callSuper, FieldAccess fieldAccess, boolean needsCanEqual, JavacNode source, List<JCAnnotation> onParam) {",
                "newContent": "\tpublic JCMethodDecl createEquals(JavacNode typeNode, java.util.List<Included<JavacNode, EqualsAndHashCode.Include>> members, GenerationConfig config, boolean needsCanEqual, JavacNode source) {"
            },
            {
                "fromLine": 449,
                "toLine": 457,
                "oldContent": "\t\tlong finalFlag = JavacHandlerUtil.addFinalIfNeeded(0L, typeNode.getContext());\n\t\t\n\t\tListBuffer<JCStatement> statements = new ListBuffer<JCStatement>();\n\t\tJCVariableDecl param = maker.VarDef(maker.Modifiers(finalFlag | Flags.PARAMETER, onParam), oName, objectType, null);",
                "newContent": "\t\tlong finalFlag = JavacHandlerUtil.addFinalIfNeeded(0L, typeNode.getContext());\n\t\t\n\t\tListBuffer<JCStatement> statements = new ListBuffer<JCStatement>();\n\t\tJCVariableDecl param = maker.VarDef(maker.Modifiers(finalFlag | Flags.PARAMETER, config.getOnParam()), oName, objectType, null);"
            }
        ]
    },
    "extractedClasses": {
        "src/core/lombok/javac/handlers/GenerationConfig.java": "package lombok.javac.handlers;\n\nimport lombok.javac.JavacNode;\nimport com.sun.tools.javac.util.List;\nimport com.sun.tools.javac.code.Symbol.Metadata;\n\npublic class GenerationConfig {\n\n    private JavacNode typeNode;\n    private Boolean callSuper;\n    private boolean whineIfExists;\n    private boolean cacheHashCode;\n    private FieldAccess fieldAccess;\n    private List<JCAnnotation> onParam;\n\n    public GenerationConfig(JavacNode typeNode, Boolean callSuper, boolean whineIfExists, boolean cacheHashCode, FieldAccess fieldAccess, List<JCAnnotation> onParam) {\n        this.typeNode = typeNode;\n        this.callSuper = callSuper;\n        this.whineIfExists = whineIfExists;\n        this.cacheHashCode = cacheHashCode;\n        this.fieldAccess = fieldAccess;\n        this.onParam = onParam;\n    }\n\n    public JavacNode getTypeNode() {\n        return typeNode;\n    }\n\n    public Boolean getCallSuper() {\n        return callSuper;\n    }\n\n    public boolean isWhineIfExists() {\n        return whineIfExists;\n    }\n\n    public boolean getCacheHashCode() {\n        return cacheHashCode;\n    }\n\n    public FieldAccess getFieldAccess() {\n        return fieldAccess;\n    }\n\n    public List<JCAnnotation> getOnParam() {\n        return onParam;\n    }\n\n    public void setCallSuper(Boolean callSuper) {\n        this.callSuper = callSuper;\n    }\n\n    public void setCacheHashCode(boolean cacheHashCode) {\n        this.cacheHashCode = cacheHashCode;\n    }\n}\n"
    }
}