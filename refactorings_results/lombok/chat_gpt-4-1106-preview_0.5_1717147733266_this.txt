{
    "refactorings": {
        "src/core/lombok/javac/handlers/HandleEqualsAndHashCode.java": [
            {
                "fromLine": 114,
                "toLine": 122,
                "oldContent": "\t}\n\t\n\tpublic void generateMethods(JavacNode typeNode, JavacNode source, java.util.List<Included<JavacNode, EqualsAndHashCode.Include>> members,\n\t\tBoolean callSuper, boolean whineIfExists, boolean cacheHashCode, FieldAccess fieldAccess, List<JCAnnotation> onParam) {\n\t\t\n\t\tif (!isClass(typeNode)) {\n\t\t\tsource.addError(\"@EqualsAndHashCode is only supported on a class.\");\n\t\t\treturn;\n\t\t}",
                "newContent": "\t}\n\t\n\tclass MethodGenerationContext {\n\t\tJavacNode typeNode;\n\t\tJavacNode source;\n\t\tList<Included<JavacNode, EqualsAndHashCode.Include>> members;\n\t\tBoolean callSuper;\n\t\tboolean whineIfExists;\n\t\tboolean cacheHashCode;\n\t\tFieldAccess fieldAccess;\n\t\tList<JCAnnotation> onParam;\n\t\t\n\t\tprivate MethodGenerationContext(JavacNode typeNode, JavacNode source, List<Included<JavacNode, EqualsAndHashCode.Include>> members,\n\t\t\tBoolean callSuper, boolean whineIfExists, boolean cacheHashCode, FieldAccess fieldAccess, List<JCAnnotation> onParam) {\n\t\t\tthis.typeNode = typeNode;\n\t\t\tthis.source = source;\n\t\t\tthis.members = members;\n\t\t\tthis.callSuper = callSuper;\n\t\t\tthis.whineIfExists = whineIfExists;\n\t\t\tthis.cacheHashCode = cacheHashCode;\n\t\t\tthis.fieldAccess = fieldAccess;\n\t\t\tthis.onParam = onParam;\n\t\t}\n\t}\n\t\n\tpublic void generateMethods(MethodGenerationContext context) {\n\t\tif (!isClass(context.typeNode)) {\n\t\t\tcontext.source.addError(\"@EqualsAndHashCode is only supported on a class.\");\n\t\t\treturn;\n\t\t}"
            },
            {
                "fromLine": 131,
                "toLine": 141,
                "oldContent": "\t\t}\n\t\t\n\t\tboolean isDirectDescendantOfObject = isDirectDescendantOfObject(typeNode);\n\t\t\n\t\tboolean isFinal = (((JCClassDecl) typeNode.get()).mods.flags & Flags.FINAL) != 0;\n\t\tboolean needsCanEqual = !isFinal || !isDirectDescendantOfObject;\n\t\tMemberExistsResult equalsExists = methodExists(\"equals\", typeNode, 1);\n\t\tMemberExistsResult hashCodeExists = methodExists(\"hashCode\", typeNode, 0);\n\t\tMemberExistsResult canEqualExists = methodExists(\"canEqual\", typeNode, 1);\n\t\tswitch (Collections.max(Arrays.asList(equalsExists, hashCodeExists))) {\n\t\tcase EXISTS_BY_LOMBOK:",
                "newContent": "\t\t}\n\t\t\n\t\tboolean isDirectDescendantOfObject = isDirectDescendantOfObject(context.typeNode);\n\t\t\n\t\tboolean isFinal = (((JCClassDecl) context.typeNode.get()).mods.flags & Flags.FINAL) != 0;\n\t\tboolean needsCanEqual = !isFinal || !isDirectDescendantOfObject;\n\t\tMemberExistsResult equalsExists = methodExists(\"equals\", context.typeNode, 1);\n\t\tMemberExistsResult hashCodeExists = methodExists(\"hashCode\", context.typeNode, 0);\n\t\tMemberExistsResult canEqualExists = methodExists(\"canEqual\", context.typeNode, 1);\n\t\tswitch (Collections.max(Arrays.asList(equalsExists, hashCodeExists))) {\n\t\tcase EXISTS_BY_LOMBOK:"
            },
            {
                "fromLine": 144,
                "toLine": 148,
                "oldContent": "\t\t\tif (whineIfExists) {\n\t\t\t\tString msg = \"Not generating equals and hashCode: A method with one of those names already exists. (Either both or none of these methods will be generated).\";\n\t\t\t\tsource.addWarning(msg);\n\t\t\t} else if (equalsExists == MemberExistsResult.NOT_EXISTS || hashCodeExists == MemberExistsResult.NOT_EXISTS) {\n\t\t\t\t// This means equals OR hashCode exists and not both.",
                "newContent": "\t\t\tif (context.whineIfExists) {\n\t\t\t\tString msg = \"Not generating equals and hashCode: A method with one of those names already exists. (Either both or none of these methods will be generated).\";\n\t\t\t\tcontext.source.addWarning(msg);\n\t\t\t} else if (equalsExists == MemberExistsResult.NOT_EXISTS || hashCodeExists == MemberExistsResult.NOT_EXISTS) {\n\t\t\t\t// This means equals OR hashCode exists and not both."
            },
            {
                "fromLine": 153,
                "toLine": 157,
                "oldContent": "\t\t\t\t\t\"You should either write both of these or none of these (in the latter case, lombok generates them).\",\n\t\t\t\t\tequalsExists == MemberExistsResult.NOT_EXISTS ? \"equals\" : \"hashCode\");\n\t\t\t\tsource.addWarning(msg);\n\t\t\t}\n\t\t\treturn;",
                "newContent": "\t\t\t\t\t\"You should either write both of these or none of these (in the latter case, lombok generates them).\",\n\t\t\t\t\tequalsExists == MemberExistsResult.NOT_EXISTS ? \"equals\" : \"hashCode\");\n\t\t\t\tcontext.source.addWarning(msg);\n\t\t\t}\n\t\t\treturn;"
            },
            {
                "fromLine": 162,
                "toLine": 171,
                "oldContent": "\t\t\n\t\tif (isDirectDescendantOfObject && callSuper) {\n\t\t\tsource.addError(\"Generating equals/hashCode with a supercall to java.lang.Object is pointless.\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (implicitCallSuper && !isDirectDescendantOfObject) {\n\t\t\tCallSuperType cst = typeNode.getAst().readConfiguration(ConfigurationKeys.EQUALS_AND_HASH_CODE_CALL_SUPER);\n\t\t\tif (cst == null) cst = CallSuperType.WARN;\n\t\t\t",
                "newContent": "\t\t\n\t\tif (isDirectDescendantOfObject && context.callSuper) {\n\t\t\tcontext.source.addError(\"Generating equals/hashCode with a supercall to java.lang.Object is pointless.\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (context.implicitCallSuper && !isDirectDescendantOfObject) {\n\t\t\tCallSuperType cst = context.typeNode.getAst().readConfiguration(ConfigurationKeys.EQUALS_AND_HASH_CODE_CALL_SUPER);\n\t\t\tif (cst == null) cst = CallSuperType.WARN;\n\t\t\t"
            },
            {
                "fromLine": 173,
                "toLine": 177,
                "oldContent": "\t\t\tdefault:\n\t\t\tcase WARN:\n\t\t\t\tsource.addWarning(\"Generating equals/hashCode implementation but without a call to superclass, even though this class does not extend java.lang.Object. If this is intentional, add '@EqualsAndHashCode(callSuper=false)' to your type.\");\n\t\t\t\tcallSuper = false;\n\t\t\t\tbreak;",
                "newContent": "\t\t\tdefault:\n\t\t\tcase WARN:\n\t\t\t\tcontext.source.addWarning(\"Generating equals/hashCode implementation but without a call to superclass, even though this class does not extend java.lang.Object. If this is intentional, add '@EqualsAndHashCode(callSuper=false)' to your type.\");\n\t\t\t\tcontext.callSuper = false;\n\t\t\t\tbreak;"
            },
            {
                "fromLine": 185,
                "toLine": 209,
                "oldContent": "\t\t}\n\t\t\n\t\tJCMethodDecl equalsMethod = createEquals(typeNode, members, callSuper, fieldAccess, needsCanEqual, source, onParam);\n\t\t\n\t\tinjectMethod(typeNode, equalsMethod);\n\t\t\n\t\tif (needsCanEqual && canEqualExists == MemberExistsResult.NOT_EXISTS) {\n\t\t\tJCMethodDecl canEqualMethod = createCanEqual(typeNode, source, copyAnnotations(onParam));\n\t\t\tinjectMethod(typeNode, canEqualMethod);\n\t\t}\n\t\t\n\t\tif (cacheHashCode){\n\t\t\tif (fieldExists(HASH_CODE_CACHE_NAME, typeNode) != MemberExistsResult.NOT_EXISTS) {\n\t\t\t\tString msg = String.format(\"Not caching the result of hashCode: A field named %s already exists.\", HASH_CODE_CACHE_NAME);\n\t\t\t\tsource.addWarning(msg);\n\t\t\t\tcacheHashCode = false;\n\t\t\t} else {\n\t\t\t\tcreateHashCodeCacheField(typeNode, source);\n\t\t\t}\n\t\t}\n\t\t\n\t\tJCMethodDecl hashCodeMethod = createHashCode(typeNode, members, callSuper, cacheHashCode, fieldAccess, source);\n\t\tinjectMethod(typeNode, hashCodeMethod);\n\t}\n",
                "newContent": "\t\t}\n\t\t\n\t\tJCMethodDecl equalsMethod = createEquals(context.typeNode, context.members, context.callSuper, context.fieldAccess, needsCanEqual, context.source, context.onParam);\n\t\t\n\t\tinjectMethod(context.typeNode, equalsMethod);\n\t\t\n\t\tif (needsCanEqual && canEqualExists == MemberExistsResult.NOT_EXISTS) {\n\t\t\tJCMethodDecl canEqualMethod = createCanEqual(context.typeNode, context.source, copyAnnotations(context.onParam));\n\t\t\tinjectMethod(context.typeNode, canEqualMethod);\n\t\t}\n\t\t\n\t\tif (context.cacheHashCode){\n\t\t\tif (fieldExists(HASH_CODE_CACHE_NAME, context.typeNode) != MemberExistsResult.NOT_EXISTS) {\n\t\t\t\tString msg = String.format(\"Not caching the result of hashCode: A field named %s already exists.\", HASH_CODE_CACHE_NAME);\n\t\t\t\tcontext.source.addWarning(msg);\n\t\t\t\tcontext.cacheHashCode = false;\n\t\t\t} else {\n\t\t\t\tcreateHashCodeCacheField(context.typeNode, context.source);\n\t\t\t}\n\t\t}\n\t\t\n\t\tJCMethodDecl hashCodeMethod = createHashCode(context.typeNode, context.members, context.callSuper, context.cacheHashCode, context.fieldAccess, context.source);\n\t\tinjectMethod(context.typeNode, hashCodeMethod);\n\t}\n"
            },
            {
                "fromLine": 423,
                "toLine": 447,
                "oldContent": "\t}\n\t\n\tpublic JCMethodDecl createEquals(JavacNode typeNode, java.util.List<Included<JavacNode, EqualsAndHashCode.Include>> members, boolean callSuper, FieldAccess fieldAccess, boolean needsCanEqual, JavacNode source, List<JCAnnotation> onParam) {\n\t\tJavacTreeMaker maker = typeNode.getTreeMaker();\n\t\t\n\t\tName oName = typeNode.toName(\"o\");\n\t\tName otherName = typeNode.toName(\"other\");\n\t\tName thisName = typeNode.toName(\"this\");\n\t\t\n\t\tList<JCAnnotation> annsOnParamOnMethod = List.nil();\n\t\t\n\t\tJCAnnotation overrideAnnotation = maker.Annotation(genJavaLangTypeRef(typeNode, \"Override\"), List.<JCExpression>nil());\n\t\tList<JCAnnotation> annsOnMethod = List.of(overrideAnnotation);\n\t\tCheckerFrameworkVersion checkerFramework = getCheckerFrameworkVersion(typeNode);\n\t\tif (checkerFramework.generateSideEffectFree()) {\n\t\t\tannsOnMethod = annsOnMethod.prepend(maker.Annotation(genTypeRef(typeNode, CheckerFrameworkVersion.NAME__SIDE_EFFECT_FREE), List.<JCExpression>nil()));\n\t\t}\n\t\tJCModifiers mods = maker.Modifiers(Flags.PUBLIC, annsOnMethod);\n\t\tJCExpression objectType;\n\t\tif (annsOnParamOnMethod.isEmpty()) {\n\t\t\tobjectType = genJavaLangTypeRef(typeNode, \"Object\");\n\t\t} else {\n\t\t\tobjectType = chainDots(typeNode, \"java\", \"lang\", \"Object\");\n\t\t\tobjectType = maker.AnnotatedType(annsOnParamOnMethod, objectType);\n\t\t}",
                "newContent": "\t}\n\t\n\tpublic JCMethodDecl createEquals(MethodGenerationContext context, boolean needsCanEqual) {\n\t\tJavacTreeMaker maker = context.typeNode.getTreeMaker();\n\t\t\n\t\tName oName = context.typeNode.toName(\"o\");\n\t\tName otherName = context.typeNode.toName(\"other\");\n\t\tName thisName = context.typeNode.toName(\"this\");\n\t\t\n\t\tList<JCAnnotation> annsOnParamOnMethod = List.nil();\n\t\t\n\t\tJCAnnotation overrideAnnotation = maker.Annotation(genJavaLangTypeRef(context.typeNode, \"Override\"), List.<JCExpression>nil());\n\t\tList<JCAnnotation> annsOnMethod = List.of(overrideAnnotation);\n\t\tCheckerFrameworkVersion checkerFramework = getCheckerFrameworkVersion(context.typeNode);\n\t\tif (checkerFramework.generateSideEffectFree()) {\n\t\t\tannsOnMethod = annsOnMethod.prepend(maker.Annotation(genTypeRef(context.typeNode, CheckerFrameworkVersion.NAME__SIDE_EFFECT_FREE), List.<JCExpression>nil()));\n\t\t}\n\t\tJCModifiers mods = maker.Modifiers(Flags.PUBLIC, annsOnMethod);\n\t\tJCExpression objectType;\n\t\tif (annsOnParamOnMethod.isEmpty()) {\n\t\t\tobjectType = genJavaLangTypeRef(context.typeNode, \"Object\");\n\t\t} else {\n\t\t\tobjectType = chainDots(context.typeNode, \"java\", \"lang\", \"Object\");\n\t\t\tobjectType = maker.AnnotatedType(annsOnParamOnMethod, objectType);\n\t\t}"
            },
            {
                "fromLine": 449,
                "toLine": 457,
                "oldContent": "\t\tJCExpression returnType = maker.TypeIdent(CTC_BOOLEAN);\n\t\t\n\t\tlong finalFlag = JavacHandlerUtil.addFinalIfNeeded(0L, typeNode.getContext());\n\t\t\n\t\tListBuffer<JCStatement> statements = new ListBuffer<JCStatement>();\n\t\tJCVariableDecl param = maker.VarDef(maker.Modifiers(finalFlag | Flags.PARAMETER, onParam), oName, objectType, null);\n\t\tJavacHandlerUtil.createRelevantNullableAnnotation(typeNode, param);\n\t\t\n\t\tfinal List<JCVariableDecl> params = List.of(param);",
                "newContent": "\t\tJCExpression returnType = maker.TypeIdent(CTC_BOOLEAN);\n\t\t\n\t\tlong finalFlag = JavacHandlerUtil.addFinalIfNeeded(0L, context.typeNode.getContext());\n\t\t\n\t\tListBuffer<JCStatement> statements = new ListBuffer<JCStatement>();\n\t\tJCVariableDecl param = maker.VarDef(maker.Modifiers(finalFlag | Flags.PARAMETER, context.onParam), oName, objectType, null);\n\t\tJavacHandlerUtil.createRelevantNullableAnnotation(context.typeNode, param);\n\t\t\n\t\tfinal List<JCVariableDecl> params = List.of(param);"
            },
            {
                "fromLine": 464,
                "toLine": 474,
                "oldContent": "\t\t/* if (!(o instanceof Outer.Inner.MyType)) return false; */ {\n\t\t\t \n\t\t\tJCUnary notInstanceOf = maker.Unary(CTC_NOT, maker.Parens(maker.TypeTest(maker.Ident(oName), createTypeReference(typeNode, false))));\n\t\t\tstatements.append(maker.If(notInstanceOf, returnBool(maker, false), null));\n\t\t}\n\t\t\n\t\t/* Outer.Inner.MyType<?> other = (Outer.Inner.MyType<?>) o; */ {\n\t\t\tif (!members.isEmpty() || needsCanEqual) {\n\t\t\t\tfinal JCExpression selfType1 = createTypeReference(typeNode, true), selfType2 = createTypeReference(typeNode, true);\n\t\t\t\t\n\t\t\t\tstatements.append(",
                "newContent": "\t\t/* if (!(o instanceof Outer.Inner.MyType)) return false; */ {\n\t\t\t \n\t\t\tJCUnary notInstanceOf = maker.Unary(CTC_NOT, maker.Parens(maker.TypeTest(maker.Ident(oName), createTypeReference(context.typeNode, false))));\n\t\t\tstatements.append(maker.If(notInstanceOf, returnBool(maker, false), null));\n\t\t}\n\t\t\n\t\t/* Outer.Inner.MyType<?> other = (Outer.Inner.MyType<?>) o; */ {\n\t\t\tif (!context.members.isEmpty() || needsCanEqual) {\n\t\t\t\tfinal JCExpression selfType1 = createTypeReference(context.typeNode, true), selfType2 = createTypeReference(context.typeNode, true);\n\t\t\t\t\n\t\t\t\tstatements.append("
            },
            {
                "fromLine": 481,
                "toLine": 487,
                "oldContent": "\t\t\t\tList<JCExpression> exprNil = List.nil();\n\t\t\t\tJCExpression thisRef = maker.Ident(thisName);\n\t\t\t\tJCExpression castThisRef = maker.TypeCast(genJavaLangTypeRef(typeNode, \"Object\"), thisRef);\n\t\t\t\tJCExpression equalityCheck = maker.Apply(exprNil, \n\t\t\t\t\tmaker.Select(maker.Ident(otherName), typeNode.toName(\"canEqual\")),\n\t\t\t\t\tList.of(castThisRef));\n\t\t\t\tstatements.append(maker.If(maker.Unary(CTC_NOT, equalityCheck), returnBool(maker, false), null));",
                "newContent": "\t\t\t\tList<JCExpression> exprNil = List.nil();\n\t\t\t\tJCExpression thisRef = maker.Ident(thisName);\n\t\t\t\tJCExpression castThisRef = maker.TypeCast(genJavaLangTypeRef(context.typeNode, \"Object\"), thisRef);\n\t\t\t\tJCExpression equalityCheck = maker.Apply"
            }
            ]}}
                