{
    "refactorings": {
        "src/core/lombok/javac/handlers/HandleEqualsAndHashCode.java": [
            {
                "fromLine": 114,
                "toLine": 122,
                "oldContent": "\tpublic void generateMethods(JavacNode typeNode, JavacNode source, java.util.List<Included<JavacNode, EqualsAndHashCode.Include>> members,\n\t\tBoolean callSuper, boolean whineIfExists, boolean cacheHashCode, FieldAccess fieldAccess, List<JCAnnotation> onParam) {",
                "newContent": "\tpublic void generateMethods(JavacNode typeNode, JavacNode source, java.util.List<Included<JavacNode, EqualsAndHashCode.Include>> members,\n\t\tMethodGenerationContext context) {"
            },
            {
                "fromLine": 131,
                "toLine": 141,
                "oldContent": "\t\tboolean isDirectDescendantOfObject = isDirectDescendantOfObject(typeNode);\n\t\t\n\t\tboolean isFinal = (((JCClassDecl) typeNode.get()).mods.flags & Flags.FINAL) != 0;\n\t\tboolean needsCanEqual = !isFinal || !isDirectDescendantOfObject;\n\t\tMemberExistsResult equalsExists = methodExists(\"equals\", typeNode, 1);\n\t\tMemberExistsResult hashCodeExists = methodExists(\"hashCode\", typeNode, 0);\n\t\tMemberExistsResult canEqualExists = methodExists(\"canEqual\", typeNode, 1);\n\t\tswitch (Collections.max(Arrays.asList(equalsExists, hashCodeExists))) {",
                "newContent": "\t\tboolean isDirectDescendantOfObject = isDirectDescendantOfObject(typeNode);\n\t\t\n\t\tboolean isFinal = (((JCClassDecl) typeNode.get()).mods.flags & Flags.FINAL) != 0;\n\t\tboolean needsCanEqual = !isFinal || !isDirectDescendantOfObject;\n\t\tMemberExistsResult equalsExists = methodExists(\"equals\", typeNode, 1);\n\t\tMemberExistsResult hashCodeExists = methodExists(\"hashCode\", typeNode, 0);\n\t\tMemberExistsResult canEqualExists = methodExists(\"canEqual\", typeNode, 1);\n\t\tswitch (Collections.max(Arrays.asList(equalsExists, hashCodeExists))) {"
            },
            {
                "fromLine": 144,
                "toLine": 148,
                "oldContent": "\t\t\tif (whineIfExists) {",
                "newContent": "\t\t\tif (context.isWhineIfExists()) {"
            },
            {
                "fromLine": 153,
                "toLine": 157,
                "oldContent": "\t\t\t\t\t\"You should either write both of these or none of these (in the latter case, lombok generates them).\",\n\t\t\t\t\tequalsExists == MemberExistsResult.NOT_EXISTS ? \"equals\" : \"hashCode\");\n\t\t\t\tsource.addWarning(msg);\n\t\t\t}\n\t\t\treturn;",
                "newContent": "\t\t\t\t\t\"You should either write both of these or none of these (in the latter case, lombok generates them).\",\n\t\t\t\t\tequalsExists == MemberExistsResult.NOT_EXISTS ? \"equals\" : \"hashCode\");\n\t\t\t\tsource.addWarning(msg);\n\t\t\t}\n\t\t\treturn;"
            },
            {
                "fromLine": 162,
                "toLine": 171,
                "oldContent": "\t\tif (isDirectDescendantOfObject && callSuper) {\n\t\t\tsource.addError(\"Generating equals/hashCode with a supercall to java.lang.Object is pointless.\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (implicitCallSuper && !isDirectDescendantOfObject) {\n\t\t\tCallSuperType cst = typeNode.getAst().readConfiguration(ConfigurationKeys.EQUALS_AND_HASH_CODE_CALL_SUPER);\n\t\t\tif (cst == null) cst = CallSuperType.WARN;\n\t\t\t",
                "newContent": "\t\tif (isDirectDescendantOfObject && context.isCallSuper()) {\n\t\t\tsource.addError(\"Generating equals/hashCode with a supercall to java.lang.Object is pointless.\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (context.isImplicitCallSuper() && !isDirectDescendantOfObject) {\n\t\t\tCallSuperType cst = typeNode.getAst().readConfiguration(ConfigurationKeys.EQUALS_AND_HASH_CODE_CALL_SUPER);\n\t\t\tif (cst == null) cst = CallSuperType.WARN;\n\t\t\t"
            },
            {
                "fromLine": 173,
                "toLine": 177,
                "oldContent": "\t\t\t\tcallSuper = false;\n\t\t\t\tbreak;",
                "newContent": "\t\t\t\tcontext.setCallSuper(false);\n\t\t\t\tbreak;"
            },
            {
                "fromLine": 185,
                "toLine": 209,
                "oldContent": "\t\tJCMethodDecl equalsMethod = createEquals(typeNode, members, callSuper, fieldAccess, needsCanEqual, source, onParam);\n\t\t\n\t\tinjectMethod(typeNode, equalsMethod);\n\t\t\n\t\tif (needsCanEqual && canEqualExists == MemberExistsResult.NOT_EXISTS) {\n\t\t\tJCMethodDecl canEqualMethod = createCanEqual(typeNode, source, copyAnnotations(onParam));\n\t\t\tinjectMethod(typeNode, canEqualMethod);\n\t\t}\n\t\t\n\t\tif (cacheHashCode){\n\t\t\tif (fieldExists(HASH_CODE_CACHE_NAME, typeNode) != MemberExistsResult.NOT_EXISTS) {\n\t\t\t\tString msg = String.format(\"Not caching the result of hashCode: A field named %s already exists.\", HASH_CODE_CACHE_NAME);\n\t\t\t\tsource.addWarning(msg);\n\t\t\t\tcacheHashCode = false;\n\t\t\t} else {\n\t\t\t\tcreateHashCodeCacheField(typeNode, source);\n\t\t\t}\n\t\t}\n\t\t\n\t\tJCMethodDecl hashCodeMethod = createHashCode(typeNode, members, callSuper, cacheHashCode, fieldAccess, source);\n\t\tinjectMethod(typeNode, hashCodeMethod);\n\t}\n",
                "newContent": "\t\tJCMethodDecl equalsMethod = createEquals(typeNode, members, context, needsCanEqual, source);\n\t\t\n\t\tinjectMethod(typeNode, equalsMethod);\n\t\t\n\t\tif (needsCanEqual && canEqualExists == MemberExistsResult.NOT_EXISTS) {\n\t\t\tJCMethodDecl canEqualMethod = createCanEqual(typeNode, source, copyAnnotations(context.getOnParam()));\n\t\t\tinjectMethod(typeNode, canEqualMethod);\n\t\t}\n\t\t\n\t\tif (context.isCacheHashCode()){\n\t\t\tif (fieldExists(HASH_CODE_CACHE_NAME, typeNode) != MemberEqualsResult.NOT_EXISTS) {\n\t\t\t\tString msg = String.format(\"Not caching the result of hashCode: A field named %s already exists.\", HASH_CODE_CACHE_NAME);\n\t\t\t\tsource.addWarning(msg);\n\t\t\t\tcontext.setCacheHashCode(false);\n\t\t\t} else {\n\t\t\t\tcreateHashCodeCacheField(typeNode, source);\n\t\t\t}\n\t\t}\n\t\t\n\t\tJCMethodDecl hashCodeMethod = createHashCode(typeNode, members, context, source);\n\t\tinjectMethod(typeNode, hashCodeMethod);\n\t}\n"
            },
 
            {
                "fromLine": 423,
                "toLine": 447,
                "oldContent": "public JCMethodDecl createEquals(JavacNode typeNode, java.util.List<Included<JavacNode, EqualsAndHashCode.Include>> members, boolean callSuper, FieldAccess fieldAccess, boolean needsCanEqual, JavacNode source, List<JCAnnotation> onParam) {",
                "newContent": "public JCMethodDecl createEquals(JavacNode typeNode, java.util.List<Included<JavacNode, EqualsAndHashCode.Include>> members, MethodGenerationContext context, boolean needsCanEqual, JavacNode source) {"
            }
        ]
    },
    "extractedClasses": {
        "src/core/lombok/javac/handlers/MethodGenerationContext.java": "package lombok.javac.handlers;\n\nimport java.util.List;\nimport lombok.javac.JavacNode;\nimport com.sun.tools.javac.code.Type;\n\npublic class MethodGenerationContext {\n\n\tprivate final Boolean callSuper;\n\tprivate final boolean whineIfExists;\n\tprivate boolean cacheHashCode;\n\tprivate final FieldAccess fieldAccess;\n\tprivate final List<Type> onParam;\n\tprivate boolean implicitCallSuper;\n\n\tpublic MethodGenerationContext(Boolean callSuper, boolean whineIfExists, boolean cacheHashCode, FieldAccess fieldAccess, List<Type> onParam) {\n\t\tthis.callSuper = callSuper;\n\t\tthis.whineIfExists = whineIfExists;\n\t\tthis.cacheHashCode = cacheHashCode;\n\t\tthis.fieldAccess = fieldAccess;\n\t\tthis.onParam = onParam;\n\t}\n\n\tpublic Boolean isCallSuper() {\n\t\treturn callSuper;\n\t}\n\n\tpublic boolean isWhineIfExists() {\n\t\treturn whineIfExists;\n\t}\n\n\tpublic boolean isCacheHashCode() {\n\t\treturn cacheHashCode;\n\t}\n\n\tpublic void setCacheHashCode(boolean cacheHashCode) {\n\t\tthis.cacheHashCode = cacheHashCode;\n\t}\n\n\tpublic FieldAccess getFieldAccess() {\n\t\treturn fieldAccess;\n\t}\n\n\tpublic List<Type> getOnParam() {\n\t\treturn onParam;\n\t}\n\n\tpublic boolean isImplicitCallSuper() {\n\t\treturn implicitCallSuper;\n\t}\n\n\tpublic void setImplicitCallSuper(boolean implicitCallSuper) {\n\t\tthis.implicitCallSuper = implicitCallSuper;\n\t}\n\n\tpublic void setCallSuper(boolean callSuper) {\n\t\tthis.callSuper = callSuper;\n\t}\n}"
    }
}