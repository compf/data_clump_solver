{
    "refactorings": {
        "src/core/lombok/javac/handlers/HandleEqualsAndHashCode.java": [
            {
                "fromLine": 114,
                "toLine": 122,
                "oldContent": "\t}\n\t\n\tpublic void generateMethods(JavacNode typeNode, JavacNode source, java.util.List<Included<JavacNode, EqualsAndHashCode.Include>> members,\n\t\tBoolean callSuper, boolean whineIfExists, boolean cacheHashCode, FieldAccess fieldAccess, List<JCAnnotation> onParam) {\n\t\t\n\t\tif (!isClass(typeNode)) {\n\t\t\tsource.addError(\"@EqualsAndHashCode is only supported on a class.\");\n\t\t\treturn;\n\t\t}",
                "newContent": "\t}\n\t\n\tpublic void generateMethods(JavacNode typeNode, JavacNode source, EqualsAndHashCodeContext context) {\n\t\t\n\t\tif (!isClass(typeNode)) {\n\t\t\tsource.addError(\"@EqualsAndHashCode is only supported on a class.\");\n\t\t\treturn;\n\t\t}"
            },
            {
                "fromLine": 185,
                "toLine": 209,
                "oldContent": "\t\t}\n\t\t\n\t\tJCMethodDecl equalsMethod = createEquals(typeNode, members, callSuper, fieldAccess, needsCanEqual, source, onParam);\n\t\t\n\t\tinjectMethod(typeNode, equalsMethod);\n\t\t\n\t\tif (needsCanEqual && canEqualExists == MemberExistsResult.NOT_EXISTS) {\n\t\t\tJCMethodDecl canEqualMethod = createCanEqual(typeNode, source, copyAnnotations(onParam));\n\t\t\tinjectMethod(typeNode, canEqualMethod);\n\t\t}\n\t\t\n\t\tif (cacheHashCode){\n\t\t\tif (fieldExists(HASH_CODE_CACHE_NAME, typeNode) != MemberExistsResult.NOT_EXISTS) {\n\t\t\t\tString msg = String.format(\"Not caching the result of hashCode: A field named %s already exists.\", HASH_CODE_CACHE_NAME);\n\t\t\t\tsource.addWarning(msg);\n\t\t\t\tcacheHashCode = false;\n\t\t\t} else {\n\t\t\t\tcreateHashCodeCacheField(typeNode, source);\n\t\t\t}\n\t\t}\n\t\t\n\t\tJCMethodDecl hashCodeMethod = createHashCode(typeNode, members, callSuper, cacheHashCode, fieldAccess, source);\n\t\tinjectMethod(typeNode, hashCodeMethod);\n\t}\n",
                "newContent": "\t\t}\n\t\t\n\t\tJCMethodDecl equalsMethod = createEquals(typeNode, context);\n\t\t\n\t\tinjectMethod(typeNode, equalsMethod);\n\t\t\n\t\tif (needsCanEqual && canEqualExists == MemberExistsResult.NOT_EXISTS) {\n\t\t\tJCMethodDecl canEqualMethod = createCanEqual(typeNode, source, copyAnnotations(context.getOnParam()));\n\t\t\tinjectMethod(typeNode, canEqualMethod);\n\t\t}\n\t\t\n\t\tif (context.isCacheHashCode()){\n\t\t\tif (fieldExists(HASH_CODE_CACHE_NAME, typeNode) != MemberExistsResult.NOT_EXISTS) {\n\t\t\t\tString msg = String.format(\"Not caching the result of hashCode: A field named %s already exists.\", HASH_CODE_CACHE_NAME);\n\t\t\t\tsource.addWarning(msg);\n\t\t\t\tcontext.setCacheHashCode(false);\n\t\t\t} else {\n\t\t\t\tcreateHashCodeCacheField(typeNode, source);\n\t\t\t}\n\t\t}\n\t\t\n\t\tJCMethodDecl hashCodeMethod = createHashCode(typeNode, context);\n\t\tinjectMethod(typeNode, hashCodeMethod);\n\t}\n"
            },
            {
                "fromLine": 423,
                "toLine": 447,
                "oldContent": "\t}\n\t\n\tpublic JCMethodDecl createEquals(JavacNode typeNode, java.util.List<Included<JavacNode, EqualsAndHashCode.Include>> members, boolean callSuper, FieldAccess fieldAccess, boolean needsCanEqual, JavacNode source, List<JCAnnotation> onParam) {\n\t\tJavacTreeMaker maker = typeNode.getTreeMaker();\n\t\t\n\t\tName oName = typeNode.toName(\"o\");\n\t\tName otherName = typeNode.toName(\"other\");\n\t\tName thisName = typeNode.toName(\"this\");\n\t\t\n\t\tList<JCAnnotation> annsOnParamOnMethod = List.nil();\n\t\t\n\t\tJCAnnotation overrideAnnotation = maker.Annotation(genJavaLangTypeRef(typeNode, \"Override\"), List.<JCExpression>nil());\n\t\tList<JCAnnotation> annsOnMethod = List.of(overrideAnnotation);\n\t\tCheckerFrameworkVersion checkerFramework = getCheckerFrameworkVersion(typeNode);\n\t\tif (checkerFramework.generateSideEffectFree()) {\n\t\t\tannsOnMethod = annsOnMethod.prepend(maker.Annotation(genTypeRef(typeNode, CheckerFrameworkVersion.NAME__SIDE_EFFECT_FREE), List.<JCExpression>nil()));\n\t\t}\n\t\tJCModifiers mods = maker.Modifiers(Flags.PUBLIC, annsOnMethod);\n\t\tJCExpression objectType;\n\t\tif (annsOnParamOnMethod.isEmpty()) {\n\t\t\tobjectType = genJavaLangTypeRef(typeNode, \"Object\");\n\t\t} else {\n\t\t\tobjectType = chainDots(typeNode, \"java\", \"lang\", \"Object\");\n\t\t\tobjectType = maker.AnnotatedType(annsOnParamOnMethod, objectType);\n\t\t}",
                "newContent": "\t}\n\t\n\tpublic JCMethodDecl createEquals(JavacNode typeNode, EqualsAndHashCodeContext context) {\n\t\tJavacTreeMaker maker = typeNode.getTreeMaker();\n\t\t\n\t\tName oName = typeNode.toName(\"o\");\n\t\tName otherName = typeNode.toName(\"other\");\n\t\tName thisName = typeNode.toName(\"this\");\n\t\t\n\t\tList<JCAnnotation> annsOnParamOnMethod = List.nil();\n\t\t\n\t\tJCAnnotation overrideAnnotation = maker.Annotation(genJavaLangTypeRef(typeNode, \"Override\"), List.<JCExpression>nil());\n\t\tList<JCAnnotation> annsOnMethod = List.of(overrideAnnotation);\n\t\tCheckerFrameworkVersion checkerFramework = getCheckerFrameworkVersion(typeNode);\n\t\tif (checkerFramework.generateSideEffectFree()) {\n\t\t\tannsOnMethod = annsOnMethod.prepend(maker.Annotation(genTypeRef(typeNode, CheckerFrameworkVersion.NAME__SIDE_EFFECT_FREE), List.<JCExpression>nil()));\n\t\t}\n\t\tJCModifiers mods = maker.Modifiers(Flags.PUBLIC, annsOnMethod);\n\t\tJCExpression objectType;\n\t\tif (annsOnParamOnMethod.isEmpty()) {\n\t\t\tobjectType = genJavaLangTypeRef(typeNode, \"Object\");\n\t\t} else {\n\t\t\tobjectType = chainDots(typeNode, \"java\", \"lang\", \"Object\");\n\t\t\tobjectType = maker.AnnotatedType(annsOnParamOnMethod, objectType);\n\t\t}"
            }
        ]
    },
    "extractedClasses": {
        "src/core/lombok/javac/handlers/EqualsAndHashCodeContext.java": "package lombok.javac.handlers;\n\nimport java.util.List;\nimport lombok.EqualsAndHashCode;\nimport lombok.javac.JavacNode;\nimport lombok.core.FieldAccess;\nimport com.sun.tools.javac.tree.JCTree.JCAnnotation;\n\npublic class EqualsAndHashCodeContext {\n    private final List<Included<JavacNode, EqualsAndHashCode.Include>> members;\n    private final boolean callSuper;\n    private final FieldAccess fieldAccess;\n    private final boolean needsCanEqual;\n    private final List<JCAnnotation> onParam;\n    private boolean cacheHashCode;\n\n    public EqualsAndHashCodeContext(List<Included<JavacNode, EqualsAndHashCode.Include>> members, boolean callSuper, FieldAccess fieldAccess, boolean needsCanEqual, List<JCAnnotation> onParam, boolean cacheHashCode) {\n        this.members = members;\n        this.callSuper = callSuper;\n        this.fieldAccess = fieldAccess;\n        this.needsCanEqual = needsCanEqual;\n        this.onParam = onParam;\n        this.cacheHashCode = cacheHashCode;\n    }\n\n    public List<Included<JavacNode, EqualsAndHashCode.Include>> getMembers() {\n        return members;\n    }\n\n    public boolean isCallSuper() {\n        return callSuper;\n    }\n\n    public FieldAccess getFieldAccess() {\n        return fieldAccess;\n    }\n\n    public boolean isNeedsCanEqual() {\n        return needsCanEqual;\n    }\n\n    public List<JCAnnotation> getOnParam() {\n        return onParam;\n    }\n\n    public boolean isCacheHashCode() {\n        return cacheHashCode;\n    }\n\n    public void setCacheHashCode(boolean cacheHashCode) {\n        this.cacheHashCode = cacheHashCode;\n    }\n}\n"
    }
}