{
    "refactorings": {
        "spock-core/src/main/java/org/spockframework/builder/ISlotFactory.java": [
            {
                "fromLine": 21,
                "toLine": 21,
                "oldContent": "  @Nullable ISlot create(Object owner, Type ownerType, String name);",
                "newContent": "  @Nullable ISlot create(SlotConfiguration slotConfig);"
            }
        ],
        "spock-core/src/main/java/org/spockframework/builder/CollectionSlot.java": [
            {
                "fromLine": 16,
                "toLine": 20,
                "oldContent": "  private final String name;\n  private final Object owner;\n  private final Type ownerType;\n  private final MetaProperty property;",
                "newContent": "  private final SlotConfiguration slotConfig;"
            },
            {
                "fromLine": 22,
                "toLine": 26,
                "oldContent": "  CollectionSlot(String name, Object owner, Type ownerType, MetaProperty property) {\n    this.name = name;\n    this.owner = owner;\n    this.ownerType = ownerType;\n    this.property = property;",
                "newContent": "  CollectionSlot(SlotConfiguration slotConfig) {\n    this.slotConfig = slotConfig;"
            }
        ],
        "spock-core/src/main/java/org/spockframework/compiler/ConditionRewriter.java": [
            {
                "fromLine": 64,
                "toLine": 64,
                "oldContent": "  private ConditionRewriter(IRewriteResources resources, String valueRecorderSuffix, String errorCollectorSuffix) {",
                "newContent": "  private ConditionRewriter(IRewriteResources resources, RewriterConfiguration rewriterConfig) {"
            },
            {
                "fromLine": 66,
                "toLine": 68,
                "oldContent": "    valueRecorderName = SpockNames.VALUE_RECORDER + valueRecorderSuffix;\n    errorCollectorName = SpockNames.ERROR_COLLECTOR + errorCollectorSuffix;",
                "newContent": "    this.rewriterConfig = rewriterConfig;\n    valueRecorderName = SpockNames.VALUE_RECORDER + rewriterConfig.getValueRecorderSuffix();\n    errorCollectorName = SpockNames.ERROR_COLLECTOR + rewriterConfig.getErrorCollectorSuffix();"
            },
            {
                "fromLine": 70,
                "toLine": 72,
                "oldContent": "  public static Statement rewriteExplicitCondition(AssertStatement stat, IRewriteResources resources,\n                                                   String valueRecorderSuffix, String errorCollectorSuffix) {",
                "newContent": "  public static Statement rewriteExplicitCondition(AssertStatement stat, IRewriteResources resources,\n                                                   RewriterConfiguration rewriterConfig) {"
            },
            {
                "fromLine": 73,
                "toLine": 73,
                "oldContent": "    ConditionRewriter rewriter = new ConditionRewriter(resources, valueRecorderSuffix, errorCollectorSuffix);",
                "newContent": "    ConditionRewriter rewriter = new ConditionRewriter(resources, rewriterConfig);"
            },
            {
                "fromLine": 76,
                "toLine": 78,
                "oldContent": "  public static Statement rewriteImplicitCondition(ExpressionStatement stat, IRewriteResources resources,\n                                                   String valueRecorderSuffix, String errorCollectorSuffix) {",
                "newContent": "  public static Statement rewriteImplicitCondition(ExpressionStatement stat, IRewriteResources resources,\n                                                   RewriterConfiguration rewriterConfig) {"
            },
            {
                "fromLine": 79,
                "toLine": 79,
                "oldContent": "    ConditionRewriter rewriter = new ConditionRewriter(resources, valueRecorderSuffix, errorCollectorSuffix);",
                "newContent": "    ConditionRewriter rewriter = new ConditionRewriter(resources, rewriterConfig);"
            }
        ],
        "spock-core/src/main/java/org/spockframework/runtime/ErrorReporter.java": [
            {
                "fromLine": 35,
                "toLine": 75,
                "oldContent": "  public void error(String msg, Object... args) {\n    sourceUnit.getErrorCollector().addErrorAndContinue(\n        new SimpleMessage(String.format(msg, args), sourceUnit));\n  }\n\n  public void error(String msg, Throwable cause, Object... args) {\n    sourceUnit.getErrorCollector().addErrorAndContinue(\n        new SimpleMessage(String.format(msg, args) + \"\\n\\n\" + TextUtil.printStackTrace(cause), sourceUnit));\n  }\n\n  public void error(ASTNode node, String msg, Object... args) {\n    error(new InvalidSpecCompileException(node, msg, args));\n  }\n\n  public void error(int line, int column, String msg, Object... args) {\n    error(new InvalidSpecCompileException(line, column, msg, args));\n  }\n\n  public void error(InvalidSpecCompileException e) {\n    sourceUnit.getErrorCollector().addErrorAndContinue(new SyntaxErrorMessage(e, sourceUnit));\n  }\n",
                "newContent": "  public void error(ErrorMessage errorMessage) {\n    sourceUnit.getErrorCollector().addErrorAndContinue(errorMessage.build(sourceUnit));\n  }\n"
            }
        ],
        "spock-core/src/main/java/org/spockframework/runtime/SpockRuntime.java": [
            {
                "fromLine": 30,
                "toLine": 81,
                "oldContent": "  public static void verifyCondition(ErrorCollector errorCollector, @Nullable ValueRecorder recorder,\n      @Nullable String text, int line, int column, @Nullable Object message, @Nullable Object condition) {\n    if (!GroovyRuntimeUtil.isTruthy(condition)) {\n      final ConditionNotSatisfiedError conditionNotSatisfiedError = new ConditionNotSatisfiedError(\n        new Condition(getValues(recorder), text, TextPosition.create(line, column), messageToString(message), null, null));\n      errorCollector.collectOrThrow(conditionNotSatisfiedError);\n    }\n  }\n\n  public static final String CONDITION_FAILED_WITH_EXCEPTION = \"conditionFailedWithException\";\n\n  public static void conditionFailedWithException(ErrorCollector errorCollector, @Nullable ValueRecorder recorder, @Nullable String text, int line, int column, @Nullable Object message, Throwable throwable){\n      if (throwable instanceof SpockAssertionError) {\n        final SpockAssertionError spockAssertionError = (SpockAssertionError) throwable;\n        errorCollector.collectOrThrow(spockAssertionError); // this is our exception - it already has good message\n        return;\n      }\n      if (throwable instanceof SpockException) {\n        final SpockException spockException = (SpockException) throwable;\n        errorCollector.collectOrThrow(spockException); // this is our exception - it already has good message\n        return;\n      }\n    final ConditionFailedWithExceptionError conditionNotSatisfiedError = new ConditionFailedWithExceptionError(\n        new Condition(\n            getValues(recorder),\n            text,\n            TextPosition.create(line, column),\n            messageToString(message),\n            recorder == null ? null : recorder.getCurrentRecordingVarNum(),\n            recorder == null ? null : throwable),\n        throwable);\n    errorCollector.collectOrThrow(conditionNotSatisfiedError);\n  }",
                "newContent": "  public static void verifyCondition(ErrorCollector errorCollector, @Nullable ValueRecorder recorder,\n      Condition condition) {\n    if (!GroovyRuntimeUtil.isTruthy(condition)) {\n      final ConditionNotSatisfiedError conditionNotSatisfiedError = new ConditionNotSatisfiedError(condition);\n      errorCollector.collectOrThrow(conditionNotSatisfiedError);\n    }\n  }\n\n  public static final String CONDITION_FAILED_WITH_EXCEPTION = \"conditionFailedWithException\";\n\n  public static void conditionFailedWithException(ErrorCollector errorCollector, @Nullable String text, int line, int column, @Nullable Object message, Throwable throwable){\n      if (throwable instanceof SpockAssertionError) {\n        final SpockAssertionError spockAssertionError = (SpockAssertionError) throwable;\n        errorCollector.collectOrThrow(spockAssertionError); // this is our exception - it already has good message\n        return;\n      }\n      if (throwable instanceof SpockException) {\n        final SpockException spockException = (SpockException) throwable;\n        errorCollector.collectOrThrow(spockException); // this is our exception - it already has good message\n        return;\n      }\n    final ConditionFailedWithExceptionError conditionNotSatisfiedError = new ConditionFailedWithExceptionError(\n        new Condition(\n            text,\n            TextPosition.create(line, column),\n            messageToString(message),\n            throwable),\n        throwable);\n    errorCollector.collectOrThrow(conditionNotSatisfiedError);\n  }"
            }
        ],
        "spock-core/src/main/java/org/spockframework/runtime/model/ParallelConfiguration.java": [
            {
                "fromLine": 91,
                "toLine": 131,
                "oldContent": "  public void custom(int parallelism, int minimumRunnable, int maxPoolSize, int corePoolSize, int keepAliveSeconds) {\n    parallelExecutionConfiguration = new DefaultParallelExecutionConfiguration(parallelism, minimumRunnable,\n      maxPoolSize, corePoolSize, keepAliveSeconds);\n  }\n\n\n  /**\n   * Internal use only\n   *\n   * @return ParallelExecutionConfiguration\n   */\n  public DefaultParallelExecutionConfiguration getParallelExecutionConfiguration() {\n    return parallelExecutionConfiguration;\n  }\n}",
                "newContent": "  public void custom(ParallelExecutionConfiguration configuration) {\n    parallelExecutionConfiguration = configuration;\n  }\n\n  /**\n   * Internal use only\n   *\n   * @return ParallelExecutionConfiguration\n   */\n  public ParallelExecutionConfiguration getParallelExecutionConfiguration() {\n    return parallelExecutionConfiguration;\n  }\n}"
            }
        ],
        "spock-core/src/main/java/spock/mock/DetachedMockFactory.java": [
            {
                "fromLine": 138,
                "toLine": 187,
                "oldContent": "  @SuppressWarnings(\"unchecked\")\n  public <T> T createMock(@Nullable String name, Class<T> type, MockNature nature, Map<String, Object> options) {\n    ClassLoader classLoader = type.getClassLoader();\n    if (classLoader == null) {\n      classLoader = ClassLoader.getSystemClassLoader();\n    }\n    return (T) new MockUtil().createDetachedMock(name, type, nature, MockImplementation.JAVA, options, classT   * </pre>\n   *\n   * @param options options for creating the mock (see {@link org.spockframework.mock.IMockConfiguration} for available options})\n   * @param type the interface or class type of the mock\n   * @param interactions a description of the mock's interactions\n   * @param <T> the interface or class type of the mock\n   *\n   * @return a mock with the specified options, type, and interactions\n   */\n  @Beta\n  public <T> T Mock(\n    @NamedParams({\n      @NamedParam(value = \"name\", type = String.class),\n      @NamedParam(value = \"additionalInterfaces\", type = List.class),\n      @NamedParam(value = \"defaultResponse\", type = IDefaultResponse.class),\n      @NamedParam(value = \"verified\", type = Boolean.class),\n      @NamedParam(value = \"useObjenesis\", type = Boolean.class),\n      @NamedParam(value = \"mockMaker\", type = IMockMakerSettings.class)\n    })\n      Map<String, Object> options,\n    @DelegatesTo.Target\n      Class<T> type,\n    @DelegatesTo(strategy = Closure.DELEGATE_FIRST, genericTypeIndex = 0)\n    @ClosureParams(SecondParam.FirstGenericType.class)\n      Closure interactions) {\n    throw invalidMockCreation();\n  }\n\n  /**\n   * Creates a stub whose type and name are inferred from the left-hand side of the enclosing variable assignment.\n   *\n   * Example:\n   *\n   * <pre>\n   *   Person person = Stub() // type is Person.class, name is \"person\"\n   * </pre>\n   *\n   * @return a stub whose type and name are inferred from the left-hand side of the enclosing variable assignment\n   */\n  @Beta\n  public <T> T Stub() {\n    throw invalidMockCreation();\n  }\n\n  /**\n   * Creates a stub with the specified options whose type and name are inferred from the left-hand side of the loader);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  public <T> T createMock(@Nullable String name, T obj, MockNature nature, Map<String, Object> options) {\n    ClassLoader classLoader = obj.getClass().getClassLoader();\n    if (classLoader == null) {\n      classLoader = ClassLoader.getSystemClassLoader();\n    }\n    return (T) new MockUtil().createDetachedMock(name, obj, nature, MockImplementation.JAVA, options, classLoader);\n  }\n\n  private String inferNameFromType(Class<?> type) {\n    return type.getSimpleName();\n  }\n}",
                "newContent": "  @SuppressWarnings(\"unchecked\")\n  public <T> T createMock(MockConfiguration configuration) {\n    ClassLoader classLoader = configuration.getType().getClassLoader();\n    if (classLoader == null) {\n      classLoader = ClassLoader.getSystemClassLoader();\n    }\n    return (T) new MockUtil().createDetachedMock(configuration, classLoader);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  public <T> T createMock(Object instance, MockConfiguration configuration) {\n    ClassLoader classLoader = instance.getClass().getClassLoader();\n    if (classLoader == null) {\n      classLoader = ClassLoader.getSystemClassLoader();\n    }\n    return (T) new MockUtil().createDetachedMock(instance, configuration, classLoader);\n  }\n\n  private String inferNameFromType(Class<?> type) {\n    return type.getSimpleName();\n  }\n}"
            }
        ],
        "spock-core/src/main/java/spock/mock/MockingApi.java": [
            {
                "fromLine": 337,
                "toLine": 382,
                "oldContent": "  @Beta\n  public <T> T Mock(\n    @NamedParams({\n      @NamedParam(value = \"name\", type = String.class),\n      @NamedParam(value = \"additionalInterfaces\", type = List.class),\n      @NamedParam(value = \"defaultResponse\", type = IDefaultResponse.class),\n      @NamedParam(value = \"verified\", type = Boolean.class),\n      @NamedParam(value = \"useObjenesis\", type = Boolean.class),\n      @NamedParam(value = \"mockMaker\", type = IMockMakerSettings.class)\n    })\n      Map<String, Object> options,\n    @DelegatesTo.Target\n      Class<T> type,\n    @DelegatesTo(strategy = Closure.DELEGATE_FIRST, genericTypeIndex = 0)\n    @ClosureParams(SecondParam.FirstGenericType.class)\n      Closure interactions) {\n    throw invalidMockCreation();\n  }\n\n  /**\n   * Creates a stub whose type and name are inferred from the left-hand side of the enclosing variable assignment.\n   *\n   * Example:\n   *\n   * <pre>\n   *   Person person = Stub() // type is Person.class, name is \"person\"\n   * </pre>\n   *\n   * @return a stub whose type and name are inferred from the left-hand side of the enclosing variable assignment\n   */\n  @Beta\n  public <T> T Stub() {\n    throw invalidMockCreation();\n  }\n\n  /**\n   * Creates a stub with the specified options whose type and name are inferred from the left-hand side of the",
                "newContent": "  @Beta\n  public <T> T Mock(\n    @NamedParams({\n      @NamedParam(value = \"name\", type = String.class),\n      @NamedParam(value = \"additionalInterfaces\", type = List.class),\n      @NamedParam(value = \"defaultResponse\", type = IDefaultResponse.class),\n      @NamedParam(value = \"verified\", type = Boolean.class),\n      @NamedParam(value = \"useObjenesis\", type = Boolean.class),\n      @NamedParam(value = \"mockMaker\", type = IMockMakerSettings.class)\n    })\n      Map<String, Object> options,\n    @DelegatesTo.Target\n      Class<T> type,\n    @DelegatesTo(strategy = Closure.DELEGATE_FIRST, genericTypeIndex = 0)\n    @ClosureParams(SecondParam.FirstGenericType.class)\n      Closure interactions) {\n    MockConfiguration configuration = createMockConfiguration(options, type, interactions);\n    return createMock(configuration);\n  }\n\n  /**\n   * Creates a stub whose type and name are inferred from the left-hand side of the enclosing variable assignment.\n   *\n   * Example:\n   *\n   * <pre>\n   *   Person person = Stub() // type is Person.class, name is \"person\"\n   * </pre>\n   *\n   * @return a stub whose type and name are inferred from the left-hand side of the enclosing variable assignment\n   */\n  @Beta\n  public <T> T Stub() {\n    throw invalidMockCreation();\n  }\n\n  /**\n   * Creates a stub with the specified options whose type and name are inferred from the left-hand side of the"
            },
            {
                "fromLine": 566,
                "toLine": 611,
                "oldContent": "  @Beta\n  public <T> T Stub(\n    @NamedParams({\n      @NamedParam(value = \"name\", type = String.class),\n      @NamedParam(value = \"additionalInterfaces\", type = List.class),\n      @NamedParam(value = \"defaultResponse\", type = IDefaultResponse.class),\n      @NamedParam(value = \"verified\", type = Boolean.class),\n      @NamedParam(value = \"useObjenesis\", type = Boolean.class),\n      @NamedParam(value = \"mockMaker\", type = IMockMakerSettings.class)\n    })\n      Map<String, Object> options,\n    @DelegatesTo.Target\n      Class<T> type,\n    @DelegatesTo(strategy = Closure.DELEGATE_FIRST, genericTypeIndex = 0)\n    @ClosureParams(SecondParam.FirstGenericType.class)\n      Closure interactions)