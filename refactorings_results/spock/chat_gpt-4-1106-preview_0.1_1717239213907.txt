{
    "refactorings": {
        "spock-core/src/main/java/org/spockframework/mock/runtime/CglibMockInterceptorAdapter.java": [
            {
                "fromLine": 9,
                "toLine": 49,
                "oldContent": "import java.lang.reflect.Method;\n\nimport net.sf.cglib.proxy.*;\n\npublic class CglibMockInterceptorAdapter implements MethodInterceptor {\n  private final IProxyBasedMockInterceptor interceptor;\n\n  public CglibMockInterceptorAdapter(IProxyBasedMockInterceptor interceptor) {\n    this.interceptor = interceptor;\n  }\n\n  @Override\n  public Object intercept(Object target, Method method, Object[] arguments, MethodProxy methodProxy) throws Throwable {\n    return interceptor.intercept(target, method, arguments, new CglibRealMethodInvoker(methodProxy));\n  }\n}\n",
                "newContent": "import java.lang.reflect.Method;\n\nimport net.sf.cglib.proxy.*;\n\npublic class CglibMockInterceptorAdapter implements MethodInterceptor {\n  private final IProxyBasedMockInterceptor interceptor;\n\n  public CglibMockInterceptorAdapter(IProxyBasedMockInterceptor interceptor) {\n    this.interceptor = interceptor;\n  }\n\n  @Override\n  public Object intercept(Object target, Method method, Object[] arguments, MethodProxy methodProxy) throws Throwable {\n    // Refactored to use InvocationContext\n    InvocationContext context = new InvocationContext(target, method, arguments, methodProxy);\n    return interceptor.intercept(context);\n  }\n}\n"
            }
        ],
        "spock-core/src/main/java/org/spockframework/mock/runtime/GroovyMockInterceptor.java": [
            {
                "fromLine": 18,
                "toLine": 58,
                "oldContent": "import spock.lang.Specification;\n\nimport java.lang.reflect.Method;\n\nimport groovy.lang.*;\n\nimport static java.util.Arrays.asList;\n\npublic class GroovyMockInterceptor extends BaseMockInterceptor {\n  private final IMockConfiguration mockConfiguration;\n  private final Specification specification;\n\n  public GroovyMockInterceptor(IMockConfiguration mockConfiguration, Specification specification, MetaClass mockMetaClass) {\n    super(mockMetaClass);\n    this.mockConfiguration = mockConfiguration;\n    this.specification = specification;\n  }\n\n  @Override\n  public Object intercept(Object target, Method method, Object[] arguments, IResponseGenerator realMethodInvoker) {\n    IMockObject mockObject = new MockObject(mockConfiguration.getName(), mockConfiguration.getExactType(), target,\n      mockConfiguration.isVerified(), mockConfiguration.isGlobal(), mockConfiguration.getDefaultResponse(), specification, this);\n\n    if (method.getDeclaringClass() == ISpockMockObject.class) {\n      return mockObject;\n    }\n\n    // we do not need the cast information from the wrappers here, the method selection\n    // is already done, so unwrap the argument array if there are still wrappers present\n    Object[] args = GroovyRuntimeUtil.asUnwrappedArgumentArray(arguments);\n\n    if (isMethod(method, \"getMetaClass\")) {\n      return getMockMetaClass();\n    }\n    if (isMethod(method, \"invokeMethod\", String.class, Object.class)) {\n      return GroovyRuntimeUtil.invokeMethod(target,\n        (String)args[0], GroovyRuntimeUtil.asArgumentArray(args[1]));\n    }\n    if (isMethod(method, \"getProperty\", String.class)) {\n      String methodName = handleGetProperty((GroovyObject)target, args);\n      if (methodName != null) {",
                "newContent": "import spock.lang.Specification;\n\nimport java.lang.reflect.Method;\n\nimport groovy.lang.*;\n\nimport static java.util.Arrays.asList;\n\npublic class GroovyMockInterceptor extends BaseMockInterceptor {\n  private final IMockConfiguration mockConfiguration;\n  private final Specification specification;\n\n  public GroovyMockInterceptor(IMockConfiguration mockConfiguration, Specification specification, MetaClass mockMetaClass) {\n    super(mockMetaClass);\n    this.mockConfiguration = mockConfiguration;\n    this.specification = specification;\n  }\n\n  @Override\n  public Object intercept(InvocationContext context) {\n    IMockObject mockObject = new MockObject(mockConfiguration.getName(), mockConfiguration.getExactType(), context.getTarget(),\n      mockConfiguration.isVerified(), mockConfiguration.isGlobal(), mockConfiguration.getDefaultResponse(), specification, this);\n\n    if (context.getMethod().getDeclaringClass() == ISpockMockObject.class) {\n      return mockObject;\n    }\n\n    // we do not need the cast information from the wrappers here, the method selection\n    // is already done, so unwrap the argument array if there are still wrappers present\n    Object[] args = context.getArguments();\n\n    if (isMethod(context.getMethod(), \"getMetaClass\")) {\n      return getMockMetaClass();\n    }\n    if (isMethod(context.getMethod(), \"invokeMethod\", String.class, Object.class)) {\n      return GroovyRuntimeUtil.invokeMethod(context.getTarget(),\n        (String)args[0], GroovyRuntimeUtil.asArgumentArray(args[1]));\n    }\n    if (isMethod(context.getMethod(), \"getProperty\", String.class)) {\n      String methodName = handleGetProperty((GroovyObject)context.getTarget(), args);\n      if (methodName != null) {"
            }
        ],
        "spock-core/src/main/java/org/spockframework/mock/runtime/IProxyBasedMockInterceptor.java": [
            {
                "fromLine": 2,
                "toLine": 42,
                "oldContent": " *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     https://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.spockframework.mock.runtime;\n\nimport java.lang.reflect.Method;\n\nimport org.spockframework.mock.IResponseGenerator;\n\npublic interface IProxyBasedMockInterceptor extends SpecificationAttachable {\n  Object intercept(Object target, Method method, Object[] arguments, IResponseGenerator realMethodInvoker);\n}\n",
                "newContent": " *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     https://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.spockframework.mock.runtime;\n\npublic interface IProxyBasedMockInterceptor extends SpecificationAttachable {\n  // Refactored to accept InvocationContext parameter\n  Object intercept(InvocationContext context);\n}\n"
            }
        ],
        "spock-core/src/main/java/org/spockframework/mock/runtime/JavaProxyMockInterceptorAdapter.java": [
            {
                "fromLine": 10,
                "toLine": 50,
                "oldContent": " * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.spockframework.mock.runtime;\n\nimport org.spockframework.mock.IResponseGenerator;\nimport org.spockframework.util.ReflectionUtil;\n\nimport java.lang.reflect.*;\n\npublic class JavaProxyMockInterceptorAdapter implements InvocationHandler {\n  private final IProxyBasedMockInterceptor interceptor;\n\n  public JavaProxyMockInterceptorAdapter(IProxyBasedMockInterceptor interceptor) {\n    this.interceptor = interceptor;\n  }\n\n  @Override\n  public Object invoke(Object target, Method method, Object[] arguments) throws Throwable {\n    IResponseGenerator realMethodInvoker = method.isDefault()\n      ? new DefaultMethodInvoker(target, method, arguments)\n      : ReflectionUtil.isObjectMethod(method)\n      ? ObjectMethodInvoker.INSTANCE\n      : new FailingRealMethodInvoker(\"Cannot invoke real method '\" + method.getName() + \"' on interface based mock object\");\n    return interceptor.intercept(target, method, arguments, realMethodInvoker);\n  }\n}\n",
                "newContent": " * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.spockframework.mock.runtime;\n\nimport org.spockframework.mock.IResponseGenerator;\nimport org.spockframework.util.ReflectionUtil;\n\nimport java.lang.reflect.*;\n\npublic class JavaProxyMockInterceptorAdapter implements InvocationHandler {\n  private final IProxyBasedMockInterceptor interceptor;\n\n  public JavaProxyMockInterceptorAdapter(IProxyBasedMockInterceptor interceptor) {\n    this.interceptor = interceptor;\n  }\n\n  @Override\n  public Object invoke(Object target, Method method, Object[] arguments) throws Throwable {\n    // Refactored to use InvocationContext\n    InvocationContext context = new InvocationContext(target, method, arguments);\n    return interceptor.intercept(context);\n  }\n}\n"
            }
        ],
        "spock-core/src/main/java/org/spockframework/spring/mock/DelegatingInterceptor.java": [
            {
                "fromLine": 16,
                "toLine": 56,
                "oldContent": "package org.spockframework.spring.mock;\n\nimport org.spockframework.mock.*;\nimport org.spockframework.mock.runtime.IProxyBasedMockInterceptor;\nimport org.spockframework.runtime.model.FieldInfo;\nimport org.spockframework.util.*;\nimport spock.lang.Specification;\n\nimport java.lang.reflect.*;\n\npublic class DelegatingInterceptor implements IProxyBasedMockInterceptor {\n  private final FieldInfo fieldInfo;\n  private Object delegate;\n\n  public DelegatingInterceptor(FieldInfo fieldInfo) {\n    this.fieldInfo = fieldInfo;\n  }\n\n  @Override\n  public Object intercept(Object target, Method method, Object[] arguments, IResponseGenerator realMethodInvoker) {\n    if (method.getDeclaringClass() == ISpockMockObject.class) {\n      return new MockObjectAdapter(this);\n    }\n\n    if (delegate == null) {\n      if (\"toString\".equals(method.getName())) {\n        return String.format(\"Mock for '%s.%s:%d'\", fieldInfo.getParent().getName(), fieldInfo.getName(), fieldInfo.getLine());\n      } else if (\"equals\".equals(method.getName())){\n        return fieldInfo.equals(arguments[0]);\n      } else if (\"hashCode\".equals(method.getName())) {\n        return fieldInfo.hashCode();\n      }\n      return null;\n    }\n\n    try {\n      return method.invoke(delegate, arguments);\n    } catch (IllegalAccessException e) {\n      return ExceptionUtil.sneakyThrow(e);\n    } catch (InvocationTargetException e) {\n      return ExceptionUtil.sneakyThrow(e.getTargetException());",
                "newContent": "package org.spockframework.spring.mock;\n\nimport org.spockframework.mock.*;\nimport org.spockframework.mock.runtime.IProxyBasedMockInterceptor;\nimport org.spockframework.runtime.model.FieldInfo;\nimport org.spockframework.util.*;\nimport spock.lang.Specification;\n\nimport java.lang.reflect.*;\n\npublic class DelegatingInterceptor implements IProxyBasedMockInterceptor {\n  private final FieldInfo fieldInfo;\n  private Object delegate;\n\n  public DelegatingInterceptor(FieldInfo fieldInfo) {\n    this.fieldInfo = fieldInfo;\n  }\n\n  @Override\n  public Object intercept(InvocationContext context) {\n    if (context.getMethod().getDeclaringClass() == ISpockMockObject.class) {\n      return new MockObjectAdapter(this);\n    }\n\n    if (delegate == null) {\n      if (\"toString\".equals(context.getMethod().getName())) {\n        return String.format(\"Mock for '%s.%s:%d'\", fieldInfo.getParent().getName(), fieldInfo.getName(), fieldInfo.getLine());\n      } else if (\"equals\".equals(context.getMethod().getName())){\n        return fieldInfo.equals(context.getArguments()[0]);\n      } else if (\"hashCode\".equals(context.getMethod().getName())) {\n        return fieldInfo.hashCode();\n      }\n      return null;\n    }\n\n    try {\n      return context.getMethod().invoke(delegate, context.getArguments());\n    } catch (IllegalAccessException e) {\n      return ExceptionUtil.sneakyThrow(e);\n    } catch (InvocationTargetException e) {\n      return ExceptionUtil.sneakyThrow(e.getTargetException());"
            }
        ],
        "spock-core/src/main/java/org/spockframework/mock/runtime/DefaultMethodInvoker.java": [
            {
                "fromLine": 15,
                "toLine": 57,
                "oldContent": "\nimport org.spockframework.mock.CannotCreateMockException;\nimport org.spockframework.mock.IMockInvocation;\nimport org.spockframework.mock.IResponseGenerator;\nimport org.spockframework.util.ExceptionUtil;\nimport org.spockframework.util.Nullable;\nimport org.spockframework.util.ThreadSafe;\n\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\n\n@ThreadSafe\npublic class DefaultMethodInvoker implements IResponseGenerator {\n  @Nullable // Available since Java 17\n  private static final Method INVOKE_DEFAULT = ReflectionUtil.getDeclaredMethodByName(InvocationHandler.class, \"invokeDefault\");\n  private final Object target;\n  private final Method method;\n  private final Object[] arguments;\n\n  public DefaultMethodInvoker(Object target, Method method, Object[] arguments) {\n    this.target = target;\n    this.method = method;\n    this.arguments = arguments;\n  }\n\n  @Override\n  public Object respond(IMockInvocation invocation) {\n    if (INVOKE_DEFAULT == null) {\n      return useInternalMethodHandle();\n    }\n    Object[] args = new Object[]{target, method, arguments};\n    return ReflectionUtil.invokeMethod(null, INVOKE_DEFAULT, args);\n  }\n\n  private Object useInternalMethodHandle() {\n    MethodHandle methodHandle;\n    try {\n      final Field field = MethodHandles.Lookup.class.getDeclaredField(\"IMPL_LOOKUP\");\n      field.setAccessible(true);",
                "newContent": "\nimport org.spockframework.mock.CannotCreateMockException;\nimport org.spockframework.mock.IMockInvocation;\nimport org.spockframework.mock.IResponseGenerator;\nimport org.spockframework.util.ExceptionUtil;\nimport org.spockframework.util.Nullable;\nimport org.spockframework.util.ThreadSafe;\n\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\n\n@ThreadSafe\npublic class DefaultMethodInvoker implements IResponseGenerator {\n  @Nullable // Available since Java 17\n  private static final Method INVOKE_DEFAULT = ReflectionUtil.getDeclaredMethodByName(InvocationHandler.class, \"invokeDefault\");\n  private final InvocationContext context;\n\n  public DefaultMethodInvoker(InvocationContext context) {\n    this.context = context;\n  }\n\n  @Override\n  public Object respond(IMockInvocation invocation) {\n    if (INVOKE_DEFAULT == null) {\n      return useInternalMethodHandle();\n    }\n    Object[] args = new Object[]{context.getTarget(), context.getMethod(), context.getArguments()};\n    return ReflectionUtil.invokeMethod(null, INVOKE_DEFAULT, args);\n  }\n\n  private Object useInternalMethodHandle() {\n    MethodHandle methodHandle;\n    try {\n      final Field field = MethodHandles.Lookup.class.getDeclaredField(\"IMPL_LOOKUP\");\n      field.setAccessible(true);"
            }
        ],
        "spock-core/src/main/java/org/spockframework/mock/runtime/JavaMockInterceptor.java": [
            {
                "fromLine": 19,
                "toLine": 59,
                "oldContent": "\nimport java.lang.reflect.Method;\n\nimport groovy.lang.*;\n\nimport static java.util.Arrays.asList;\n\npublic class JavaMockInterceptor extends BaseMockInterceptor {\n  private final IMockConfiguration mockConfiguration;\n  private Specification specification;\n  private MockController fallbackMockController;\n\n  public JavaMockInterceptor(IMockConfiguration mockConfiguration, Specification specification, MetaClass mockMetaClass) {\n    super(mockMetaClass);\n    this.mockConfiguration = mockConfiguration;\n    this.specification = specification;\n  }\n\n  @Override\n  public Object intercept(Object target, Method method, Object[] arguments, IResponseGenerator realMethodInvoker) {\n    IMockObject mockObject = new MockObject(mockConfiguration.getName(), mockConfiguration.getExactType(),\n      target, mockConfiguration.isVerified(), false, mockConfiguration.getDefaultResponse(), specification, this);\n\n    if (method.getDeclaringClass() == ISpockMockObject.class) {\n      return mockObject;\n    }\n\n    // here no instances of org.codehaus.groovy.runtime.wrappers.Wrapper subclasses\n    // should arrive in the arguments array. If there are some found, it should first\n    // be investigated whether they should have made it until here. If it is correct\n    // that they arrived here, maybe GroovyRuntimeUtil.asUnwrappedArgumentArray needs\n    // to be used to unwrap the arguments. Wrapper subclasses are used to transport\n    // type cast information to select proper overloaded methods.\n    Object[] args = GroovyRuntimeUtil.asArgumentArray(arguments);\n\n    if (target instanceof GroovyObject) {\n      if (isMethod(method, \"getMetaClass\")) {\n        return getMockMetaClass();\n      }\n      if (isMethod(method, \"setProperty\", String.class, Object.class)) {\n        Throwable throwable = new Throwable();",
                "newContent": "\nimport java.lang.reflect.Method;\n\nimport groovy.lang.*;\n\nimport static java.util.Arrays.asList;\n\npublic class JavaMockInterceptor extends BaseMockInterceptor {\n  private final IMockConfiguration mockConfiguration;\n  private Specification specification;\n  private MockController fallbackMockController;\n\n  public JavaMockInterceptor(IMockConfiguration mockConfiguration, Specification specification, MetaClass mockMetaClass) {\n    super(mockMetaClass);\n    this.mockConfiguration = mockConfiguration;\n    this.specification = specification;\n  }\