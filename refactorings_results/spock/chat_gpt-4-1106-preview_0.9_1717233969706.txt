{
    "refactorings": {
        "spock-core/src/main/java/org/spockframework/runtime/SpecificationContext.java": [
            {
                "fromLine": 1,
                "toLine": 35,
                "oldContent": "",
                "newContent": "package org.spockframework.runtime;\n\nimport org.spockframework.mock.runtime.MockObject;\nimport org.spockframework.util.Nullable;\n\nimport java.util.Map;\n\npublic class SpecificationContext {\n  private final boolean failed;\n  private final Throwable thrownException;\n  private MockObject currentMock;\n  private Map<String, Object> currentDataVariables;\n\n  public SpecificationContext(boolean failed, Throwable thrownException) {\n    this.failed = failed;\n    this.thrownException = thrownException;\n  }\n\n  public boolean isFailed() {\n    return failed;\n  }\n\n  @Nullable\n  public Throwable getThrownException() {\n    return thrownException;\n  }\n\n  public void setCurrentMock(MockObject currentMock) {\n    this.currentMock = currentOhject;\n  }\n\n  @Nullable\n  public MockObject getCurrentMock() {\n    return currentMock;\n  }\n\n  public void setCurrentDataVariables(Map<String, Object> currentDataVariables) {\n    this.currentDataVariables = currentDataVariables;\n  }\n\n  public Map<String, Object> getCurrentDataVariables() {\n    return currentDataVariables;\n  }\n}\n"
            }
        ],
        "spock-core/src/main/java/org/spockframework/mock/runtime/MockObject.java": [
            {
                "fromLine": 7,
                "toLine": 52,
                "oldContent": " * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.spockframework.mock.runtime;\n\nimport org.spockframework.util.GenericTypeReflectorUtil;\nimport org.spockframework.lang.Wildcard;\nimport org.spockframework.mock.*;\nimport org.spockframework.runtime.InvalidSpecException;\nimport org.spockframework.util.Nullable;\nimport spock.lang.Specification;\n\nimport java.lang.reflect.Type;\n\npublic class MockObject implements IMockObject {\n  private final String name;\n  private final Type type;\n  private final Object instance;\n  private final boolean verified;\n  private final boolean global;\n  private final IDefaultResponse defaultResponse;\n  private final SpecificationAttachable mockInterceptor;\n\n  private Specification specification;\n\n  public MockObject(@Nullable String name, Type type, Object instance, boolean verified, boolean global,\n      IDefaultResponse defaultResponse, Specification specification, SpecificationAttachable mockInterceptor) {\n    this.name = name;\n    this.type = type;\n    this.instance = instance;\n    this.verified = verified;\n    this.global = global;\n    this.defaultResponse = defaultResponse;\n    this.specification = specification;\n    this.mockInterceptor = mockInterceptor;\n  }\n\n  @Override\n  @Nullable\n  public String getName() {\n    return name;\n  }",
                "newContent": " * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.spockframework.mock.runtime;\n\nimport org.spockframework.util.GenericTypeReflectorUtil;\nimport org.spockframework.lang.Wildcard;\nimport org.spockframework.mock.*;\nimport org.spockframework.runtime.InvalidSpecException;\nimport org.spockframework.util.Nullable;\nimport spock.lang.Specification;\n\nimport java.lang.reflect.Type;\n\npublic class MockObject implements IMockObject {\n  private final String name;\n  private final Type type;\n  private final Object instance;\n  private final boolean verified;\n  private final boolean global;\n  private final IDefaultResponse defaultResponse;\n  private final SpecificationAttachable mockInterceptor;\n\n  private Specification specification;\n  private SpecificationContext context;\n\n  public MockObject(@Nullable String name, Type type, Object instance, boolean verified, boolean global,\n      IDefaultResponse defaultResponse, Specification specification, SpecificationAttachable mockInterceptor) {\n    this.name = name;\n    this.type = type;\n    this.instance = instance;\n    this.verified = verified;\n    this.global = global;\n    this.defaultResponse = defaultResponse;\n    this.specification = specification;\n    this.mockInterceptor = mockInterceptor;\n  }\n\n  @Override\n  @Nullable\n  public String getName() {\n    return name;\n  }\n\n  public void setContext(SpecificationContext context) {\n    this.context = context;\n  }\n\n  @Nullable\n  public SpecificationContext getContext() {\n    return context;\n  }\n}"
            }
        ],
        "spock-core/src/main/java/org/spockframework/runtime/SpockExecutionContext.java": [
            {
                "fromLine": 14,
                "toLine": 58,
                "oldContent": "\npackage org.spockframework.runtime;\n\nimport org.spockframework.runtime.model.*;\nimport org.spockframework.util.InternalSpockError;\nimport spock.lang.Specification;\n\nimport org.junit.platform.engine.*;\nimport org.junit.platform.engine.support.hierarchical.EngineExecutionContext;\n\npublic class SpockExecutionContext implements EngineExecutionContext, Cloneable {\n  private EngineExecutionListener engineExecutionListener;\n\n  private RunContext runContext;\n\n  private PlatformParameterizedSpecRunner runner;\n\n  private SpecInfo spec;\n\n  private FeatureInfo currentFeature;\n\n  private IterationInfo currentIteration;\n\n  private Specification sharedInstance;\n\n  private Specification currentInstance;\n\n  private UniqueId parentId;\n\n  private ErrorInfoCollector errorInfoCollector;\n\n  private StoreProvider storeProvider;\n\n  public SpockExecutionContext(EngineExecutionListener engineExecutionListener) {\n    this.engineExecutionListener = engineExecutionListener;\n    this.storeProvider = StoreProvider.createRootStoreProvider();\n  }\n\n  private SpockExecutionContext setRunContext(RunContext runContext) {\n    this.runContext = runContext;\n    return this;\n  }\n\n  private SpockExecutionContext setRunner(PlatformParameterizedSpecRunner runner) {\n    this.runner = runner;",
                "newContent": "\npackage org.spockframework.runtime;\n\nimport org.spockframework.runtime.model.*;\nimport org.spockframework.util.InternalSpockError;\nimport spock.lang.Specification;\n\nimport org.junit.platform.engine.*;\nimport org.junit.platform.engine.support.hierarchical.EngineExecutionContext;\n\npublic class SpockExecutionContext implements EngineExecutionContext, Cloneable {\n  private EngineExecutionListener engineExecutionListener;\n\n  private RunContext runContext;\n\n  private PlatformParameterizedSpecRunner runner;\n\n  private SpecInfo spec;\n\n  private FeatureInfo currentFeature;\n\n  private IterationInfo currentIteration;\n\n  private Specification sharedInstance;\n\n  private Specification currentInstance;\n\n  private UniqueId parentId;\n\n  private ErrorInfoCollector errorInfoCollector;\n\n  private StoreProvider storeProvider;\n\n  private SpecificationContext specificationContext;\n\n  public SpockExecutionContext(EngineExecutionListener engineExecutionListener) {\n    this.engineExecutionListener = engineExecutionListener;\n    this.storeProvider = StoreProvider.createRootStoreProvider();\n  }\n\n  public SpockExecutionContext setRunContext(RunContext runContext) {\n    this.runContext = runContext;\n    return this;\n  }\n\n  public SpockExecutionContext setRunner(PlatformParameterizedSpecRunner runner) {\n    this.runner = runner;\n    return this;\n  }\n\n  public SpecificationContext getSpecificationContext() {\n    if (specificationContext == null) {\n      specificationContext = new SpecificationContext(currentFeature != null && currentFeature.isParameterized(),\n        errorInfoCollector.hasErrors() ? errorInfoCollector.getLastError().getException() : null);\n      ((MockObject)specificationContext.getCurrentMock()).setContext(specificationContext);\n      specificationContext.setCurrentDataVariables(currentFeature == null ? Map.of() : currentFeature.getCurrentDataVariables());\n    }\n    return specificationContext;\n  }\n\n  public SpockExecutionContext setSpecificationContext(SpecificationContext specificationContext) {\n    this.specificationContext = specificationContext;\n    return this;\n  }\n}"
            }
        ],
        "spock-core/src/main/java/org/spockframework/mock/runtime/MockConfiguration.java": [
            {
                "fromLine": 9,
                "toLine": 60,
                "oldContent": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.spockframework.mock.runtime;\n\nimport org.spockframework.mock.*;\nimport org.spockframework.util.*;\nimport spock.mock.IMockMakerSettings;\n\nimport java.lang.reflect.Type;\nimport java.util.*;\n\nimport static java.util.Collections.emptyList;\nimport static java.util.Collections.singletonList;\n\n@Beta\npublic class MockConfiguration implements IMockConfiguration {\n  private final String name;\n  private final Type type;\n  private final Object instance;\n  private final MockNature nature;\n  private final MockImplementation implementation;\n  private final List<Object> constructorArgs;\n  private final List<Class<?>> additionalInterfaces;\n  private final IDefaultResponse defaultResponse;\n  private final boolean global;\n  private final boolean verified;\n  private final boolean useObjenesis;\n  private final IMockMakerSettings mockMakerSettings;\n\n  public MockConfiguration(@Nullable String name, Type type, MockNature nature,\n      MockImplementation implementation, Map<String, Object> options) {\n      this(name, type, null, nature, implementation, options);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  public MockConfiguration(@Nullable String name, Type type, @Nullable Object instance, MockNature nature,\n      MockImplementation implementation, Map<String, Object> options) {\n    this.name = getOption(options, \"name\", String.class, name);\n    this.type = getOption(options, \"type\", Type.class, type);\n    this.instance = getOption(options, \"instance\", Object.class, instance);\n    this.nature = getOption(options, \"nature\", MockNature.class, nature);\n    this.implementation = getOption(options, \"implementation\", MockImplementation.class, implementation);\n    this.constructorArgs = getOptionAsList(options, \"constructorArgs\");\n    this.additionalInterfaces = getOption(options, \"additionalInterfaces\", List.class, emptyList());\n    this.defaultResponse = getOption(options, \"defaultResponse\", IDefaultResponse.class, this.nature.getDefaultResponse());\n    this.global = getOption(options, \"global\", Boolean.class, false);\n    this.verified = getOption(options, \"verified\", Boolean.class, this.nature.isVerified());\n    this.useObjenesis = getOption(options, \"useObjenesis\", Boolean.class, this.nature.isUseObjenesis());\n    this.mockMakerSettings = getOption(options, \"mockMaker\", IMockMakerSettings.class, null);",
                "newContent": " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.spockframework.mock.runtime;\n\nimport org.spockframework.mock.*;\nimport org.spockframework.util.*;\nimport spock.mock.IMockMakerSettings;\n\nimport java.lang.reflect.Type;\nimport java.util.*;\n\nimport static java.util.Collections.emptyList;\nimport static java.util.Collections.singletonList;\n\n@Beta\npublic class MockConfiguration implements IMockConfiguration {\n  private final String name;\n  private final Type type;\n  private final Object instance;\n  private final MockNature nature;\n  private final MockImplementation implementation;\n  private final List<Object> constructorArgs;\n  private final List<Class<?>> additionalInterfaces;\n  private final IDefaultResponse defaultResponse;\n  private final boolean global;\n  private final boolean verified;\n  private final boolean useObjenesis;\n  private final IMockMakerSettings mockMakerSettings;\n  private final SpecificationContext context;\n\n  public MockConfiguration(@Nullable String name, Type type, MockNature nature,\n      MockImplementation implementation, Map<String, Object> options) {\n      this(name, type, null, nature, implementation, options, null);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  public MockConfiguration(@Nullable String name, Type type, @Nullable Object instance, MockNature nature,\n      MockImplementation implementation, Map<String, Object> options, @Nullable SpecificationContext context) {\n    this.name = getOption(options, \"name\", String.class, name);\n    this.type = getOption(options, \"type\", Type.class, type);\n    this.instance = getOption(options, \"instance\", Object.class, instance);\n    this.nature = getOption(options, \"nature\", MockNature.class, nature);\n    this.implementation = getOption(options, \"implementation\", MockImplementation.class, implementation);\n    this.constructorArgs = getOptionAsList(options, \"constructorArgs\");\n    this.additionalInterfaces = getOption(options, \"additionalInterfaces\", List.class, emptyList());\n    this.defaultResponse = getOption(options, \"defaultResponse\", IDefaultResponse.class, this.nature.getDefaultResponse());\n    this.global = getOption(options, \"global\", Boolean.class, false);\n    this.verified = getOption(options, \"verified\", Boolean.class, this.nature.isVerified());\n    this.useObjenesis = getOption(options, \"useObjenesis\", Boolean.class, this.nature.isUseObjenesis());\n    this.mockMakerSettings = getOption(options, \"mockMaker\", IMockMakerSettings.class, null);\n    this.context = context;\n  }\n\n  public SpecificationContext getContext() {\n    return context;\n  }\n}"
            }
        ],
        "spock-core/src/main/java/org/spockframework/builders/PropertySlot.java": [
            {
                "fromLine": 4,
                "toLine": 46,
                "oldContent": " * You may obtain a copy of the License at\n *     https://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.spockframework.builder;\n\nimport org.spockframework.util.*;\n\nimport java.lang.reflect.*;\n\nimport groovy.lang.MetaProperty;\n\npublic class PropertySlot implements ISlot {\n  private final Object owner;\n  private final Type ownerType;\n  private final MetaProperty property;\n\n  PropertySlot(Object owner, Type ownerMode, SpecificationContext context, MetaProperty property) {\n    this.owner = owner;\n    this.ownerType = ownerType;\n    this.property = property;\n    this.context = context;\n  }\n\n  @Override\n  public Type getType() {\n    // could possibly add fast path here, but be careful (inner classes etc.)\n\n    Method setter = MopUtil.setterFor(property);\n    if (setter != null) return GenericTypeReflectorUtil.getParameterTypes(setter, ownerType)[0];\n\n    Field field = MopUtil.fieldFor(property);\n    if (field != null) return GenericTypeReflectorUtil.getExactFieldType(field, ownerType);\n\n    throw new UnreachableCodeError();\n  }\n\n  @Override\n  public",
                "newContent": " * You may obtain a copy of the License at\n *     https://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.spockframework.builder;\n\nimport org.spockframework.util.*;\n\nimport java.lang.reflect.*;\n\nimport groovy.lang.MetaProperty;\n\npublic class PropertySlot implements ISlot {\n  private final Object owner;\n  private final Type ownerType;\n  private final MetaProperty property;\n  private final SpecificationContext context;\n\n  PropertySlot(Object owner, Type ownerMode, SpecificationContext context, MetaProperty property) {\n    this.owner = owner;\n    this.ownerType = ownerType;\n    this.property = property;\n    this.context = context;\n  }\n\n  public void setContext(SpecificationContext context) {\n    this.context = context;\n  }\n\n  public SpecificationContext getContext() {\n    return context;\n  }\n\n  @Override\n  public Type getType() {\n    // could possibly add fast path here, but be careful (inner classes etc.)\n\n    Method setter = MopUtil.setterFor(property);\n    if (setter != null) return GenericTypeReflectorUtil.getParameterTypes(setter, ownerType)[0];\n\n    Field field = MopUtil.fieldFor(property);\n    if (field != null) return GenericTypeReflectorUtil.getExactFieldType(field, ownerType);\n\n    throw new UnreachableCodeError();\n  }\n\n  @Override\n  public"
            }
        ],
        "spock-core/src/main/java/org/spockframework/runtime/StandardStreamsCapturer.java": [
            {
                "fromLine": 16,
                "toLine": 88,
                "oldContent": "import org.spockframework.util.*;\n\nimport java.io.PrintStream;\nimport java.util.Set;\nimport java.util.concurrent.CopyOnWriteArraySet;\n\n@ThreadSafe\npublic class StandardStreamsCapturer implements IStoppable {\n  private final Set<IStandardStreamsListener> standardStreamsListeners =\n    new CopyOnWriteArraySet<>();\n\n  private volatile TeePrintStream outStream;\n  private volatile TeePrintStream errStream;\n\n  public synchronized void start() {\n    startCapture(System.out, outStream, true);\n    startCapture(System.err, errStream