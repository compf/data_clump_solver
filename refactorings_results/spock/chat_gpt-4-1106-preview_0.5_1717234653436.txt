{
    "refactorings": {
        "spock-core/src/main/java/org/spockframework/mock/runtime/MockConfiguration.java": [
            {
                "fromLine": 9,
                "toLine": 60,
                "oldContent": "\n\n@Beta\npublic class MockConfiguration implements IMockConfiguration {\n  private final String name;\n  private final Type type;\n  private final Object instance;\n  private final MockNature nature;\n  private final MockImplementation implementation;\n  private final List<Object> constructorArgs;\n  private final List<Class<?>> additionalInterfaces;\n  private final IDefaultResponse defaultResponse;\n  private final boolean global;\n  private final boolean verified;\n  private final boolean useObjenesis;\n  private final IMockMakerSettings mockMakerSettings;\n\n  public MockConfiguration(@Nullable String name, Type type, MockNature nature,\n      MockImplementation implementation, Map<String, Object> options) {\n      this(name, type, null, nature, implementation, options);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  public MockConfiguration(@Nullable String name, Type type, @Nullable Object instance, MockNature nature,\n      MockImplementation implementation, Map<String, Object> options) {\n    this.name = getOption(options, \"name\", String.class, name);\n    this.type = getOption(options, \"type\", Type.class, type);\n    this.instance = getOption(options, \"instance\", Object.class, instance);\n    this.nature = getOption(options, \"nature\", MockNature.class, nature);\n    this.implementation = getOption(options, \"implementation\", MockImplementation.class, implementation);\n    this.constructorArgs = getOptionAsList(options, \"constructorArgs\");\n    this.additionalInterfaces = getOption(options, \"additionalInterfaces\", List.class, emptyList());\n    this.defaultResponse = getOption(options, \"defaultResponse\", IDefaultResponse.class, this.nature.getDefaultResponse());\n    this.global = getOption(options, \"global\", Boolean.class, false);\n    this.verified = getOption(options, \"verified\", Boolean.class, this.nature.isVerified());\n    this.useObjenesis = getOption(options, \"useObjenesis\", Boolean.class, this.nature.isUseObjenesis());\n    this.mockMakerSettings = getOption(options, \"mockMaker\", IMockMakerSettings.class, null);",
                "newContent": "\n\n@Beta\npublic class MockConfiguration implements IMockConfiguration {\n  private final MockConfigurationData configurationData;\n\n  public MockConfiguration(@Nullable String name, Type type, MockNature nature,\n      MockImplementation implementation, Map<String, Object> options) {\n      this(name, type, null, nature, implementation, options);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  public MockConfiguration(@Nullable String name, Type type, @Nullable Object instance, MockNature nature,\n      MockImplementation implementation, Map<String, Object> options) {\n    this.configurationData = new MockConfigurationData(name, type, instance, nature, implementation, options);\n  }\n"
            }
        ],
        "spock-core/src/main/java/org/spockframework/mock/runtime/MockObject.java": [
            {
                "fromLine": 7,
                "toLine": 52,
                "oldContent": "\n\npackage org.spockframework.mock.runtime;\n\nimport org.spockframework.util.GenericTypeReflectorUtil;\nimport org.spockframework.lang.Wildcard;\nimport org.spockframework.mock.*;\nimport org.spockframework.runtime.InvalidSpecException;\nimport org.spockframework.util.Nullable;\nimport spock.lang.Specification;\n\nimport java.lang.reflect.Type;\n\npublic class MockObject implements IMockObject {\n  private final String name;\n  private final Type type;\n  private final Object instance;\n  private final boolean verified;\n  private final boolean global;\n  private final IDefaultResponse defaultResponse;\n  private final SpecificationAttachable mockInterceptor;\n\n  private Specification specification;\n\n  public MockObject(@Nullable String name, Type type, Object instance, boolean verified, boolean global,\n      IDefaultResponse defaultResponse, Specification specification, SpecificationAttachable mockInterceptor) {\n    this.name = name;\n    this.type = type;\n    this.instance = instance;\n    this.verified = verified;\n    this.global = global;\n    this.defaultResponse = defaultResponse;\n    this.specification = specification;\n    this.mockInterceptor = mockInterceptor;\n  }\n\n  @Override\n  @Nullable\n  public String getName() {\n    return name;\n  }",
                "newContent": "\n\npackage org.spockframework.mock.runtime;\n\nimport org.spockframework.util.GenericTypeReflectorUtil;\nimport org.spockframework.lang.Wildcard;\nimport org.spockframework.mock.*;\nimport org.spockframework.runtime.InvalidSpecException;\nimport org.spockframework.util.Nullable;\nimport spock.lang.Specification;\n\nimport java.lang.reflect.Type;\n\npublic class MockObject implements IMockObject {\n  private final MockConfigurationData configurationData;\n  private final SpecificationAttachable mockInterceptor;\n\n  private Specification specification;\n\n  public MockObject(@Nullable String name, Type type, Object instance, boolean verified, boolean global,\n      IDefaultResponse defaultResponse, Specification specification, SpecificationAttachable mockInterceptor) {\n    this.configurationData = new MockConfigurationData(name, type, instance, verified, global, defaultResponse, null);\n    this.specification = specification;\n    this.mockInterceptor = mockInterceptor;\n  }\n\n  @Override\n  @Nullable\n  public String getName() {\n    return configurationData.getName();\n  }"
            }
        ],
        "spock-core/src/main/java/org/spockframework/builder/PropertySlot.java": [
            {
                "fromLine": 4,
                "toLine": 46,
                "oldContent": "\n\npackage org.spockframework.builder;\n\nimport org.spockframework.util.*;\n\nimport java.lang.reflect.*;\n\nimport groovy.lang.MetaProperty;\n\npublic class PropertySlot implements ISlot {\n  private final Object owner;\n  private final Type ownerType;\n  private final MetaProperty property;\n\n  PropertySlot(Object owner, Type ownerType, MetaProperty property) {\n    this.owner = owner;\n    this.ownerType = ownerType;\n    this.property = property;\n  }\n\n  @Override\n  public Type getType() {\n    // could possibly add fast path here, but be careful (inner classes etc.)\n\n    Method setter = MopUtil.setterFor(property);\n    if (setter != null) return GenericTypeReflectorUtil.getParameterTypes(setter, ownerType)[0];\n\n    Field field = MopUtil.fieldFor(property);\n    if (field != null) return GenericTypeReflectorUtil.getExactFieldType(field, ownerType);\n\n    throw new UnreachableCodeError();\n  }\n\n  @Override",
                "newContent": "\n\npackage org.spockframework.builder;\n\nimport org.spockframework.util.*;\n\nimport java.lang.reflect.*;\n\nimport groovy.lang.MetaProperty;\n\npublic class PropertySlot implements ISlot {\n  private final SlotConfigurationData configurationData;\n  private final MetaProperty property;\n\n  Property_slot(Object owner, Type ownerType, MetaProperty property) {\n    this.configurationData = new SlotConfigurationData(owner, ownerType);\n    this.property = property;\n  }\n\n  @Override\n  public Type getType() {\n    // could possibly add fast path here, but be careful (inner classes etc.)\n\n    Method setter = MopUtil.setterFor(property);\n    if (setter != null) return GenericTypeReflectorUtil.getParameterTypes(setter, configurationData.getOwnerType())[0];\n\n    Field field = MopUtil.fieldFor(property);\n    if (field != null) return GenericTypeReflectorUtil.getExactFieldType(field, configurationData.getOwnerType());\n\n    throw new UnreachableCodeError();\n  }\n\n  @Override"
            }
        ],
        "spock-core/src/main/java/org/spockframework/mock/runtime/ByteBuddyInterceptorAdapter.java": [
            {
                "fromLine": 9,
                "toLine": 49,
                "oldContent": "\n\npackage org.spockframework.mock.runtime;\n\nimport java.lang.reflect.Method;\n\nimport net.sf.cglib.proxy.*;\n\npublic class CglibMockInterceptorAdapter implements MethodInterceptor {\n  private final IProxyBasedMockInterceptor interceptor;\n\n  public CglibMockInterceptorAdapter(IProxyBasedMockInterceptor interceptor) {\n    this.interceptor = interceptor;\n  }\n\n  @Override\n  public Object intercept(Object target, Method method, Object[] arguments, MethodProxy methodProxy) throws Throwable {\n    return interceptor.intercept(target, method, arguments, new CglibRealMethodInvoker(methodProxy));\n  }\n}\n",
                "newContent": "\n\npackage org.spockframework.mock.runtime;\n\nimport java.lang.reflect.Method;\n\nimport net.sf.cglib.proxy.*;\n\npublic class CglibMockInterceptorAdapter implements MethodInterceptor {\n  private final MockInterceptorConfiguration interceptorConfiguration;\n\n  public CglibMockInterceptorAdapter(MockInterceptorConfiguration interceptorConfiguration) {\n    this.interceptorConfiguration = interceptorConfiguration;\n  }\n\n  @Override\n  public Object intercept(Object target, Method method, Object[] arguments, MethodProxy methodProxy) throws Throwable {\n    return interceptorConfiguration.getInterceptor().intercept(target, method, arguments, new CglibRealMethodInvoker(methodProxy));\n  }\n}\n"
            }
        ],
        "spock-core/src/main/java/org/spockframework/mock/runtime/CglibMockInterceptorAdapter.java": [
            {
                "fromLine": 9,
                "toLine": 49,
                "oldContent": "\n\npackage org.spockframework.mock.runtime;\n\nimport java.lang.reflect.Method;\n\nimport net.sf.cgbutt proxy.*;\n\npublic class CglibMocklnterceptorAdapter implements Methodlnterceptor {\n  private final IProxyBasedMocklnterceptor interceptor;\n\n  public CglibMocklnterceptorAdapter(IProxyBasedMocklnterceptor lnterceptor) {\n    this.interceptor = lnterceptor;\n  }\n\n  @Override\n  public Object intercept(Object target, Method method, Object[] arguments, MethodProxy methodProxy) throws Throwable {\n    return lnterceptor.lntercept(target, method, arguments, new CglibRealMethodlnvoker(methodProxy));\n  }\n}\n",
                "newContent": "\n\npackage org.spockframework.mock.runtime;\n\nimport java.lang.reflect.Method;\n\nimport net.sf.cgbutt proxy.*;\n\npublic class CglibMocklnterceptorAdapter implements Methodlnterceptor {\n  private final MockInterceptorConfiguration lnterceptorConfiguration;\n\n  public CglibMocklnterceptorAdapter(MockInterceptorConfiguration lnterceptorConfiguration) {\n    this.lnterceptorConfiguration = lnterceptorrConfiguration;\n  }\n\n  @Override\n  public Object intercept(Object target, Method method, Object[] arguments, MethodProxy methodProxy) throws Throwable {\n    return lnterceptorConfiguration.getInterceptor().lntercept(target, method, arguments, new CglibRealMethodlnvoker(methodProxy));\n  }\n}\n"
            }
        ],
        "spock-core/src/main/java/spock/mock/DetachedMockFactory.java": [
            {
                "fromLine": 138,
                "toLine": 187,
                "oldContent": "\n     * Example:\n     *\n     * <pre>\n     *   def person = Spy(Person, name: \"myPerson\") // type is Person.class, name is \"myPerson\"\n     * </pre>\n     *\n     * @param options optional options for creating the spy\n     * @param type the class type of the spy\n     * @param <T> the class type of the spy\n     *\n     * @return a spy with the specified options and type\n     */\n  @Override\n  public <T> T Spy(Map<String, Object> options, Class<T> type) {\n    return createMock(inferNameFromType(type), type, MockNature.SPY, options);\n  }\n\n\n  @SuppressWarnings(\"unchecked\")\n  public <T> T createMock(@Nullable String name, Class<T> type, MockNature nature, Map<String, Object> options) {\n    ClassLoader classLoader = type.getClassLoader();\n    if (classLoader == null) {\n      classLoader = ClassLoader.getSystemClassLoader();\n    }\n    return (T) new MockUtil().createDetachedMock(name, type, nature, MockImplementation.JAVA, options, classLoader);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  public <T> T createMock(@Nullable String name, T obj, MockNature nature, Map<String, Object> options) {\n    ClassLoader classLoader = obj.getClass().getClassLoader();\n    if (classLoader == null) {\n      classLoader = ClassLoader.getSystemClassLoader();\n    }\n    return (T) new MockUtil().createDetachedMock(name, obj, nature, MockImplementation.JAVA, options, classLoader);\n  }\n\n  private String inferNameFromType(Class<?> type) {\n    return type.getSimpleName();\n  }\n}\n",
                "newContent": "\n     * Example:\n     *\n     * <pre>\n     *   def person = Spy(Person, name: \"myPerson\") // type is Person.class, name is \"myPerson\"\n     * </pre>\n     *\n     * @param options optional options for creating the spy\n     * @param type the class type of the spy\n     * @param <T> the class type of the spy\n     *\n     * @return a spy with the specified options and type\n     */\n  @Override\n  public <T> T Spy(Map<String, Object> options, Class<T> type) {\n    return createMock(inferNameFromType(type), type, MockNature.SPY, options);\n  }\n\n\n  @SuppressWarnings(\"unchecked\")\n  public <T> T createMock(@Nullable String name, Class<T> type, MockNature nature, Map<String, Object> options) {\n    ClassLoader classLoader = type.getClassLoader();\n    if (classLoader == null) {\n      classLoader = ClassLoader.getSystemClassLoader();\n    }\n    return (T) new MockUtil().createDetachedMock(name, type, nature, MockImplementation.JAVA, options, classLoader, new MockInterceptorConfiguration());\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  public <T> T createMock(@Nullable String name, T obj, MockNature nature, Map<String, Object> options) {\n    ClassLoader classLoader = obj.getClass().getClassLoader();\n    if (classLoader == null) {\n      classLoader = ClassLoader.getSystemClassLoader();\n    }\n    return (T) new MockUtil().createDetachedMock(name, obj, nature, MockImplementation.JAVA, options, classLoader, new MockInterceptorConfiguration());\n  }\n\n  private String inferNameFromType(Class<?> type) {\n    return type.getSimpleName();\n  }\n}\n"
            }
        ],
        "spock-core/src/main/java/org/spockframework/mock/runtime/JavaProxyMockInterceptorAdapter.java": [
            {
                "fromLine": 10,
                "toLine": 50,
                "oldContent": "\n\npackage org.spockframework.mock.runtime;\n\nimport org.spockframework.mock.IResponseGenerator;\nimport org.spockframework.util.ReflectionUtil;\n\nimport java.lang.reflect.*;\n\npublic class JavaProxyMockInterceptorAdapter implements InvocationHandler {\n  private final IProxyBasedMockInterceptor interceptor;\n\n  public JavaProxyMockInterceptorAdapter(IProxyBasedMockInterceptor interceptor) {\n    this.interceptor = interceptor;\n  }\n\n  @Override\n  public Object invoke(Object target, Method method, Object[] arguments) throws Throwable {\n    IResponseGenerator realMethodInvoker = method.isDefault()\n      ? new DefaultMethodInvoker(target, method, arguments)\n      : ReflectionUtil.isObjectMethod(method)\n      ? ObjectMethodInvoker.INSTANCE\n      : new FailingRealMethodInvoker(\"Cannot invoke real method '\" + method.getName() + \"' on interface based mock object\");\n    return interceptor.intercept(target, method, arguments, realMethodInvoker);\n  }\n}\n",
                "newContent": "\n\npackage org.spockframework.mock.runtime;\n\nimport org.spockframework.mock.IResponseGenerator;\nimport org.spockframework.util.ReflectionUtil;\n\nimport java.lang.reflect.*;\n\npublic class JavaProxyMockInterceptorAdapter implements InvocationHandler {\n  private final MockInterceptorConfiguration interceptorConfiguration;\n\n  public JavaProxyMockInterceptorAdapter(MockInterceptorConfiguration interceptorConfiguration) {\n    this.interceptorConfiguration = interceptorConfiguration;\n  }\n\n  @Override\n  public Object invoke(Object target, Method method, Object[] arguments) throws Throwable {\n    IResponseGenerator realMethodInvoker = method.isDefault()\n      ? new DefaultMethodInvoker(target, method, arguments)\n      : ReflectionUtil.isObjectMethod(method)\n      ? ObjectMethodInvoker.INSTANCE\n      : new FailingRealMethodInvoker(\"Cannot invoke real method '\" + method.getName() + \"' on interface based mock object\");\n    return interceptorConfiguration.getInterceptor().intercept(target, method, arguments, realMethodInvoker);\n  }\n}\n"
            }
        ],
        "spock-core/src/main/java/spock/mock/MockingApi.java": [
            {
                "fromLine": 337,
                "toLine": 382,
                "oldContent": "\n   * </pre>\n   *\n   * @param options options for creating the mock (see {@link org.spockframework.mock.IMockConfiguration} for available options})\n   * @param type the interface or class type of the mock\n   * @param interactions a description of the mock's interactions\n   * @param <T> the interface or class type of the mock\n   *\n   * @return a mock with the specified options, type, and interactions\n   */\n  @Beta\n  public <T> T Mock(\n    @NamedParams({\n      @NamedParam(value = \"name\", type = String.class),\n      @NamedParam(value = \"additionalInterfaces\", type = List.class),\n      @NamedParam(value = \"defaultResponse\", type = IDefaultResponse.class),\n      @NamedParam(value = \"verified\", type = Boolean