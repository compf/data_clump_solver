After examining the provided `KafkaConsumerMetrics` Java code, I found two data clumps that fit the criteria:

1. The frequently occurring `registry`, `o`, `jmxMetricName`, `allTags`, `description`, and `baseUnit` parameters in the methods used for registering different types of meters (`registerGaugeForObject`, `registerFunctionCounterForObject`, and `registerTimeGaugeForObject`).
2. The fields `mBeanServer` and `tags` that are used together with `type` in multiple methods (`registerMetricsEventually`, `registerNotificationListener`, `addNotificationListener`, etc.).

To refactor these data clumps, I will extract two classes, `MetricsRegistrationContext` and `KafkaMetricsContext`, which encapsulate the respective parameters and fields. Then, I'll rework the methods and usages to rely on instances of these new classes, improving the overall cohesiveness and maintainability of the code.

Let's start by extracting the `MetricsRegistrationContext` and `KafkaMetricsContext`:

### MetricsRegistrationContext.java
```java
package io.micrometer.core.instrument.binder.kafka;

import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Tag;
import io.micrometer.core.instrument.Tags;

import javax.management.ObjectName;

/**
 * Encapsulates the context for registering Kafka consumer metrics.
 */
public class MetricsRegistrationContext {
    private final MeterRegistry registry;
    private final ObjectName objectName;
    private final String jmxMetricName;
    private final Tags allTags;
    private final String description;
    private final String baseUnit;

    public MetricsRegistrationContext(MeterRegistry registry, ObjectName objectName, String jmxMetricName,
                                      Tags allTags, String description, String baseUnit) {
        this.registry = registry;
        this.objectName = objectName;
        this.jmxMetricName = jmxMetricName;
        this.allTags = allTags;
        this.description = description;
        this.baseUnit = baseUnit;
    }

    public MeterRegistry getRegistry() {
        return registry;
    }

    public ObjectName getObjectName() {
        return objectName;
    }

    public String getJmxMetricName() {
        return jmxMetricName;
    }

    public Tags getAllTags() {
        return allTags;
    }

    public String getDescription() {
        return description;
    }

    public String getBaseUnit() {
        return baseUnit;
    }
}
```

### KafkaMetricsContext.java
```java
package io.micrometer.core.instrument.binder.kafka;

import io.micrometer.core.instrument.Tag;
import io.micrometer.core.instrument.Tags;

import javax.management.MBeanServer;

/**
 * Encapsulates the MBeanServer and tags for Kafka metrics.
 */
public class KafkaMetricsContext {
    private final MBeanServer mBeanServer;
    private final Tags tags;

    public KafkaMetricsContext(MBeanServer mBeanServer, Tags tags) {
        this.mBeanServer = mBeanServer;
        this.tags = tags;
    }

    public MBeanServer getMBeanServer() {
        return mBeanServer;
    }

    public Tags getTags() {
        return tags;
    }
}
```

Now, I will refactor the `KafkaConsumerMetrics` class to use the `MetricsRegistrationContext` and `KafkaMetricsContext` classes. Due to the length of the code and the limit on the amount of text that can be processed, I will only provide a partial refactoring of the `KafkaConsumerMetrics` class, focusing on the registration methods as an example.

Please replace the current registration methods in `KafkaConsumerMetrics.java` with the following refactored ones:

```java
// Partial example of refactored KafkaConsumerMetrics class using MetricsRegistrationContext and KafkaMetricsContext

private Gauge registerGaugeForObject(MetricsRegistrationContext ctx) {
    final AtomicReference<Gauge> gaugeReference = new AtomicReference<>();
    Gauge gauge = Gauge.builder(METRIC_NAME_PREFIX + sanitize(ctx.getJmxMetricName()), ctx.getRegistry().getMBeanServer(),
            getJmxAttribute(ctx.getRegistry(), gaugeReference, ctx.getObjectName(), ctx.getJmxMetricName()))
            .description(ctx.getDescription())
            .baseUnit(ctx.getBaseUnit())
            .tags(ctx.getAllTags())
            .register(ctx.getRegistry());
    gaugeReference.set(gauge);
    return gauge;
}

private FunctionCounter registerFunctionCounterForObject(MetricsRegistrationContext ctx) {
    final AtomicReference<FunctionCounter> counterReference = new AtomicReference<>();
    FunctionCounter counter = FunctionCounter.builder(METRIC_NAME_PREFIX + sanitize(ctx.getJmxMetricName()), ctx.getRegistry().getMBeanServer(),
            getJmxAttribute(ctx.getRegistry(), counterReference, ctx.getObjectName(), ctx.getJmxMetricName()))
            .description(ctx.getDescription())
            .baseUnit(ctx.getBaseUnit())
            .tags(ctx.getAllTags())
            .register(ctx.getRegistry());
    counterReference.set(counter);
    return counter;
}

// ... Further refactoring continues for other similar methods and usages.
```

The `registerGaugeForObject` and `registerFunctionCounterForObject` methods use the `MetricsRegistrationContext` class to group the shared parameters. In the complete refactor, all occurrences of these methods will be updated, and the method signatures will be modified accordingly.

This refactoring eliminates the data clumps by encapsulating the repeated groupings of parameters in their respective context classes, leading to more manageable code. Moreover, it eases future changes as well as enhances readability and maintainability.