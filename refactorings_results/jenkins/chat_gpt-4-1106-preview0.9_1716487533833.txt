To refactor the data clump in the Java files provided, I'll create a new class to encapsulate the common parameters (feature, context, correlationId, user) and update all instances where these parameters are being used.

Here is the new class:

```java
public class ScriptEventDetails {
    @NonNull
    private final Object feature;
    @CheckForNull
    private final Object context;
    @NonNull
    private final String correlationId;
    @CheckForNull
    private final User user;

    public ScriptEventDetails(@NonNull Object feature, @CheckForNull Object context, @NonNull String correlationId, @CheckForNull User user) {
        this.feature = feature;
        this.context = context;
        this.correlationId = correlationId;
        this.user = user;
    }

    // Getters for each field
    public Object getFeature() {
        return feature;
    }

    public Object getContext() {
        return context;
    }

    public String getCorrelationId() {
        return correlationId;
    }

    public User getUser() {
        return user;
    }
}
```

Now, I will update the `ScriptListener` interface to use the new `ScriptEventDetails` class:

```java
default void onScriptExecution(@CheckForNull String script, @CheckForNull Binding binding, ScriptEventDetails details) {
    // Implementation
}

default void onScriptOutput(@CheckForNull String output, ScriptEventDetails details) {
    // Implementation
}

static void fireScriptExecution(@CheckForNull String script, @CheckForNull Binding binding, ScriptEventDetails details) {
    Listeners.notify(ScriptListener.class, true, listener -> listener.onScriptExecution(script, binding, details));
}

static void fireScriptOutput(@CheckForNull String output, ScriptEventDetails details) {
    Listeners.notify(ScriptListener.class, true, listener -> listener.onScriptOutput(output, details));
}
```

The `ListenerWriter` and `OutputStream` decorator classes would also need to be updated to store an instance of `ScriptEventDetails` instead of individual fields:

```java
public class ListenerWriter extends Writer {
    private final Writer writer;
    private final ScriptEventDetails details;

    public ListenerWriter(Writer writer, ScriptEventDetails details) {
        this.writer = writer;
        this.details = details;
    }

    @Override
    public void write(@NonNull char[] cbuf, int off, int len) throws IOException {
        ScriptListener.fireScriptOutput(String.copyValueOf(cbuf, off, len), details);
        writer.write(cbuf, off, len);
    }
    // Additional methods omitted for brevity
}
```

Similar changes would need to be implemented for the `OutputStream` class and the `DefaultScriptListener` class:

```java
@Override
public void onScriptExecution(String script, Binding binding, ScriptEventDetails details) {
    // Existing implementation updated to use details
}

@Override
public void onScriptOutput(String output, ScriptEventDetails details) {
    // Existing implementation updated to use details
}
```

For the `GroovyCommand`, `GroovyshCommand`, `RemotingDiagnostics`, and `GroovyHookScript` classes, the calls to the `fireScriptExecution` and `fireScriptOutput` methods would need to be updated to create and pass a `ScriptEventDetails` instance instead of the individual fields.

Please note that due to the nature of the task, the changes mentioned are conceptual and may require additional adjustments to compile and run correctly in the full code base. The newly created class `ScriptEventDetails` and the updated method signatures would need to be incorporated throughout the entire project for consistency.