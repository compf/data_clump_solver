Based on the provided code snippets, we can see some data clumps are present in the parameters of the `fireScriptExecution` and `fireScriptOutput` methods as well as the constructors of `ListenerWriter` and `OutputStream`. These methods and constructors share at least three common fields/parameters (`Object feature`, `Object context`, `String correlationId`, and `User user`).

Below is the refactored code for the detected data clumps, along with the extracted new class `ScriptContext` which encapsulates the common fields:

### Extracted Class: ScriptContext.java

```java
public class ScriptContext {
    private final Object feature;
    private final Object context;
    private final String correlationId;
    private final User user;
    
    public ScriptContext(Object feature, Object context, String correlationId, User user) {
        this.feature = feature;
        this.context = context;
        this.correlationId = correlationId;
        this.user = user;
    }

    public Object getFeature() {
        return feature;
    }

    public Object getContext() {
        return context;
    }

    public String getCorrelationId() {
        return correlationId;
    }

    public User getUser() {
        return user;
    }
}
```

### Refactored Method Signatures:

For `ScriptListener.java`, the method signatures of `onScriptExecution` and `onScriptOutput` would be updated to the following:
```java
default void onScriptExecution(@CheckForNull String script, @CheckForNull Binding binding,
                               @NonNull ScriptContext scriptContext) {
    // Method implementation...
}

default void onScriptOutput(@CheckForNull String output, @NonNull ScriptContext scriptContext) {
    // Method implementation...
}

// And similarly for static fire methods
static void fireScriptExecution(@CheckForNull String script, @CheckForNull Binding binding, @NonNull ScriptContext scriptContext) {
    Listeners.notify(ScriptListener.class, true, listener -> listener.onScriptExecution(script, binding, scriptContext));
}

static void fireScriptOutput(@CheckForNull String output, @NonNull ScriptContext scriptContext) {
    Listeners.notify(ScriptListener.class, true, listener -> listener.onScriptOutput(output, scriptContext));
}
```

For `ListenerWriter` and the unnamed `OutputStream` subclass:
```java
// ListenerWriter Constructor
public ListenerWriter(Writer writer, @NonNull ScriptContext scriptContext) {
    // Implementation...
}

// OutputStream Subclass Constructor
public SomeOutputStreamSubclass(OutputStream os, Charset charset, @NonNull ScriptContext scriptContext) {
    // Implementation...
}
```

All usages should be updated accordingly in places like `DefaultScriptListener.java`, `GroovyCommand.java`, `GroovyshCommand.java`, `RemotingDiagnostics.java`, and `GroovyHookScript.java` to pass a `ScriptContext` object instead of individual parameters.

Note that in some cases, the parameter `script` is also part of the methods, but since it's not part of all related method signatures, I've left it as a standalone parameter in the refactored methods.