The data clump we are going to refactor here involves the parameters `Object feature`, `Object context`, `String correlationId`, and `User user`, which are common across various methods and uses. I will create a class to encapsulate these parameters and update the respective methods and fields to use this new class.

### The extracted class `ScriptContext`:

```java
public class ScriptContext {
    private final Object feature;
    private final Object context;
    private final String correlationId;
    private final User user;

    public ScriptContext(Object feature, Object context, String correlationId, User user) {
        this.feature = feature;
        this.context = context;
        this.correlationId = correlationId;
        this.user = user;
    }

    public Object getFeature() {
        return feature;
    }

    public Object getContext() {
        return context;
    }

    public String getCorrelationId() {
        return correlationId;
    }

    public User getUser() {
        return user;
    }
}
```

### Refactored methods and usages:

#### `ScriptListener.java`:

```java
default void onScriptExecution(@CheckForNull String script, @CheckForNull Binding binding, @NonNull ScriptContext scriptContext) {
}

default void onScriptOutput(@CheckForNull String output, @NonNull ScriptContext scriptContext) {
}

static void fireScriptExecution(@CheckForNull String script, @CheckForNull Binding binding, @NonNull ScriptContext scriptContext) {
    Listeners.notify(ScriptListener.class, true, listener -> listener.onScriptExecution(script, binding, scriptContext));
}

static void fireScriptOutput(@CheckForNull String output, @NonNull ScriptContext scriptContext) {
    Listeners.notify(ScriptListener.class, true, listener -> listener.onScriptOutput(output, scriptContext));
}
```

#### `DefaultScriptListener.java`:

```java
@Override
public void onScriptExecution(String script, Binding binding, @NonNull ScriptContext scriptContext) {
    ...
}

@Override
public void onScriptOutput(String output, @NonNull ScriptContext scriptContext) {
    ...
}
```

#### `GroovyCommand.java`, `GroovyshCommand.java`, and `RemotingDiagnostics.java`:

For each instance where `fireScriptExecution` and `fireScriptOutput` are called, you will need to create an instance of `ScriptContext` and pass it to the methods. For example:

```java
// Inside GroovyCommand.java
ScriptContext scriptContext = new ScriptContext(GroovyCommand.class, null, scriptListenerCorrelationId, User.current());
ScriptListener.fireScriptExecution(script, binding, scriptContext);
```

#### `ListenerWriter.java` and similar classes:

Update the constructors and usage to accept `ScriptContext` and use its getters where needed.

```java
private final Writer writer;
private final ScriptContext scriptContext;

...

public void write(@NonNull char[] cbuf, int off, int len) throws IOException {
    ScriptListener.fireScriptOutput(String.copyValueOf(cbuf, off, len), scriptContext);
    writer.write(cbuf, off, len);
}
```

Please ensure that you also update the constructors and any other relevant part of the code where the old set of parameters is used, replacing them with the new `ScriptContext` class.