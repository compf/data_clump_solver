The identified data clumps in the provided Java files are as follows:

1. Between the method `onScriptExecution` and `onScriptOutput` in `ScriptListener.java`, as well as the corresponding `fireScriptExecution` and `fireScriptOutput` methods, and several other locations across different classes, we have the fields `feature`, `context`, and `correlationId`, along with an optional `User user`.

We will create a new class called `ScriptContext` to encapsulate these fields and then refactor the method signatures and usages accordingly.

### New Class `ScriptContext.java`:
```java
import hudson.model.User;
import javax.annotation.CheckForNull;
import javax.annotation.NonNull;

public class ScriptContext {
    @NonNull
    private final Object feature;
    @CheckForNull
    private final Object context;
    @NonNull
    private final String correlationId;
    @CheckForNull
    private final User user;

    public ScriptContext(@NonNull Object feature, @CheckForNull Object context, @NonNull String correlationId, @CheckForNull User user) {
        this.feature = feature;
        this.context = context;
        this.correlationId = correlationId;
        this.user = user;
    }

    @NonNull
    public Object getFeature() {
        return feature;
    }

    @CheckForNull
    public Object getContext() {
        return context;
    }

    @NonNull
    public String getCorrelationId() {
        return correlationId;
    }

    @CheckForNull
    public User getUser() {
        return user;
    }
}
```

### Refactored Method Signatures:
Update the method signatures in `ScriptListener.java` and all other locations where these parameters are used to have `ScriptContext scriptContext` as a single parameter instead of the separate fields.

For example, the `onScriptExecution` method in `ScriptListener.java` will now become:

```java
default void onScriptExecution(@CheckForNull String script, @CheckForNull Binding binding, ScriptContext scriptContext) {
    // Implementation...
}
```

The `fireScriptExecution` and `fireScriptOutput` methods, as well as their corresponding usages across different classes, would be refactored in a similar manner to use the new `ScriptContext` class.

Since there are multiple usages with different contexts, I'll show an example of how the `fireScriptExecution` method would be updated:

```java
static void fireScriptExecution(@CheckForNull String script, @CheckForNull Binding binding, ScriptContext scriptContext) {
    Listeners.notify(ScriptListener.class, true, listener -> listener.onScriptExecution(script, binding, scriptContext));
}
```

And for invoking this method from somewhere like `GroovyHookScript.java`, the call would be refactored as follows:

```java
ScriptContext scriptContext = new ScriptContext(this.getClass(), s.getFile(), this.getClass().getName() + ":" + hook, User.current());
ScriptListener.fireScriptExecution(s.getScriptText(), bindings, scriptContext);
```

The same pattern of utilizing `ScriptContext` will be followed for all other modified locations where data clumps were identified, ensuring that the new `ScriptContext` class encapsulates the common fields and is used in place of the previously cluttered method parameters.