The provided Java snippets indicate that there is a data clump consisting of the `feature`, `context`, and `correlationId` parameters which appear together in several methods across multiple classes. Additionally, the `User` parameter is frequently used alongside them. This suggests that these four parameters can be refactored into a single class to encapsulate the related data.

Here's the refactored class `ScriptEventDetails`:

```java
public class ScriptEventDetails {
    private final Object feature;
    private final Object context;
    private final String correlationId;
    private final User user;
    
    public ScriptEventDetails(Object feature, Object context, String correlationId, User user) {
        this.feature = feature;
        this.context = context;
        this.correlationId = correlationId;
        this.user = user;
    }

    public Object getFeature() {
        return feature;
    }

    public Object getContext() {
        return context;
    }

    public String getCorrelationId() {
        return correlationId;
    }

    public User getUser() {
        return user;
    }
}
```

Now, we will refactor the methods and usages accordingly.

1. Update the `ScriptListener` interface to use `ScriptEventDetails`:

```java
default void onScriptExecution(@CheckForNull String script, @CheckForNull Binding binding, @NonNull ScriptEventDetails details) {
    // Implementation...
}

default void onScriptOutput(@CheckForNull String output, @NonNull ScriptEventDetails details) {
    // Implementation...
}
```

2. Update `fireScriptExecution` and `fireScriptOutput` static methods in `ScriptListener` and `DefaultScriptListener`:

```java
// In ScriptListener
static void fireScriptExecution(@CheckForNull String script, @CheckForNull Binding binding, @NonNull ScriptEventDetails details) {
    Listeners.notify(ScriptListener.class, true, listener -> listener.onScriptExecution(script, binding, details));
}

static void fireScriptOutput(@CheckForNull String output, @NonNull ScriptEventDetails details) {
    Listeners.notify(ScriptListener.class, true, listener -> listener.onScriptOutput(output, details));
}

// In DefaultScriptListener
@Override
public void onScriptExecution(String script, Binding binding, @NonNull ScriptEventDetails details) {
    // Existing implementation with details.getFeature(), details.getContext(), details.getCorrelationId(), details.getUser()
}

@Override
public void onScriptOutput(String output, @NonNull ScriptEventDetails details) {
    // Existing implementation with details.getFeature(), details.getContext(), details.getCorrelationId(), details.getUser()
}
```

3. Update the constructors for `ListenerWriter` and the anonymous `OutputStream`-based class to accept `ScriptEventDetails` instead of individual parameters:

```java
// In ListenerWriter constructor
public ListenerWriter(Writer writer, ScriptEventDetails details) {
    // Use details.getFeature(), details.getContext(), details.getCorrelationId(), details.getUser()
}

// Similarly refactor the OutputStream-based class to accept ScriptEventDetails
```

4. Finally, update the usages in `GroovyCommand`, `GroovyshCommand`, `RemotingDiagnostics`, and `GroovyHookScript` to create instances of `ScriptEventDetails` and pass them to the refactored methods:

```java
// In GroovyCommand
ScriptEventDetails details = new ScriptEventDetails(GroovyCommand.class, null, scriptListenerCorrelationId, User.current());
ScriptListener.fireScriptExecution(script, binding, details);

// Apply similar changes wherever fireScriptExecution or fireScriptOutput are called with feature, context, correlationId, and user.
```

Make sure that each usage constructs a `ScriptEventDetails` object with the appropriate arguments. The usage of `ScriptEventDetails` simplifies the method signatures and makes it easier to manage related parameters as a single entity.