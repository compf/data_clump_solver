The Java files provided show a pattern of common parameters across methods `onScriptExecution`, `onScriptOutput`, `fireScriptExecution`, `fireScriptOutput`, and constructors `ListenerWriter`, `OutputStream`. The common parameters are `Object feature`, `Object context`, `String correlationId`, and `User user`. This forms a data clump according to the definition given.

The extracted class could be named `ScriptEventContext` and would encapsulate these common fields. Below is the content of the extracted class, followed by the refactored code snippets:

### Extracted Class: `ScriptEventContext.java`
```java
public class ScriptEventContext {
    private final Object feature;
    private final Object context;
    private final String correlationId;
    private final User user;

    public ScriptEventContext(Object feature, Object context, String correlationId, User user) {
        this.feature = feature;
        this.context = context;
        this.correlationId = correlationId;
        this.user = user;
    }

    public Object getFeature() {
        return feature;
    }

    public Object getContext() {
        return context;
    }

    public String getCorrelationId() {
        return correlationId;
    }

    public User getUser() {
        return user;
    }
}
```

### Refactored `onScriptExecution` method in `ScriptListener.java`
```java
default void onScriptExecution(@CheckForNull String script, @CheckForNull Binding binding, @NonNull ScriptEventContext context) {
}
```

### Refactored `onScriptOutput` method in `ScriptListener.java`
```java
default void onScriptOutput(@CheckForNull String output, @NonNull ScriptEventContext context) {
}
```

### Refactored `fireScriptExecution` method in `ScriptListener.java`
```java
static void fireScriptExecution(@CheckForNull String script, @CheckForNull Binding binding, @NonNull ScriptEventContext context) {
    Listeners.notify(ScriptListener.class, true, listener -> listener.onScriptExecution(script, binding, context));
}
```

### Refactored `fireScriptOutput` method in `ScriptListener.java`
```java
static void fireScriptOutput(@CheckForNull String output, @NonNull ScriptEventContext context) {
    Listeners.notify(ScriptListener.class, true, listener -> listener.onScriptOutput(output, context));
}
```

### Refactored `ListenerWriter` constructor in `ScriptListener.java`
```java
public ListenerWriter(Writer writer, ScriptEventContext context) {
    this.writer = writer;
    this.context = context;
}
```
The write method would be updated to use the context field where `feature`, `context`, `correlationId`, and `user` are required.

### Refactored `OutputStream` constructor in `ScriptListener.java`
```java
public OutputStream(OutputStream os, Charset charset, ScriptEventContext context) {
    this.os = os;
    this.charset = charset;
    this.context = context;
}
```
The write methods would be updated similarly.

### Refactored `onScriptExecution` method in `DefaultScriptListener.java`
```java
@Override
public void onScriptExecution(String script, Binding binding, @NonNull ScriptEventContext context) {
    ...
}
```

### Refactored `onScriptOutput` method in `DefaultScriptListener.java`
```java
@Override
public void onScriptOutput(String output, @NonNull ScriptEventContext context) {
    ...
}
```

For `GroovyCommand.java`, `GroovyshCommand.java`, `RemotingDiagnostics.java`, `GroovyHookScript.java`, and any other usages where the data clump existed, instances of `ScriptEventContext` would replace the common parameter lists:

### Refactored method call in `GroovyCommand.java`
```java
ScriptEventContext context = new ScriptEventContext(GroovyCommand.class, null, scriptListenerCorrelationId, User.current());
ScriptListener.fireScriptExecution(script, binding, context);
```

In each file, the respective method calls and constructors would be updated to use the `ScriptEventContext` class instead of the individual fields. The actual implementation details (like logging lines or method body content) would remain intact, but use the getters from `ScriptEventContext` where needed.
