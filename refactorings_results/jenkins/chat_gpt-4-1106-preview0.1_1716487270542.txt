To refactor the data clumps in the provided Java files, we can extract a class that encapsulates the parameters `feature`, `context`, `correlationId`, and `user` which are common across various methods and classes.

Let's create a class named `ScriptEventContext`:

```java
import javax.annotation.CheckForNull;
import javax.annotation.Nonnull;

public class ScriptEventContext {
    @Nonnull
    private final Object feature;
    @CheckForNull
    private final Object context;
    @Nonnull
    private final String correlationId;
    @CheckForNull
    private final User user;

    public ScriptEventContext(@Nonnull Object feature, @CheckForNull Object context, @Nonnull String correlationId, @CheckForNull User user) {
        this.feature = feature;
        this.context = context;
        this.correlationId = correlationId;
        this.user = user;
    }

    @Nonnull
    public Object getFeature() {
        return feature;
    }

    @CheckForNull
    public Object getContext() {
        return context;
    }

    @Nonnull
    public String getCorrelationId() {
        return correlationId;
    }

    @CheckForNull
    public User getUser() {
        return user;
    }
}
```

Now, let's refactor the methods to use instances of `ScriptEventContext`.

For instance, in `ScriptListener.java`, the `onScriptExecution` method would look like this:

```java
default void onScriptExecution(@CheckForNull String script, @CheckForNull Binding binding, @NonNull ScriptEventContext context) {
    // Method body remains unchanged
}

// And the corresponding fireScriptExecution:
static void fireScriptExecution(@CheckForNull String script, @CheckForNull Binding binding, @NonNull ScriptEventContext context) {
    Listeners.notify(ScriptListener.class, true, listener -> listener.onScriptExecution(script, binding, context));
}
```

Similarly, update the `onScriptOutput`, `fireScriptOutput`, and any other method that contains these clumped parameters to use the new `ScriptEventContext`. Here's how `onScriptOutput` would look:

```java
default void onScriptOutput(@CheckForNull String output, @NonNull ScriptEventContext context) {
    // Method body remains unchanged
}

// And the corresponding fireScriptOutput:
static void fireScriptOutput(@CheckForNull String output, @NonNull ScriptEventContext context) {
    Listeners.notify(ScriptListener.class, true, listener -> listener.onScriptOutput(output, context));
}
```

This same approach should be taken for other occurrences in classes like `DefaultScriptListener`, `GroovyCommand`, `GroovyshCommand`, `RemotingDiagnostics`, and `GroovyHookScript`. Replace the parameters `feature`, `context`, `correlationId`, and `user` with an instance of `ScriptEventContext` and update the method calls accordingly.

Remember, after refactoring, run your unit tests, or create some if they don't exist, to ensure that your changes don't break the existing functionality.