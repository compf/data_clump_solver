The data clump consists of the parameters `Object feature, Object context, String correlationId, User user` that are found across multiple methods in the `ScriptListener` interface, the `ListenerWriter` and `OutputStream2Writer` classes, and in multiple classes that fire script events like `DefaultScriptListener`, `GroovyCommand`, `GroovyshCommand`, `RemotingDiagnostics`, and `GroovyHookScript`. To refactor this data clump, we can extract these parameters to a separate class.

First, let's define a new class `ScriptEventContext` to encapsulate the features `feature, context, correlationId, user`:

```java
public class ScriptEventContext {
    private final Object feature;
    private final Object context;
    private final String correlationId;
    private final User user;

    public ScriptEventContext(Object feature, Object context, String correlationId, User user) {
        this.feature = feature;
        this.context = context;
        this.correlationId = correlationId;
        this.user = user;
    }

    public Object getFeature() {
        return feature;
    }

    public Object getContext() {
        return context;
    }

    public String getCorrelationId() {
        return correlationId;
    }

    public User getUser() {
        return user;
    }
}
```

Next, we update all affected methods and constructors to use `ScriptEventContext` instead of the individual parameters:

In the `ScriptListener` interface:

```java
default void onScriptExecution(@CheckForNull String script, @CheckForNull Binding binding, @NonNull ScriptEventContext eventContext) {
}

default void onScriptOutput(@CheckForNull String output, @NonNull ScriptEventContext eventContext) {
}

static void fireScriptExecution(@CheckForNull String script, @CheckForNull Binding binding, @NonNull ScriptEventContext eventContext) {
    Listeners.notify(ScriptListener.class, true, listener -> listener.onScriptExecution(script, binding, eventContext));
}

static void fireScriptOutput(@CheckForNull String output, @NonNull ScriptEventContext eventContext) {
    Listeners.notify(ScriptListener.class, true, listener -> listener.onScriptOutput(output, eventContext));
}
```

For the classes `DefaultScriptListener`, `GroovyCommand`, `GroovyshCommand`, `RemotingDiagnostics`, and `GroovyHookScript`, you would replace the parameters with `ScriptEventContext` in method calls, for example:

```java
// Example from GroovyCommand.java
ScriptEventContext eventContext = new ScriptEventContext(GroovyCommand.class, null, scriptListenerCorrelationId, User.current());
ScriptListener.fireScriptExecution(script, binding, eventContext);
```

For `ListenerWriter` and the anonymous `OutputStream2Writer` class, the constructors would be refactored accordingly:

```java
// ListenerWriter
public ListenerWriter(Writer writer, ScriptEventContext eventContext) {
    this.writer = writer;
    this.eventContext = eventContext;
}

// OutputStream2Writer
public OutputStream2Writer(OutputStream os, Charset charset, ScriptEventContext eventContext) {
    this.os = os;
    this.charset = charset;
    this.eventContext = eventContext;
}
```

And the corresponding method implementations within these classes would call `fireScriptOutput` using the `eventContext` rather than the individual parameters.

Remember to update all instances where these methods are called and all usages of the individual parameters to use the new `ScriptEventContext` class. This will centralize the handling of these parameters and reduce the redundancy across methods and classes.