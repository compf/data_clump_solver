Based on the provided code snippets, it is observable that the `onScriptExecution`, `onScriptOutput`, `fireScriptExecution`, and `fireScriptOutput` methods in the `ScriptListener` interface and corresponding invocations have a data clump with the parameters `Object feature`, `Object context`, `String correlationId`, and `User user`. This data clump also shows in the constructor of `ListenerWriter` and the fields of that class. Additionally, although the number of parameters does not exactly match on all occurrences, an `ScriptEventInfo` class can be created to encapsulate these common parameters.

Let's create the `ScriptEventInfo` class:

```java
// Extracted class to encapsulate common fields and parameters
public class ScriptEventInfo {
    private final Object feature;
    private final Object context;
    private final String correlationId;
    private final User user;

    public ScriptEventInfo(Object feature, Object context, String correlationId, User user) {
        this.feature = feature;
        this.context = context;
        this.correlationId = correlationId;
        this.user = user;
    }

    // Getters for the fields
    public Object getFeature() {
        return feature;
    }

    public Object getContext() {
        return context;
    }

    public String getCorrelationId() {
        return correlationId;
    }

    public User getUser() {
        return user;
    }
}
```

Now, let's refactor the `ScriptListener` interface to use `ScriptEventInfo`:

```java
// Refactored methods in the ScriptListener interface
default void onScriptExecution(@CheckForNull String script, @CheckForNull Binding binding, @NonNull ScriptEventInfo info) {
}

default void onScriptOutput(@CheckForNull String output, @NonNull ScriptEventInfo info) {
}

// Refactor static fire methods
static void fireScriptExecution(@CheckForNull String script, @CheckForNull Binding binding, @NonNull ScriptEventInfo info) {
    Listeners.notify(ScriptListener.class, true, listener -> listener.onScriptExecution(script, binding, info));
}

static void fireScriptOutput(@CheckForNull String output, @NonNull ScriptEventInfo info) {
    Listeners.notify(ScriptListener.class, true, listener -> listener.onScriptOutput(output, info));
}
```

All corresponding invocations of these methods would then need to be updated to create an instance of `ScriptEventInfo` and pass it in place of the individual parameters. For example:

Refactoring a method call in `DefaultScriptListener`:

```java
@Override
public void onScriptExecution(String script, Binding binding, @NonNull ScriptEventInfo info) {
    // ... use getters from `info` ...
    LOGGER.log(Level.FINE, LOGGER.isLoggable(Level.FINEST) ? new Exception() : null,
            () -> "Execution of script: '" + script + "' with binding: '" + stringifyBinding(binding) + "' in feature: '" + info.getFeature() + "' and context: '" + info.getContext() + "' with correlation: '" + info.getCorrelationId() + "'" + userFragment);
}

@Override
public void onScriptOutput(String output, @NonNull ScriptEventInfo info) {
    // ... use getters from `info` ...
    LOGGER.log(Level.FINER, LOGGER.isLoggable(Level.FINEST) ? new Exception() : null,
            () -> "Script output: '" + output + "' in feature: '" + info.getFeature() + "' and context: '" + info.getContext() + "' with correlation: '" + info.getCorrelationId() + "'" + userFragment);
}
```

And refactoring calls in other classes:

```java
// Example of call in GroovyCommand.java
ScriptEventInfo eventInfo = new ScriptEventInfo(GroovyCommand.class, null, scriptListenerCorrelationId, User.current());
ScriptListener.fireScriptExecution(script, binding, eventInfo);

// Similar changes would need to be made in all places where fireScriptExecution, fireScriptOutput, or related listener methods are called.
```

Lastly, update the `ListenerWriter` class to utilize `ScriptEventInfo`:

```java
public class ListenerWriter extends Writer {
    private final Writer writer;
    private final ScriptEventInfo scriptEventInfo;

    public ListenerWriter(Writer writer, ScriptEventInfo scriptEventInfo) {
        this.writer = writer;
        this.scriptEventInfo = scriptEventInfo;
    }

    @Override
    public void write(@NonNull char[] cbuf, int off, int len) throws IOException {
        ScriptListener.fireScriptOutput(String.copyValueOf(cbuf, off, len), scriptEventInfo);
        writer.write(cbuf, off, len);
    }
}
```

Perform similar changes in other classes where the data clump is present. Each usage will need to be updated to properly instantiate and use `ScriptEventInfo` instead of individual parameters.