To refactor the data clumps present in the provided code snippets, we need to identify a data clump according to the given definition and then replace the clumped data with a single object of an extracted class.

From the available code snippets, we can identify that the `feature`, `context`, `correlationId`, and `user` parameters appear together in several methods which indicate a data clump according to the definition. To refactor this, we will introduce a new class, `ScriptEventDetails`, to encapsulate these fields.

Here is the content of the extracted class:

```java
public class ScriptEventDetails {
    @NonNull
    private final Object feature;
    @CheckForNull
    private final Object context;
    @NonNull
    private final String correlationId;
    @CheckForNull
    private final User user;

    public ScriptEventDetails(@NonNull Object feature, @CheckForNull Object context,
                              @NonNull String correlationId, @CheckForNull User user) {
        this.feature = feature;
        this.context = context;
        this.correlationId = correlationId;
        this.user = user;
    }

    // Getters
    public Object getFeature() {
        return feature;
    }

    public Object getContext() {
        return context;
    }

    public String getCorrelationId() {
        return correlationId;
    }

    public User getUser() {
        return user;
    }
}
```

Now, let's update the method signatures and usages accordingly:

Note: The following refactored code snippets provide the method signatures and relevant parts of the methods only, not the complete implementations.

```java
// Update to ScriptListener.java
default void onScriptExecution(@CheckForNull String script, @CheckForNull Binding binding, @NonNull ScriptEventDetails details) {
}

default void onScriptOutput(@CheckForNull String output, @NonNull ScriptEventDetails details) {
}

static void fireScriptExecution(@CheckForNull String script, @CheckForNull Binding binding, @NonNull ScriptEventDetails details) {
    // Updated usage:
    Listeners.notify(ScriptListener.class, true, listener -> listener.onScriptExecution(script, binding, details));
}

static void fireScriptOutput(@CheckForNull String output, @NonNull ScriptEventDetails details) {
    // Updated usage:
    Listeners.notify(ScriptListener.class, true, listener -> listener.onScriptOutput(output, details));
}

// Usage in ListenerWriter constructor
public ListenerWriter(Writer writer, ScriptEventDetails details) {
    this.writer = writer;
    // Store the provided ScriptEventDetails object instead of separate fields
    this.details = details;
}

// Usage in onScriptExecution and onScriptOutput overrides in DefaultScriptListener.java
@Override
public void onScriptExecution(String script, Binding binding, @NonNull ScriptEventDetails details) {
    // ... use details.getFeature(), details.getContext(), etc.
}

@Override
public void onScriptOutput(String output, @NonNull ScriptEventDetails details) {
    // ... use details.getFeature(), details.getContext(), etc.
}

// Update other classes that call these methods
// Example usage:
ScriptEventDetails details = new ScriptEventDetails(GroovyCommand.class, null, scriptListenerCorrelationId, User.current());
ScriptListener.fireScriptExecution(script, binding, details);

// And similarly for other usages where feature, context, correlationId, and user are passed together.
```

With these changes, all occurrences of the data clumps have been replaced with an instance of the `ScriptEventDetails` class, and the methods have been updated to use this new class.