To refactor the data clumps in these Java files, we'll first need to identify the parameters that frequently appear together. We can notice that the following parameters are commonly used together:

1. `Object feature`
2. `Object context`
3. `String correlationId`
4. `User user`

These four parameters are used together in the `onScriptExecution`, `onScriptOutput`, `fireScriptExecution`, `fireScriptOutput`, and constructors of `ListenerWriter` and other related classes. These form a data clump, and therefore we can extract them into a new class, let's call it `ScriptEventContext`.

Here's the `ScriptEventContext` class that encapsulates the data clump:

```java
public class ScriptEventContext {
    private final Object feature;
    private final Object context;
    private final String correlationId;
    private final User user;

    public ScriptEventContext(Object feature, Object context, String correlationId, User user) {
        this.feature = feature;
        this.context = context;
        this.correlationId = correlationId;
        this.user = user;
    }

    public Object getFeature() {
        return feature;
    }

    public Object getContext() {
        return context;
    }

    public String getCorrelationId() {
        return correlationId;
    }

    public User getUser() {
        return user;
    }
}
```

Now we can refactor the methods to use the `ScriptEventContext`:

```java
// In ScriptListener interface:
default void onScriptExecution(@CheckForNull String script, @CheckForNull Binding binding, @NonNull ScriptEventContext context) {
}

default void onScriptOutput(@CheckForNull String output, @NonNull ScriptEventContext context) {
}

// In the ListenerWriter class:
private final ScriptEventContext scriptEventContext;

public ListenerWriter(Writer writer, ScriptEventContext context) {
    this.writer = writer;
    this.scriptEventContext = context;
}

@Override
public void write(@NonNull char[] cbuf, int off, int len) throws IOException {
    ScriptListener.fireScriptOutput(String.copyValueOf(cbuf, off, len), scriptEventContext);
    writer.write(cbuf, off, len);
}

// In all locations where the methods are called or implemented, e.g.:
ScriptListener.fireScriptExecution(script, binding, new ScriptEventContext(GroovyCommand.class, null, scriptListenerCorrelationId, User.current()));
```

Make sure to update the `fireScriptExecution` and `fireScriptOutput` static methods, and their usages, to accept a `ScriptEventContext` instead of individual parameters. Also, update the constructors of any affected classes (e.g., `ListenerWriter`, `OutputStream`, etc.) to take a `ScriptEventContext` as a parameter.

This refactoring will remove the data clump by encapsulating the common parameters into a single class and updating all the usages accordingly.