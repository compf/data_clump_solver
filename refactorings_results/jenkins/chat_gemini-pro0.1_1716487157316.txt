In the provided Java code snippets, we have several cases of data clumps based on common parameters across methods. The common parameters are `Object feature`, `Object context`, `String correlationId`, and `User user`. To refactor this data clump, we can create a new class that encapsulates these parameters and replace occurrences of these parameters with an instance of the new class.

Here is the content of the extracted class, which I will name `ScriptContext`:

```java
import hudson.model.User;

public class ScriptContext {
    private final Object feature;
    private final Object context;
    private final String correlationId;
    private final User user;

    public ScriptContext(Object feature, Object context, String correlationId, User user) {
        this.feature = feature;
        this.context = context;
        this.correlationId = correlationId;
        this.user = user;
    }

    // Getters for each of the fields, if needed
    public Object getFeature() {
        return feature;
    }
    
    public Object getContext() {
        return context;
    }
    
    public String getCorrelationId() {
        return correlationId;
    }
    
    public User getUser() {
        return user;
    }
}
```

Now, we need to refactor the code snippets to use `ScriptContext`. For brevity, I will refactor only a couple of methods from `ScriptListener.java`, and you can follow the same pattern for the rest of the methods and occurrences across the various files.

Refactored methods in `ScriptListener.java`:

```java
// Refactor the method signature to take ScriptContext as a parameter.
default void onScriptExecution(@CheckForNull String script, @CheckForNull Binding binding, @NonNull ScriptContext scriptContext) {
    // Implementation remains the same, but now use scriptContext to access the parameters.
}

// Refactor the method signature to take ScriptContext as a parameter.
default void onScriptOutput(@CheckForNull String output, @NonNull ScriptContext scriptContext) {
    // Implementation remains the same, but now use scriptContext to access the parameters.
}

// Refactor fireScriptExecution to use ScriptContext.
static void fireScriptExecution(@CheckForNull String script, @CheckForNull Binding binding, @NonNull ScriptContext scriptContext) {
    Listeners.notify(ScriptListener.class, true, listener -> listener.onScriptExecution(script, binding, scriptContext));
}

// Refactor fireScriptOutput to use ScriptContext.
static void fireScriptOutput(@CheckForNull String output, @NonNull ScriptContext scriptContext) {
    Listeners.notify(ScriptListener.class, true, listener -> listener.onScriptOutput(output, scriptContext));
}
```

Following this pattern, all other methods and constructor invocations that currently use the data clump of `Object feature`, `Object context`, `String correlationId`, and `User user` should be refactored to use a `ScriptContext` object instead. All usages of the parameters would be replaced with getters from the `ScriptContext` object.

Remember to also refactor the constructor and methods in `ListenerWriter` and the other classes that use the data clump.